""" This module provides an interface to the Elastic Compute Cloud (EC2) CloudWatch service from AWS. """ try : import simplejson as json except ImportError : import json from boto . connection import AWSQueryConnection from boto . ec2 . cloudwatch . metric import Metric from boto . ec2 . cloudwatch . alarm import MetricAlarm , MetricAlarms , AlarmHistoryItem from boto . ec2 . cloudwatch . datapoint import Datapoint from boto . regioninfo import RegionInfo import boto RegionData = { : 'monitoring.us-east-1.amazonaws.com' , : 'monitoring.us-west-1.amazonaws.com' , : 'monitoring.us-west-2.amazonaws.com' , : 'monitoring.sa-east-1.amazonaws.com' , : 'monitoring.eu-west-1.amazonaws.com' , : 'monitoring.ap-northeast-1.amazonaws.com' , : 'monitoring.ap-southeast-1.amazonaws.com' } def regions ( ) : regions = [ ] for region_name in RegionData : region = RegionInfo ( name = region_name , endpoint = RegionData [ region_name ] , connection_cls = CloudWatchConnection ) regions . append ( region ) return regions def connect_to_region ( region_name , ** kw_params ) : for region in regions ( ) : if region . name == region_name : return region . connect ( ** kw_params ) return None class CloudWatchConnection ( AWSQueryConnection ) : APIVersion = boto . config . get ( 'Boto' , 'cloudwatch_version' , '2010-08-01' ) DefaultRegionName = boto . config . get ( 'Boto' , 'cloudwatch_region_name' , ) DefaultRegionEndpoint = boto . config . get ( 'Boto' , , ) def __init__ ( self , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , proxy_user = None , proxy_pass = None , debug = 0 , https_connection_factory = None , region = None , path = '/' ) : if not region : region = RegionInfo ( self , self . DefaultRegionName , self . DefaultRegionEndpoint ) self . region = region AWSQueryConnection . __init__ ( self , aws_access_key_id , aws_secret_access_key , is_secure , port , proxy , proxy_port , proxy_user , proxy_pass , self . region . endpoint , debug , https_connection_factory , path ) def _required_auth_capability ( self ) : return [ 'ec2' ] def build_dimension_param ( self , dimension , params ) : for i , dim_name in enumerate ( dimension ) : dim_value = dimension [ dim_name ] if isinstance ( dim_value , basestring ) : dim_value = [ dim_value ] for j , value in enumerate ( dim_value ) : params [ 'Dimensions.member.%d.Name.%d' % ( i + 1 , j + 1 ) ] = dim_name params [ 'Dimensions.member.%d.Value.%d' % ( i + 1 , j + 1 ) ] = value def build_list_params ( self , params , items , label ) : if isinstance ( items , basestring ) : items = [ items ] for index , item in enumerate ( items ) : i = index + 1 if isinstance ( item , dict ) : for k , v in item . iteritems ( ) : params [ label % ( i , 'Name' ) ] = k if v is not None : params [ label % ( i , 'Value' ) ] = v else : params [ label % i ] = item def build_put_params ( self , params , name , value = None , timestamp = None , unit = None , dimensions = None , statistics = None ) : args = ( name , value , unit , dimensions , statistics ) length = max ( map ( lambda a : len ( a ) if isinstance ( a , list ) else 1 , args ) ) def aslist ( a ) : if isinstance ( a , list ) : if len ( a ) != length : raise Exception ( 'Must specify equal number of elements; expected %d.' % length ) return a return [ a ] * length for index , ( n , v , u , d , s ) in enumerate ( zip ( * map ( aslist , args ) ) ) : metric_data = { 'MetricName' : n } if timestamp : metric_data [ 'Timestamp' ] = timestamp . isoformat ( ) if unit : metric_data [ 'Unit' ] = u if dimensions : self . build_dimension_param ( d , metric_data ) if statistics : metric_data [ 'StatisticValues.Maximum' ] = s [ 'maximum' ] metric_data [ 'StatisticValues.Minimum' ] = s [ 'minimum' ] metric_data [ 'StatisticValues.SampleCount' ] = s [ 'samplecount' ] metric_data [ 'StatisticValues.Sum' ] = s [ 'sum' ] if value != None : msg = 'You supplied a value and statistics for a metric.' msg += 'Posting statistics and not value.' boto . log . warn ( msg ) elif value != None : metric_data [ 'Value' ] = v else : raise Exception ( 'Must specify a value or statistics to put.' ) for key , value in metric_data . iteritems ( ) : params [ 'MetricData.member.%d.%s' % ( index + 1 , key ) ] = value def get_metric_statistics ( self , period , start_time , end_time , metric_name , namespace , statistics , dimensions = None , unit = None ) : params = { 'Period' : period , : metric_name , : namespace , : start_time . isoformat ( ) , : end_time . isoformat ( ) } self . build_list_params ( params , statistics , 'Statistics.member.%d' ) if dimensions : self . build_dimension_param ( dimensions , params ) return self . get_list ( 'GetMetricStatistics' , params , [ ( 'member' , Datapoint ) ] ) def list_metrics ( self , next_token = None , dimensions = None , metric_name = None , namespace = None ) : params = { } if next_token : params [ 'NextToken' ] = next_token if dimensions : self . build_dimension_param ( dimensions , params ) if metric_name : params [ 'MetricName' ] = metric_name if namespace : params [ 'Namespace' ] = namespace return self . get_list ( 'ListMetrics' , params , [ ( 'member' , Metric ) ] ) def put_metric_data ( self , namespace , name , value = None , timestamp = None , unit = None , dimensions = None , statistics = None ) : params = { 'Namespace' : namespace } self . build_put_params ( params , name , value = value , timestamp = timestamp , unit = unit , dimensions = dimensions , statistics = statistics ) return self . get_status ( 'PutMetricData' , params ) def describe_alarms ( self , action_prefix = None , alarm_name_prefix = None , alarm_names = None , max_records = None , state_value = None , next_token = None ) : params = { } if action_prefix : params [ 'ActionPrefix' ] = action_prefix if alarm_name_prefix : params [ 'AlarmNamePrefix' ] = alarm_name_prefix elif alarm_names : self . build_list_params ( params , alarm_names , 'AlarmNames.member.%s' ) if max_records : params [ 'MaxRecords' ] = max_records if next_token : params [ 'NextToken' ] = next_token if state_value : params [ 'StateValue' ] = state_value return self . get_list ( 'DescribeAlarms' , params , [ ( 'MetricAlarms' , MetricAlarms ) ] ) [ 0 ] def describe_alarm_history ( self , alarm_name = None , start_date = None , end_date = None , max_records = None , history_item_type = None , next_token = None ) : params = { } if alarm_name : params [ 'AlarmName' ] = alarm_name if start_date : params [ 'StartDate' ] = start_date . isoformat ( ) if end_date : params [ 'EndDate' ] = end_date . isoformat ( ) if history_item_type : params [ 'HistoryItemType' ] = history_item_type if max_records : params [ 'MaxRecords' ] = max_records if next_token : params [ 'NextToken' ] = next_token return self . get_list ( 'DescribeAlarmHistory' , params , [ ( 'member' , AlarmHistoryItem ) ] ) def describe_alarms_for_metric ( self , metric_name , namespace , period = None , statistic = None , dimensions = None , unit = None ) : params = { 'MetricName' : metric_name , : namespace } if period : params [ 'Period' ] = period if statistic : params [ 'Statistic' ] = statistic if dimensions : self . build_dimension_param ( dimensions , params ) if unit : params [ 'Unit' ] = unit return self . get_list ( 'DescribeAlarmsForMetric' , params , [ ( 'member' , MetricAlarm ) ] ) def put_metric_alarm ( self , alarm ) : params = { : alarm . name , : alarm . metric , : alarm . namespace , : alarm . statistic , : alarm . comparison , : alarm . threshold , : alarm . evaluation_periods , : alarm . period , } if alarm . actions_enabled is not None : params [ 'ActionsEnabled' ] = alarm . actions_enabled if alarm . alarm_actions : self . build_list_params ( params , alarm . alarm_actions , ) if alarm . description : params [ 'AlarmDescription' ] = alarm . description if alarm . dimensions : self . build_dimension_param ( alarm . dimensions , params ) if alarm . insufficient_data_actions : self . build_list_params ( params , alarm . insufficient_data_actions , ) if alarm . ok_actions : self . build_list_params ( params , alarm . ok_actions , ) if alarm . unit : params [ 'Unit' ] = alarm . unit alarm . connection = self return self . get_status ( 'PutMetricAlarm' , params ) create_alarm = put_metric_alarm update_alarm = put_metric_alarm def delete_alarms ( self , alarms ) : params = { } self . build_list_params ( params , alarms , 'AlarmNames.member.%s' ) return self . get_status ( 'DeleteAlarms' , params ) def set_alarm_state ( self , alarm_name , state_reason , state_value , state_reason_data = None ) : params = { 'AlarmName' : alarm_name , : state_reason , : state_value } if state_reason_data : params [ 'StateReasonData' ] = json . dumps ( state_reason_data ) return self . get_status ( 'SetAlarmState' , params ) def enable_alarm_actions ( self , alarm_names ) : params = { } self . build_list_params ( params , alarm_names , 'AlarmNames.member.%s' ) return self . get_status ( 'EnableAlarmActions' , params ) def disable_alarm_actions ( self , alarm_names ) : params = { } self . build_list_params ( params , alarm_names , 'AlarmNames.member.%s' ) return self . get_status ( 'DisableAlarmActions' , params )

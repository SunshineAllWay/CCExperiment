from boto . dynamodb . schema import Schema from boto . dynamodb . item import Item from boto . dynamodb import exceptions as dynamodb_exceptions import time class Table ( object ) : def __init__ ( self , layer2 , response = None ) : self . layer2 = layer2 self . _dict = { } self . update_from_response ( response ) def __repr__ ( self ) : return 'Table(%s)' % self . name @ property def name ( self ) : return self . _dict [ 'TableName' ] @ property def create_time ( self ) : return self . _dict [ 'CreationDateTime' ] @ property def status ( self ) : return self . _dict [ 'TableStatus' ] @ property def item_count ( self ) : return self . _dict [ 'ItemCount' ] @ property def size_bytes ( self ) : return self . _dict [ 'TableSizeBytes' ] @ property def schema ( self ) : return self . _schema @ property def read_units ( self ) : return self . _dict [ 'ProvisionedThroughput' ] [ 'ReadCapacityUnits' ] @ property def write_units ( self ) : return self . _dict [ 'ProvisionedThroughput' ] [ 'WriteCapacityUnits' ] def update_from_response ( self , response ) : if 'Table' in response : self . _dict . update ( response [ 'Table' ] ) elif 'TableDescription' in response : self . _dict . update ( response [ 'TableDescription' ] ) if 'KeySchema' in self . _dict : self . _schema = Schema ( self . _dict [ 'KeySchema' ] ) def refresh ( self , wait_for_active = False , retry_seconds = 5 ) : done = False while not done : response = self . layer2 . describe_table ( self . name ) self . update_from_response ( response ) if wait_for_active : if self . status == 'ACTIVE' : done = True else : time . sleep ( retry_seconds ) else : done = True def update_throughput ( self , read_units , write_units ) : self . layer2 . update_throughput ( self , read_units , write_units ) def delete ( self ) : self . layer2 . delete_table ( self ) def get_item ( self , hash_key , range_key = None , attributes_to_get = None , consistent_read = False , item_class = Item ) : return self . layer2 . get_item ( self , hash_key , range_key , attributes_to_get , consistent_read , item_class ) lookup = get_item def has_item ( self , hash_key , range_key = None , consistent_read = False ) : try : self . get_item ( hash_key , range_key = range_key , attributes_to_get = [ hash_key ] , consistent_read = consistent_read ) except dynamodb_exceptions . DynamoDBKeyNotFoundError : return False return True def new_item ( self , hash_key , range_key = None , attrs = None ) : return Item ( self , hash_key , range_key , attrs ) def query ( self , hash_key , range_key_condition = None , attributes_to_get = None , request_limit = None , max_results = None , consistent_read = False , scan_index_forward = True , exclusive_start_key = None , item_class = Item ) : return self . layer2 . query ( self , hash_key , range_key_condition , attributes_to_get , request_limit , max_results , consistent_read , scan_index_forward , exclusive_start_key , item_class = item_class ) def scan ( self , scan_filter = None , attributes_to_get = None , request_limit = None , max_results = None , count = False , exclusive_start_key = None , item_class = Item ) : return self . layer2 . scan ( self , scan_filter , attributes_to_get , request_limit , max_results , exclusive_start_key , item_class = item_class )

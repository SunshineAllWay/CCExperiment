import types import boto import boto . utils from boto . ec2 . regioninfo import RegionInfo from boto . emr . emrobject import JobFlow , RunJobFlowResponse from boto . emr . emrobject import AddInstanceGroupsResponse , ModifyInstanceGroupsResponse from boto . emr . step import JarStep from boto . connection import AWSQueryConnection from boto . exception import EmrResponseError class EmrConnection ( AWSQueryConnection ) : APIVersion = boto . config . get ( 'Boto' , 'emr_version' , '2009-03-31' ) DefaultRegionName = boto . config . get ( 'Boto' , 'emr_region_name' , 'us-east-1' ) DefaultRegionEndpoint = boto . config . get ( 'Boto' , 'emr_region_endpoint' , ) ResponseError = EmrResponseError DebuggingJar = 's3n://us-east-1.elasticmapreduce/libs/script-runner/script-runner.jar' DebuggingArgs = 's3n://us-east-1.elasticmapreduce/libs/state-pusher/0.1/fetch' def __init__ ( self , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , proxy_user = None , proxy_pass = None , debug = 0 , https_connection_factory = None , region = None , path = '/' ) : if not region : region = RegionInfo ( self , self . DefaultRegionName , self . DefaultRegionEndpoint ) self . region = region AWSQueryConnection . __init__ ( self , aws_access_key_id , aws_secret_access_key , is_secure , port , proxy , proxy_port , proxy_user , proxy_pass , self . region . endpoint , debug , https_connection_factory , path ) def _required_auth_capability ( self ) : return [ 'emr' ] def describe_jobflow ( self , jobflow_id ) : jobflows = self . describe_jobflows ( jobflow_ids = [ jobflow_id ] ) if jobflows : return jobflows [ 0 ] def describe_jobflows ( self , states = None , jobflow_ids = None , created_after = None , created_before = None ) : params = { } if states : self . build_list_params ( params , states , 'JobFlowStates.member' ) if jobflow_ids : self . build_list_params ( params , jobflow_ids , 'JobFlowIds.member' ) if created_after : params [ 'CreatedAfter' ] = created_after . strftime ( boto . utils . ISO8601 ) if created_before : params [ 'CreatedBefore' ] = created_before . strftime ( boto . utils . ISO8601 ) return self . get_list ( 'DescribeJobFlows' , params , [ ( 'member' , JobFlow ) ] ) def terminate_jobflow ( self , jobflow_id ) : self . terminate_jobflows ( [ jobflow_id ] ) def terminate_jobflows ( self , jobflow_ids ) : params = { } self . build_list_params ( params , jobflow_ids , 'JobFlowIds.member' ) return self . get_status ( 'TerminateJobFlows' , params , verb = 'POST' ) def add_jobflow_steps ( self , jobflow_id , steps ) : if type ( steps ) != types . ListType : steps = [ steps ] params = { } params [ 'JobFlowId' ] = jobflow_id step_args = [ self . _build_step_args ( step ) for step in steps ] params . update ( self . _build_step_list ( step_args ) ) return self . get_object ( , params , RunJobFlowResponse , verb = 'POST' ) def add_instance_groups ( self , jobflow_id , instance_groups ) : if type ( instance_groups ) != types . ListType : instance_groups = [ instance_groups ] params = { } params [ 'JobFlowId' ] = jobflow_id params . update ( self . _build_instance_group_list_args ( instance_groups ) ) return self . get_object ( 'AddInstanceGroups' , params , AddInstanceGroupsResponse , verb = 'POST' ) def modify_instance_groups ( self , instance_group_ids , new_sizes ) : if type ( instance_group_ids ) != types . ListType : instance_group_ids = [ instance_group_ids ] if type ( new_sizes ) != types . ListType : new_sizes = [ new_sizes ] instance_groups = zip ( instance_group_ids , new_sizes ) params = { } for k , ig in enumerate ( instance_groups ) : params [ 'InstanceGroups.member.%d.InstanceGroupId' % ( k + 1 ) ] = ig [ 0 ] params [ 'InstanceGroups.member.%d.InstanceCount' % ( k + 1 ) ] = ig [ 1 ] return self . get_object ( 'ModifyInstanceGroups' , params , ModifyInstanceGroupsResponse , verb = 'POST' ) def run_jobflow ( self , name , log_uri , ec2_keyname = None , availability_zone = None , master_instance_type = 'm1.small' , slave_instance_type = 'm1.small' , num_instances = 1 , action_on_failure = 'TERMINATE_JOB_FLOW' , keep_alive = False , enable_debugging = False , hadoop_version = None , steps = [ ] , bootstrap_actions = [ ] , instance_groups = None , additional_info = None , ami_version = "1.0" , api_params = None ) : if not ( hadoop_version or ami_version ) : hadoop_version = '0.20' params = { } if action_on_failure : params [ 'ActionOnFailure' ] = action_on_failure params [ 'Name' ] = name params [ 'LogUri' ] = log_uri common_params = self . _build_instance_common_args ( ec2_keyname , availability_zone , keep_alive , hadoop_version ) params . update ( common_params ) if not instance_groups : instance_params = self . _build_instance_count_and_type_args ( master_instance_type , slave_instance_type , num_instances ) params . update ( instance_params ) else : list_args = self . _build_instance_group_list_args ( instance_groups ) instance_params = dict ( ( 'Instances.%s' % k , v ) for k , v in list_args . iteritems ( ) ) params . update ( instance_params ) if enable_debugging : debugging_step = JarStep ( name = 'Setup Hadoop Debugging' , action_on_failure = 'TERMINATE_JOB_FLOW' , main_class = None , jar = self . DebuggingJar , step_args = self . DebuggingArgs ) steps . insert ( 0 , debugging_step ) if steps : step_args = [ self . _build_step_args ( step ) for step in steps ] params . update ( self . _build_step_list ( step_args ) ) if bootstrap_actions : bootstrap_action_args = [ self . _build_bootstrap_action_args ( bootstrap_action ) for bootstrap_action in bootstrap_actions ] params . update ( self . _build_bootstrap_action_list ( bootstrap_action_args ) ) if ami_version : params [ 'AmiVersion' ] = ami_version if additional_info is not None : params [ 'AdditionalInfo' ] = additional_info if api_params : for key , value in api_params . iteritems ( ) : if value is None : params . pop ( key , None ) else : params [ key ] = value response = self . get_object ( , params , RunJobFlowResponse , verb = 'POST' ) return response . jobflowid def set_termination_protection ( self , jobflow_id , termination_protection_status ) : assert termination_protection_status in ( True , False ) params = { } params [ 'TerminationProtected' ] = ( termination_protection_status and "true" ) or "false" self . build_list_params ( params , [ jobflow_id ] , 'JobFlowIds.member' ) return self . get_status ( 'SetTerminationProtection' , params , verb = 'POST' ) def _build_bootstrap_action_args ( self , bootstrap_action ) : bootstrap_action_params = { } bootstrap_action_params [ 'ScriptBootstrapAction.Path' ] = bootstrap_action . path try : bootstrap_action_params [ 'Name' ] = bootstrap_action . name except AttributeError : pass args = bootstrap_action . args ( ) if args : self . build_list_params ( bootstrap_action_params , args , 'ScriptBootstrapAction.Args.member' ) return bootstrap_action_params def _build_step_args ( self , step ) : step_params = { } step_params [ 'ActionOnFailure' ] = step . action_on_failure step_params [ 'HadoopJarStep.Jar' ] = step . jar ( ) main_class = step . main_class ( ) if main_class : step_params [ 'HadoopJarStep.MainClass' ] = main_class args = step . args ( ) if args : self . build_list_params ( step_params , args , 'HadoopJarStep.Args.member' ) step_params [ 'Name' ] = step . name return step_params def _build_bootstrap_action_list ( self , bootstrap_actions ) : if type ( bootstrap_actions ) != types . ListType : bootstrap_actions = [ bootstrap_actions ] params = { } for i , bootstrap_action in enumerate ( bootstrap_actions ) : for key , value in bootstrap_action . iteritems ( ) : params [ 'BootstrapActions.member.%s.%s' % ( i + 1 , key ) ] = value return params def _build_step_list ( self , steps ) : if type ( steps ) != types . ListType : steps = [ steps ] params = { } for i , step in enumerate ( steps ) : for key , value in step . iteritems ( ) : params [ 'Steps.member.%s.%s' % ( i + 1 , key ) ] = value return params def _build_instance_common_args ( self , ec2_keyname , availability_zone , keep_alive , hadoop_version ) : params = { : str ( keep_alive ) . lower ( ) , } if hadoop_version : params [ 'Instances.HadoopVersion' ] = hadoop_version if ec2_keyname : params [ 'Instances.Ec2KeyName' ] = ec2_keyname if availability_zone : params [ 'Instances.Placement.AvailabilityZone' ] = availability_zone return params def _build_instance_count_and_type_args ( self , master_instance_type , slave_instance_type , num_instances ) : params = { : master_instance_type , : slave_instance_type , : num_instances , } return params def _build_instance_group_args ( self , instance_group ) : params = { : instance_group . num_instances , : instance_group . role , : instance_group . type , : instance_group . name , : instance_group . market } if instance_group . market == 'SPOT' : params [ 'BidPrice' ] = instance_group . bidprice return params def _build_instance_group_list_args ( self , instance_groups ) : if type ( instance_groups ) != types . ListType : instance_groups = [ instance_groups ] params = { } for i , instance_group in enumerate ( instance_groups ) : ig_dict = self . _build_instance_group_args ( instance_group ) for key , value in ig_dict . iteritems ( ) : params [ 'InstanceGroups.member.%d.%s' % ( i + 1 , key ) ] = value return params

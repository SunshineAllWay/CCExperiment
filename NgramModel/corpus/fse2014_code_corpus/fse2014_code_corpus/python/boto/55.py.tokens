from __future__ import with_statement import base64 import errno import httplib import os import Queue import random import re import socket import sys import time import urllib , urlparse import xml . sax import auth import auth_handler import boto import boto . utils import boto . handler import boto . cacerts from boto import config , UserAgent from boto . exception import AWSConnectionError , BotoClientError , BotoServerError from boto . provider import Provider from boto . resultset import ResultSet HAVE_HTTPS_CONNECTION = False try : import ssl from boto import https_connection if hasattr ( ssl , 'SSLError' ) : HAVE_HTTPS_CONNECTION = True except ImportError : pass try : import threading except ImportError : import dummy_threading as threading ON_APP_ENGINE = all ( key in os . environ for key in ( , 'CURRENT_VERSION_ID' , 'APPLICATION_ID' ) ) PORTS_BY_SECURITY = { True : 443 , False : 80 } DEFAULT_CA_CERTS_FILE = os . path . join ( os . path . dirname ( os . path . abspath ( boto . cacerts . __file__ ) ) , "cacerts.txt" ) class HostConnectionPool ( object ) : def __init__ ( self ) : self . queue = [ ] def size ( self ) : return len ( self . queue ) def put ( self , conn ) : self . queue . append ( ( conn , time . time ( ) ) ) def get ( self ) : self . clean ( ) for _ in range ( len ( self . queue ) ) : ( conn , _ ) = self . queue . pop ( 0 ) if self . _conn_ready ( conn ) : return conn else : self . put ( conn ) return None def _conn_ready ( self , conn ) : if ON_APP_ENGINE : return False else : response = getattr ( conn , '_HTTPConnection__response' , None ) return ( response is None ) or response . isclosed ( ) def clean ( self ) : while len ( self . queue ) > 0 and self . _pair_stale ( self . queue [ 0 ] ) : self . queue . pop ( 0 ) def _pair_stale ( self , pair ) : ( _conn , return_time ) = pair now = time . time ( ) return return_time + ConnectionPool . STALE_DURATION < now class ConnectionPool ( object ) : CLEAN_INTERVAL = 5.0 STALE_DURATION = 60.0 def __init__ ( self ) : self . host_to_pool = { } self . last_clean_time = 0.0 self . mutex = threading . Lock ( ) def size ( self ) : return sum ( pool . size ( ) for pool in self . host_to_pool . values ( ) ) def get_http_connection ( self , host , is_secure ) : self . clean ( ) with self . mutex : key = ( host , is_secure ) if key not in self . host_to_pool : return None return self . host_to_pool [ key ] . get ( ) def put_http_connection ( self , host , is_secure , conn ) : with self . mutex : key = ( host , is_secure ) if key not in self . host_to_pool : self . host_to_pool [ key ] = HostConnectionPool ( ) self . host_to_pool [ key ] . put ( conn ) def clean ( self ) : with self . mutex : now = time . time ( ) if self . last_clean_time + self . CLEAN_INTERVAL < now : to_remove = [ ] for ( host , pool ) in self . host_to_pool . items ( ) : pool . clean ( ) if pool . size ( ) == 0 : to_remove . append ( host ) for host in to_remove : del self . host_to_pool [ host ] self . last_clean_time = now class HTTPRequest ( object ) : def __init__ ( self , method , protocol , host , port , path , auth_path , params , headers , body ) : self . method = method self . protocol = protocol self . host = host self . port = port self . path = path if auth_path is None : auth_path = path self . auth_path = auth_path self . params = params if headers and 'Transfer-Encoding' in headers and headers [ 'Transfer-Encoding' ] == 'chunked' and self . method != 'PUT' : self . headers = headers . copy ( ) del self . headers [ 'Transfer-Encoding' ] else : self . headers = headers self . body = body def __str__ ( self ) : return ( ( 'method:(%s) protocol:(%s) host(%s) port(%s) path(%s) ' ) % ( self . method , self . protocol , self . host , self . port , self . path , self . params , self . headers , self . body ) ) def authorize ( self , connection , ** kwargs ) : for key in self . headers : val = self . headers [ key ] if isinstance ( val , unicode ) : self . headers [ key ] = urllib . quote_plus ( val . encode ( 'utf-8' ) ) connection . _auth_handler . add_auth ( self , ** kwargs ) self . headers [ 'User-Agent' ] = UserAgent if not self . headers . has_key ( 'Content-Length' ) : if not self . headers . has_key ( 'Transfer-Encoding' ) or self . headers [ 'Transfer-Encoding' ] != 'chunked' : self . headers [ 'Content-Length' ] = str ( len ( self . body ) ) class AWSAuthConnection ( object ) : def __init__ ( self , host , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , proxy_user = None , proxy_pass = None , debug = 0 , https_connection_factory = None , path = '/' , provider = 'aws' , security_token = None , suppress_consec_slashes = True ) : self . suppress_consec_slashes = suppress_consec_slashes self . num_retries = 6 if config . has_option ( 'Boto' , 'is_secure' ) : is_secure = config . getboolean ( 'Boto' , 'is_secure' ) self . is_secure = is_secure self . https_validate_certificates = config . getbool ( , 'https_validate_certificates' , False ) if self . https_validate_certificates and not HAVE_HTTPS_CONNECTION : raise BotoClientError ( ) self . ca_certificates_file = config . get_value ( , 'ca_certificates_file' , DEFAULT_CA_CERTS_FILE ) self . handle_proxy ( proxy , proxy_port , proxy_user , proxy_pass ) self . http_exceptions = ( httplib . HTTPException , socket . error , socket . gaierror ) self . http_unretryable_exceptions = [ ] if HAVE_HTTPS_CONNECTION : self . http_unretryable_exceptions . append ( https_connection . InvalidCertificateException ) self . socket_exception_values = ( errno . EINTR , ) if https_connection_factory is not None : self . https_connection_factory = https_connection_factory [ 0 ] self . http_exceptions += https_connection_factory [ 1 ] else : self . https_connection_factory = None if ( is_secure ) : self . protocol = 'https' else : self . protocol = 'http' self . host = host self . path = path if isinstance ( debug , ( int , long ) ) : self . debug = debug else : self . debug = config . getint ( 'Boto' , 'debug' , 0 ) if port : self . port = port else : self . port = PORTS_BY_SECURITY [ is_secure ] self . http_connection_kwargs = { } if ( sys . version_info [ 0 ] , sys . version_info [ 1 ] ) >= ( 2 , 6 ) : if config . has_option ( 'Boto' , 'http_socket_timeout' ) : timeout = config . getint ( 'Boto' , 'http_socket_timeout' ) self . http_connection_kwargs [ 'timeout' ] = timeout self . provider = Provider ( provider , aws_access_key_id , aws_secret_access_key , security_token ) if self . provider . host : self . host = self . provider . host self . _pool = ConnectionPool ( ) self . _connection = ( self . server_name ( ) , self . is_secure ) self . _last_rs = None self . _auth_handler = auth . get_auth_handler ( host , config , self . provider , self . _required_auth_capability ( ) ) def __repr__ ( self ) : return '%s:%s' % ( self . __class__ . __name__ , self . host ) def _required_auth_capability ( self ) : return [ ] def connection ( self ) : return self . get_http_connection ( * self . _connection ) connection = property ( connection ) def aws_access_key_id ( self ) : return self . provider . access_key aws_access_key_id = property ( aws_access_key_id ) gs_access_key_id = aws_access_key_id access_key = aws_access_key_id def aws_secret_access_key ( self ) : return self . provider . secret_key aws_secret_access_key = property ( aws_secret_access_key ) gs_secret_access_key = aws_secret_access_key secret_key = aws_secret_access_key def get_path ( self , path = '/' ) : if not self . suppress_consec_slashes : return self . path + re . sub ( '^/*' , "" , path ) pos = path . find ( '?' ) if pos >= 0 : params = path [ pos : ] path = path [ : pos ] else : params = None if path [ - 1 ] == '/' : need_trailing = True else : need_trailing = False path_elements = self . path . split ( '/' ) path_elements . extend ( path . split ( '/' ) ) path_elements = [ p for p in path_elements if p ] path = '/' + '/' . join ( path_elements ) if path [ - 1 ] != '/' and need_trailing : path += '/' if params : path = path + params return path def server_name ( self , port = None ) : if not port : port = self . port if port == 80 : signature_host = self . host else : if ( ( ON_APP_ENGINE and sys . version [ : 3 ] == '2.5' ) or sys . version [ : 3 ] in ( '2.6' , '2.7' ) ) and port == 443 : signature_host = self . host else : signature_host = '%s:%d' % ( self . host , port ) return signature_host def handle_proxy ( self , proxy , proxy_port , proxy_user , proxy_pass ) : self . proxy = proxy self . proxy_port = proxy_port self . proxy_user = proxy_user self . proxy_pass = proxy_pass if os . environ . has_key ( 'http_proxy' ) and not self . proxy : pattern = re . compile ( '(?:(?P<user>\w+):(?P<pass>.*)@)?' '(?P<host>[\w\-\.]+)' '(?::(?P<port>\d+))?' ) match = pattern . match ( os . environ [ 'http_proxy' ] ) if match : self . proxy = match . group ( 'host' ) self . proxy_port = match . group ( 'port' ) self . proxy_user = match . group ( 'user' ) self . proxy_pass = match . group ( 'pass' ) else : if not self . proxy : self . proxy = config . get_value ( 'Boto' , 'proxy' , None ) if not self . proxy_port : self . proxy_port = config . get_value ( 'Boto' , 'proxy_port' , None ) if not self . proxy_user : self . proxy_user = config . get_value ( 'Boto' , 'proxy_user' , None ) if not self . proxy_pass : self . proxy_pass = config . get_value ( 'Boto' , 'proxy_pass' , None ) if not self . proxy_port and self . proxy : print "http_proxy environment variable does not specify " "a port, using default" self . proxy_port = self . port self . use_proxy = ( self . proxy != None ) def get_http_connection ( self , host , is_secure ) : conn = self . _pool . get_http_connection ( host , is_secure ) if conn is not None : return conn else : return self . new_http_connection ( host , is_secure ) def new_http_connection ( self , host , is_secure ) : if self . use_proxy : host = '%s:%d' % ( self . proxy , int ( self . proxy_port ) ) if host is None : host = self . server_name ( ) if is_secure : boto . log . debug ( , host , self . http_connection_kwargs ) if self . use_proxy : connection = self . proxy_ssl ( ) elif self . https_connection_factory : connection = self . https_connection_factory ( host ) elif self . https_validate_certificates and HAVE_HTTPS_CONNECTION : connection = https_connection . CertValidatingHTTPSConnection ( host , ca_certs = self . ca_certificates_file , ** self . http_connection_kwargs ) else : connection = httplib . HTTPSConnection ( host , ** self . http_connection_kwargs ) else : boto . log . debug ( 'establishing HTTP connection: kwargs=%s' % self . http_connection_kwargs ) connection = httplib . HTTPConnection ( host , ** self . http_connection_kwargs ) if self . debug > 1 : connection . set_debuglevel ( self . debug ) if host . split ( ':' ) [ 0 ] == self . host and is_secure == self . is_secure : self . _connection = ( host , is_secure ) return connection def put_http_connection ( self , host , is_secure , connection ) : self . _pool . put_http_connection ( host , is_secure , connection ) def proxy_ssl ( self ) : host = '%s:%d' % ( self . host , self . port ) sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) try : sock . connect ( ( self . proxy , int ( self . proxy_port ) ) ) except : raise boto . log . debug ( "Proxy connection: CONNECT %s HTTP/1.0\r\n" , host ) sock . sendall ( "CONNECT %s HTTP/1.0\r\n" % host ) sock . sendall ( "User-Agent: %s\r\n" % UserAgent ) if self . proxy_user and self . proxy_pass : for k , v in self . get_proxy_auth_header ( ) . items ( ) : sock . sendall ( "%s: %s\r\n" % ( k , v ) ) sock . sendall ( "\r\n" ) resp = httplib . HTTPResponse ( sock , strict = True , debuglevel = self . debug ) resp . begin ( ) if resp . status != 200 : raise socket . error ( - 71 , % ( self . proxy , self . proxy_port , resp . status , resp . reason ) ) resp . close ( ) h = httplib . HTTPConnection ( host ) if self . https_validate_certificates and HAVE_HTTPS_CONNECTION : boto . log . debug ( "wrapping ssl socket for proxied connection; " , self . ca_certificates_file ) key_file = self . http_connection_kwargs . get ( 'key_file' , None ) cert_file = self . http_connection_kwargs . get ( 'cert_file' , None ) sslSock = ssl . wrap_socket ( sock , keyfile = key_file , certfile = cert_file , cert_reqs = ssl . CERT_REQUIRED , ca_certs = self . ca_certificates_file ) cert = sslSock . getpeercert ( ) hostname = self . host . split ( ':' , 0 ) [ 0 ] if not https_connection . ValidateCertificateHostname ( cert , hostname ) : raise https_connection . InvalidCertificateException ( hostname , cert , 'hostname mismatch' ) else : if hasattr ( httplib , 'ssl' ) : sslSock = httplib . ssl . SSLSocket ( sock ) else : sslSock = socket . ssl ( sock , None , None ) sslSock = httplib . FakeSocket ( sock , sslSock ) h . sock = sslSock return h def prefix_proxy_to_path ( self , path , host = None ) : path = self . protocol + '://' + ( host or self . server_name ( ) ) + path return path def get_proxy_auth_header ( self ) : auth = base64 . encodestring ( self . proxy_user + ':' + self . proxy_pass ) return { 'Proxy-Authorization' : 'Basic %s' % auth } def _mexe ( self , request , sender = None , override_num_retries = None , retry_handler = None ) : boto . log . debug ( 'Method: %s' % request . method ) boto . log . debug ( 'Path: %s' % request . path ) boto . log . debug ( 'Data: %s' % request . body ) boto . log . debug ( 'Headers: %s' % request . headers ) boto . log . debug ( 'Host: %s' % request . host ) response = None body = None e = None if override_num_retries is None : num_retries = config . getint ( 'Boto' , 'num_retries' , self . num_retries ) else : num_retries = override_num_retries i = 0 connection = self . get_http_connection ( request . host , self . is_secure ) while i <= num_retries : next_sleep = random . random ( ) * ( 2 ** i ) try : boto . log . debug ( 'Token: %s' % self . provider . security_token ) request . authorize ( connection = self ) if callable ( sender ) : response = sender ( connection , request . method , request . path , request . body , request . headers ) else : connection . request ( request . method , request . path , request . body , request . headers ) response = connection . getresponse ( ) location = response . getheader ( 'location' ) if request . method == 'HEAD' and getattr ( response , , False ) : response . chunked = 0 if callable ( retry_handler ) : status = retry_handler ( response , i , next_sleep ) if status : msg , i , next_sleep = status if msg : boto . log . debug ( msg ) time . sleep ( next_sleep ) continue if response . status == 500 or response . status == 503 : msg = 'Received %d response. ' % response . status msg += 'Retrying in %3.1f seconds' % next_sleep boto . log . debug ( msg ) body = response . read ( ) elif response . status < 300 or response . status >= 400 or not location : self . put_http_connection ( request . host , self . is_secure , connection ) return response else : scheme , request . host , request . path , params , query , fragment = urlparse . urlparse ( location ) if query : request . path += '?' + query msg = 'Redirecting: %s' % scheme + '://' msg += request . host + request . path boto . log . debug ( msg ) connection = self . get_http_connection ( request . host , scheme == 'https' ) continue except self . http_exceptions , e : for unretryable in self . http_unretryable_exceptions : if isinstance ( e , unretryable ) : boto . log . debug ( % e . __class__ . __name__ ) raise e boto . log . debug ( 'encountered %s exception, reconnecting' % e . __class__ . __name__ ) connection = self . new_http_connection ( request . host , self . is_secure ) time . sleep ( next_sleep ) i += 1 if response : raise BotoServerError ( response . status , response . reason , body ) elif e : raise e else : msg = 'Please report this exception as a Boto Issue!' raise BotoClientError ( msg ) def build_base_http_request ( self , method , path , auth_path , params = None , headers = None , data = '' , host = None ) : path = self . get_path ( path ) if auth_path is not None : auth_path = self . get_path ( auth_path ) if params == None : params = { } else : params = params . copy ( ) if headers == None : headers = { } else : headers = headers . copy ( ) host = host or self . host if self . use_proxy : if not auth_path : auth_path = path path = self . prefix_proxy_to_path ( path , host ) if self . proxy_user and self . proxy_pass and not self . is_secure : headers . update ( self . get_proxy_auth_header ( ) ) return HTTPRequest ( method , self . protocol , host , self . port , path , auth_path , params , headers , data ) def make_request ( self , method , path , headers = None , data = '' , host = None , auth_path = None , sender = None , override_num_retries = None ) : http_request = self . build_base_http_request ( method , path , auth_path , { } , headers , data , host ) return self . _mexe ( http_request , sender , override_num_retries ) def close ( self ) : boto . log . debug ( 'closing all HTTP connections' ) self . _connection = None class AWSQueryConnection ( AWSAuthConnection ) : APIVersion = '' ResponseError = BotoServerError def __init__ ( self , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , proxy_user = None , proxy_pass = None , host = None , debug = 0 , https_connection_factory = None , path = '/' , security_token = None ) : AWSAuthConnection . __init__ ( self , host , aws_access_key_id , aws_secret_access_key , is_secure , port , proxy , proxy_port , proxy_user , proxy_pass , debug , https_connection_factory , path , security_token = security_token ) def _required_auth_capability ( self ) : return [ ] def get_utf8_value ( self , value ) : return boto . utils . get_utf8_value ( value ) def make_request ( self , action , params = None , path = '/' , verb = 'GET' ) : http_request = self . build_base_http_request ( verb , path , None , params , { } , '' , self . server_name ( ) ) if action : http_request . params [ 'Action' ] = action if self . APIVersion : http_request . params [ 'Version' ] = self . APIVersion return self . _mexe ( http_request ) def build_list_params ( self , params , items , label ) : if isinstance ( items , str ) : items = [ items ] for i in range ( 1 , len ( items ) + 1 ) : params [ '%s.%d' % ( label , i ) ] = items [ i - 1 ] def get_list ( self , action , params , markers , path = '/' , parent = None , verb = 'GET' ) : if not parent : parent = self response = self . make_request ( action , params , path , verb ) body = response . read ( ) boto . log . debug ( body ) if not body : boto . log . error ( 'Null body %s' % body ) raise self . ResponseError ( response . status , response . reason , body ) elif response . status == 200 : rs = ResultSet ( markers ) h = boto . handler . XmlHandler ( rs , parent ) xml . sax . parseString ( body , h ) return rs else : boto . log . error ( '%s %s' % ( response . status , response . reason ) ) boto . log . error ( '%s' % body ) raise self . ResponseError ( response . status , response . reason , body ) def get_object ( self , action , params , cls , path = '/' , parent = None , verb = 'GET' ) : if not parent : parent = self response = self . make_request ( action , params , path , verb ) body = response . read ( ) boto . log . debug ( body ) if not body : boto . log . error ( 'Null body %s' % body ) raise self . ResponseError ( response . status , response . reason , body ) elif response . status == 200 : obj = cls ( parent ) h = boto . handler . XmlHandler ( obj , parent ) xml . sax . parseString ( body , h ) return obj else : boto . log . error ( '%s %s' % ( response . status , response . reason ) ) boto . log . error ( '%s' % body ) raise self . ResponseError ( response . status , response . reason , body ) def get_status ( self , action , params , path = '/' , parent = None , verb = 'GET' ) : if not parent : parent = self response = self . make_request ( action , params , path , verb ) body = response . read ( ) boto . log . debug ( body ) if not body : boto . log . error ( 'Null body %s' % body ) raise self . ResponseError ( response . status , response . reason , body ) elif response . status == 200 : rs = ResultSet ( ) h = boto . handler . XmlHandler ( rs , parent ) xml . sax . parseString ( body , h ) return rs . status else : boto . log . error ( '%s %s' % ( response . status , response . reason ) ) boto . log . error ( '%s' % body ) raise self . ResponseError ( response . status , response . reason , body )

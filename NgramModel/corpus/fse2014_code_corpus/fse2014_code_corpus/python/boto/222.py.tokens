import xml . sax import threading import boto from boto import handler from boto . connection import AWSQueryConnection from boto . sdb . domain import Domain , DomainMetaData from boto . sdb . item import Item from boto . sdb . regioninfo import SDBRegionInfo from boto . exception import SDBResponseError class ItemThread ( threading . Thread ) : def __init__ ( self , name , domain_name , item_names ) : threading . Thread . __init__ ( self , name = name ) self . domain_name = domain_name self . conn = SDBConnection ( ) self . item_names = item_names self . items = [ ] def run ( self ) : for item_name in self . item_names : item = self . conn . get_attributes ( self . domain_name , item_name ) self . items . append ( item ) class SDBConnection ( AWSQueryConnection ) : DefaultRegionName = 'us-east-1' DefaultRegionEndpoint = 'sdb.amazonaws.com' APIVersion = '2009-04-15' ResponseError = SDBResponseError def __init__ ( self , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , proxy_user = None , proxy_pass = None , debug = 0 , https_connection_factory = None , region = None , path = '/' , converter = None , security_token = None ) : if not region : region_name = boto . config . get ( 'SDB' , 'region' , self . DefaultRegionName ) for reg in boto . sdb . regions ( ) : if reg . name == region_name : region = reg break self . region = region AWSQueryConnection . __init__ ( self , aws_access_key_id , aws_secret_access_key , is_secure , port , proxy , proxy_port , proxy_user , proxy_pass , self . region . endpoint , debug , https_connection_factory , path , security_token = security_token ) self . box_usage = 0.0 self . converter = converter self . item_cls = Item def _required_auth_capability ( self ) : return [ 'sdb' ] def set_item_cls ( self , cls ) : self . item_cls = cls def _build_name_value_list ( self , params , attributes , replace = False , label = 'Attribute' ) : keys = attributes . keys ( ) keys . sort ( ) i = 1 for key in keys : value = attributes [ key ] if isinstance ( value , list ) : for v in value : params [ '%s.%d.Name' % ( label , i ) ] = key if self . converter : v = self . converter . encode ( v ) params [ '%s.%d.Value' % ( label , i ) ] = v if replace : params [ '%s.%d.Replace' % ( label , i ) ] = 'true' i += 1 else : params [ '%s.%d.Name' % ( label , i ) ] = key if self . converter : value = self . converter . encode ( value ) params [ '%s.%d.Value' % ( label , i ) ] = value if replace : params [ '%s.%d.Replace' % ( label , i ) ] = 'true' i += 1 def _build_expected_value ( self , params , expected_value ) : params [ 'Expected.1.Name' ] = expected_value [ 0 ] if expected_value [ 1 ] is True : params [ 'Expected.1.Exists' ] = 'true' elif expected_value [ 1 ] is False : params [ 'Expected.1.Exists' ] = 'false' else : params [ 'Expected.1.Value' ] = expected_value [ 1 ] def _build_batch_list ( self , params , items , replace = False ) : item_names = items . keys ( ) i = 0 for item_name in item_names : params [ 'Item.%d.ItemName' % i ] = item_name j = 0 item = items [ item_name ] if item is not None : attr_names = item . keys ( ) for attr_name in attr_names : value = item [ attr_name ] if isinstance ( value , list ) : for v in value : if self . converter : v = self . converter . encode ( v ) params [ 'Item.%d.Attribute.%d.Name' % ( i , j ) ] = attr_name params [ 'Item.%d.Attribute.%d.Value' % ( i , j ) ] = v if replace : params [ 'Item.%d.Attribute.%d.Replace' % ( i , j ) ] = 'true' j += 1 else : params [ 'Item.%d.Attribute.%d.Name' % ( i , j ) ] = attr_name if self . converter : value = self . converter . encode ( value ) params [ 'Item.%d.Attribute.%d.Value' % ( i , j ) ] = value if replace : params [ 'Item.%d.Attribute.%d.Replace' % ( i , j ) ] = 'true' j += 1 i += 1 def _build_name_list ( self , params , attribute_names ) : i = 1 attribute_names . sort ( ) for name in attribute_names : params [ 'Attribute.%d.Name' % i ] = name i += 1 def get_usage ( self ) : return self . box_usage def print_usage ( self ) : print 'Total Usage: %f compute seconds' % self . box_usage cost = self . box_usage * 0.14 print 'Approximate Cost: $%f' % cost def get_domain ( self , domain_name , validate = True ) : domain = Domain ( self , domain_name ) if validate : self . select ( domain , """select * from `%s` limit 1""" % domain_name ) return domain def lookup ( self , domain_name , validate = True ) : try : domain = self . get_domain ( domain_name , validate ) except : domain = None return domain def get_all_domains ( self , max_domains = None , next_token = None ) : params = { } if max_domains : params [ 'MaxNumberOfDomains' ] = max_domains if next_token : params [ 'NextToken' ] = next_token return self . get_list ( 'ListDomains' , params , [ ( 'DomainName' , Domain ) ] ) def create_domain ( self , domain_name ) : params = { 'DomainName' : domain_name } d = self . get_object ( 'CreateDomain' , params , Domain ) d . name = domain_name return d def get_domain_and_name ( self , domain_or_name ) : if ( isinstance ( domain_or_name , Domain ) ) : return ( domain_or_name , domain_or_name . name ) else : return ( self . get_domain ( domain_or_name ) , domain_or_name ) def delete_domain ( self , domain_or_name ) : domain , domain_name = self . get_domain_and_name ( domain_or_name ) params = { 'DomainName' : domain_name } return self . get_status ( 'DeleteDomain' , params ) def domain_metadata ( self , domain_or_name ) : domain , domain_name = self . get_domain_and_name ( domain_or_name ) params = { 'DomainName' : domain_name } d = self . get_object ( 'DomainMetadata' , params , DomainMetaData ) d . domain = domain return d def put_attributes ( self , domain_or_name , item_name , attributes , replace = True , expected_value = None ) : domain , domain_name = self . get_domain_and_name ( domain_or_name ) params = { 'DomainName' : domain_name , : item_name } self . _build_name_value_list ( params , attributes , replace ) if expected_value : self . _build_expected_value ( params , expected_value ) return self . get_status ( 'PutAttributes' , params ) def batch_put_attributes ( self , domain_or_name , items , replace = True ) : domain , domain_name = self . get_domain_and_name ( domain_or_name ) params = { 'DomainName' : domain_name } self . _build_batch_list ( params , items , replace ) return self . get_status ( 'BatchPutAttributes' , params , verb = 'POST' ) def get_attributes ( self , domain_or_name , item_name , attribute_names = None , consistent_read = False , item = None ) : domain , domain_name = self . get_domain_and_name ( domain_or_name ) params = { 'DomainName' : domain_name , : item_name } if consistent_read : params [ 'ConsistentRead' ] = 'true' if attribute_names : if not isinstance ( attribute_names , list ) : attribute_names = [ attribute_names ] self . build_list_params ( params , attribute_names , 'AttributeName' ) response = self . make_request ( 'GetAttributes' , params ) body = response . read ( ) if response . status == 200 : if item == None : item = self . item_cls ( domain , item_name ) h = handler . XmlHandler ( item , self ) xml . sax . parseString ( body , h ) return item else : raise SDBResponseError ( response . status , response . reason , body ) def delete_attributes ( self , domain_or_name , item_name , attr_names = None , expected_value = None ) : domain , domain_name = self . get_domain_and_name ( domain_or_name ) params = { 'DomainName' : domain_name , : item_name } if attr_names : if isinstance ( attr_names , list ) : self . _build_name_list ( params , attr_names ) elif isinstance ( attr_names , dict ) or isinstance ( attr_names , self . item_cls ) : self . _build_name_value_list ( params , attr_names ) if expected_value : self . _build_expected_value ( params , expected_value ) return self . get_status ( 'DeleteAttributes' , params ) def batch_delete_attributes ( self , domain_or_name , items ) : domain , domain_name = self . get_domain_and_name ( domain_or_name ) params = { 'DomainName' : domain_name } self . _build_batch_list ( params , items , False ) return self . get_status ( 'BatchDeleteAttributes' , params , verb = 'POST' ) def select ( self , domain_or_name , query = '' , next_token = None , consistent_read = False ) : domain , domain_name = self . get_domain_and_name ( domain_or_name ) params = { 'SelectExpression' : query } if consistent_read : params [ 'ConsistentRead' ] = 'true' if next_token : params [ 'NextToken' ] = next_token try : return self . get_list ( 'Select' , params , [ ( 'Item' , self . item_cls ) ] , parent = domain ) except SDBResponseError , e : e . body = "Query: %s\n%s" % ( query , e . body ) raise e

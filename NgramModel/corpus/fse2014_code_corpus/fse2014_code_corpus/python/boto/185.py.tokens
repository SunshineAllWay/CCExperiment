from boto . ec2 . ec2object import TaggedEC2Object from boto . exception import BotoClientError class SecurityGroup ( TaggedEC2Object ) : def __init__ ( self , connection = None , owner_id = None , name = None , description = None , id = None ) : TaggedEC2Object . __init__ ( self , connection ) self . id = id self . owner_id = owner_id self . name = name self . description = description self . vpc_id = None self . rules = IPPermissionsList ( ) self . rules_egress = IPPermissionsList ( ) def __repr__ ( self ) : return 'SecurityGroup:%s' % self . name def startElement ( self , name , attrs , connection ) : retval = TaggedEC2Object . startElement ( self , name , attrs , connection ) if retval is not None : return retval if name == 'ipPermissions' : return self . rules elif name == 'ipPermissionsEgress' : return self . rules_egress else : return None def endElement ( self , name , value , connection ) : if name == 'ownerId' : self . owner_id = value elif name == 'groupId' : self . id = value elif name == 'groupName' : self . name = value elif name == 'vpcId' : self . vpc_id = value elif name == 'groupDescription' : self . description = value elif name == 'ipRanges' : pass elif name == 'return' : if value == 'false' : self . status = False elif value == 'true' : self . status = True else : raise Exception ( % ( value , self . name ) ) else : setattr ( self , name , value ) def delete ( self ) : return self . connection . delete_security_group ( self . name ) def add_rule ( self , ip_protocol , from_port , to_port , src_group_name , src_group_owner_id , cidr_ip ) : rule = IPPermissions ( self ) rule . ip_protocol = ip_protocol rule . from_port = from_port rule . to_port = to_port self . rules . append ( rule ) rule . add_grant ( src_group_name , src_group_owner_id , cidr_ip ) def remove_rule ( self , ip_protocol , from_port , to_port , src_group_name , src_group_owner_id , cidr_ip ) : target_rule = None for rule in self . rules : if rule . ip_protocol == ip_protocol : if rule . from_port == from_port : if rule . to_port == to_port : target_rule = rule target_grant = None for grant in rule . grants : if grant . name == src_group_name : if grant . owner_id == src_group_owner_id : if grant . cidr_ip == cidr_ip : target_grant = grant if target_grant : rule . grants . remove ( target_grant ) if len ( rule . grants ) == 0 : self . rules . remove ( target_rule ) def authorize ( self , ip_protocol = None , from_port = None , to_port = None , cidr_ip = None , src_group = None ) : if src_group : cidr_ip = None src_group_name = src_group . name src_group_owner_id = src_group . owner_id else : src_group_name = None src_group_owner_id = None status = self . connection . authorize_security_group ( self . name , src_group_name , src_group_owner_id , ip_protocol , from_port , to_port , cidr_ip ) if status : self . add_rule ( ip_protocol , from_port , to_port , src_group_name , src_group_owner_id , cidr_ip ) return status def revoke ( self , ip_protocol = None , from_port = None , to_port = None , cidr_ip = None , src_group = None ) : if src_group : cidr_ip = None src_group_name = src_group . name src_group_owner_id = src_group . owner_id else : src_group_name = None src_group_owner_id = None status = self . connection . revoke_security_group ( self . name , src_group_name , src_group_owner_id , ip_protocol , from_port , to_port , cidr_ip ) if status : self . remove_rule ( ip_protocol , from_port , to_port , src_group_name , src_group_owner_id , cidr_ip ) return status def copy_to_region ( self , region , name = None ) : if region . name == self . region : raise BotoClientError ( 'Unable to copy to the same Region' ) conn_params = self . connection . get_params ( ) rconn = region . connect ( ** conn_params ) sg = rconn . create_security_group ( name or self . name , self . description ) source_groups = [ ] for rule in self . rules : for grant in rule . grants : if grant . name : if grant . name not in source_groups : source_groups . append ( grant . name ) sg . authorize ( None , None , None , None , grant ) else : sg . authorize ( rule . ip_protocol , rule . from_port , rule . to_port , grant . cidr_ip ) return sg def instances ( self ) : instances = [ ] rs = self . connection . get_all_instances ( ) for reservation in rs : uses_group = [ g . name for g in reservation . groups if g . name == self . name ] if uses_group : instances . extend ( reservation . instances ) return instances class IPPermissionsList ( list ) : def startElement ( self , name , attrs , connection ) : if name == 'item' : self . append ( IPPermissions ( self ) ) return self [ - 1 ] return None def endElement ( self , name , value , connection ) : pass class IPPermissions ( object ) : def __init__ ( self , parent = None ) : self . parent = parent self . ip_protocol = None self . from_port = None self . to_port = None self . grants = [ ] def __repr__ ( self ) : return 'IPPermissions:%s(%s-%s)' % ( self . ip_protocol , self . from_port , self . to_port ) def startElement ( self , name , attrs , connection ) : if name == 'item' : self . grants . append ( GroupOrCIDR ( self ) ) return self . grants [ - 1 ] return None def endElement ( self , name , value , connection ) : if name == 'ipProtocol' : self . ip_protocol = value elif name == 'fromPort' : self . from_port = value elif name == 'toPort' : self . to_port = value else : setattr ( self , name , value ) def add_grant ( self , name = None , owner_id = None , cidr_ip = None ) : grant = GroupOrCIDR ( self ) grant . owner_id = owner_id grant . name = name grant . cidr_ip = cidr_ip self . grants . append ( grant ) return grant class GroupOrCIDR ( object ) : def __init__ ( self , parent = None ) : self . owner_id = None self . name = None self . cidr_ip = None def __repr__ ( self ) : if self . cidr_ip : return '%s' % self . cidr_ip else : return '%s-%s' % ( self . name , self . owner_id ) def startElement ( self , name , attrs , connection ) : return None def endElement ( self , name , value , connection ) : if name == 'userId' : self . owner_id = value elif name == 'groupName' : self . name = value if name == 'cidrIp' : self . cidr_ip = value else : setattr ( self , name , value )

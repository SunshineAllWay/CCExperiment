import base64 import boto from boto . connection import AWSQueryConnection from boto . ec2 . regioninfo import RegionInfo from boto . ec2 . autoscale . request import Request from boto . ec2 . autoscale . launchconfig import LaunchConfiguration from boto . ec2 . autoscale . group import AutoScalingGroup , ProcessType from boto . ec2 . autoscale . activity import Activity from boto . ec2 . autoscale . policy import AdjustmentType , MetricCollectionTypes , ScalingPolicy from boto . ec2 . autoscale . instance import Instance from boto . ec2 . autoscale . scheduled import ScheduledUpdateGroupAction from boto . ec2 . autoscale . tag import Tag RegionData = { : 'autoscaling.us-east-1.amazonaws.com' , : 'autoscaling.us-west-1.amazonaws.com' , : 'autoscaling.us-west-2.amazonaws.com' , : 'autoscaling.sa-east-1.amazonaws.com' , : 'autoscaling.eu-west-1.amazonaws.com' , : 'autoscaling.ap-northeast-1.amazonaws.com' , : 'autoscaling.ap-southeast-1.amazonaws.com' } def regions ( ) : regions = [ ] for region_name in RegionData : region = RegionInfo ( name = region_name , endpoint = RegionData [ region_name ] , connection_cls = AutoScaleConnection ) regions . append ( region ) return regions def connect_to_region ( region_name , ** kw_params ) : for region in regions ( ) : if region . name == region_name : return region . connect ( ** kw_params ) return None class AutoScaleConnection ( AWSQueryConnection ) : APIVersion = boto . config . get ( 'Boto' , 'autoscale_version' , '2011-01-01' ) DefaultRegionEndpoint = boto . config . get ( 'Boto' , 'autoscale_endpoint' , ) DefaultRegionName = boto . config . get ( 'Boto' , 'autoscale_region_name' , ) def __init__ ( self , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , proxy_user = None , proxy_pass = None , debug = 0 , https_connection_factory = None , region = None , path = '/' ) : if not region : region = RegionInfo ( self , self . DefaultRegionName , self . DefaultRegionEndpoint , AutoScaleConnection ) self . region = region AWSQueryConnection . __init__ ( self , aws_access_key_id , aws_secret_access_key , is_secure , port , proxy , proxy_port , proxy_user , proxy_pass , self . region . endpoint , debug , https_connection_factory , path = path ) def _required_auth_capability ( self ) : return [ 'ec2' ] def build_list_params ( self , params , items , label ) : for i in xrange ( 1 , len ( items ) + 1 ) : if isinstance ( items [ i - 1 ] , dict ) : for k , v in items [ i - 1 ] . iteritems ( ) : if isinstance ( v , dict ) : for kk , vv in v . iteritems ( ) : params [ '%s.member.%d.%s.%s' % ( label , i , k , kk ) ] = vv else : params [ '%s.member.%d.%s' % ( label , i , k ) ] = v elif isinstance ( items [ i - 1 ] , basestring ) : params [ '%s.member.%d' % ( label , i ) ] = items [ i - 1 ] def _update_group ( self , op , as_group ) : params = { 'AutoScalingGroupName' : as_group . name , : as_group . launch_config_name , : as_group . min_size , : as_group . max_size } zones = as_group . availability_zones self . build_list_params ( params , zones , 'AvailabilityZones' ) if as_group . desired_capacity : params [ 'DesiredCapacity' ] = as_group . desired_capacity if as_group . vpc_zone_identifier : params [ 'VPCZoneIdentifier' ] = as_group . vpc_zone_identifier if as_group . health_check_period : params [ 'HealthCheckGracePeriod' ] = as_group . health_check_period if as_group . health_check_type : params [ 'HealthCheckType' ] = as_group . health_check_type if as_group . default_cooldown : params [ 'DefaultCooldown' ] = as_group . default_cooldown if as_group . placement_group : params [ 'PlacementGroup' ] = as_group . placement_group if op . startswith ( 'Create' ) : if as_group . load_balancers : self . build_list_params ( params , as_group . load_balancers , ) return self . get_object ( op , params , Request ) def create_auto_scaling_group ( self , as_group ) : return self . _update_group ( 'CreateAutoScalingGroup' , as_group ) def delete_auto_scaling_group ( self , name , force_delete = False ) : if ( force_delete ) : params = { 'AutoScalingGroupName' : name , 'ForceDelete' : 'true' } else : params = { 'AutoScalingGroupName' : name } return self . get_object ( 'DeleteAutoScalingGroup' , params , Request ) def create_launch_configuration ( self , launch_config ) : params = { 'ImageId' : launch_config . image_id , : launch_config . name , : launch_config . instance_type } if launch_config . key_name : params [ 'KeyName' ] = launch_config . key_name if launch_config . user_data : params [ 'UserData' ] = base64 . b64encode ( launch_config . user_data ) if launch_config . kernel_id : params [ 'KernelId' ] = launch_config . kernel_id if launch_config . ramdisk_id : params [ 'RamdiskId' ] = launch_config . ramdisk_id if launch_config . block_device_mappings : self . build_list_params ( params , launch_config . block_device_mappings , ) if launch_config . security_groups : self . build_list_params ( params , launch_config . security_groups , ) if launch_config . instance_monitoring : params [ 'InstanceMonitoring.Enabled' ] = 'true' return self . get_object ( 'CreateLaunchConfiguration' , params , Request , verb = 'POST' ) def create_scaling_policy ( self , scaling_policy ) : params = { 'AdjustmentType' : scaling_policy . adjustment_type , : scaling_policy . as_name , : scaling_policy . name , : scaling_policy . scaling_adjustment } if scaling_policy . cooldown is not None : params [ 'Cooldown' ] = scaling_policy . cooldown return self . get_object ( 'PutScalingPolicy' , params , Request ) def delete_launch_configuration ( self , launch_config_name ) : params = { 'LaunchConfigurationName' : launch_config_name } return self . get_object ( 'DeleteLaunchConfiguration' , params , Request ) def get_all_groups ( self , names = None , max_records = None , next_token = None ) : params = { } if max_records : params [ 'MaxRecords' ] = max_records if next_token : params [ 'NextToken' ] = next_token if names : self . build_list_params ( params , names , 'AutoScalingGroupNames' ) return self . get_list ( 'DescribeAutoScalingGroups' , params , [ ( 'member' , AutoScalingGroup ) ] ) def get_all_launch_configurations ( self , ** kwargs ) : params = { } max_records = kwargs . get ( 'max_records' , None ) names = kwargs . get ( 'names' , None ) if max_records is not None : params [ 'MaxRecords' ] = max_records if names : self . build_list_params ( params , names , 'LaunchConfigurationNames' ) next_token = kwargs . get ( 'next_token' ) if next_token : params [ 'NextToken' ] = next_token return self . get_list ( 'DescribeLaunchConfigurations' , params , [ ( 'member' , LaunchConfiguration ) ] ) def get_all_activities ( self , autoscale_group , activity_ids = None , max_records = None , next_token = None ) : name = autoscale_group if isinstance ( autoscale_group , AutoScalingGroup ) : name = autoscale_group . name params = { 'AutoScalingGroupName' : name } if max_records : params [ 'MaxRecords' ] = max_records if next_token : params [ 'NextToken' ] = next_token if activity_ids : self . build_list_params ( params , activity_ids , 'ActivityIds' ) return self . get_list ( 'DescribeScalingActivities' , params , [ ( 'member' , Activity ) ] ) def delete_scheduled_action ( self , scheduled_action_name , autoscale_group = None ) : params = { 'ScheduledActionName' : scheduled_action_name } if autoscale_group : params [ 'AutoScalingGroupName' ] = autoscale_group return self . get_status ( 'DeleteScheduledAction' , params ) def terminate_instance ( self , instance_id , decrement_capacity = True ) : params = { 'InstanceId' : instance_id } if decrement_capacity : params [ 'ShouldDecrementDesiredCapacity' ] = 'true' else : params [ 'ShouldDecrementDesiredCapacity' ] = 'false' return self . get_object ( 'TerminateInstanceInAutoScalingGroup' , params , Activity ) def delete_policy ( self , policy_name , autoscale_group = None ) : params = { 'PolicyName' : policy_name } if autoscale_group : params [ 'AutoScalingGroupName' ] = autoscale_group return self . get_status ( 'DeletePolicy' , params ) def get_all_adjustment_types ( self ) : return self . get_list ( 'DescribeAdjustmentTypes' , { } , [ ( 'member' , AdjustmentType ) ] ) def get_all_autoscaling_instances ( self , instance_ids = None , max_records = None , next_token = None ) : params = { } if instance_ids : self . build_list_params ( params , instance_ids , 'InstanceIds' ) if max_records : params [ 'MaxRecords' ] = max_records if next_token : params [ 'NextToken' ] = next_token return self . get_list ( 'DescribeAutoScalingInstances' , params , [ ( 'member' , Instance ) ] ) def get_all_metric_collection_types ( self ) : return self . get_object ( 'DescribeMetricCollectionTypes' , { } , MetricCollectionTypes ) def get_all_policies ( self , as_group = None , policy_names = None , max_records = None , next_token = None ) : params = { } if as_group : params [ 'AutoScalingGroupName' ] = as_group if policy_names : self . build_list_params ( params , policy_names , 'PolicyNames' ) if max_records : params [ 'MaxRecords' ] = max_records if next_token : params [ 'NextToken' ] = next_token return self . get_list ( 'DescribePolicies' , params , [ ( 'member' , ScalingPolicy ) ] ) def get_all_scaling_process_types ( self ) : return self . get_list ( 'DescribeScalingProcessTypes' , { } , [ ( 'member' , ProcessType ) ] ) def suspend_processes ( self , as_group , scaling_processes = None ) : params = { 'AutoScalingGroupName' : as_group } if scaling_processes : self . build_list_params ( params , scaling_processes , 'ScalingProcesses' ) return self . get_status ( 'SuspendProcesses' , params ) def resume_processes ( self , as_group , scaling_processes = None ) : params = { 'AutoScalingGroupName' : as_group } if scaling_processes : self . build_list_params ( params , scaling_processes , 'ScalingProcesses' ) return self . get_status ( 'ResumeProcesses' , params ) def create_scheduled_group_action ( self , as_group , name , time , desired_capacity = None , min_size = None , max_size = None ) : params = { 'AutoScalingGroupName' : as_group , : name , : time . isoformat ( ) } if desired_capacity is not None : params [ 'DesiredCapacity' ] = desired_capacity if min_size is not None : params [ 'MinSize' ] = min_size if max_size is not None : params [ 'MaxSize' ] = max_size return self . get_status ( 'PutScheduledUpdateGroupAction' , params ) def get_all_scheduled_actions ( self , as_group = None , start_time = None , end_time = None , scheduled_actions = None , max_records = None , next_token = None ) : params = { } if as_group : params [ 'AutoScalingGroupName' ] = as_group if scheduled_actions : self . build_list_params ( params , scheduled_actions , ) if max_records : params [ 'MaxRecords' ] = max_records if next_token : params [ 'NextToken' ] = next_token return self . get_list ( 'DescribeScheduledActions' , params , [ ( 'member' , ScheduledUpdateGroupAction ) ] ) def disable_metrics_collection ( self , as_group , metrics = None ) : params = { 'AutoScalingGroupName' : as_group } if metrics : self . build_list_params ( params , metrics , 'Metrics' ) return self . get_status ( 'DisableMetricsCollection' , params ) def enable_metrics_collection ( self , as_group , granularity , metrics = None ) : params = { 'AutoScalingGroupName' : as_group , : granularity } if metrics : self . build_list_params ( params , metrics , 'Metrics' ) return self . get_status ( 'EnableMetricsCollection' , params ) def execute_policy ( self , policy_name , as_group = None , honor_cooldown = None ) : params = { 'PolicyName' : policy_name } if as_group : params [ 'AutoScalingGroupName' ] = as_group if honor_cooldown : params [ 'HonorCooldown' ] = honor_cooldown return self . get_status ( 'ExecutePolicy' , params ) def set_instance_health ( self , instance_id , health_status , should_respect_grace_period = True ) : params = { 'InstanceId' : instance_id , : health_status } if should_respect_grace_period : params [ 'ShouldRespectGracePeriod' ] = 'true' else : params [ 'ShouldRespectGracePeriod' ] = 'false' return self . get_status ( 'SetInstanceHealth' , params ) def get_all_tags ( self , filters = None , max_records = None , next_token = None ) : params = { } if max_records : params [ 'MaxRecords' ] = max_records if next_token : params [ 'NextToken' ] = next_token return self . get_list ( 'DescribeTags' , params , [ ( 'member' , Tag ) ] ) def create_or_update_tags ( self , tags ) : params = { } for i , tag in enumerate ( tags ) : tag . build_params ( params , i + 1 ) return self . get_status ( 'CreateOrUpdateTags' , params , verb = 'POST' ) def delete_tags ( self , tags ) : params = { } for i , tag in enumerate ( tags ) : tag . build_params ( params , i + 1 ) return self . get_status ( 'DeleteTags' , params , verb = 'POST' )

from boto . dynamodb . layer1 import Layer1 from boto . dynamodb . table import Table from boto . dynamodb . schema import Schema from boto . dynamodb . item import Item from boto . dynamodb . batch import BatchList def is_num ( n ) : return isinstance ( n , ( int , long , float , bool ) ) def is_str ( n ) : return isinstance ( n , basestring ) def convert_num ( s ) : if '.' in s : n = float ( s ) else : n = int ( s ) return n def item_object_hook ( dct ) : if len ( dct . keys ( ) ) > 1 : return dct if 'S' in dct : return dct [ 'S' ] if 'N' in dct : return convert_num ( dct [ 'N' ] ) if 'SS' in dct : return set ( dct [ 'SS' ] ) if 'NS' in dct : return set ( map ( convert_num , dct [ 'NS' ] ) ) return dct class Layer2 ( object ) : def __init__ ( self , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , host = None , debug = 0 , session_token = None ) : self . layer1 = Layer1 ( aws_access_key_id , aws_secret_access_key , is_secure , port , proxy , proxy_port , host , debug , session_token ) def dynamize_attribute_updates ( self , pending_updates ) : d = { } for attr_name in pending_updates : action , value = pending_updates [ attr_name ] if value is None : d [ attr_name ] = { "Action" : action } else : d [ attr_name ] = { "Action" : action , : self . dynamize_value ( value ) } return d def dynamize_item ( self , item ) : d = { } for attr_name in item : d [ attr_name ] = self . dynamize_value ( item [ attr_name ] ) return d def dynamize_range_key_condition ( self , range_key_condition ) : d = None if range_key_condition : d = { } for range_value in range_key_condition : range_condition = range_key_condition [ range_value ] if range_condition == 'BETWEEN' : if isinstance ( range_value , tuple ) : avl = [ self . dynamize_value ( v ) for v in range_value ] else : msg = 'BETWEEN condition requires a tuple value' raise TypeError ( msg ) elif isinstance ( range_value , tuple ) : msg = 'Tuple can only be supplied with BETWEEN condition' raise TypeError ( msg ) else : avl = [ self . dynamize_value ( range_value ) ] d = { 'AttributeValueList' : avl , : range_condition } return d def dynamize_scan_filter ( self , scan_filter ) : d = None if scan_filter : d = { } for attr_name , op , value in scan_filter : if op == 'BETWEEN' : if isinstance ( value , tuple ) : avl = [ self . dynamize_value ( v ) for v in value ] else : msg = 'BETWEEN condition requires a tuple value' raise TypeError ( msg ) elif op == 'NULL' or op == 'NOT_NULL' : avl = None elif isinstance ( value , tuple ) : msg = 'Tuple can only be supplied with BETWEEN condition' raise TypeError ( msg ) else : avl = [ self . dynamize_value ( value ) ] dd = { 'ComparisonOperator' : op } if avl : dd [ 'AttributeValueList' ] = avl d [ attr_name ] = dd return d def dynamize_expected_value ( self , expected_value ) : d = None if expected_value : d = { } for attr_name in expected_value : attr_value = expected_value [ attr_name ] if attr_value is True : attr_value = { 'Exists' : True } elif attr_value is False : attr_value = { 'Exists' : False } else : val = self . dynamize_value ( expected_value [ attr_name ] ) attr_value = { 'Value' : val } d [ attr_name ] = attr_value return d def dynamize_last_evaluated_key ( self , last_evaluated_key ) : d = None if last_evaluated_key : hash_key = last_evaluated_key [ 'HashKeyElement' ] d = { 'HashKeyElement' : self . dynamize_value ( hash_key ) } if 'RangeKeyElement' in last_evaluated_key : range_key = last_evaluated_key [ 'RangeKeyElement' ] d [ 'RangeKeyElement' ] = self . dynamize_value ( range_key ) return d def dynamize_request_items ( self , batch_list ) : d = None if batch_list : d = { } for batch in batch_list : batch_dict = { } key_list = [ ] for key in batch . keys : if isinstance ( key , tuple ) : hash_key , range_key = key else : hash_key = key range_key = None k = self . build_key_from_values ( batch . table . schema , hash_key , range_key ) key_list . append ( k ) batch_dict [ 'Keys' ] = key_list if batch . attributes_to_get : batch_dict [ 'AttributesToGet' ] = batch . attributes_to_get d [ batch . table . name ] = batch_dict return d def get_dynamodb_type ( self , val ) : dynamodb_type = None if is_num ( val ) : dynamodb_type = 'N' elif is_str ( val ) : dynamodb_type = 'S' elif isinstance ( val , ( set , frozenset ) ) : if False not in map ( is_num , val ) : dynamodb_type = 'NS' elif False not in map ( is_str , val ) : dynamodb_type = 'SS' if dynamodb_type is None : raise TypeError ( 'Unsupported type "%s" for value "%s"' % ( type ( val ) , val ) ) return dynamodb_type def dynamize_value ( self , val ) : def _str ( val ) : if isinstance ( val , bool ) : return str ( int ( val ) ) return str ( val ) dynamodb_type = self . get_dynamodb_type ( val ) if dynamodb_type == 'N' : val = { dynamodb_type : _str ( val ) } elif dynamodb_type == 'S' : val = { dynamodb_type : val } elif dynamodb_type == 'NS' : val = { dynamodb_type : [ str ( n ) for n in val ] } elif dynamodb_type == 'SS' : val = { dynamodb_type : [ n for n in val ] } return val def build_key_from_values ( self , schema , hash_key , range_key = None ) : dynamodb_key = { } dynamodb_value = self . dynamize_value ( hash_key ) if dynamodb_value . keys ( ) [ 0 ] != schema . hash_key_type : msg = 'Hashkey must be of type: %s' % schema . hash_key_type raise TypeError ( msg ) dynamodb_key [ 'HashKeyElement' ] = dynamodb_value if range_key is not None : dynamodb_value = self . dynamize_value ( range_key ) if dynamodb_value . keys ( ) [ 0 ] != schema . range_key_type : msg = 'RangeKey must be of type: %s' % schema . range_key_type raise TypeError ( msg ) dynamodb_key [ 'RangeKeyElement' ] = dynamodb_value return dynamodb_key def new_batch_list ( self ) : return BatchList ( self ) def list_tables ( self , limit = None , start_table = None ) : result = self . layer1 . list_tables ( limit , start_table ) return result [ 'TableNames' ] def describe_table ( self , name ) : return self . layer1 . describe_table ( name ) def get_table ( self , name ) : response = self . layer1 . describe_table ( name ) return Table ( self , response ) lookup = get_table def create_table ( self , name , schema , read_units , write_units ) : response = self . layer1 . create_table ( name , schema . dict , { 'ReadCapacityUnits' : read_units , : write_units } ) return Table ( self , response ) def update_throughput ( self , table , read_units , write_units ) : response = self . layer1 . update_table ( table . name , { 'ReadCapacityUnits' : read_units , : write_units } ) table . update_from_response ( response [ 'TableDescription' ] ) def delete_table ( self , table ) : response = self . layer1 . delete_table ( table . name ) table . update_from_response ( response ) def create_schema ( self , hash_key_name , hash_key_proto_value , range_key_name = None , range_key_proto_value = None ) : schema = { } hash_key = { } hash_key [ 'AttributeName' ] = hash_key_name hash_key_type = self . get_dynamodb_type ( hash_key_proto_value ) hash_key [ 'AttributeType' ] = hash_key_type schema [ 'HashKeyElement' ] = hash_key if range_key_name and range_key_proto_value is not None : range_key = { } range_key [ 'AttributeName' ] = range_key_name range_key_type = self . get_dynamodb_type ( range_key_proto_value ) range_key [ 'AttributeType' ] = range_key_type schema [ 'RangeKeyElement' ] = range_key return Schema ( schema ) def get_item ( self , table , hash_key , range_key = None , attributes_to_get = None , consistent_read = False , item_class = Item ) : key = self . build_key_from_values ( table . schema , hash_key , range_key ) response = self . layer1 . get_item ( table . name , key , attributes_to_get , consistent_read , object_hook = item_object_hook ) item = item_class ( table , hash_key , range_key , response [ 'Item' ] ) if 'ConsumedCapacityUnits' in response : item . consumed_units = response [ 'ConsumedCapacityUnits' ] return item def batch_get_item ( self , batch_list ) : request_items = self . dynamize_request_items ( batch_list ) return self . layer1 . batch_get_item ( request_items , object_hook = item_object_hook ) def put_item ( self , item , expected_value = None , return_values = None ) : expected_value = self . dynamize_expected_value ( expected_value ) response = self . layer1 . put_item ( item . table . name , self . dynamize_item ( item ) , expected_value , return_values , object_hook = item_object_hook ) if 'ConsumedCapacityUnits' in response : item . consumed_units = response [ 'ConsumedCapacityUnits' ] return response def update_item ( self , item , expected_value = None , return_values = None ) : expected_value = self . dynamize_expected_value ( expected_value ) key = self . build_key_from_values ( item . table . schema , item . hash_key , item . range_key ) attr_updates = self . dynamize_attribute_updates ( item . _updates ) response = self . layer1 . update_item ( item . table . name , key , attr_updates , expected_value , return_values , object_hook = item_object_hook ) item . _updates . clear ( ) if 'ConsumedCapacityUnits' in response : item . consumed_units = response [ 'ConsumedCapacityUnits' ] return response def delete_item ( self , item , expected_value = None , return_values = None ) : expected_value = self . dynamize_expected_value ( expected_value ) key = self . build_key_from_values ( item . table . schema , item . hash_key , item . range_key ) return self . layer1 . delete_item ( item . table . name , key , expected = expected_value , return_values = return_values , object_hook = item_object_hook ) def query ( self , table , hash_key , range_key_condition = None , attributes_to_get = None , request_limit = None , max_results = None , consistent_read = False , scan_index_forward = True , exclusive_start_key = None , item_class = Item ) : rkc = self . dynamize_range_key_condition ( range_key_condition ) response = True n = 0 while response : if response is True : pass elif response . has_key ( "LastEvaluatedKey" ) : lek = response [ 'LastEvaluatedKey' ] exclusive_start_key = self . dynamize_last_evaluated_key ( lek ) else : break response = self . layer1 . query ( table . name , self . dynamize_value ( hash_key ) , rkc , attributes_to_get , request_limit , consistent_read , scan_index_forward , exclusive_start_key , object_hook = item_object_hook ) for item in response [ 'Items' ] : if max_results and n == max_results : break yield item_class ( table , attrs = item ) n += 1 def scan ( self , table , scan_filter = None , attributes_to_get = None , request_limit = None , max_results = None , count = False , exclusive_start_key = None , item_class = Item ) : sf = self . dynamize_scan_filter ( scan_filter ) response = True n = 0 while response : if response is True : pass elif response . has_key ( "LastEvaluatedKey" ) : exclusive_start_key = response [ 'LastEvaluatedKey' ] else : break response = self . layer1 . scan ( table . name , sf , attributes_to_get , request_limit , count , exclusive_start_key , object_hook = item_object_hook ) if response : for item in response [ 'Items' ] : if max_results and n == max_results : break yield item_class ( table , attrs = item ) n += 1

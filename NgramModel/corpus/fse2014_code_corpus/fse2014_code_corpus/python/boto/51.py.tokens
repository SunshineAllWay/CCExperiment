import httplib import re import socket import ssl import boto class InvalidCertificateException ( httplib . HTTPException ) : def __init__ ( self , host , cert , reason ) : httplib . HTTPException . __init__ ( self ) self . host = host self . cert = cert self . reason = reason def __str__ ( self ) : return ( 'Host %s returned an invalid certificate (%s): %s' % ( self . host , self . reason , self . cert ) ) def GetValidHostsForCert ( cert ) : if 'subjectAltName' in cert : return [ x [ 1 ] for x in cert [ 'subjectAltName' ] if x [ 0 ] . lower ( ) == 'dns' ] else : return [ x [ 0 ] [ 1 ] for x in cert [ 'subject' ] if x [ 0 ] [ 0 ] . lower ( ) == 'commonname' ] def ValidateCertificateHostname ( cert , hostname ) : hosts = GetValidHostsForCert ( cert ) boto . log . debug ( , hostname , hosts ) for host in hosts : host_re = host . replace ( '.' , '\.' ) . replace ( '*' , '[^.]*' ) if re . search ( '^%s$' % ( host_re , ) , hostname , re . I ) : return True return False class CertValidatingHTTPSConnection ( httplib . HTTPConnection ) : default_port = httplib . HTTPS_PORT def __init__ ( self , host , port = None , key_file = None , cert_file = None , ca_certs = None , strict = None , ** kwargs ) : httplib . HTTPConnection . __init__ ( self , host , port , strict , ** kwargs ) self . key_file = key_file self . cert_file = cert_file self . ca_certs = ca_certs def connect ( self ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect ( ( self . host , self . port ) ) boto . log . debug ( "wrapping ssl socket; CA certificate file=%s" , self . ca_certs ) self . sock = ssl . wrap_socket ( sock , keyfile = self . key_file , certfile = self . cert_file , cert_reqs = ssl . CERT_REQUIRED , ca_certs = self . ca_certs ) cert = self . sock . getpeercert ( ) hostname = self . host . split ( ':' , 0 ) [ 0 ] if not ValidateCertificateHostname ( cert , hostname ) : raise InvalidCertificateException ( hostname , cert , 'certificate' % hostname )

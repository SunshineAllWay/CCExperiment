import xml . sax import datetime import itertools from boto import handler from boto import config from boto . mturk . price import Price import boto . mturk . notification from boto . connection import AWSQueryConnection from boto . exception import EC2ResponseError from boto . resultset import ResultSet from boto . mturk . question import QuestionForm , ExternalQuestion class MTurkRequestError ( EC2ResponseError ) : class MTurkConnection ( AWSQueryConnection ) : APIVersion = '2008-08-02' def __init__ ( self , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , proxy_user = None , proxy_pass = None , host = None , debug = 0 , https_connection_factory = None ) : if not host : if config . has_option ( 'MTurk' , 'sandbox' ) and config . get ( 'MTurk' , 'sandbox' ) == 'True' : host = 'mechanicalturk.sandbox.amazonaws.com' else : host = 'mechanicalturk.amazonaws.com' AWSQueryConnection . __init__ ( self , aws_access_key_id , aws_secret_access_key , is_secure , port , proxy , proxy_port , proxy_user , proxy_pass , host , debug , https_connection_factory ) def _required_auth_capability ( self ) : return [ 'mturk' ] def get_account_balance ( self ) : params = { } return self . _process_request ( 'GetAccountBalance' , params , [ ( 'AvailableBalance' , Price ) , ( 'OnHoldBalance' , Price ) ] ) def register_hit_type ( self , title , description , reward , duration , keywords = None , approval_delay = None , qual_req = None ) : params = dict ( Title = title , Description = description , AssignmentDurationInSeconds = self . duration_as_seconds ( duration ) , ) params . update ( MTurkConnection . get_price_as_price ( reward ) . get_as_params ( 'Reward' ) ) if keywords : params [ 'Keywords' ] = self . get_keywords_as_string ( keywords ) if approval_delay is not None : d = self . duration_as_seconds ( approval_delay ) params [ 'AutoApprovalDelayInSeconds' ] = d if qual_req is not None : params . update ( qual_req . get_as_params ( ) ) return self . _process_request ( 'RegisterHITType' , params ) def set_email_notification ( self , hit_type , email , event_types = None ) : return self . _set_notification ( hit_type , 'Email' , email , event_types ) def set_rest_notification ( self , hit_type , url , event_types = None ) : return self . _set_notification ( hit_type , 'REST' , url , event_types ) def _set_notification ( self , hit_type , transport , destination , event_types = None ) : assert type ( hit_type ) is str , "hit_type argument should be a string." params = { 'HITTypeId' : hit_type } notification_params = { 'Destination' : destination , : transport , : boto . mturk . notification . NotificationMessage . NOTIFICATION_VERSION , : True , } if event_types : self . build_list_params ( notification_params , event_types , 'EventType' ) notification_rest_params = { } num = 1 for key in notification_params : notification_rest_params [ 'Notification.%d.%s' % ( num , key ) ] = notification_params [ key ] params . update ( notification_rest_params ) return self . _process_request ( 'SetHITTypeNotification' , params ) def create_hit ( self , hit_type = None , question = None , lifetime = datetime . timedelta ( days = 7 ) , max_assignments = 1 , title = None , description = None , keywords = None , reward = None , duration = datetime . timedelta ( days = 7 ) , approval_delay = None , annotation = None , questions = None , qualifications = None , response_groups = None ) : neither = question is None and questions is None both = question is not None and questions is not None if neither or both : raise ValueError ( "Must specify either question (single Question instance) or questions (list or QuestionForm instance), but not both" ) if question : questions = [ question ] question_param = QuestionForm ( questions ) if isinstance ( question , QuestionForm ) : question_param = question elif isinstance ( question , ExternalQuestion ) : question_param = question params = { 'Question' : question_param . get_as_xml ( ) , : self . duration_as_seconds ( lifetime ) , : max_assignments , } if hit_type : params [ 'HITTypeId' ] = hit_type else : final_keywords = MTurkConnection . get_keywords_as_string ( keywords ) final_price = MTurkConnection . get_price_as_price ( reward ) final_duration = self . duration_as_seconds ( duration ) additional_params = dict ( Title = title , Description = description , Keywords = final_keywords , AssignmentDurationInSeconds = final_duration , ) additional_params . update ( final_price . get_as_params ( 'Reward' ) ) if approval_delay is not None : d = self . duration_as_seconds ( approval_delay ) additional_params [ 'AutoApprovalDelayInSeconds' ] = d params . update ( additional_params ) if annotation is not None : params [ 'RequesterAnnotation' ] = annotation if qualifications is not None : params . update ( qualifications . get_as_params ( ) ) if response_groups : self . build_list_params ( params , response_groups , 'ResponseGroup' ) return self . _process_request ( 'CreateHIT' , params , [ ( 'HIT' , HIT ) , ] ) def change_hit_type_of_hit ( self , hit_id , hit_type ) : params = { 'HITId' : hit_id , : hit_type } return self . _process_request ( 'ChangeHITTypeOfHIT' , params ) def get_reviewable_hits ( self , hit_type = None , status = 'Reviewable' , sort_by = 'Expiration' , sort_direction = 'Ascending' , page_size = 10 , page_number = 1 ) : params = { 'Status' : status , : sort_by , : sort_direction , : page_size , : page_number } if hit_type is not None : params . update ( { 'HITTypeId' : hit_type } ) return self . _process_request ( 'GetReviewableHITs' , params , [ ( 'HIT' , HIT ) , ] ) @ staticmethod def _get_pages ( page_size , total_records ) : pages = total_records / page_size + bool ( total_records % page_size ) return range ( 1 , pages + 1 ) def get_all_hits ( self ) : page_size = 100 search_rs = self . search_hits ( page_size = page_size ) total_records = int ( search_rs . TotalNumResults ) get_page_hits = lambda ( page ) : self . search_hits ( page_size = page_size , page_number = page ) page_nums = self . _get_pages ( page_size , total_records ) hit_sets = itertools . imap ( get_page_hits , page_nums ) return itertools . chain . from_iterable ( hit_sets ) def search_hits ( self , sort_by = 'CreationTime' , sort_direction = 'Ascending' , page_size = 10 , page_number = 1 , response_groups = None ) : params = { 'SortProperty' : sort_by , : sort_direction , : page_size , : page_number } if response_groups : self . build_list_params ( params , response_groups , 'ResponseGroup' ) return self . _process_request ( 'SearchHITs' , params , [ ( 'HIT' , HIT ) , ] ) def get_assignments ( self , hit_id , status = None , sort_by = 'SubmitTime' , sort_direction = 'Ascending' , page_size = 10 , page_number = 1 , response_groups = None ) : params = { 'HITId' : hit_id , : sort_by , : sort_direction , : page_size , : page_number } if status is not None : params [ 'AssignmentStatus' ] = status if response_groups : self . build_list_params ( params , response_groups , 'ResponseGroup' ) return self . _process_request ( 'GetAssignmentsForHIT' , params , [ ( 'Assignment' , Assignment ) , ] ) def approve_assignment ( self , assignment_id , feedback = None ) : params = { 'AssignmentId' : assignment_id , } if feedback : params [ 'RequesterFeedback' ] = feedback return self . _process_request ( 'ApproveAssignment' , params ) def reject_assignment ( self , assignment_id , feedback = None ) : params = { 'AssignmentId' : assignment_id , } if feedback : params [ 'RequesterFeedback' ] = feedback return self . _process_request ( 'RejectAssignment' , params ) def get_hit ( self , hit_id , response_groups = None ) : params = { 'HITId' : hit_id , } if response_groups : self . build_list_params ( params , response_groups , 'ResponseGroup' ) return self . _process_request ( 'GetHIT' , params , [ ( 'HIT' , HIT ) , ] ) def set_reviewing ( self , hit_id , revert = None ) : params = { 'HITId' : hit_id , } if revert : params [ 'Revert' ] = revert return self . _process_request ( 'SetHITAsReviewing' , params ) def disable_hit ( self , hit_id , response_groups = None ) : params = { 'HITId' : hit_id , } if response_groups : self . build_list_params ( params , response_groups , 'ResponseGroup' ) return self . _process_request ( 'DisableHIT' , params ) def dispose_hit ( self , hit_id ) : params = { 'HITId' : hit_id , } return self . _process_request ( 'DisposeHIT' , params ) def expire_hit ( self , hit_id ) : params = { 'HITId' : hit_id , } return self . _process_request ( 'ForceExpireHIT' , params ) def extend_hit ( self , hit_id , assignments_increment = None , expiration_increment = None ) : if ( assignments_increment is None and expiration_increment is None ) or ( assignments_increment is not None and expiration_increment is not None ) : raise ValueError ( "Must specify either assignments_increment or expiration_increment, but not both" ) params = { 'HITId' : hit_id , } if assignments_increment : params [ 'MaxAssignmentsIncrement' ] = assignments_increment if expiration_increment : params [ 'ExpirationIncrementInSeconds' ] = expiration_increment return self . _process_request ( 'ExtendHIT' , params ) def get_help ( self , about , help_type = 'Operation' ) : params = { 'About' : about , 'HelpType' : help_type , } return self . _process_request ( 'Help' , params ) def grant_bonus ( self , worker_id , assignment_id , bonus_price , reason ) : params = bonus_price . get_as_params ( 'BonusAmount' , 1 ) params [ 'WorkerId' ] = worker_id params [ 'AssignmentId' ] = assignment_id params [ 'Reason' ] = reason return self . _process_request ( 'GrantBonus' , params ) def block_worker ( self , worker_id , reason ) : params = { 'WorkerId' : worker_id , 'Reason' : reason } return self . _process_request ( 'BlockWorker' , params ) def unblock_worker ( self , worker_id , reason ) : params = { 'WorkerId' : worker_id , 'Reason' : reason } return self . _process_request ( 'UnblockWorker' , params ) def notify_workers ( self , worker_ids , subject , message_text ) : params = { 'Subject' : subject , : message_text } self . build_list_params ( params , worker_ids , 'WorkerId' ) return self . _process_request ( 'NotifyWorkers' , params ) def create_qualification_type ( self , name , description , status , keywords = None , retry_delay = None , test = None , answer_key = None , answer_key_xml = None , test_duration = None , auto_granted = False , auto_granted_value = 1 ) : params = { 'Name' : name , : description , : status , } if retry_delay is not None : params [ 'RetryDelayInSeconds' ] = retry_delay if test is not None : assert ( isinstance ( test , QuestionForm ) ) assert ( test_duration is not None ) params [ 'Test' ] = test . get_as_xml ( ) if test_duration is not None : params [ 'TestDurationInSeconds' ] = test_duration if answer_key is not None : if isinstance ( answer_key , basestring ) : params [ 'AnswerKey' ] = answer_key else : raise TypeError if auto_granted : assert ( test is None ) params [ 'AutoGranted' ] = True params [ 'AutoGrantedValue' ] = auto_granted_value if keywords : params [ 'Keywords' ] = self . get_keywords_as_string ( keywords ) return self . _process_request ( 'CreateQualificationType' , params , [ ( 'QualificationType' , QualificationType ) , ] ) def get_qualification_type ( self , qualification_type_id ) : params = { 'QualificationTypeId' : qualification_type_id } return self . _process_request ( 'GetQualificationType' , params , [ ( 'QualificationType' , QualificationType ) , ] ) def get_qualifications_for_qualification_type ( self , qualification_type_id ) : params = { 'QualificationTypeId' : qualification_type_id } return self . _process_request ( 'GetQualificationsForQualificationType' , params , [ ( 'QualificationType' , QualificationType ) , ] ) def update_qualification_type ( self , qualification_type_id , description = None , status = None , retry_delay = None , test = None , answer_key = None , test_duration = None , auto_granted = None , auto_granted_value = None ) : params = { 'QualificationTypeId' : qualification_type_id } if description is not None : params [ 'Description' ] = description if status is not None : params [ 'QualificationTypeStatus' ] = status if retry_delay is not None : params [ 'RetryDelayInSeconds' ] = retry_delay if test is not None : assert ( isinstance ( test , QuestionForm ) ) params [ 'Test' ] = test . get_as_xml ( ) if test_duration is not None : params [ 'TestDurationInSeconds' ] = test_duration if answer_key is not None : if isinstance ( answer_key , basestring ) : params [ 'AnswerKey' ] = answer_key else : raise TypeError if auto_granted is not None : params [ 'AutoGranted' ] = auto_granted if auto_granted_value is not None : params [ 'AutoGrantedValue' ] = auto_granted_value return self . _process_request ( 'UpdateQualificationType' , params , [ ( 'QualificationType' , QualificationType ) , ] ) def dispose_qualification_type ( self , qualification_type_id ) : params = { 'QualificationTypeId' : qualification_type_id } return self . _process_request ( 'DisposeQualificationType' , params ) def search_qualification_types ( self , query = None , sort_by = 'Name' , sort_direction = 'Ascending' , page_size = 10 , page_number = 1 , must_be_requestable = True , must_be_owned_by_caller = True ) : params = { 'Query' : query , : sort_by , : sort_direction , : page_size , : page_number , : must_be_requestable , : must_be_owned_by_caller } return self . _process_request ( 'SearchQualificationTypes' , params , [ ( 'QualificationType' , QualificationType ) , ] ) def get_qualification_requests ( self , qualification_type_id , sort_by = 'Expiration' , sort_direction = 'Ascending' , page_size = 10 , page_number = 1 ) : params = { 'QualificationTypeId' : qualification_type_id , : sort_by , : sort_direction , : page_size , : page_number } return self . _process_request ( 'GetQualificationRequests' , params , [ ( 'QualificationRequest' , QualificationRequest ) , ] ) def grant_qualification ( self , qualification_request_id , integer_value = 1 ) : params = { 'QualificationRequestId' : qualification_request_id , : integer_value } return self . _process_request ( 'GrantQualification' , params ) def revoke_qualification ( self , subject_id , qualification_type_id , reason = None ) : params = { 'SubjectId' : subject_id , : qualification_type_id , : reason } return self . _process_request ( 'RevokeQualification' , params ) def assign_qualification ( self , qualification_type_id , worker_id , value = 1 , send_notification = True ) : params = { 'QualificationTypeId' : qualification_type_id , : worker_id , : value , : send_notification } return self . _process_request ( 'AssignQualification' , params ) def get_qualification_score ( self , qualification_type_id , worker_id ) : params = { 'QualificationTypeId' : qualification_type_id , : worker_id } return self . _process_request ( 'GetQualificationScore' , params , [ ( 'Qualification' , Qualification ) , ] ) def update_qualification_score ( self , qualification_type_id , worker_id , value ) : params = { 'QualificationTypeId' : qualification_type_id , : worker_id , : value } return self . _process_request ( 'UpdateQualificationScore' , params ) def _process_request ( self , request_type , params , marker_elems = None ) : response = self . make_request ( request_type , params , verb = 'POST' ) return self . _process_response ( response , marker_elems ) def _process_response ( self , response , marker_elems = None ) : body = response . read ( ) if '<Errors>' not in body : rs = ResultSet ( marker_elems ) h = handler . XmlHandler ( rs , self ) xml . sax . parseString ( body , h ) return rs else : raise MTurkRequestError ( response . status , response . reason , body ) @ staticmethod def get_keywords_as_string ( keywords ) : if type ( keywords ) is list : keywords = ', ' . join ( keywords ) if type ( keywords ) is str : final_keywords = keywords elif type ( keywords ) is unicode : final_keywords = keywords . encode ( 'utf-8' ) elif keywords is None : final_keywords = "" else : raise TypeError ( "keywords argument must be a string or a list of strings; got a %s" % type ( keywords ) ) return final_keywords @ staticmethod def get_price_as_price ( reward ) : if isinstance ( reward , Price ) : final_price = reward else : final_price = Price ( reward ) return final_price @ staticmethod def duration_as_seconds ( duration ) : if isinstance ( duration , datetime . timedelta ) : duration = duration . days * 86400 + duration . seconds try : duration = int ( duration ) except TypeError : raise TypeError ( "Duration must be a timedelta or int-castable, got %s" % type ( duration ) ) return duration class BaseAutoResultElement : def __init__ ( self , connection ) : pass def startElement ( self , name , attrs , connection ) : return None def endElement ( self , name , value , connection ) : setattr ( self , name , value ) class HIT ( BaseAutoResultElement ) : def _has_expired ( self ) : expired = False if hasattr ( self , 'Expiration' ) : now = datetime . datetime . utcnow ( ) expiration = datetime . datetime . strptime ( self . Expiration , '%Y-%m-%dT%H:%M:%SZ' ) expired = ( now >= expiration ) else : raise ValueError ( "ERROR: Request for expired property, but no Expiration in HIT!" ) return expired expired = property ( _has_expired ) class Qualification ( BaseAutoResultElement ) : pass class QualificationType ( BaseAutoResultElement ) : pass class QualificationRequest ( BaseAutoResultElement ) : pass class Assignment ( BaseAutoResultElement ) : def __init__ ( self , connection ) : BaseAutoResultElement . __init__ ( self , connection ) self . answers = [ ] def endElement ( self , name , value , connection ) : if name == 'Answer' : answer_rs = ResultSet ( [ ( 'Answer' , QuestionFormAnswer ) , ] ) h = handler . XmlHandler ( answer_rs , connection ) value = connection . get_utf8_value ( value ) xml . sax . parseString ( value , h ) self . answers . append ( answer_rs ) else : BaseAutoResultElement . endElement ( self , name , value , connection ) class QuestionFormAnswer ( BaseAutoResultElement ) : def __init__ ( self , connection ) : BaseAutoResultElement . __init__ ( self , connection ) self . fields = [ ] self . qid = None def endElement ( self , name , value , connection ) : if name == 'QuestionIdentifier' : self . qid = value elif name in [ 'FreeText' , 'SelectionIdentifier' , 'OtherSelectionText' ] and self . qid : self . fields . append ( value )

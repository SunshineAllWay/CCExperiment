import errno import getopt import os import random import re import shutil import socket import StringIO import sys import tempfile import time import unittest import boto from boto import storage_uri from boto . s3 . resumable_download_handler import get_cur_file_size from boto . s3 . resumable_download_handler import ResumableDownloadHandler from boto . exception import ResumableTransferDisposition from boto . exception import ResumableDownloadException from boto . exception import StorageResponseError from cb_test_harnass import CallbackTestHarnass try : from oauth2_plugin import oauth2_plugin except ImportError : pass class ResumableDownloadTests ( unittest . TestCase ) : def get_suite_description ( self ) : return 'Resumable download test suite' @ staticmethod def resilient_close ( key ) : try : key . close ( ) except StorageResponseError , e : pass @ classmethod def setUp ( cls ) : cls . dst_fp = open ( cls . dst_file_name , 'w' ) @ classmethod def tearDown ( cls ) : shutil . rmtree ( cls . tmp_dir ) os . mkdir ( cls . tmp_dir ) cls . resilient_close ( cls . empty_src_key ) cls . resilient_close ( cls . small_src_key ) cls . resilient_close ( cls . larger_src_key ) @ classmethod def build_test_input_object ( cls , obj_name , size , debug ) : buf = [ ] for i in range ( size ) : buf . append ( str ( random . randint ( 0 , 9 ) ) ) string_data = '' . join ( buf ) uri = cls . src_bucket_uri . clone_replace_name ( obj_name ) key = uri . new_key ( validate = False ) key . set_contents_from_file ( StringIO . StringIO ( string_data ) ) key . bucket . connection . debug = debug return ( string_data , key ) @ classmethod def set_up_class ( cls , debug ) : hostname = socket . gethostname ( ) . split ( '.' ) [ 0 ] uri_base_str = 'gs://res-download-test-%s-%s-%s' % ( hostname , os . getpid ( ) , int ( time . time ( ) ) ) cls . src_bucket_uri = storage_uri ( '%s-dst' % uri_base_str ) cls . src_bucket_uri . create_bucket ( ) cls . empty_src_key_size = 0 ( cls . empty_src_key_as_string , cls . empty_src_key ) = ( cls . build_test_input_object ( 'empty' , cls . empty_src_key_size , debug = debug ) ) cls . small_src_key_size = 2 * 1024 ( cls . small_src_key_as_string , cls . small_src_key ) = ( cls . build_test_input_object ( 'small' , cls . small_src_key_size , debug = debug ) ) cls . larger_src_key_size = 500 * 1024 ( cls . larger_src_key_as_string , cls . larger_src_key ) = ( cls . build_test_input_object ( 'larger' , cls . larger_src_key_size , debug = debug ) ) cls . tmpdir_prefix = 'tmp_resumable_download_test' cls . tmp_dir = tempfile . mkdtemp ( prefix = cls . tmpdir_prefix ) cls . dst_file_name = '%s%sdst_file' % ( cls . tmp_dir , os . sep ) cls . tracker_file_name = '%s%stracker' % ( cls . tmp_dir , os . sep ) cls . created_test_data = True @ classmethod def tear_down_class ( cls ) : if not hasattr ( cls , 'created_test_data' ) : return cls . tearDown ( ) cls . empty_src_key . delete ( ) cls . small_src_key . delete ( ) cls . larger_src_key . delete ( ) for i in range ( 60 ) : try : cls . src_bucket_uri . delete_bucket ( ) break except StorageResponseError : print 'Test bucket (%s) not yet deleted, still trying' % ( cls . src_bucket_uri . uri ) time . sleep ( 2 ) shutil . rmtree ( cls . tmp_dir ) cls . tmp_dir = tempfile . mkdtemp ( prefix = cls . tmpdir_prefix ) def test_non_resumable_download ( self ) : self . small_src_key . get_contents_to_file ( self . dst_fp ) self . assertEqual ( self . small_src_key_size , get_cur_file_size ( self . dst_fp ) ) self . assertEqual ( self . small_src_key_as_string , self . small_src_key . get_contents_as_string ( ) ) def test_download_without_persistent_tracker ( self ) : res_download_handler = ResumableDownloadHandler ( ) self . small_src_key . get_contents_to_file ( self . dst_fp , res_download_handler = res_download_handler ) self . assertEqual ( self . small_src_key_size , get_cur_file_size ( self . dst_fp ) ) self . assertEqual ( self . small_src_key_as_string , self . small_src_key . get_contents_as_string ( ) ) def test_failed_download_with_persistent_tracker ( self ) : harnass = CallbackTestHarnass ( ) res_download_handler = ResumableDownloadHandler ( tracker_file_name = self . tracker_file_name , num_retries = 0 ) try : self . small_src_key . get_contents_to_file ( self . dst_fp , cb = harnass . call , res_download_handler = res_download_handler ) self . fail ( 'Did not get expected ResumableDownloadException' ) except ResumableDownloadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT_CUR_PROCESS ) self . assertTrue ( os . path . exists ( self . tracker_file_name ) ) f = open ( self . tracker_file_name ) etag_line = f . readline ( ) m = re . search ( ResumableDownloadHandler . ETAG_REGEX , etag_line ) f . close ( ) self . assertTrue ( m ) def test_retryable_exception_recovery ( self ) : exception = ResumableDownloadHandler . RETRYABLE_EXCEPTIONS [ 0 ] harnass = CallbackTestHarnass ( exception = exception ) res_download_handler = ResumableDownloadHandler ( num_retries = 1 ) self . small_src_key . get_contents_to_file ( self . dst_fp , cb = harnass . call , res_download_handler = res_download_handler ) self . assertEqual ( self . small_src_key_size , get_cur_file_size ( self . dst_fp ) ) self . assertEqual ( self . small_src_key_as_string , self . small_src_key . get_contents_as_string ( ) ) def test_broken_pipe_recovery ( self ) : exception = IOError ( errno . EPIPE , "Broken pipe" ) harnass = CallbackTestHarnass ( exception = exception ) res_download_handler = ResumableDownloadHandler ( num_retries = 1 ) self . small_src_key . get_contents_to_file ( self . dst_fp , cb = harnass . call , res_download_handler = res_download_handler ) self . assertEqual ( self . small_src_key_size , get_cur_file_size ( self . dst_fp ) ) self . assertEqual ( self . small_src_key_as_string , self . small_src_key . get_contents_as_string ( ) ) def test_non_retryable_exception_handling ( self ) : harnass = CallbackTestHarnass ( exception = OSError ( errno . EACCES , 'Permission denied' ) ) res_download_handler = ResumableDownloadHandler ( num_retries = 1 ) try : self . small_src_key . get_contents_to_file ( self . dst_fp , cb = harnass . call , res_download_handler = res_download_handler ) self . fail ( 'Did not get expected OSError' ) except OSError , e : self . assertEqual ( e . errno , 13 ) def test_failed_and_restarted_download_with_persistent_tracker ( self ) : harnass = CallbackTestHarnass ( ) res_download_handler = ResumableDownloadHandler ( tracker_file_name = self . tracker_file_name , num_retries = 1 ) self . small_src_key . get_contents_to_file ( self . dst_fp , cb = harnass . call , res_download_handler = res_download_handler ) self . assertEqual ( self . small_src_key_size , get_cur_file_size ( self . dst_fp ) ) self . assertEqual ( self . small_src_key_as_string , self . small_src_key . get_contents_as_string ( ) ) self . assertFalse ( os . path . exists ( self . tracker_file_name ) ) def test_multiple_in_process_failures_then_succeed ( self ) : res_download_handler = ResumableDownloadHandler ( num_retries = 3 ) self . small_src_key . get_contents_to_file ( self . dst_fp , res_download_handler = res_download_handler ) self . assertEqual ( self . small_src_key_size , get_cur_file_size ( self . dst_fp ) ) self . assertEqual ( self . small_src_key_as_string , self . small_src_key . get_contents_as_string ( ) ) def test_multiple_in_process_failures_then_succeed_with_tracker_file ( self ) : harnass = CallbackTestHarnass ( fail_after_n_bytes = self . larger_src_key_size / 2 , num_times_to_fail = 2 ) res_download_handler = ResumableDownloadHandler ( tracker_file_name = self . tracker_file_name , num_retries = 0 ) try : self . larger_src_key . get_contents_to_file ( self . dst_fp , cb = harnass . call , res_download_handler = res_download_handler ) self . fail ( 'Did not get expected ResumableDownloadException' ) except ResumableDownloadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT_CUR_PROCESS ) self . assertTrue ( os . path . exists ( self . tracker_file_name ) ) self . larger_src_key . get_contents_to_file ( self . dst_fp , cb = harnass . call , res_download_handler = res_download_handler ) self . assertEqual ( self . larger_src_key_size , get_cur_file_size ( self . dst_fp ) ) self . assertEqual ( self . larger_src_key_as_string , self . larger_src_key . get_contents_as_string ( ) ) self . assertFalse ( os . path . exists ( self . tracker_file_name ) ) self . assertTrue ( len ( harnass . transferred_seq_before_first_failure ) > 1 and len ( harnass . transferred_seq_after_first_failure ) > 1 ) def test_download_with_inital_partial_download_before_failure ( self ) : harnass = CallbackTestHarnass ( fail_after_n_bytes = self . larger_src_key_size / 2 ) res_download_handler = ResumableDownloadHandler ( num_retries = 1 ) self . larger_src_key . get_contents_to_file ( self . dst_fp , cb = harnass . call , res_download_handler = res_download_handler ) self . assertEqual ( self . larger_src_key_size , get_cur_file_size ( self . dst_fp ) ) self . assertEqual ( self . larger_src_key_as_string , self . larger_src_key . get_contents_as_string ( ) ) self . assertTrue ( len ( harnass . transferred_seq_before_first_failure ) > 1 and len ( harnass . transferred_seq_after_first_failure ) > 1 ) def test_zero_length_object_download ( self ) : res_download_handler = ResumableDownloadHandler ( ) self . empty_src_key . get_contents_to_file ( self . dst_fp , res_download_handler = res_download_handler ) self . assertEqual ( 0 , get_cur_file_size ( self . dst_fp ) ) def test_download_with_invalid_tracker_etag ( self ) : invalid_etag_tracker_file_name = ( % ( self . tmp_dir , os . sep ) ) f = open ( invalid_etag_tracker_file_name , 'w' ) f . write ( '3.14159\n' ) f . close ( ) res_download_handler = ResumableDownloadHandler ( tracker_file_name = invalid_etag_tracker_file_name ) self . small_src_key . get_contents_to_file ( self . dst_fp , res_download_handler = res_download_handler ) self . assertEqual ( self . small_src_key_size , get_cur_file_size ( self . dst_fp ) ) self . assertEqual ( self . small_src_key_as_string , self . small_src_key . get_contents_as_string ( ) ) def test_download_with_inconsistent_etag_in_tracker ( self ) : inconsistent_etag_tracker_file_name = ( % ( self . tmp_dir , os . sep ) ) f = open ( inconsistent_etag_tracker_file_name , 'w' ) good_etag = self . small_src_key . etag . strip ( '"\'' ) new_val_as_list = [ ] for c in reversed ( good_etag ) : new_val_as_list . append ( c ) f . write ( '%s\n' % '' . join ( new_val_as_list ) ) f . close ( ) res_download_handler = ResumableDownloadHandler ( tracker_file_name = inconsistent_etag_tracker_file_name ) self . small_src_key . get_contents_to_file ( self . dst_fp , res_download_handler = res_download_handler ) self . assertEqual ( self . small_src_key_size , get_cur_file_size ( self . dst_fp ) ) self . assertEqual ( self . small_src_key_as_string , self . small_src_key . get_contents_as_string ( ) ) def test_download_with_unwritable_tracker_file ( self ) : save_mod = os . stat ( self . tmp_dir ) . st_mode try : os . chmod ( self . tmp_dir , 0 ) res_download_handler = ResumableDownloadHandler ( tracker_file_name = self . tracker_file_name ) except ResumableDownloadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT ) self . assertNotEqual ( e . message . find ( 'Couldn\'t write URI tracker file' ) , - 1 ) finally : os . chmod ( self . tmp_dir , save_mod ) if __name__ == '__main__' : if sys . version_info [ : 3 ] < ( 2 , 5 , 1 ) : sys . exit ( 'These tests must be run on at least Python 2.5.1\n' ) debug = 0 opts , args = getopt . getopt ( sys . argv [ 1 : ] , 'd' , [ 'debug' ] ) for o , a in opts : if o in ( '-d' , '--debug' ) : debug = 2 test_loader = unittest . TestLoader ( ) test_loader . testMethodPrefix = 'test_' suite = test_loader . loadTestsFromTestCase ( ResumableDownloadTests ) test_class = suite . __getattribute__ ( '_tests' ) [ 0 ] try : print 'Setting up %s...' % test_class . get_suite_description ( ) test_class . set_up_class ( debug ) print 'Running %s...' % test_class . get_suite_description ( ) unittest . TextTestRunner ( verbosity = 2 ) . run ( suite ) finally : print 'Cleaning up after %s...' % test_class . get_suite_description ( ) test_class . tear_down_class ( ) print ''

import boto from boto import handler from boto . resultset import ResultSet from boto . exception import BotoClientError from boto . s3 . acl import Policy , CannedACLStrings , Grant from boto . s3 . key import Key from boto . s3 . prefix import Prefix from boto . s3 . deletemarker import DeleteMarker from boto . s3 . multipart import MultiPartUpload from boto . s3 . multipart import CompleteMultiPartUpload from boto . s3 . multidelete import MultiDeleteResult from boto . s3 . multidelete import Error from boto . s3 . bucketlistresultset import BucketListResultSet from boto . s3 . bucketlistresultset import VersionedBucketListResultSet from boto . s3 . bucketlistresultset import MultiPartUploadListResultSet from boto . s3 . lifecycle import Lifecycle import boto . jsonresponse import boto . utils import xml . sax import xml . sax . saxutils import StringIO import urllib import re import base64 from collections import defaultdict class S3WebsiteEndpointTranslate : trans_region = defaultdict ( lambda : 's3-website-us-east-1' ) trans_region [ 'eu-west-1' ] = 's3-website-eu-west-1' trans_region [ 'us-west-1' ] = 's3-website-us-west-1' trans_region [ 'us-west-2' ] = 's3-website-us-west-2' trans_region [ 'sa-east-1' ] = 's3-website-sa-east-1' trans_region [ 'ap-northeast-1' ] = 's3-website-ap-northeast-1' trans_region [ 'ap-southeast-1' ] = 's3-website-ap-southeast-1' @ classmethod def translate_region ( self , reg ) : return self . trans_region [ reg ] S3Permissions = [ 'READ' , 'WRITE' , 'READ_ACP' , 'WRITE_ACP' , 'FULL_CONTROL' ] class Bucket ( object ) : BucketLoggingBody = """<?xml version="1.0" encoding="UTF-8"?> <BucketLoggingStatus xmlns="http://s3.amazonaws.com/doc/2006-03-01/"> <LoggingEnabled> <TargetBucket>%s</TargetBucket> <TargetPrefix>%s</TargetPrefix> </LoggingEnabled> </BucketLoggingStatus>""" EmptyBucketLoggingBody = """<?xml version="1.0" encoding="UTF-8"?> <BucketLoggingStatus xmlns="http://s3.amazonaws.com/doc/2006-03-01/"> </BucketLoggingStatus>""" LoggingGroup = 'http://acs.amazonaws.com/groups/s3/LogDelivery' BucketPaymentBody = """<?xml version="1.0" encoding="UTF-8"?> <RequestPaymentConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/"> <Payer>%s</Payer> </RequestPaymentConfiguration>""" VersioningBody = """<?xml version="1.0" encoding="UTF-8"?> <VersioningConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/"> <Status>%s</Status> <MfaDelete>%s</MfaDelete> </VersioningConfiguration>""" WebsiteBody = """<?xml version="1.0" encoding="UTF-8"?> <WebsiteConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/"> <IndexDocument><Suffix>%s</Suffix></IndexDocument> %s </WebsiteConfiguration>""" WebsiteErrorFragment = """<ErrorDocument><Key>%s</Key></ErrorDocument>""" VersionRE = '<Status>([A-Za-z]+)</Status>' MFADeleteRE = '<MfaDelete>([A-Za-z]+)</MfaDelete>' def __init__ ( self , connection = None , name = None , key_class = Key ) : self . name = name self . connection = connection self . key_class = key_class def __repr__ ( self ) : return '<Bucket: %s>' % self . name def __iter__ ( self ) : return iter ( BucketListResultSet ( self ) ) def __contains__ ( self , key_name ) : return not ( self . get_key ( key_name ) is None ) def startElement ( self , name , attrs , connection ) : return None def endElement ( self , name , value , connection ) : if name == 'Name' : self . name = value elif name == 'CreationDate' : self . creation_date = value else : setattr ( self , name , value ) def set_key_class ( self , key_class ) : self . key_class = key_class def lookup ( self , key_name , headers = None ) : return self . get_key ( key_name , headers = headers ) def get_key ( self , key_name , headers = None , version_id = None ) : if version_id : query_args = 'versionId=%s' % version_id else : query_args = None response = self . connection . make_request ( 'HEAD' , self . name , key_name , headers = headers , query_args = query_args ) if response . status / 100 == 2 : response . read ( ) k = self . key_class ( self ) provider = self . connection . provider k . metadata = boto . utils . get_aws_metadata ( response . msg , provider ) k . etag = response . getheader ( 'etag' ) k . content_type = response . getheader ( 'content-type' ) k . content_encoding = response . getheader ( 'content-encoding' ) k . last_modified = response . getheader ( 'last-modified' ) clen = response . getheader ( 'content-length' ) if clen : k . size = int ( response . getheader ( 'content-length' ) ) else : k . size = 0 k . cache_control = response . getheader ( 'cache-control' ) k . name = key_name k . handle_version_headers ( response ) k . handle_encryption_headers ( response ) return k else : if response . status == 404 : response . read ( ) return None else : raise self . connection . provider . storage_response_error ( response . status , response . reason , '' ) def list ( self , prefix = '' , delimiter = '' , marker = '' , headers = None ) : return BucketListResultSet ( self , prefix , delimiter , marker , headers ) def list_versions ( self , prefix = '' , delimiter = '' , key_marker = '' , version_id_marker = '' , headers = None ) : return VersionedBucketListResultSet ( self , prefix , delimiter , key_marker , version_id_marker , headers ) def list_multipart_uploads ( self , key_marker = '' , upload_id_marker = '' , headers = None ) : return MultiPartUploadListResultSet ( self , key_marker , upload_id_marker , headers ) def _get_all ( self , element_map , initial_query_string = '' , headers = None , ** params ) : l = [ ] for k , v in params . items ( ) : k = k . replace ( '_' , '-' ) if k == 'maxkeys' : k = 'max-keys' if isinstance ( v , unicode ) : v = v . encode ( 'utf-8' ) if v is not None and v != '' : l . append ( '%s=%s' % ( urllib . quote ( k ) , urllib . quote ( str ( v ) ) ) ) if len ( l ) : s = initial_query_string + '&' + '&' . join ( l ) else : s = initial_query_string response = self . connection . make_request ( 'GET' , self . name , headers = headers , query_args = s ) body = response . read ( ) boto . log . debug ( body ) if response . status == 200 : rs = ResultSet ( element_map ) h = handler . XmlHandler ( rs , self ) xml . sax . parseString ( body , h ) return rs else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def get_all_keys ( self , headers = None , ** params ) : return self . _get_all ( [ ( 'Contents' , self . key_class ) , ( 'CommonPrefixes' , Prefix ) ] , , headers , ** params ) def get_all_versions ( self , headers = None , ** params ) : return self . _get_all ( [ ( 'Version' , self . key_class ) , ( 'CommonPrefixes' , Prefix ) , ( 'DeleteMarker' , DeleteMarker ) ] , , headers , ** params ) def get_all_multipart_uploads ( self , headers = None , ** params ) : return self . _get_all ( [ ( 'Upload' , MultiPartUpload ) ] , , headers , ** params ) def new_key ( self , key_name = None ) : return self . key_class ( self , key_name ) def generate_url ( self , expires_in , method = 'GET' , headers = None , force_http = False , response_headers = None , expires_in_absolute = False ) : return self . connection . generate_url ( expires_in , method , self . name , headers = headers , force_http = force_http , response_headers = response_headers , expires_in_absolute = expires_in_absolute ) def delete_keys ( self , keys , quiet = False , mfa_token = None , headers = None ) : ikeys = iter ( keys ) result = MultiDeleteResult ( self ) provider = self . connection . provider query_args = 'delete' def delete_keys2 ( hdrs ) : hdrs = hdrs or { } data = u"""<?xml version="1.0" encoding="UTF-8"?>""" data += u"<Delete>" if quiet : data += u"<Quiet>true</Quiet>" count = 0 while count < 1000 : try : key = ikeys . next ( ) except StopIteration : break if isinstance ( key , basestring ) : key_name = key version_id = None elif isinstance ( key , tuple ) and len ( key ) == 2 : key_name , version_id = key elif ( isinstance ( key , Key ) or isinstance ( key , DeleteMarker ) ) and key . name : key_name = key . name version_id = key . version_id else : if isinstance ( key , Prefix ) : key_name = key . name code = 'PrefixSkipped' else : key_name = repr ( key ) code = 'InvalidArgument' message = 'Invalid. No delete action taken for this object.' error = Error ( key_name , code = code , message = message ) result . errors . append ( error ) continue count += 1 data += u"<Object><Key>%s</Key>" % xml . sax . saxutils . escape ( key_name ) if version_id : data += u"<VersionId>%s</VersionId>" % version_id data += u"</Object>" data += u"</Delete>" if count <= 0 : return False data = data . encode ( 'utf-8' ) fp = StringIO . StringIO ( data ) md5 = boto . utils . compute_md5 ( fp ) hdrs [ 'Content-MD5' ] = md5 [ 1 ] hdrs [ 'Content-Type' ] = 'text/xml' if mfa_token : hdrs [ provider . mfa_header ] = ' ' . join ( mfa_token ) response = self . connection . make_request ( 'POST' , self . name , headers = hdrs , query_args = query_args , data = data ) body = response . read ( ) if response . status == 200 : h = handler . XmlHandler ( result , self ) xml . sax . parseString ( body , h ) return count >= 1000 else : raise provider . storage_response_error ( response . status , response . reason , body ) while delete_keys2 ( headers ) : pass return result def delete_key ( self , key_name , headers = None , version_id = None , mfa_token = None ) : provider = self . connection . provider if version_id : query_args = 'versionId=%s' % version_id else : query_args = None if mfa_token : if not headers : headers = { } headers [ provider . mfa_header ] = ' ' . join ( mfa_token ) response = self . connection . make_request ( 'DELETE' , self . name , key_name , headers = headers , query_args = query_args ) body = response . read ( ) if response . status != 204 : raise provider . storage_response_error ( response . status , response . reason , body ) def copy_key ( self , new_key_name , src_bucket_name , src_key_name , metadata = None , src_version_id = None , storage_class = 'STANDARD' , preserve_acl = False , encrypt_key = False , headers = None , query_args = None ) : headers = headers or { } provider = self . connection . provider src_key_name = boto . utils . get_utf8_value ( src_key_name ) if preserve_acl : if self . name == src_bucket_name : src_bucket = self else : src_bucket = self . connection . get_bucket ( src_bucket_name ) acl = src_bucket . get_xml_acl ( src_key_name ) if encrypt_key : headers [ provider . server_side_encryption_header ] = 'AES256' src = '%s/%s' % ( src_bucket_name , urllib . quote ( src_key_name ) ) if src_version_id : src += '?versionId=%s' % src_version_id headers [ provider . copy_source_header ] = str ( src ) if provider . storage_class_header and storage_class : headers [ provider . storage_class_header ] = storage_class if metadata : headers [ provider . metadata_directive_header ] = 'REPLACE' headers = boto . utils . merge_meta ( headers , metadata , provider ) elif not query_args : headers [ provider . metadata_directive_header ] = 'COPY' response = self . connection . make_request ( 'PUT' , self . name , new_key_name , headers = headers , query_args = query_args ) body = response . read ( ) if response . status == 200 : key = self . new_key ( new_key_name ) h = handler . XmlHandler ( key , self ) xml . sax . parseString ( body , h ) if hasattr ( key , 'Error' ) : raise provider . storage_copy_error ( key . Code , key . Message , body ) key . handle_version_headers ( response ) if preserve_acl : self . set_xml_acl ( acl , new_key_name ) return key else : raise provider . storage_response_error ( response . status , response . reason , body ) def set_canned_acl ( self , acl_str , key_name = '' , headers = None , version_id = None ) : assert acl_str in CannedACLStrings if headers : headers [ self . connection . provider . acl_header ] = acl_str else : headers = { self . connection . provider . acl_header : acl_str } query_args = 'acl' if version_id : query_args += '&versionId=%s' % version_id response = self . connection . make_request ( 'PUT' , self . name , key_name , headers = headers , query_args = query_args ) body = response . read ( ) if response . status != 200 : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def get_xml_acl ( self , key_name = '' , headers = None , version_id = None ) : query_args = 'acl' if version_id : query_args += '&versionId=%s' % version_id response = self . connection . make_request ( 'GET' , self . name , key_name , query_args = query_args , headers = headers ) body = response . read ( ) if response . status != 200 : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) return body def set_xml_acl ( self , acl_str , key_name = '' , headers = None , version_id = None , query_args = 'acl' ) : if version_id : query_args += '&versionId=%s' % version_id response = self . connection . make_request ( 'PUT' , self . name , key_name , data = acl_str . encode ( 'ISO-8859-1' ) , query_args = query_args , headers = headers ) body = response . read ( ) if response . status != 200 : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def set_acl ( self , acl_or_str , key_name = '' , headers = None , version_id = None ) : if isinstance ( acl_or_str , Policy ) : self . set_xml_acl ( acl_or_str . to_xml ( ) , key_name , headers , version_id ) else : self . set_canned_acl ( acl_or_str , key_name , headers , version_id ) def get_acl ( self , key_name = '' , headers = None , version_id = None ) : query_args = 'acl' if version_id : query_args += '&versionId=%s' % version_id response = self . connection . make_request ( 'GET' , self . name , key_name , query_args = query_args , headers = headers ) body = response . read ( ) if response . status == 200 : policy = Policy ( self ) h = handler . XmlHandler ( policy , self ) xml . sax . parseString ( body , h ) return policy else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def set_subresource ( self , subresource , value , key_name = '' , headers = None , version_id = None ) : if not subresource : raise TypeError ( 'set_subresource called with subresource=None' ) query_args = subresource if version_id : query_args += '&versionId=%s' % version_id response = self . connection . make_request ( 'PUT' , self . name , key_name , data = value . encode ( 'UTF-8' ) , query_args = query_args , headers = headers ) body = response . read ( ) if response . status != 200 : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def get_subresource ( self , subresource , key_name = '' , headers = None , version_id = None ) : if not subresource : raise TypeError ( 'get_subresource called with subresource=None' ) query_args = subresource if version_id : query_args += '&versionId=%s' % version_id response = self . connection . make_request ( 'GET' , self . name , key_name , query_args = query_args , headers = headers ) body = response . read ( ) if response . status != 200 : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) return body def make_public ( self , recursive = False , headers = None ) : self . set_canned_acl ( 'public-read' , headers = headers ) if recursive : for key in self : self . set_canned_acl ( 'public-read' , key . name , headers = headers ) def add_email_grant ( self , permission , email_address , recursive = False , headers = None ) : if permission not in S3Permissions : raise self . connection . provider . storage_permissions_error ( % permission ) policy = self . get_acl ( headers = headers ) policy . acl . add_email_grant ( permission , email_address ) self . set_acl ( policy , headers = headers ) if recursive : for key in self : key . add_email_grant ( permission , email_address , headers = headers ) def add_user_grant ( self , permission , user_id , recursive = False , headers = None , display_name = None ) : if permission not in S3Permissions : raise self . connection . provider . storage_permissions_error ( % permission ) policy = self . get_acl ( headers = headers ) policy . acl . add_user_grant ( permission , user_id , display_name = display_name ) self . set_acl ( policy , headers = headers ) if recursive : for key in self : key . add_user_grant ( permission , user_id , headers = headers , display_name = display_name ) def list_grants ( self , headers = None ) : policy = self . get_acl ( headers = headers ) return policy . acl . grants def get_location ( self ) : response = self . connection . make_request ( 'GET' , self . name , query_args = 'location' ) body = response . read ( ) if response . status == 200 : rs = ResultSet ( self ) h = handler . XmlHandler ( rs , self ) xml . sax . parseString ( body , h ) return rs . LocationConstraint else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def enable_logging ( self , target_bucket , target_prefix = '' , headers = None ) : if isinstance ( target_bucket , Bucket ) : target_bucket = target_bucket . name body = self . BucketLoggingBody % ( target_bucket , target_prefix ) response = self . connection . make_request ( 'PUT' , self . name , data = body , query_args = 'logging' , headers = headers ) body = response . read ( ) if response . status == 200 : return True else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def disable_logging ( self , headers = None ) : body = self . EmptyBucketLoggingBody response = self . connection . make_request ( 'PUT' , self . name , data = body , query_args = 'logging' , headers = headers ) body = response . read ( ) if response . status == 200 : return True else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def get_logging_status ( self , headers = None ) : response = self . connection . make_request ( 'GET' , self . name , query_args = 'logging' , headers = headers ) body = response . read ( ) if response . status == 200 : return body else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def set_as_logging_target ( self , headers = None ) : policy = self . get_acl ( headers = headers ) g1 = Grant ( permission = 'WRITE' , type = 'Group' , uri = self . LoggingGroup ) g2 = Grant ( permission = 'READ_ACP' , type = 'Group' , uri = self . LoggingGroup ) policy . acl . add_grant ( g1 ) policy . acl . add_grant ( g2 ) self . set_acl ( policy , headers = headers ) def get_request_payment ( self , headers = None ) : response = self . connection . make_request ( 'GET' , self . name , query_args = 'requestPayment' , headers = headers ) body = response . read ( ) if response . status == 200 : return body else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def set_request_payment ( self , payer = 'BucketOwner' , headers = None ) : body = self . BucketPaymentBody % payer response = self . connection . make_request ( 'PUT' , self . name , data = body , query_args = 'requestPayment' , headers = headers ) body = response . read ( ) if response . status == 200 : return True else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def configure_versioning ( self , versioning , mfa_delete = False , mfa_token = None , headers = None ) : if versioning : ver = 'Enabled' else : ver = 'Suspended' if mfa_delete : mfa = 'Enabled' else : mfa = 'Disabled' body = self . VersioningBody % ( ver , mfa ) if mfa_token : if not headers : headers = { } provider = self . connection . provider headers [ provider . mfa_header ] = ' ' . join ( mfa_token ) response = self . connection . make_request ( 'PUT' , self . name , data = body , query_args = 'versioning' , headers = headers ) body = response . read ( ) if response . status == 200 : return True else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def get_versioning_status ( self , headers = None ) : response = self . connection . make_request ( 'GET' , self . name , query_args = 'versioning' , headers = headers ) body = response . read ( ) boto . log . debug ( body ) if response . status == 200 : d = { } ver = re . search ( self . VersionRE , body ) if ver : d [ 'Versioning' ] = ver . group ( 1 ) mfa = re . search ( self . MFADeleteRE , body ) if mfa : d [ 'MfaDelete' ] = mfa . group ( 1 ) return d else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def configure_lifecycle ( self , lifecycle_config , headers = None ) : fp = StringIO . StringIO ( lifecycle_config . to_xml ( ) ) md5 = boto . utils . compute_md5 ( fp ) if headers is None : headers = { } headers [ 'Content-MD5' ] = md5 [ 1 ] headers [ 'Content-Type' ] = 'text/xml' response = self . connection . make_request ( 'PUT' , self . name , data = fp . getvalue ( ) , query_args = 'lifecycle' , headers = headers ) body = response . read ( ) if response . status == 200 : return True else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def get_lifecycle_config ( self , headers = None ) : response = self . connection . make_request ( 'GET' , self . name , query_args = 'lifecycle' , headers = headers ) body = response . read ( ) boto . log . debug ( body ) if response . status == 200 : lifecycle = Lifecycle ( self ) h = handler . XmlHandler ( lifecycle , self ) xml . sax . parseString ( body , h ) return lifecycle else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def delete_lifecycle_configuration ( self , headers = None ) : response = self . connection . make_request ( 'DELETE' , self . name , query_args = 'lifecycle' , headers = headers ) body = response . read ( ) boto . log . debug ( body ) if response . status == 204 : return True else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def configure_website ( self , suffix , error_key = '' , headers = None ) : if error_key : error_frag = self . WebsiteErrorFragment % error_key else : error_frag = '' body = self . WebsiteBody % ( suffix , error_frag ) response = self . connection . make_request ( 'PUT' , self . name , data = body , query_args = 'website' , headers = headers ) body = response . read ( ) if response . status == 200 : return True else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def get_website_configuration ( self , headers = None ) : response = self . connection . make_request ( 'GET' , self . name , query_args = 'website' , headers = headers ) body = response . read ( ) boto . log . debug ( body ) if response . status == 200 : e = boto . jsonresponse . Element ( ) h = boto . jsonresponse . XmlHandler ( e , None ) h . parse ( body ) return e else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def delete_website_configuration ( self , headers = None ) : response = self . connection . make_request ( 'DELETE' , self . name , query_args = 'website' , headers = headers ) body = response . read ( ) boto . log . debug ( body ) if response . status == 204 : return True else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def get_website_endpoint ( self ) : l = [ self . name ] l . append ( S3WebsiteEndpointTranslate . translate_region ( self . get_location ( ) ) ) l . append ( '.' . join ( self . connection . host . split ( '.' ) [ - 2 : ] ) ) return '.' . join ( l ) def get_policy ( self , headers = None ) : response = self . connection . make_request ( 'GET' , self . name , query_args = 'policy' , headers = headers ) body = response . read ( ) if response . status == 200 : return body else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def set_policy ( self , policy , headers = None ) : response = self . connection . make_request ( 'PUT' , self . name , data = policy , query_args = 'policy' , headers = headers ) body = response . read ( ) if response . status >= 200 and response . status <= 204 : return True else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def delete_policy ( self , headers = None ) : response = self . connection . make_request ( 'DELETE' , self . name , data = '/?policy' , query_args = 'policy' , headers = headers ) body = response . read ( ) if response . status >= 200 and response . status <= 204 : return True else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def initiate_multipart_upload ( self , key_name , headers = None , reduced_redundancy = False , metadata = None , encrypt_key = False ) : query_args = 'uploads' provider = self . connection . provider if headers is None : headers = { } if reduced_redundancy : storage_class_header = provider . storage_class_header if storage_class_header : headers [ storage_class_header ] = 'REDUCED_REDUNDANCY' if encrypt_key : headers [ provider . server_side_encryption_header ] = 'AES256' if metadata is None : metadata = { } headers = boto . utils . merge_meta ( headers , metadata , self . connection . provider ) response = self . connection . make_request ( 'POST' , self . name , key_name , query_args = query_args , headers = headers ) body = response . read ( ) boto . log . debug ( body ) if response . status == 200 : resp = MultiPartUpload ( self ) h = handler . XmlHandler ( resp , self ) xml . sax . parseString ( body , h ) return resp else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def complete_multipart_upload ( self , key_name , upload_id , xml_body , headers = None ) : query_args = 'uploadId=%s' % upload_id if headers is None : headers = { } headers [ 'Content-Type' ] = 'text/xml' response = self . connection . make_request ( 'POST' , self . name , key_name , query_args = query_args , headers = headers , data = xml_body ) contains_error = False body = response . read ( ) if body . find ( '<Error>' ) > 0 : contains_error = True boto . log . debug ( body ) if response . status == 200 and not contains_error : resp = CompleteMultiPartUpload ( self ) h = handler . XmlHandler ( resp , self ) xml . sax . parseString ( body , h ) return resp else : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def cancel_multipart_upload ( self , key_name , upload_id , headers = None ) : query_args = 'uploadId=%s' % upload_id response = self . connection . make_request ( 'DELETE' , self . name , key_name , query_args = query_args , headers = headers ) body = response . read ( ) boto . log . debug ( body ) if response . status != 204 : raise self . connection . provider . storage_response_error ( response . status , response . reason , body ) def delete ( self , headers = None ) : return self . connection . delete_bucket ( self . name , headers = headers )

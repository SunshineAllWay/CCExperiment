import cgi import errno import httplib import os import random import re import socket import time import urlparse import boto from boto import config from boto . connection import AWSAuthConnection from boto . exception import InvalidUriError from boto . exception import ResumableTransferDisposition from boto . exception import ResumableUploadException class ResumableUploadHandler ( object ) : BUFFER_SIZE = 8192 RETRYABLE_EXCEPTIONS = ( httplib . HTTPException , IOError , socket . error , socket . gaierror ) SERVER_HAS_NOTHING = ( 0 , - 1 ) def __init__ ( self , tracker_file_name = None , num_retries = None ) : self . tracker_file_name = tracker_file_name self . num_retries = num_retries self . server_has_bytes = 0 self . tracker_uri = None if tracker_file_name : self . _load_tracker_uri_from_file ( ) self . upload_start_point = None def _load_tracker_uri_from_file ( self ) : f = None try : f = open ( self . tracker_file_name , 'r' ) uri = f . readline ( ) . strip ( ) self . _set_tracker_uri ( uri ) except IOError , e : if e . errno != errno . ENOENT : print ( 'Couldn\'t read URI tracker file (%s): %s. Restarting ' % ( self . tracker_file_name , e . strerror ) ) except InvalidUriError , e : print ( 'Invalid tracker URI (%s) found in URI tracker file ' % ( uri , self . tracker_file_name ) ) finally : if f : f . close ( ) def _save_tracker_uri_to_file ( self ) : if not self . tracker_file_name : return f = None try : f = open ( self . tracker_file_name , 'w' ) f . write ( self . tracker_uri ) except IOError , e : raise ResumableUploadException ( % ( self . tracker_file_name , e . strerror ) , ResumableTransferDisposition . ABORT ) finally : if f : f . close ( ) def _set_tracker_uri ( self , uri ) : parse_result = urlparse . urlparse ( uri ) if ( parse_result . scheme . lower ( ) not in [ 'http' , 'https' ] or not parse_result . netloc or not parse_result . query ) : raise InvalidUriError ( 'Invalid tracker URI (%s)' % uri ) qdict = cgi . parse_qs ( parse_result . query ) if not qdict or not 'upload_id' in qdict : raise InvalidUriError ( 'Invalid tracker URI (%s)' % uri ) self . tracker_uri = uri self . tracker_uri_host = parse_result . netloc self . tracker_uri_path = '%s/?%s' % ( parse_result . netloc , parse_result . query ) self . server_has_bytes = 0 def get_tracker_uri ( self ) : return self . tracker_uri def _remove_tracker_file ( self ) : if ( self . tracker_file_name and os . path . exists ( self . tracker_file_name ) ) : os . unlink ( self . tracker_file_name ) def _build_content_range_header ( self , range_spec = '*' , length_spec = '*' ) : return 'bytes %s/%s' % ( range_spec , length_spec ) def _query_server_state ( self , conn , file_length ) : put_headers = { } put_headers [ 'Content-Range' ] = ( self . _build_content_range_header ( '*' , file_length ) ) put_headers [ 'Content-Length' ] = '0' return AWSAuthConnection . make_request ( conn , 'PUT' , path = self . tracker_uri_path , auth_path = self . tracker_uri_path , headers = put_headers , host = self . tracker_uri_host ) def _query_server_pos ( self , conn , file_length ) : resp = self . _query_server_state ( conn , file_length ) if resp . status == 200 : return ( 0 , file_length ) if resp . status != 308 : raise ResumableUploadException ( % resp . status , ResumableTransferDisposition . START_OVER ) got_valid_response = False range_spec = resp . getheader ( 'range' ) if range_spec : m = re . search ( 'bytes=(\d+)-(\d+)' , range_spec ) if m : server_start = long ( m . group ( 1 ) ) server_end = long ( m . group ( 2 ) ) got_valid_response = True else : return self . SERVER_HAS_NOTHING if not got_valid_response : raise ResumableUploadException ( % str ( resp . getheaders ( ) ) , ResumableTransferDisposition . START_OVER ) if conn . debug >= 1 : print 'Server has: Range: %d - %d.' % ( server_start , server_end ) return ( server_start , server_end ) def _start_new_resumable_upload ( self , key , headers = None ) : conn = key . bucket . connection if conn . debug >= 1 : print 'Starting new resumable upload.' self . server_has_bytes = 0 post_headers = { } for k in headers : if k . lower ( ) == 'content-length' : raise ResumableUploadException ( , ResumableTransferDisposition . ABORT ) post_headers [ k ] = headers [ k ] post_headers [ conn . provider . resumable_upload_header ] = 'start' resp = conn . make_request ( , key . bucket . name , key . name , post_headers ) body = resp . read ( ) if resp . status in [ 500 , 503 ] : raise ResumableUploadException ( % resp . status , ResumableTransferDisposition . WAIT_BEFORE_RETRY ) elif resp . status != 200 and resp . status != 201 : raise ResumableUploadException ( % resp . status , ResumableTransferDisposition . ABORT ) tracker_uri = resp . getheader ( 'Location' ) if not tracker_uri : raise ResumableUploadException ( % body , ResumableTransferDisposition . WAIT_BEFORE_RETRY ) self . _set_tracker_uri ( tracker_uri ) self . _save_tracker_uri_to_file ( ) def _upload_file_bytes ( self , conn , http_conn , fp , file_length , total_bytes_uploaded , cb , num_cb ) : buf = fp . read ( self . BUFFER_SIZE ) if cb : if num_cb > 2 : cb_count = file_length / self . BUFFER_SIZE / ( num_cb - 2 ) elif num_cb < 0 : cb_count = - 1 else : cb_count = 0 i = 0 cb ( total_bytes_uploaded , file_length ) put_headers = { } if file_length : range_header = self . _build_content_range_header ( % ( total_bytes_uploaded , file_length - 1 ) , file_length ) put_headers [ 'Content-Range' ] = range_header put_headers [ 'Content-Length' ] = str ( file_length - total_bytes_uploaded ) http_request = AWSAuthConnection . build_base_http_request ( conn , 'PUT' , path = self . tracker_uri_path , auth_path = None , headers = put_headers , host = self . tracker_uri_host ) http_conn . putrequest ( 'PUT' , http_request . path ) for k in put_headers : http_conn . putheader ( k , put_headers [ k ] ) http_conn . endheaders ( ) http_conn . set_debuglevel ( 0 ) while buf : http_conn . send ( buf ) total_bytes_uploaded += len ( buf ) if cb : i += 1 if i == cb_count or cb_count == - 1 : cb ( total_bytes_uploaded , file_length ) i = 0 buf = fp . read ( self . BUFFER_SIZE ) if cb : cb ( total_bytes_uploaded , file_length ) if total_bytes_uploaded != file_length : raise ResumableUploadException ( % ( total_bytes_uploaded , file_length ) , ResumableTransferDisposition . ABORT ) resp = http_conn . getresponse ( ) body = resp . read ( ) http_conn . set_debuglevel ( conn . debug ) if resp . status == 200 : return resp . getheader ( 'etag' ) elif resp . status in [ 408 , 500 , 503 ] : disposition = ResumableTransferDisposition . WAIT_BEFORE_RETRY else : disposition = ResumableTransferDisposition . ABORT raise ResumableUploadException ( 'Got response code %d while attempting ' % ( resp . status , resp . reason ) , disposition ) def _attempt_resumable_upload ( self , key , fp , file_length , headers , cb , num_cb ) : ( server_start , server_end ) = self . SERVER_HAS_NOTHING conn = key . bucket . connection if self . tracker_uri : try : ( server_start , server_end ) = ( self . _query_server_pos ( conn , file_length ) ) self . server_has_bytes = server_start key = key if conn . debug >= 1 : print 'Resuming transfer.' except ResumableUploadException , e : if conn . debug >= 1 : print 'Unable to resume transfer (%s).' % e . message self . _start_new_resumable_upload ( key , headers ) else : self . _start_new_resumable_upload ( key , headers ) if self . upload_start_point is None : self . upload_start_point = server_end if server_end == file_length : total_bytes_uploaded = server_end else : total_bytes_uploaded = server_end + 1 fp . seek ( total_bytes_uploaded ) conn = key . bucket . connection http_conn = conn . new_http_connection ( self . tracker_uri_host , conn . is_secure ) http_conn . set_debuglevel ( conn . debug ) try : return self . _upload_file_bytes ( conn , http_conn , fp , file_length , total_bytes_uploaded , cb , num_cb ) except ( ResumableUploadException , socket . error ) : resp = self . _query_server_state ( conn , file_length ) if resp . status == 400 : raise ResumableUploadException ( 'Got 400 response from server ' , ResumableTransferDisposition . ABORT ) else : raise finally : http_conn . close ( ) def _check_final_md5 ( self , key , etag ) : if key . bucket . connection . debug >= 1 : print 'Checking md5 against etag.' if key . md5 != etag . strip ( '"\'' ) : key . open_read ( ) key . close ( ) key . delete ( ) raise ResumableUploadException ( , ResumableTransferDisposition . ABORT ) def send_file ( self , key , fp , headers , cb = None , num_cb = 10 ) : if not headers : headers = { } fp . seek ( 0 , os . SEEK_END ) file_length = fp . tell ( ) fp . seek ( 0 ) debug = key . bucket . connection . debug if self . num_retries is None : self . num_retries = config . getint ( 'Boto' , 'num_retries' , 5 ) progress_less_iterations = 0 while True : server_had_bytes_before_attempt = self . server_has_bytes try : etag = self . _attempt_resumable_upload ( key , fp , file_length , headers , cb , num_cb ) self . _remove_tracker_file ( ) self . _check_final_md5 ( key , etag ) if debug >= 1 : print 'Resumable upload complete.' return except self . RETRYABLE_EXCEPTIONS , e : if debug >= 1 : print ( 'Caught exception (%s)' % e . __repr__ ( ) ) if isinstance ( e , IOError ) and e . errno == errno . EPIPE : key . bucket . connection . connection . close ( ) except ResumableUploadException , e : if ( e . disposition == ResumableTransferDisposition . ABORT_CUR_PROCESS ) : if debug >= 1 : print ( 'Caught non-retryable ResumableUploadException ' % e . message ) raise elif ( e . disposition == ResumableTransferDisposition . ABORT ) : if debug >= 1 : print ( 'Caught non-retryable ResumableUploadException ' % e . message ) self . _remove_tracker_file ( ) raise else : if debug >= 1 : print ( 'Caught ResumableUploadException (%s) - will ' % e . message ) if self . server_has_bytes > server_had_bytes_before_attempt : progress_less_iterations = 0 else : progress_less_iterations += 1 if progress_less_iterations > self . num_retries : raise ResumableUploadException ( , ResumableTransferDisposition . ABORT_CUR_PROCESS ) sleep_time_secs = random . random ( ) * ( 2 ** progress_less_iterations ) if debug >= 1 : print ( 'Got retryable failure (%d progress-less in a row).\n' % ( progress_less_iterations , sleep_time_secs ) ) time . sleep ( sleep_time_secs )

import boto from boto . connection import AWSAuthConnection from boto . exception import DynamoDBResponseError from boto . provider import Provider from boto . dynamodb import exceptions as dynamodb_exceptions from boto . dynamodb . table import Table import time try : import simplejson as json except ImportError : import json Debug = 0 class Layer1 ( AWSAuthConnection ) : DefaultHost = 'dynamodb.us-east-1.amazonaws.com' ServiceName = 'DynamoDB' Version = '20111205' ThruputError = "ProvisionedThroughputExceededException" SessionExpiredError = 'com.amazon.coral.service#ExpiredTokenException' ResponseError = DynamoDBResponseError def __init__ ( self , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , host = None , debug = 0 , session_token = None ) : if not host : host = self . DefaultHost self . _passed_access_key = aws_access_key_id self . _passed_secret_key = aws_secret_access_key if not session_token : session_token = self . _get_session_token ( ) self . creds = session_token self . throughput_exceeded_events = 0 AWSAuthConnection . __init__ ( self , host , self . creds . access_key , self . creds . secret_key , is_secure , port , proxy , proxy_port , debug = debug , security_token = self . creds . session_token ) def _update_provider ( self ) : self . provider = Provider ( 'aws' , self . creds . access_key , self . creds . secret_key , self . creds . session_token ) self . _auth_handler . update_provider ( self . provider ) def _get_session_token ( self ) : boto . log . debug ( 'Creating new Session Token' ) sts = boto . connect_sts ( self . _passed_access_key , self . _passed_secret_key ) return sts . get_session_token ( ) def _required_auth_capability ( self ) : return [ 'hmac-v3-http' ] def make_request ( self , action , body = '' , object_hook = None ) : headers = { 'X-Amz-Target' : '%s_%s.%s' % ( self . ServiceName , self . Version , action ) , : 'application/x-amz-json-1.0' , : str ( len ( body ) ) } http_request = self . build_base_http_request ( 'POST' , '/' , '/' , { } , headers , body , None ) response = self . _mexe ( http_request , sender = None , override_num_retries = 10 , retry_handler = self . _retry_handler ) response_body = response . read ( ) boto . log . debug ( response_body ) return json . loads ( response_body , object_hook = object_hook ) def _retry_handler ( self , response , i , next_sleep ) : status = None if response . status == 400 : response_body = response . read ( ) boto . log . debug ( response_body ) json_response = json . loads ( response_body ) if self . ThruputError in json_response . get ( '__type' ) : self . throughput_exceeded_events += 1 msg = "%s, retry attempt %s" % ( self . ThruputError , i ) if i == 0 : next_sleep = 0 else : next_sleep = 0.05 * ( 2 ** i ) i += 1 status = ( msg , i , next_sleep ) elif self . SessionExpiredError in json_response . get ( '__type' ) : msg = 'Renewing Session Token' self . creds = self . _get_session_token ( ) self . _update_provider ( ) status = ( msg , i + self . num_retries - 1 , next_sleep ) else : raise self . ResponseError ( response . status , response . reason , json_response ) return status def list_tables ( self , limit = None , start_table = None ) : data = { } if limit : data [ 'Limit' ] = limit if start_table : data [ 'ExclusiveStartTableName' ] = start_table json_input = json . dumps ( data ) return self . make_request ( 'ListTables' , json_input ) def describe_table ( self , table_name ) : data = { 'TableName' : table_name } json_input = json . dumps ( data ) return self . make_request ( 'DescribeTable' , json_input ) def create_table ( self , table_name , schema , provisioned_throughput ) : data = { 'TableName' : table_name , : schema , : provisioned_throughput } json_input = json . dumps ( data ) response_dict = self . make_request ( 'CreateTable' , json_input ) return response_dict def update_table ( self , table_name , provisioned_throughput ) : data = { 'TableName' : table_name , : provisioned_throughput } json_input = json . dumps ( data ) return self . make_request ( 'UpdateTable' , json_input ) def delete_table ( self , table_name ) : data = { 'TableName' : table_name } json_input = json . dumps ( data ) return self . make_request ( 'DeleteTable' , json_input ) def get_item ( self , table_name , key , attributes_to_get = None , consistent_read = False , object_hook = None ) : data = { 'TableName' : table_name , : key } if attributes_to_get : data [ 'AttributesToGet' ] = attributes_to_get if consistent_read : data [ 'ConsistentRead' ] = True json_input = json . dumps ( data ) response = self . make_request ( 'GetItem' , json_input , object_hook = object_hook ) if not response . has_key ( 'Item' ) : raise dynamodb_exceptions . DynamoDBKeyNotFoundError ( ) return response def batch_get_item ( self , request_items , object_hook = None ) : data = { 'RequestItems' : request_items } json_input = json . dumps ( data ) return self . make_request ( 'BatchGetItem' , json_input , object_hook = object_hook ) def put_item ( self , table_name , item , expected = None , return_values = None , object_hook = None ) : data = { 'TableName' : table_name , : item } if expected : data [ 'Expected' ] = expected if return_values : data [ 'ReturnValues' ] = return_values json_input = json . dumps ( data ) return self . make_request ( 'PutItem' , json_input , object_hook = object_hook ) def update_item ( self , table_name , key , attribute_updates , expected = None , return_values = None , object_hook = None ) : data = { 'TableName' : table_name , : key , : attribute_updates } if expected : data [ 'Expected' ] = expected if return_values : data [ 'ReturnValues' ] = return_values json_input = json . dumps ( data ) return self . make_request ( 'UpdateItem' , json_input , object_hook = object_hook ) def delete_item ( self , table_name , key , expected = None , return_values = None , object_hook = None ) : data = { 'TableName' : table_name , : key } if expected : data [ 'Expected' ] = expected if return_values : data [ 'ReturnValues' ] = return_values json_input = json . dumps ( data ) return self . make_request ( 'DeleteItem' , json_input , object_hook = object_hook ) def query ( self , table_name , hash_key_value , range_key_conditions = None , attributes_to_get = None , limit = None , consistent_read = False , scan_index_forward = True , exclusive_start_key = None , object_hook = None ) : data = { 'TableName' : table_name , : hash_key_value } if range_key_conditions : data [ 'RangeKeyCondition' ] = range_key_conditions if attributes_to_get : data [ 'AttributesToGet' ] = attributes_to_get if limit : data [ 'Limit' ] = limit if consistent_read : data [ 'ConsistentRead' ] = True if scan_index_forward : data [ 'ScanIndexForward' ] = True else : data [ 'ScanIndexForward' ] = False if exclusive_start_key : data [ 'ExclusiveStartKey' ] = exclusive_start_key json_input = json . dumps ( data ) return self . make_request ( 'Query' , json_input , object_hook = object_hook ) def scan ( self , table_name , scan_filter = None , attributes_to_get = None , limit = None , count = False , exclusive_start_key = None , object_hook = None ) : data = { 'TableName' : table_name } if scan_filter : data [ 'ScanFilter' ] = scan_filter if attributes_to_get : data [ 'AttributesToGet' ] = attributes_to_get if limit : data [ 'Limit' ] = limit if count : data [ 'Count' ] = True if exclusive_start_key : data [ 'ExclusiveStartKey' ] = exclusive_start_key json_input = json . dumps ( data ) return self . make_request ( 'Scan' , json_input , object_hook = object_hook )

import urlparse from boto . sqs . message import Message class Queue : def __init__ ( self , connection = None , url = None , message_class = Message ) : self . connection = connection self . url = url self . message_class = message_class self . visibility_timeout = None def __repr__ ( self ) : return 'Queue(%s)' % self . url def _id ( self ) : if self . url : val = urlparse . urlparse ( self . url ) [ 2 ] else : val = self . url return val id = property ( _id ) def _name ( self ) : if self . url : val = urlparse . urlparse ( self . url ) [ 2 ] . split ( '/' ) [ 2 ] else : val = self . url return val name = property ( _name ) def startElement ( self , name , attrs , connection ) : return None def endElement ( self , name , value , connection ) : if name == 'QueueUrl' : self . url = value elif name == 'VisibilityTimeout' : self . visibility_timeout = int ( value ) else : setattr ( self , name , value ) def set_message_class ( self , message_class ) : self . message_class = message_class def get_attributes ( self , attributes = 'All' ) : return self . connection . get_queue_attributes ( self , attributes ) def set_attribute ( self , attribute , value ) : return self . connection . set_queue_attribute ( self , attribute , value ) def get_timeout ( self ) : a = self . get_attributes ( 'VisibilityTimeout' ) return int ( a [ 'VisibilityTimeout' ] ) def set_timeout ( self , visibility_timeout ) : retval = self . set_attribute ( 'VisibilityTimeout' , visibility_timeout ) if retval : self . visibility_timeout = visibility_timeout return retval def add_permission ( self , label , aws_account_id , action_name ) : return self . connection . add_permission ( self , label , aws_account_id , action_name ) def remove_permission ( self , label ) : return self . connection . remove_permission ( self , label ) def read ( self , visibility_timeout = None ) : rs = self . get_messages ( 1 , visibility_timeout ) if len ( rs ) == 1 : return rs [ 0 ] else : return None def write ( self , message , delay_seconds = None ) : new_msg = self . connection . send_message ( self , message . get_body_encoded ( ) , delay_seconds ) message . id = new_msg . id message . md5 = new_msg . md5 return message def new_message ( self , body = '' ) : m = self . message_class ( self , body ) m . queue = self return m def get_messages ( self , num_messages = 1 , visibility_timeout = None , attributes = None ) : return self . connection . receive_message ( self , number_messages = num_messages , visibility_timeout = visibility_timeout , attributes = attributes ) def delete_message ( self , message ) : return self . connection . delete_message ( self , message ) def delete ( self ) : return self . connection . delete_queue ( self ) def clear ( self , page_size = 10 , vtimeout = 10 ) : n = 0 l = self . get_messages ( page_size , vtimeout ) while l : for m in l : self . delete_message ( m ) n += 1 l = self . get_messages ( page_size , vtimeout ) return n def count ( self , page_size = 10 , vtimeout = 10 ) : a = self . get_attributes ( 'ApproximateNumberOfMessages' ) return int ( a [ 'ApproximateNumberOfMessages' ] ) def count_slow ( self , page_size = 10 , vtimeout = 10 ) : n = 0 l = self . get_messages ( page_size , vtimeout ) while l : for m in l : n += 1 l = self . get_messages ( page_size , vtimeout ) return n def dump ( self , file_name , page_size = 10 , vtimeout = 10 , sep = '\n' ) : fp = open ( file_name , 'wb' ) n = 0 l = self . get_messages ( page_size , vtimeout ) while l : for m in l : fp . write ( m . get_body ( ) ) if sep : fp . write ( sep ) n += 1 l = self . get_messages ( page_size , vtimeout ) fp . close ( ) return n def save_to_file ( self , fp , sep = '\n' ) : n = 0 m = self . read ( ) while m : n += 1 fp . write ( m . get_body ( ) ) if sep : fp . write ( sep ) self . delete_message ( m ) m = self . read ( ) return n def save_to_filename ( self , file_name , sep = '\n' ) : fp = open ( file_name , 'wb' ) n = self . save_to_file ( fp , sep ) fp . close ( ) return n save = save_to_filename def save_to_s3 ( self , bucket ) : n = 0 m = self . read ( ) while m : n += 1 key = bucket . new_key ( '%s/%s' % ( self . id , m . id ) ) key . set_contents_from_string ( m . get_body ( ) ) self . delete_message ( m ) m = self . read ( ) return n def load_from_s3 ( self , bucket , prefix = None ) : n = 0 if prefix : prefix = '%s/' % prefix else : prefix = '%s/' % self . id [ 1 : ] rs = bucket . list ( prefix = prefix ) for key in rs : n += 1 m = self . new_message ( key . get_contents_as_string ( ) ) self . write ( m ) return n def load_from_file ( self , fp , sep = '\n' ) : n = 0 body = '' l = fp . readline ( ) while l : if l == sep : m = Message ( self , body ) self . write ( m ) n += 1 print 'writing message %d' % n body = '' else : body = body + l l = fp . readline ( ) return n def load_from_filename ( self , file_name , sep = '\n' ) : fp = open ( file_name , 'rb' ) n = self . load_from_file ( fp , sep ) fp . close ( ) return n load = load_from_filename

import errno import httplib import os import re import socket import time import boto from boto import config , storage_uri_for_key from boto . connection import AWSAuthConnection from boto . exception import ResumableDownloadException from boto . exception import ResumableTransferDisposition class ByteTranslatingCallbackHandler ( object ) : def __init__ ( self , proxied_cb , download_start_point ) : self . proxied_cb = proxied_cb self . download_start_point = download_start_point def call ( self , total_bytes_uploaded , total_size ) : self . proxied_cb ( self . download_start_point + total_bytes_uploaded , total_size ) def get_cur_file_size ( fp , position_to_eof = False ) : if not position_to_eof : cur_pos = fp . tell ( ) fp . seek ( 0 , os . SEEK_END ) cur_file_size = fp . tell ( ) if not position_to_eof : fp . seek ( cur_pos , os . SEEK_SET ) return cur_file_size class ResumableDownloadHandler ( object ) : ETAG_REGEX = '([a-z0-9]{32})\n' RETRYABLE_EXCEPTIONS = ( httplib . HTTPException , IOError , socket . error , socket . gaierror ) def __init__ ( self , tracker_file_name = None , num_retries = None ) : self . tracker_file_name = tracker_file_name self . num_retries = num_retries self . etag_value_for_current_download = None if tracker_file_name : self . _load_tracker_file_etag ( ) self . download_start_point = None def _load_tracker_file_etag ( self ) : f = None try : f = open ( self . tracker_file_name , 'r' ) etag_line = f . readline ( ) m = re . search ( self . ETAG_REGEX , etag_line ) if m : self . etag_value_for_current_download = m . group ( 1 ) else : print ( 'Couldn\'t read etag in tracker file (%s). Restarting ' % self . tracker_file_name ) except IOError , e : if e . errno != errno . ENOENT : print ( 'Couldn\'t read URI tracker file (%s): %s. Restarting ' % ( self . tracker_file_name , e . strerror ) ) finally : if f : f . close ( ) def _save_tracker_info ( self , key ) : self . etag_value_for_current_download = key . etag . strip ( '"\'' ) if not self . tracker_file_name : return f = None try : f = open ( self . tracker_file_name , 'w' ) f . write ( '%s\n' % self . etag_value_for_current_download ) except IOError , e : raise ResumableDownloadException ( % ( self . tracker_file_name , e . strerror ) , ResumableTransferDisposition . ABORT ) finally : if f : f . close ( ) def _remove_tracker_file ( self ) : if ( self . tracker_file_name and os . path . exists ( self . tracker_file_name ) ) : os . unlink ( self . tracker_file_name ) def _attempt_resumable_download ( self , key , fp , headers , cb , num_cb , torrent , version_id ) : cur_file_size = get_cur_file_size ( fp , position_to_eof = True ) if ( cur_file_size and self . etag_value_for_current_download and self . etag_value_for_current_download == key . etag . strip ( '"\'' ) ) : if cur_file_size > key . size : raise ResumableDownloadException ( % ( fp . name , cur_file_size , str ( storage_uri_for_key ( key ) ) , key . size ) , ResumableTransferDisposition . ABORT ) elif cur_file_size == key . size : if key . bucket . connection . debug >= 1 : print 'Download complete.' return if key . bucket . connection . debug >= 1 : print 'Resuming download.' headers = headers . copy ( ) headers [ 'Range' ] = 'bytes=%d-%d' % ( cur_file_size , key . size - 1 ) cb = ByteTranslatingCallbackHandler ( cb , cur_file_size ) . call self . download_start_point = cur_file_size else : if key . bucket . connection . debug >= 1 : print 'Starting new resumable download.' self . _save_tracker_info ( key ) self . download_start_point = 0 fp . truncate ( 0 ) key . get_file ( fp , headers , cb , num_cb , torrent , version_id , override_num_retries = 0 ) fp . flush ( ) def get_file ( self , key , fp , headers , cb = None , num_cb = 10 , torrent = False , version_id = None ) : debug = key . bucket . connection . debug if not headers : headers = { } if self . num_retries is None : self . num_retries = config . getint ( 'Boto' , 'num_retries' , 5 ) progress_less_iterations = 0 while True : had_file_bytes_before_attempt = get_cur_file_size ( fp ) try : self . _attempt_resumable_download ( key , fp , headers , cb , num_cb , torrent , version_id ) self . _remove_tracker_file ( ) if debug >= 1 : print 'Resumable download complete.' return except self . RETRYABLE_EXCEPTIONS , e : if debug >= 1 : print ( 'Caught exception (%s)' % e . __repr__ ( ) ) if isinstance ( e , IOError ) and e . errno == errno . EPIPE : key . get_file ( fp , headers , cb , num_cb , torrent , version_id , override_num_retries = 0 ) except ResumableDownloadException , e : if ( e . disposition == ResumableTransferDisposition . ABORT_CUR_PROCESS ) : if debug >= 1 : print ( 'Caught non-retryable ResumableDownloadException ' % e . message ) raise elif ( e . disposition == ResumableTransferDisposition . ABORT ) : if debug >= 1 : print ( 'Caught non-retryable ResumableDownloadException ' % e . message ) self . _remove_tracker_file ( ) raise else : if debug >= 1 : print ( 'Caught ResumableDownloadException (%s) - will ' % e . message ) if get_cur_file_size ( fp ) > had_file_bytes_before_attempt : progress_less_iterations = 0 else : progress_less_iterations += 1 if progress_less_iterations > self . num_retries : raise ResumableDownloadException ( , ResumableTransferDisposition . ABORT_CUR_PROCESS ) try : key . close ( ) except httplib . IncompleteRead : pass sleep_time_secs = 2 ** progress_less_iterations if debug >= 1 : print ( 'Got retryable failure (%d progress-less in a row).\n' % ( progress_less_iterations , sleep_time_secs ) ) time . sleep ( sleep_time_secs )

import errno import getopt import os import random import re import shutil import socket import StringIO import sys import tempfile import time import unittest import boto from boto . exception import GSResponseError from boto . gs . resumable_upload_handler import ResumableUploadHandler from boto . exception import InvalidUriError from boto . exception import ResumableTransferDisposition from boto . exception import ResumableUploadException from boto . exception import StorageResponseError from cb_test_harnass import CallbackTestHarnass try : from oauth2_plugin import oauth2_plugin except ImportError : pass class ResumableUploadTests ( unittest . TestCase ) : def get_suite_description ( self ) : return 'Resumable upload test suite' def setUp ( self ) : self . dst_key = self . dst_key_uri . new_key ( validate = False ) def tearDown ( self ) : try : self . dst_key_uri . delete_key ( ) except GSResponseError : pass shutil . rmtree ( self . tmp_dir ) os . mkdir ( self . tmp_dir ) @ staticmethod def build_test_input_file ( size ) : buf = [ ] for i in range ( size ) : buf . append ( str ( random . randint ( 0 , 9 ) ) ) file_as_string = '' . join ( buf ) return ( file_as_string , StringIO . StringIO ( file_as_string ) ) @ classmethod def get_dst_bucket_uri ( cls , debug ) : hostname = socket . gethostname ( ) . split ( '.' ) [ 0 ] uri_base_str = 'gs://res-upload-test-%s-%s-%s' % ( hostname , os . getpid ( ) , int ( time . time ( ) ) ) return boto . storage_uri ( '%s-dst' % uri_base_str , debug = debug ) @ classmethod def get_dst_key_uri ( cls ) : return cls . dst_bucket_uri . clone_replace_name ( 'obj' ) @ classmethod def get_staged_host ( cls ) : return 'pub.commondatastorage.googleapis.com' @ classmethod def get_invalid_upload_id ( cls ) : return ( % ( cls . get_staged_host ( ) ) ) @ classmethod def set_up_class ( cls , debug ) : cls . tmpdir_prefix = 'tmp_resumable_upload_test' cls . empty_src_file_size = 0 ( cls . empty_src_file_as_string , cls . empty_src_file ) = ( cls . build_test_input_file ( cls . empty_src_file_size ) ) cls . small_src_file_size = 2 * 1024 ( cls . small_src_file_as_string , cls . small_src_file ) = ( cls . build_test_input_file ( cls . small_src_file_size ) ) cls . larger_src_file_size = 500 * 1024 ( cls . larger_src_file_as_string , cls . larger_src_file ) = ( cls . build_test_input_file ( cls . larger_src_file_size ) ) cls . largest_src_file_size = 1024 * 1024 ( cls . largest_src_file_as_string , cls . largest_src_file ) = ( cls . build_test_input_file ( cls . largest_src_file_size ) ) cls . tmp_dir = tempfile . mkdtemp ( prefix = cls . tmpdir_prefix ) cls . dst_bucket_uri = cls . get_dst_bucket_uri ( debug ) cls . dst_bucket_uri . create_bucket ( ) cls . dst_key_uri = cls . get_dst_key_uri ( ) cls . tracker_file_name = '%s%suri_tracker' % ( cls . tmp_dir , os . sep ) cls . syntactically_invalid_tracker_file_name = ( % ( cls . tmp_dir , os . sep ) ) f = open ( cls . syntactically_invalid_tracker_file_name , 'w' ) f . write ( 'ftp://example.com' ) f . close ( ) cls . invalid_upload_id = cls . get_invalid_upload_id ( ) cls . invalid_upload_id_tracker_file_name = ( % ( cls . tmp_dir , os . sep ) ) f = open ( cls . invalid_upload_id_tracker_file_name , 'w' ) f . write ( cls . invalid_upload_id ) f . close ( ) cls . created_test_data = True @ classmethod def tear_down_class ( cls ) : if not hasattr ( cls , 'created_test_data' ) : return for i in range ( 60 ) : try : cls . dst_bucket_uri . delete_bucket ( ) break except StorageResponseError : print 'Test bucket (%s) not yet deleted, still trying' % ( cls . dst_bucket_uri . uri ) time . sleep ( 2 ) shutil . rmtree ( cls . tmp_dir ) cls . tmp_dir = tempfile . mkdtemp ( prefix = cls . tmpdir_prefix ) def test_non_resumable_upload ( self ) : self . small_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . small_src_file ) self . assertEqual ( self . small_src_file_size , self . dst_key . size ) self . assertEqual ( self . small_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) def test_upload_without_persistent_tracker ( self ) : res_upload_handler = ResumableUploadHandler ( ) self . small_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . small_src_file , res_upload_handler = res_upload_handler ) self . assertEqual ( self . small_src_file_size , self . dst_key . size ) self . assertEqual ( self . small_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) def test_failed_upload_with_persistent_tracker ( self ) : harnass = CallbackTestHarnass ( ) res_upload_handler = ResumableUploadHandler ( tracker_file_name = self . tracker_file_name , num_retries = 0 ) self . small_src_file . seek ( 0 ) try : self . dst_key . set_contents_from_file ( self . small_src_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . fail ( 'Did not get expected ResumableUploadException' ) except ResumableUploadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT_CUR_PROCESS ) self . assertTrue ( os . path . exists ( self . tracker_file_name ) ) f = open ( self . tracker_file_name ) uri_from_file = f . readline ( ) . strip ( ) f . close ( ) self . assertEqual ( uri_from_file , res_upload_handler . get_tracker_uri ( ) ) def test_retryable_exception_recovery ( self ) : exception = ResumableUploadHandler . RETRYABLE_EXCEPTIONS [ 0 ] harnass = CallbackTestHarnass ( exception = exception ) res_upload_handler = ResumableUploadHandler ( num_retries = 1 ) self . small_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . small_src_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . assertEqual ( self . small_src_file_size , self . dst_key . size ) self . assertEqual ( self . small_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) def test_broken_pipe_recovery ( self ) : exception = IOError ( errno . EPIPE , "Broken pipe" ) harnass = CallbackTestHarnass ( exception = exception ) res_upload_handler = ResumableUploadHandler ( num_retries = 1 ) self . small_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . small_src_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . assertEqual ( self . small_src_file_size , self . dst_key . size ) self . assertEqual ( self . small_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) def test_non_retryable_exception_handling ( self ) : harnass = CallbackTestHarnass ( exception = OSError ( errno . EACCES , 'Permission denied' ) ) res_upload_handler = ResumableUploadHandler ( num_retries = 1 ) self . small_src_file . seek ( 0 ) try : self . dst_key . set_contents_from_file ( self . small_src_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . fail ( 'Did not get expected OSError' ) except OSError , e : self . assertEqual ( e . errno , 13 ) def test_failed_and_restarted_upload_with_persistent_tracker ( self ) : harnass = CallbackTestHarnass ( ) res_upload_handler = ResumableUploadHandler ( tracker_file_name = self . tracker_file_name , num_retries = 1 ) self . small_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . small_src_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . assertEqual ( self . small_src_file_size , self . dst_key . size ) self . assertEqual ( self . small_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) self . assertFalse ( os . path . exists ( self . tracker_file_name ) ) def test_multiple_in_process_failures_then_succeed ( self ) : res_upload_handler = ResumableUploadHandler ( num_retries = 3 ) self . small_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . small_src_file , res_upload_handler = res_upload_handler ) self . assertEqual ( self . small_src_file_size , self . dst_key . size ) self . assertEqual ( self . small_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) def test_multiple_in_process_failures_then_succeed_with_tracker_file ( self ) : harnass = CallbackTestHarnass ( fail_after_n_bytes = self . larger_src_file_size / 2 , num_times_to_fail = 2 ) res_upload_handler = ResumableUploadHandler ( tracker_file_name = self . tracker_file_name , num_retries = 1 ) self . larger_src_file . seek ( 0 ) try : self . dst_key . set_contents_from_file ( self . larger_src_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . fail ( 'Did not get expected ResumableUploadException' ) except ResumableUploadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT_CUR_PROCESS ) self . assertTrue ( os . path . exists ( self . tracker_file_name ) ) self . larger_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . larger_src_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . assertEqual ( self . larger_src_file_size , self . dst_key . size ) self . assertEqual ( self . larger_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) self . assertFalse ( os . path . exists ( self . tracker_file_name ) ) self . assertTrue ( len ( harnass . transferred_seq_before_first_failure ) > 1 and len ( harnass . transferred_seq_after_first_failure ) > 1 ) def test_upload_with_inital_partial_upload_before_failure ( self ) : harnass = CallbackTestHarnass ( fail_after_n_bytes = self . larger_src_file_size / 2 ) res_upload_handler = ResumableUploadHandler ( num_retries = 1 ) self . larger_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . larger_src_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . assertEqual ( self . larger_src_file_size , self . dst_key . size ) self . assertEqual ( self . larger_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) self . assertTrue ( len ( harnass . transferred_seq_before_first_failure ) > 1 and len ( harnass . transferred_seq_after_first_failure ) > 1 ) def test_empty_file_upload ( self ) : res_upload_handler = ResumableUploadHandler ( ) self . empty_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . empty_src_file , res_upload_handler = res_upload_handler ) self . assertEqual ( 0 , self . dst_key . size ) def test_upload_retains_metadata ( self ) : res_upload_handler = ResumableUploadHandler ( ) headers = { 'Content-Type' : 'text/plain' , 'Content-Encoding' : 'gzip' , : 'my meta' , 'x-goog-acl' : 'public-read' } self . small_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . small_src_file , headers = headers , res_upload_handler = res_upload_handler ) self . assertEqual ( self . small_src_file_size , self . dst_key . size ) self . assertEqual ( self . small_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) self . dst_key . open_read ( ) self . assertEqual ( 'text/plain' , self . dst_key . content_type ) self . assertEqual ( 'gzip' , self . dst_key . content_encoding ) self . assertTrue ( 'abc' in self . dst_key . metadata ) self . assertEqual ( 'my meta' , str ( self . dst_key . metadata [ 'abc' ] ) ) acl = self . dst_key . get_acl ( ) for entry in acl . entries . entry_list : if str ( entry . scope ) == '<AllUsers>' : self . assertEqual ( 'READ' , str ( acl . entries . entry_list [ 1 ] . permission ) ) return self . fail ( 'No <AllUsers> scope found' ) def test_upload_with_file_size_change_between_starts ( self ) : harnass = CallbackTestHarnass ( fail_after_n_bytes = self . larger_src_file_size / 2 ) res_upload_handler = ResumableUploadHandler ( tracker_file_name = self . tracker_file_name , num_retries = 0 ) self . larger_src_file . seek ( 0 ) try : self . dst_key . set_contents_from_file ( self . larger_src_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . fail ( 'Did not get expected ResumableUploadException' ) except ResumableUploadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT_CUR_PROCESS ) self . assertTrue ( os . path . exists ( self . tracker_file_name ) ) time . sleep ( 1 ) try : self . largest_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . largest_src_file , res_upload_handler = res_upload_handler ) self . fail ( 'Did not get expected ResumableUploadException' ) except ResumableUploadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT ) self . assertNotEqual ( e . message . find ( 'file size changed' ) , - 1 , e . message ) def test_upload_with_file_size_change_during_upload ( self ) : test_file_size = 500 * 1024 test_file = self . build_test_input_file ( test_file_size ) [ 1 ] harnass = CallbackTestHarnass ( fp_to_change = test_file , fp_change_pos = test_file_size ) res_upload_handler = ResumableUploadHandler ( num_retries = 1 ) try : self . dst_key . set_contents_from_file ( test_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . fail ( 'Did not get expected ResumableUploadException' ) except ResumableUploadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT ) self . assertNotEqual ( e . message . find ( 'File changed during upload' ) , - 1 ) def test_upload_with_file_content_change_during_upload ( self ) : test_file_size = 500 * 1024 test_file = self . build_test_input_file ( test_file_size ) [ 1 ] harnass = CallbackTestHarnass ( fail_after_n_bytes = test_file_size / 2 , fp_to_change = test_file , fp_change_pos = test_file_size - 5 ) res_upload_handler = ResumableUploadHandler ( num_retries = 1 ) try : self . dst_key . set_contents_from_file ( test_file , cb = harnass . call , res_upload_handler = res_upload_handler ) self . fail ( 'Did not get expected ResumableUploadException' ) except ResumableUploadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT ) test_file . seek ( 0 , os . SEEK_END ) self . assertEqual ( test_file_size , test_file . tell ( ) ) self . assertNotEqual ( e . message . find ( 'md5 signature doesn\'t match etag' ) , - 1 ) try : self . dst_key_uri . get_key ( ) self . fail ( 'Did not get expected InvalidUriError' ) except InvalidUriError , e : pass def test_upload_with_content_length_header_set ( self ) : res_upload_handler = ResumableUploadHandler ( ) self . small_src_file . seek ( 0 ) try : self . dst_key . set_contents_from_file ( self . small_src_file , res_upload_handler = res_upload_handler , headers = { 'Content-Length' : self . small_src_file_size } ) self . fail ( 'Did not get expected ResumableUploadException' ) except ResumableUploadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT ) self . assertNotEqual ( e . message . find ( 'Attempt to specify Content-Length header' ) , - 1 ) def test_upload_with_syntactically_invalid_tracker_uri ( self ) : res_upload_handler = ResumableUploadHandler ( tracker_file_name = self . syntactically_invalid_tracker_file_name ) self . small_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . small_src_file , res_upload_handler = res_upload_handler ) self . assertEqual ( self . small_src_file_size , self . dst_key . size ) self . assertEqual ( self . small_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) def test_upload_with_invalid_upload_id_in_tracker_file ( self ) : res_upload_handler = ResumableUploadHandler ( tracker_file_name = self . invalid_upload_id_tracker_file_name ) self . small_src_file . seek ( 0 ) self . dst_key . set_contents_from_file ( self . small_src_file , res_upload_handler = res_upload_handler ) self . assertEqual ( self . small_src_file_size , self . dst_key . size ) self . assertEqual ( self . small_src_file_as_string , self . dst_key . get_contents_as_string ( ) ) self . assertNotEqual ( self . invalid_upload_id , res_upload_handler . get_tracker_uri ( ) ) def test_upload_with_unwritable_tracker_file ( self ) : save_mod = os . stat ( self . tmp_dir ) . st_mode try : os . chmod ( self . tmp_dir , 0 ) res_upload_handler = ResumableUploadHandler ( tracker_file_name = self . tracker_file_name ) except ResumableUploadException , e : self . assertEqual ( e . disposition , ResumableTransferDisposition . ABORT ) self . assertNotEqual ( e . message . find ( 'Couldn\'t write URI tracker file' ) , - 1 ) finally : os . chmod ( self . tmp_dir , save_mod ) if __name__ == '__main__' : if sys . version_info [ : 3 ] < ( 2 , 5 , 1 ) : sys . exit ( 'These tests must be run on at least Python 2.5.1\n' ) debug = 0 opts , args = getopt . getopt ( sys . argv [ 1 : ] , 'd' , [ 'debug' ] ) for o , a in opts : if o in ( '-d' , '--debug' ) : debug = 2 test_loader = unittest . TestLoader ( ) test_loader . testMethodPrefix = 'test_' suite = test_loader . loadTestsFromTestCase ( ResumableUploadTests ) test_class = suite . __getattribute__ ( '_tests' ) [ 0 ] try : print 'Setting up %s...' % test_class . get_suite_description ( ) test_class . set_up_class ( debug ) print 'Running %s...' % test_class . get_suite_description ( ) unittest . TextTestRunner ( verbosity = 2 ) . run ( suite ) finally : print 'Cleaning up after %s...' % test_class . get_suite_description ( ) test_class . tear_down_class ( ) print ''

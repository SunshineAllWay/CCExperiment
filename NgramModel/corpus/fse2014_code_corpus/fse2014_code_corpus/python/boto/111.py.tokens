from boto . connection import AWSAuthConnection from boto . exception import BotoServerError from boto . regioninfo import RegionInfo import boto import boto . jsonresponse import urllib import base64 from boto . ses import exceptions as ses_exceptions class SESConnection ( AWSAuthConnection ) : ResponseError = BotoServerError DefaultRegionName = 'us-east-1' DefaultRegionEndpoint = 'email.us-east-1.amazonaws.com' APIVersion = '2010-12-01' def __init__ ( self , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , proxy_user = None , proxy_pass = None , debug = 0 , https_connection_factory = None , region = None , path = '/' ) : if not region : region = RegionInfo ( self , self . DefaultRegionName , self . DefaultRegionEndpoint ) self . region = region AWSAuthConnection . __init__ ( self , self . region . endpoint , aws_access_key_id , aws_secret_access_key , is_secure , port , proxy , proxy_port , proxy_user , proxy_pass , debug , https_connection_factory , path ) def _required_auth_capability ( self ) : return [ 'ses' ] def _build_list_params ( self , params , items , label ) : if isinstance ( items , basestring ) : items = [ items ] for i in range ( 1 , len ( items ) + 1 ) : params [ '%s.%d' % ( label , i ) ] = items [ i - 1 ] def _make_request ( self , action , params = None ) : ct = 'application/x-www-form-urlencoded; charset=UTF-8' headers = { 'Content-Type' : ct } params = params or { } params [ 'Action' ] = action for k , v in params . items ( ) : if isinstance ( v , unicode ) : params [ k ] = v . encode ( 'utf-8' ) response = super ( SESConnection , self ) . make_request ( , , headers = headers , data = urllib . urlencode ( params ) ) body = response . read ( ) if response . status == 200 : list_markers = ( 'VerifiedEmailAddresses' , 'SendDataPoints' ) e = boto . jsonresponse . Element ( list_marker = list_markers ) h = boto . jsonresponse . XmlHandler ( e , None ) h . parse ( body ) return e else : self . _handle_error ( response , body ) def _handle_error ( self , response , body ) : boto . log . error ( '%s %s' % ( response . status , response . reason ) ) boto . log . error ( '%s' % body ) if "Address blacklisted." in body : ExceptionToRaise = ses_exceptions . SESAddressBlacklistedError exc_reason = "Address blacklisted." elif "Email address is not verified." in body : ExceptionToRaise = ses_exceptions . SESAddressNotVerifiedError exc_reason = "Email address is not verified." elif "Daily message quota exceeded." in body : ExceptionToRaise = ses_exceptions . SESDailyQuotaExceededError exc_reason = "Daily message quota exceeded." elif "Maximum sending rate exceeded." in body : ExceptionToRaise = ses_exceptions . SESMaxSendingRateExceededError exc_reason = "Maximum sending rate exceeded." elif "Domain ends with dot." in body : ExceptionToRaise = ses_exceptions . SESDomainEndsWithDotError exc_reason = "Domain ends with dot." else : ExceptionToRaise = self . ResponseError exc_reason = response . reason raise ExceptionToRaise ( response . status , exc_reason , body ) def send_email ( self , source , subject , body , to_addresses , cc_addresses = None , bcc_addresses = None , format = 'text' , reply_addresses = None , return_path = None , text_body = None , html_body = None ) : format = format . lower ( ) . strip ( ) if body is not None : if format == "text" : if text_body is not None : raise Warning ( "You've passed in both a body and a text_body; please choose one or the other." ) text_body = body else : if html_body is not None : raise Warning ( "You've passed in both a body and an html_body; please choose one or the other." ) html_body = body params = { : source , : subject , } if return_path : params [ 'ReturnPath' ] = return_path if html_body is not None : params [ 'Message.Body.Html.Data' ] = html_body if text_body is not None : params [ 'Message.Body.Text.Data' ] = text_body if ( format not in ( "text" , "html" ) ) : raise ValueError ( "'format' argument must be 'text' or 'html'" ) if ( not ( html_body or text_body ) ) : raise ValueError ( "No text or html body found for mail" ) self . _build_list_params ( params , to_addresses , ) if cc_addresses : self . _build_list_params ( params , cc_addresses , ) if bcc_addresses : self . _build_list_params ( params , bcc_addresses , ) if reply_addresses : self . _build_list_params ( params , reply_addresses , ) return self . _make_request ( 'SendEmail' , params ) def send_raw_email ( self , raw_message , source = None , destinations = None ) : params = { : base64 . b64encode ( raw_message ) , } if source : params [ 'Source' ] = source if destinations : self . _build_list_params ( params , destinations , ) return self . _make_request ( 'SendRawEmail' , params ) def list_verified_email_addresses ( self ) : return self . _make_request ( 'ListVerifiedEmailAddresses' ) def get_send_quota ( self ) : return self . _make_request ( 'GetSendQuota' ) def get_send_statistics ( self ) : return self . _make_request ( 'GetSendStatistics' ) def delete_verified_email_address ( self , email_address ) : return self . _make_request ( 'DeleteVerifiedEmailAddress' , { : email_address , } ) def verify_email_address ( self , email_address ) : return self . _make_request ( 'VerifyEmailAddress' , { : email_address , } )

import base64 import boto import boto . auth_handler import boto . exception import boto . plugin import boto . utils import hmac import sys import urllib from email . utils import formatdate from boto . auth_handler import AuthHandler from boto . exception import BotoClientError try : from hashlib import sha1 as sha from hashlib import sha256 as sha256 if sys . version [ : 3 ] == "2.4" : class Faker : def __init__ ( self , which ) : self . which = which self . digest_size = self . which ( ) . digest_size def new ( self , * args , ** kwargs ) : return self . which ( * args , ** kwargs ) sha = Faker ( sha ) sha256 = Faker ( sha256 ) except ImportError : import sha sha256 = None class HmacKeys ( object ) : def __init__ ( self , host , config , provider ) : if provider . access_key is None or provider . secret_key is None : raise boto . auth_handler . NotReadyToAuthenticate ( ) self . host = host self . update_provider ( provider ) def update_provider ( self , provider ) : self . _provider = provider self . _hmac = hmac . new ( self . _provider . secret_key , digestmod = sha ) if sha256 : self . _hmac_256 = hmac . new ( self . _provider . secret_key , digestmod = sha256 ) else : self . _hmac_256 = None def algorithm ( self ) : if self . _hmac_256 : return 'HmacSHA256' else : return 'HmacSHA1' def sign_string ( self , string_to_sign ) : if self . _hmac_256 : hmac = self . _hmac_256 . copy ( ) else : hmac = self . _hmac . copy ( ) hmac . update ( string_to_sign ) return base64 . encodestring ( hmac . digest ( ) ) . strip ( ) class AnonAuthHandler ( AuthHandler , HmacKeys ) : capability = [ 'anon' ] def __init__ ( self , host , config , provider ) : AuthHandler . __init__ ( self , host , config , provider ) def add_auth ( self , http_request , ** kwargs ) : pass class HmacAuthV1Handler ( AuthHandler , HmacKeys ) : capability = [ 'hmac-v1' , 's3' ] def __init__ ( self , host , config , provider ) : AuthHandler . __init__ ( self , host , config , provider ) HmacKeys . __init__ ( self , host , config , provider ) self . _hmac_256 = None def add_auth ( self , http_request , ** kwargs ) : headers = http_request . headers method = http_request . method auth_path = http_request . auth_path if not headers . has_key ( 'Date' ) : headers [ 'Date' ] = formatdate ( usegmt = True ) if self . _provider . security_token : key = self . _provider . security_token_header headers [ key ] = self . _provider . security_token string_to_sign = boto . utils . canonical_string ( method , auth_path , headers , None , self . _provider ) boto . log . debug ( 'StringToSign:\n%s' % string_to_sign ) b64_hmac = self . sign_string ( string_to_sign ) auth_hdr = self . _provider . auth_header headers [ 'Authorization' ] = ( "%s %s:%s" % ( auth_hdr , self . _provider . access_key , b64_hmac ) ) class HmacAuthV2Handler ( AuthHandler , HmacKeys ) : capability = [ 'hmac-v2' , 'cloudfront' ] def __init__ ( self , host , config , provider ) : AuthHandler . __init__ ( self , host , config , provider ) HmacKeys . __init__ ( self , host , config , provider ) self . _hmac_256 = None def add_auth ( self , http_request , ** kwargs ) : headers = http_request . headers if not headers . has_key ( 'Date' ) : headers [ 'Date' ] = formatdate ( usegmt = True ) b64_hmac = self . sign_string ( headers [ 'Date' ] ) auth_hdr = self . _provider . auth_header headers [ 'Authorization' ] = ( "%s %s:%s" % ( auth_hdr , self . _provider . access_key , b64_hmac ) ) class HmacAuthV3Handler ( AuthHandler , HmacKeys ) : capability = [ 'hmac-v3' , 'route53' , 'ses' ] def __init__ ( self , host , config , provider ) : AuthHandler . __init__ ( self , host , config , provider ) HmacKeys . __init__ ( self , host , config , provider ) def add_auth ( self , http_request , ** kwargs ) : headers = http_request . headers if not headers . has_key ( 'Date' ) : headers [ 'Date' ] = formatdate ( usegmt = True ) b64_hmac = self . sign_string ( headers [ 'Date' ] ) s = "AWS3-HTTPS AWSAccessKeyId=%s," % self . _provider . access_key s += "Algorithm=%s,Signature=%s" % ( self . algorithm ( ) , b64_hmac ) headers [ 'X-Amzn-Authorization' ] = s class HmacAuthV3HTTPHandler ( AuthHandler , HmacKeys ) : capability = [ 'hmac-v3-http' ] def __init__ ( self , host , config , provider ) : AuthHandler . __init__ ( self , host , config , provider ) HmacKeys . __init__ ( self , host , config , provider ) def headers_to_sign ( self , http_request ) : headers_to_sign = { } headers_to_sign = { 'Host' : self . host } for name , value in http_request . headers . items ( ) : lname = name . lower ( ) if lname . startswith ( 'x-amz' ) : headers_to_sign [ name ] = value return headers_to_sign def canonical_headers ( self , headers_to_sign ) : l = [ '%s:%s' % ( n . lower ( ) . strip ( ) , headers_to_sign [ n ] . strip ( ) ) for n in headers_to_sign ] l . sort ( ) return '\n' . join ( l ) def string_to_sign ( self , http_request ) : headers_to_sign = self . headers_to_sign ( http_request ) canonical_headers = self . canonical_headers ( headers_to_sign ) string_to_sign = '\n' . join ( [ http_request . method , http_request . path , , canonical_headers , , http_request . body ] ) return string_to_sign , headers_to_sign def add_auth ( self , req , ** kwargs ) : if 'X-Amzn-Authorization' in req . headers : del req . headers [ 'X-Amzn-Authorization' ] req . headers [ 'X-Amz-Date' ] = formatdate ( usegmt = True ) req . headers [ 'X-Amz-Security-Token' ] = self . _provider . security_token string_to_sign , headers_to_sign = self . string_to_sign ( req ) boto . log . debug ( 'StringToSign:\n%s' % string_to_sign ) hash_value = sha256 ( string_to_sign ) . digest ( ) b64_hmac = self . sign_string ( hash_value ) s = "AWS3 AWSAccessKeyId=%s," % self . _provider . access_key s += "Algorithm=%s," % self . algorithm ( ) s += "SignedHeaders=%s," % ';' . join ( headers_to_sign ) s += "Signature=%s" % b64_hmac req . headers [ 'X-Amzn-Authorization' ] = s class QuerySignatureHelper ( HmacKeys ) : def add_auth ( self , http_request , ** kwargs ) : headers = http_request . headers params = http_request . params params [ 'AWSAccessKeyId' ] = self . _provider . access_key params [ 'SignatureVersion' ] = self . SignatureVersion params [ 'Timestamp' ] = boto . utils . get_ts ( ) qs , signature = self . _calc_signature ( http_request . params , http_request . method , http_request . auth_path , http_request . host ) boto . log . debug ( 'query_string: %s Signature: %s' % ( qs , signature ) ) if http_request . method == 'POST' : headers [ 'Content-Type' ] = 'application/x-www-form-urlencoded; charset=UTF-8' http_request . body = qs + '&Signature=' + urllib . quote_plus ( signature ) http_request . headers [ 'Content-Length' ] = str ( len ( http_request . body ) ) else : http_request . body = '' http_request . path = http_request . path . split ( '?' ) [ 0 ] http_request . path = ( http_request . path + '?' + qs + + urllib . quote_plus ( signature ) ) class QuerySignatureV0AuthHandler ( QuerySignatureHelper , AuthHandler ) : SignatureVersion = 0 capability = [ 'sign-v0' ] def _calc_signature ( self , params , * args ) : boto . log . debug ( 'using _calc_signature_0' ) hmac = self . _hmac . copy ( ) s = params [ 'Action' ] + params [ 'Timestamp' ] hmac . update ( s ) keys = params . keys ( ) keys . sort ( cmp = lambda x , y : cmp ( x . lower ( ) , y . lower ( ) ) ) pairs = [ ] for key in keys : val = boto . utils . get_utf8_value ( params [ key ] ) pairs . append ( key + '=' + urllib . quote ( val ) ) qs = '&' . join ( pairs ) return ( qs , base64 . b64encode ( hmac . digest ( ) ) ) class QuerySignatureV1AuthHandler ( QuerySignatureHelper , AuthHandler ) : SignatureVersion = 1 capability = [ 'sign-v1' , 'mturk' ] def _calc_signature ( self , params , * args ) : boto . log . debug ( 'using _calc_signature_1' ) hmac = self . _hmac . copy ( ) keys = params . keys ( ) keys . sort ( cmp = lambda x , y : cmp ( x . lower ( ) , y . lower ( ) ) ) pairs = [ ] for key in keys : hmac . update ( key ) val = boto . utils . get_utf8_value ( params [ key ] ) hmac . update ( val ) pairs . append ( key + '=' + urllib . quote ( val ) ) qs = '&' . join ( pairs ) return ( qs , base64 . b64encode ( hmac . digest ( ) ) ) class QuerySignatureV2AuthHandler ( QuerySignatureHelper , AuthHandler ) : SignatureVersion = 2 capability = [ 'sign-v2' , 'ec2' , 'ec2' , 'emr' , 'fps' , 'ecs' , , 'iam' , 'rds' , 'sns' , 'sqs' , 'cloudformation' ] def _calc_signature ( self , params , verb , path , server_name ) : boto . log . debug ( 'using _calc_signature_2' ) string_to_sign = '%s\n%s\n%s\n' % ( verb , server_name . lower ( ) , path ) if self . _hmac_256 : hmac = self . _hmac_256 . copy ( ) params [ 'SignatureMethod' ] = 'HmacSHA256' else : hmac = self . _hmac . copy ( ) params [ 'SignatureMethod' ] = 'HmacSHA1' if self . _provider . security_token : params [ 'SecurityToken' ] = self . _provider . security_token keys = params . keys ( ) keys . sort ( ) pairs = [ ] for key in keys : val = boto . utils . get_utf8_value ( params [ key ] ) pairs . append ( urllib . quote ( key , safe = '' ) + '=' + urllib . quote ( val , safe = '-_~' ) ) qs = '&' . join ( pairs ) boto . log . debug ( 'query string: %s' % qs ) string_to_sign += qs boto . log . debug ( 'string_to_sign: %s' % string_to_sign ) hmac . update ( string_to_sign ) b64 = base64 . b64encode ( hmac . digest ( ) ) boto . log . debug ( 'len(b64)=%d' % len ( b64 ) ) boto . log . debug ( 'base64 encoded digest: %s' % b64 ) return ( qs , b64 ) def get_auth_handler ( host , config , provider , requested_capability = None ) : ready_handlers = [ ] auth_handlers = boto . plugin . get_plugin ( AuthHandler , requested_capability ) total_handlers = len ( auth_handlers ) for handler in auth_handlers : try : ready_handlers . append ( handler ( host , config , provider ) ) except boto . auth_handler . NotReadyToAuthenticate : pass if not ready_handlers : checked_handlers = auth_handlers names = [ handler . __name__ for handler in checked_handlers ] raise boto . exception . NoAuthHandlerFound ( % ( len ( names ) , str ( names ) ) ) if len ( ready_handlers ) > 1 : names = [ handler . __class__ . __name__ for handler in ready_handlers ] raise boto . exception . TooManyAuthHandlerReadyToAuthenticate ( % ( len ( names ) , str ( names ) , requested_capability ) ) return ready_handlers [ 0 ]

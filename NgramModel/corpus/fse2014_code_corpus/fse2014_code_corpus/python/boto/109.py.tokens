import xml . sax import urllib , base64 import time import boto . utils from boto . connection import AWSAuthConnection from boto import handler from boto . s3 . bucket import Bucket from boto . s3 . key import Key from boto . resultset import ResultSet from boto . exception import BotoClientError def check_lowercase_bucketname ( n ) : if not ( n + 'a' ) . islower ( ) : raise BotoClientError ( "Bucket names cannot contain upper-case " "characters when using either the sub-domain or virtual " "hosting calling format." ) return True def assert_case_insensitive ( f ) : def wrapper ( * args , ** kwargs ) : if len ( args ) == 3 and check_lowercase_bucketname ( args [ 2 ] ) : pass return f ( * args , ** kwargs ) return wrapper class _CallingFormat ( object ) : def get_bucket_server ( self , server , bucket ) : return '' def build_url_base ( self , connection , protocol , server , bucket , key = '' ) : url_base = '%s://' % protocol url_base += self . build_host ( server , bucket ) url_base += connection . get_path ( self . build_path_base ( bucket , key ) ) return url_base def build_host ( self , server , bucket ) : if bucket == '' : return server else : return self . get_bucket_server ( server , bucket ) def build_auth_path ( self , bucket , key = '' ) : key = boto . utils . get_utf8_value ( key ) path = '' if bucket != '' : path = '/' + bucket return path + '/%s' % urllib . quote ( key ) def build_path_base ( self , bucket , key = '' ) : key = boto . utils . get_utf8_value ( key ) return '/%s' % urllib . quote ( key ) class SubdomainCallingFormat ( _CallingFormat ) : @ assert_case_insensitive def get_bucket_server ( self , server , bucket ) : return '%s.%s' % ( bucket , server ) class VHostCallingFormat ( _CallingFormat ) : @ assert_case_insensitive def get_bucket_server ( self , server , bucket ) : return bucket class OrdinaryCallingFormat ( _CallingFormat ) : def get_bucket_server ( self , server , bucket ) : return server def build_path_base ( self , bucket , key = '' ) : key = boto . utils . get_utf8_value ( key ) path_base = '/' if bucket : path_base += "%s/" % bucket return path_base + urllib . quote ( key ) class ProtocolIndependentOrdinaryCallingFormat ( OrdinaryCallingFormat ) : def build_url_base ( self , connection , protocol , server , bucket , key = '' ) : url_base = '//' url_base += self . build_host ( server , bucket ) url_base += connection . get_path ( self . build_path_base ( bucket , key ) ) return url_base class Location : DEFAULT = '' EU = 'EU' USWest = 'us-west-1' SAEast = 'sa-east-1' APNortheast = 'ap-northeast-1' APSoutheast = 'ap-southeast-1' class S3Connection ( AWSAuthConnection ) : DefaultHost = 's3.amazonaws.com' QueryString = 'Signature=%s&Expires=%d&AWSAccessKeyId=%s' def __init__ ( self , aws_access_key_id = None , aws_secret_access_key = None , is_secure = True , port = None , proxy = None , proxy_port = None , proxy_user = None , proxy_pass = None , host = DefaultHost , debug = 0 , https_connection_factory = None , calling_format = SubdomainCallingFormat ( ) , path = '/' , provider = 'aws' , bucket_class = Bucket , security_token = None , suppress_consec_slashes = True , anon = False ) : self . calling_format = calling_format self . bucket_class = bucket_class self . anon = anon AWSAuthConnection . __init__ ( self , host , aws_access_key_id , aws_secret_access_key , is_secure , port , proxy , proxy_port , proxy_user , proxy_pass , debug = debug , https_connection_factory = https_connection_factory , path = path , provider = provider , security_token = security_token , suppress_consec_slashes = suppress_consec_slashes ) def _required_auth_capability ( self ) : if self . anon : return [ 'anon' ] else : return [ 's3' ] def __iter__ ( self ) : for bucket in self . get_all_buckets ( ) : yield bucket def __contains__ ( self , bucket_name ) : return not ( self . lookup ( bucket_name ) is None ) def set_bucket_class ( self , bucket_class ) : self . bucket_class = bucket_class def build_post_policy ( self , expiration_time , conditions ) : assert type ( expiration_time ) == time . struct_time , 'Policy document must include a valid expiration Time object' return '{"expiration": "%s",\n"conditions": [%s]}' % ( time . strftime ( boto . utils . ISO8601 , expiration_time ) , "," . join ( conditions ) ) def build_post_form_args ( self , bucket_name , key , expires_in = 6000 , acl = None , success_action_redirect = None , max_content_length = None , http_method = "http" , fields = None , conditions = None ) : if fields == None : fields = [ ] if conditions == None : conditions = [ ] expiration = time . gmtime ( int ( time . time ( ) + expires_in ) ) conditions . append ( '{"bucket": "%s"}' % bucket_name ) if key . endswith ( "${filename}" ) : conditions . append ( '["starts-with", "$key", "%s"]' % key [ : - len ( "${filename}" ) ] ) else : conditions . append ( '{"key": "%s"}' % key ) if acl : conditions . append ( '{"acl": "%s"}' % acl ) fields . append ( { "name" : "acl" , "value" : acl } ) if success_action_redirect : conditions . append ( '{"success_action_redirect": "%s"}' % success_action_redirect ) fields . append ( { "name" : "success_action_redirect" , "value" : success_action_redirect } ) if max_content_length : conditions . append ( '["content-length-range", 0, %i]' % max_content_length ) fields . append ( { "name" : 'content-length-range' , "value" : "0,%i" % max_content_length } ) policy = self . build_post_policy ( expiration , conditions ) policy_b64 = base64 . b64encode ( policy ) fields . append ( { "name" : "policy" , "value" : policy_b64 } ) fields . append ( { "name" : "AWSAccessKeyId" , : self . aws_access_key_id } ) signature = self . _auth_handler . sign_string ( policy_b64 ) fields . append ( { "name" : "signature" , "value" : signature } ) fields . append ( { "name" : "key" , "value" : key } ) url = '%s://%s/' % ( http_method , self . calling_format . build_host ( self . server_name ( ) , bucket_name ) ) return { "action" : url , "fields" : fields } def generate_url ( self , expires_in , method , bucket = '' , key = '' , headers = None , query_auth = True , force_http = False , response_headers = None , expires_in_absolute = False ) : if not headers : headers = { } if expires_in_absolute : expires = int ( expires_in ) else : expires = int ( time . time ( ) + expires_in ) auth_path = self . calling_format . build_auth_path ( bucket , key ) auth_path = self . get_path ( auth_path ) if response_headers : response_hdrs = [ "%s=%s" % ( k , v ) for k , v in response_headers . items ( ) ] delimiter = '?' if '?' not in auth_path else '&' auth_path = "%s%s" % ( auth_path , delimiter ) auth_path += '&' . join ( response_hdrs ) else : response_headers = { } c_string = boto . utils . canonical_string ( method , auth_path , headers , expires , self . provider ) b64_hmac = self . _auth_handler . sign_string ( c_string ) encoded_canonical = urllib . quote_plus ( b64_hmac ) self . calling_format . build_path_base ( bucket , key ) if query_auth : query_part = '?' + self . QueryString % ( encoded_canonical , expires , self . aws_access_key_id ) headers . update ( response_headers ) hdrs = [ '%s=%s' % ( n , urllib . quote ( v ) ) for n , v in headers . items ( ) ] q_str = '&' . join ( hdrs ) if q_str : query_part += '&' + q_str else : query_part = '' if force_http : protocol = 'http' port = 80 else : protocol = self . protocol port = self . port return self . calling_format . build_url_base ( self , protocol , self . server_name ( port ) , bucket , key ) + query_part def get_all_buckets ( self , headers = None ) : response = self . make_request ( 'GET' , headers = headers ) body = response . read ( ) if response . status > 300 : raise self . provider . storage_response_error ( response . status , response . reason , body ) rs = ResultSet ( [ ( 'Bucket' , self . bucket_class ) ] ) h = handler . XmlHandler ( rs , self ) xml . sax . parseString ( body , h ) return rs def get_canonical_user_id ( self , headers = None ) : rs = self . get_all_buckets ( headers = headers ) return rs . ID def get_bucket ( self , bucket_name , validate = True , headers = None ) : bucket = self . bucket_class ( self , bucket_name ) if validate : bucket . get_all_keys ( headers , maxkeys = 0 ) return bucket def lookup ( self , bucket_name , validate = True , headers = None ) : try : bucket = self . get_bucket ( bucket_name , validate , headers = headers ) except : bucket = None return bucket def create_bucket ( self , bucket_name , headers = None , location = Location . DEFAULT , policy = None ) : check_lowercase_bucketname ( bucket_name ) if policy : if headers : headers [ self . provider . acl_header ] = policy else : headers = { self . provider . acl_header : policy } if location == Location . DEFAULT : data = '' else : data = '<CreateBucketConstraint><LocationConstraint>' + location + '</LocationConstraint></CreateBucketConstraint>' response = self . make_request ( 'PUT' , bucket_name , headers = headers , data = data ) body = response . read ( ) if response . status == 409 : raise self . provider . storage_create_error ( response . status , response . reason , body ) if response . status == 200 : return self . bucket_class ( self , bucket_name ) else : raise self . provider . storage_response_error ( response . status , response . reason , body ) def delete_bucket ( self , bucket , headers = None ) : response = self . make_request ( 'DELETE' , bucket , headers = headers ) body = response . read ( ) if response . status != 204 : raise self . provider . storage_response_error ( response . status , response . reason , body ) def make_request ( self , method , bucket = '' , key = '' , headers = None , data = '' , query_args = None , sender = None , override_num_retries = None ) : if isinstance ( bucket , self . bucket_class ) : bucket = bucket . name if isinstance ( key , Key ) : key = key . name path = self . calling_format . build_path_base ( bucket , key ) boto . log . debug ( 'path=%s' % path ) auth_path = self . calling_format . build_auth_path ( bucket , key ) boto . log . debug ( 'auth_path=%s' % auth_path ) host = self . calling_format . build_host ( self . server_name ( ) , bucket ) if query_args : path += '?' + query_args boto . log . debug ( 'path=%s' % path ) auth_path += '?' + query_args boto . log . debug ( 'auth_path=%s' % auth_path ) return AWSAuthConnection . make_request ( self , method , path , headers , data , host , auth_path , sender , override_num_retries = override_num_retries )

from django . db import models from django . utils . translation import ugettext_lazy as _ from django . utils . encoding import smart_unicode , force_unicode class ContentTypeManager ( models . Manager ) : _cache = { } def get_by_natural_key ( self , app_label , model ) : try : ct = self . __class__ . _cache [ self . db ] [ ( app_label , model ) ] except KeyError : ct = self . get ( app_label = app_label , model = model ) self . _add_to_cache ( self . db , ct ) return ct def _get_opts ( self , model ) : opts = model . _meta while opts . proxy : model = opts . proxy_for_model opts = model . _meta return opts def _get_from_cache ( self , opts ) : key = ( opts . app_label , opts . object_name . lower ( ) ) return self . __class__ . _cache [ self . db ] [ key ] def get_for_model ( self , model ) : opts = self . _get_opts ( model ) try : ct = self . _get_from_cache ( opts ) except KeyError : ct , created = self . get_or_create ( app_label = opts . app_label , model = opts . object_name . lower ( ) , defaults = { 'name' : smart_unicode ( opts . verbose_name_raw ) } , ) self . _add_to_cache ( self . db , ct ) return ct def get_for_models ( self , * models ) : results = { } needed_app_labels = set ( ) needed_models = set ( ) needed_opts = set ( ) for model in models : opts = self . _get_opts ( model ) try : ct = self . _get_from_cache ( opts ) except KeyError : needed_app_labels . add ( opts . app_label ) needed_models . add ( opts . object_name . lower ( ) ) needed_opts . add ( opts ) else : results [ model ] = ct if needed_opts : cts = self . filter ( app_label__in = needed_app_labels , model__in = needed_models ) for ct in cts : model = ct . model_class ( ) if model . _meta in needed_opts : results [ model ] = ct needed_opts . remove ( model . _meta ) self . _add_to_cache ( self . db , ct ) for opts in needed_opts : ct = self . create ( app_label = opts . app_label , model = opts . object_name . lower ( ) , name = smart_unicode ( opts . verbose_name_raw ) , ) self . _add_to_cache ( self . db , ct ) results [ ct . model_class ( ) ] = ct return results def get_for_id ( self , id ) : try : ct = self . __class__ . _cache [ self . db ] [ id ] except KeyError : ct = self . get ( pk = id ) self . _add_to_cache ( self . db , ct ) return ct def clear_cache ( self ) : self . __class__ . _cache . clear ( ) def _add_to_cache ( self , using , ct ) : model = ct . model_class ( ) key = ( model . _meta . app_label , model . _meta . object_name . lower ( ) ) self . __class__ . _cache . setdefault ( using , { } ) [ key ] = ct self . __class__ . _cache . setdefault ( using , { } ) [ ct . id ] = ct class ContentType ( models . Model ) : name = models . CharField ( max_length = 100 ) app_label = models . CharField ( max_length = 100 ) model = models . CharField ( _ ( 'python model class name' ) , max_length = 100 ) objects = ContentTypeManager ( ) class Meta : verbose_name = _ ( 'content type' ) verbose_name_plural = _ ( 'content types' ) db_table = 'django_content_type' ordering = ( 'name' , ) unique_together = ( ( 'app_label' , 'model' ) , ) def __unicode__ ( self ) : model = self . model_class ( ) if not model or self . name != model . _meta . verbose_name_raw : return self . name else : return force_unicode ( model . _meta . verbose_name ) def model_class ( self ) : from django . db import models return models . get_model ( self . app_label , self . model , only_installed = False ) def get_object_for_this_type ( self , ** kwargs ) : return self . model_class ( ) . _base_manager . using ( self . _state . db ) . get ( ** kwargs ) def get_all_objects_for_this_type ( self , ** kwargs ) : return self . model_class ( ) . _base_manager . using ( self . _state . db ) . filter ( ** kwargs ) def natural_key ( self ) : return ( self . app_label , self . model )

"""Timezone helper functions. This module uses pytz when it's available and fallbacks when it isn't. """ from datetime import datetime , timedelta , tzinfo from threading import local import time as _time try : import pytz except ImportError : pytz = None from django . conf import settings __all__ = [ , 'get_default_timezone' , 'get_current_timezone' , , 'deactivate' , 'override' , , 'is_naive' , 'is_aware' , 'make_aware' , 'make_naive' , ] ZERO = timedelta ( 0 ) class UTC ( tzinfo ) : def utcoffset ( self , dt ) : return ZERO def tzname ( self , dt ) : return "UTC" def dst ( self , dt ) : return ZERO class LocalTimezone ( tzinfo ) : def __init__ ( self ) : self . STDOFFSET = timedelta ( seconds = - _time . timezone ) if _time . daylight : self . DSTOFFSET = timedelta ( seconds = - _time . altzone ) else : self . DSTOFFSET = self . STDOFFSET self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET tzinfo . __init__ ( self ) def utcoffset ( self , dt ) : if self . _isdst ( dt ) : return self . DSTOFFSET else : return self . STDOFFSET def dst ( self , dt ) : if self . _isdst ( dt ) : return self . DSTDIFF else : return ZERO def tzname ( self , dt ) : return _time . tzname [ self . _isdst ( dt ) ] def _isdst ( self , dt ) : tt = ( dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , 0 , 0 ) stamp = _time . mktime ( tt ) tt = _time . localtime ( stamp ) return tt . tm_isdst > 0 utc = pytz . utc if pytz else UTC ( ) _localtime = None def get_default_timezone ( ) : global _localtime if _localtime is None : if isinstance ( settings . TIME_ZONE , basestring ) and pytz is not None : _localtime = pytz . timezone ( settings . TIME_ZONE ) else : _localtime = LocalTimezone ( ) return _localtime def get_default_timezone_name ( ) : return _get_timezone_name ( get_default_timezone ( ) ) _active = local ( ) def get_current_timezone ( ) : return getattr ( _active , "value" , get_default_timezone ( ) ) def get_current_timezone_name ( ) : return _get_timezone_name ( get_current_timezone ( ) ) def _get_timezone_name ( timezone ) : try : return timezone . zone except AttributeError : local_now = datetime . now ( timezone ) return timezone . tzname ( local_now ) def activate ( timezone ) : if isinstance ( timezone , tzinfo ) : _active . value = timezone elif isinstance ( timezone , basestring ) and pytz is not None : _active . value = pytz . timezone ( timezone ) else : raise ValueError ( "Invalid timezone: %r" % timezone ) def deactivate ( ) : if hasattr ( _active , "value" ) : del _active . value class override ( object ) : def __init__ ( self , timezone ) : self . timezone = timezone self . old_timezone = getattr ( _active , 'value' , None ) def __enter__ ( self ) : if self . timezone is None : deactivate ( ) else : activate ( self . timezone ) def __exit__ ( self , exc_type , exc_value , traceback ) : if self . old_timezone is not None : _active . value = self . old_timezone else : del _active . value def localtime ( value , use_tz = None ) : if ( isinstance ( value , datetime ) and ( settings . USE_TZ if use_tz is None else use_tz ) and not is_naive ( value ) and getattr ( value , 'convert_to_local_time' , True ) ) : timezone = get_current_timezone ( ) value = value . astimezone ( timezone ) if hasattr ( timezone , 'normalize' ) : value = timezone . normalize ( value ) return value def now ( ) : if settings . USE_TZ : return datetime . utcnow ( ) . replace ( tzinfo = utc ) else : return datetime . now ( ) def is_aware ( value ) : return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None def is_naive ( value ) : return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None def make_aware ( value , timezone ) : if hasattr ( timezone , 'localize' ) : return timezone . localize ( value , is_dst = None ) else : return value . replace ( tzinfo = timezone ) def make_naive ( value , timezone ) : value = value . astimezone ( timezone ) if hasattr ( timezone , 'normalize' ) : value = timezone . normalize ( value ) return value . replace ( tzinfo = None )

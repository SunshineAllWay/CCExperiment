""" This module contains the 'base' GEOSGeometry object -- all GEOS Geometries inherit from this object. """ import warnings from ctypes import addressof , byref , c_double from django . contrib . gis . geos . mutable_list import ListMixin from django . contrib . gis . geos . base import GEOSBase , gdal from django . contrib . gis . geos . coordseq import GEOSCoordSeq from django . contrib . gis . geos . error import GEOSException , GEOSIndexError from django . contrib . gis . geos . libgeos import GEOM_PTR , GEOS_PREPARE from django . contrib . gis . geos . mutable_list import ListMixin from django . contrib . gis . geos import prototypes as capi from django . contrib . gis . geos . prototypes . io import wkt_r , wkt_w , wkb_r , wkb_w , ewkb_w , ewkb_w3d from django . contrib . gis . geometry . regex import hex_regex , wkt_regex , json_regex class GEOSGeometry ( GEOSBase , ListMixin ) : _IndexError = GEOSIndexError ptr_type = GEOM_PTR def __init__ ( self , geo_input , srid = None ) : if isinstance ( geo_input , basestring ) : if isinstance ( geo_input , unicode ) : geo_input = geo_input . encode ( 'ascii' ) wkt_m = wkt_regex . match ( geo_input ) if wkt_m : if wkt_m . group ( 'srid' ) : srid = int ( wkt_m . group ( 'srid' ) ) g = wkt_r ( ) . read ( wkt_m . group ( 'wkt' ) ) elif hex_regex . match ( geo_input ) : g = wkb_r ( ) . read ( geo_input ) elif gdal . GEOJSON and json_regex . match ( geo_input ) : g = wkb_r ( ) . read ( gdal . OGRGeometry ( geo_input ) . wkb ) else : raise ValueError ( 'String or unicode input unrecognized as WKT EWKT, and HEXEWKB.' ) elif isinstance ( geo_input , GEOM_PTR ) : g = geo_input elif isinstance ( geo_input , buffer ) : g = wkb_r ( ) . read ( geo_input ) elif isinstance ( geo_input , GEOSGeometry ) : g = capi . geom_clone ( geo_input . ptr ) else : raise TypeError ( 'Improper geometry input type: %s' % str ( type ( geo_input ) ) ) if bool ( g ) : self . ptr = g else : raise GEOSException ( 'Could not initialize GEOS Geometry with given input.' ) self . _post_init ( srid ) def _post_init ( self , srid ) : if srid and isinstance ( srid , int ) : self . srid = srid self . __class__ = GEOS_CLASSES [ self . geom_typeid ] self . _set_cs ( ) def __del__ ( self ) : if self . _ptr : capi . destroy_geom ( self . _ptr ) def __copy__ ( self ) : return self . clone ( ) def __deepcopy__ ( self , memodict ) : return self . clone ( ) def __str__ ( self ) : return self . wkt def __repr__ ( self ) : return '<%s object at %s>' % ( self . geom_type , hex ( addressof ( self . ptr ) ) ) def __getstate__ ( self ) : return str ( self . wkb ) , self . srid def __setstate__ ( self , state ) : wkb , srid = state ptr = wkb_r ( ) . read ( buffer ( wkb ) ) if not ptr : raise GEOSException ( 'Invalid Geometry loaded from pickled state.' ) self . ptr = ptr self . _post_init ( srid ) def __eq__ ( self , other ) : if isinstance ( other , basestring ) : return self . wkt == other elif isinstance ( other , GEOSGeometry ) : return self . equals_exact ( other ) else : return False def __ne__ ( self , other ) : return not ( self == other ) def __or__ ( self , other ) : return self . union ( other ) def __and__ ( self , other ) : return self . intersection ( other ) def __sub__ ( self , other ) : return self . difference ( other ) def __xor__ ( self , other ) : return self . sym_difference ( other ) @ property def has_cs ( self ) : if isinstance ( self , ( Point , LineString , LinearRing ) ) : return True else : return False def _set_cs ( self ) : if self . has_cs : self . _cs = GEOSCoordSeq ( capi . get_cs ( self . ptr ) , self . hasz ) else : self . _cs = None @ property def coord_seq ( self ) : if self . has_cs : return self . _cs . clone ( ) @ property def geom_type ( self ) : return capi . geos_type ( self . ptr ) @ property def geom_typeid ( self ) : return capi . geos_typeid ( self . ptr ) @ property def num_geom ( self ) : return capi . get_num_geoms ( self . ptr ) @ property def num_coords ( self ) : return capi . get_num_coords ( self . ptr ) @ property def num_points ( self ) : return self . num_coords @ property def dims ( self ) : return capi . get_dims ( self . ptr ) def normalize ( self ) : return capi . geos_normalize ( self . ptr ) @ property def empty ( self ) : return capi . geos_isempty ( self . ptr ) @ property def hasz ( self ) : return capi . geos_hasz ( self . ptr ) @ property def ring ( self ) : return capi . geos_isring ( self . ptr ) @ property def simple ( self ) : return capi . geos_issimple ( self . ptr ) @ property def valid ( self ) : return capi . geos_isvalid ( self . ptr ) @ property def valid_reason ( self ) : if not GEOS_PREPARE : raise GEOSException ( 'Upgrade GEOS to 3.1 to get validity reason.' ) return capi . geos_isvalidreason ( self . ptr ) def contains ( self , other ) : return capi . geos_contains ( self . ptr , other . ptr ) def crosses ( self , other ) : return capi . geos_crosses ( self . ptr , other . ptr ) def disjoint ( self , other ) : return capi . geos_disjoint ( self . ptr , other . ptr ) def equals ( self , other ) : return capi . geos_equals ( self . ptr , other . ptr ) def equals_exact ( self , other , tolerance = 0 ) : return capi . geos_equalsexact ( self . ptr , other . ptr , float ( tolerance ) ) def intersects ( self , other ) : return capi . geos_intersects ( self . ptr , other . ptr ) def overlaps ( self , other ) : return capi . geos_overlaps ( self . ptr , other . ptr ) def relate_pattern ( self , other , pattern ) : if not isinstance ( pattern , basestring ) or len ( pattern ) > 9 : raise GEOSException ( 'invalid intersection matrix pattern' ) return capi . geos_relatepattern ( self . ptr , other . ptr , pattern ) def touches ( self , other ) : return capi . geos_touches ( self . ptr , other . ptr ) def within ( self , other ) : return capi . geos_within ( self . ptr , other . ptr ) def get_srid ( self ) : s = capi . geos_get_srid ( self . ptr ) if s == 0 : return None else : return s def set_srid ( self , srid ) : capi . geos_set_srid ( self . ptr , srid ) srid = property ( get_srid , set_srid ) @ property def ewkt ( self ) : if self . get_srid ( ) : return 'SRID=%s;%s' % ( self . srid , self . wkt ) else : return self . wkt @ property def wkt ( self ) : return wkt_w ( ) . write ( self ) @ property def hex ( self ) : return wkb_w ( ) . write_hex ( self ) @ property def hexewkb ( self ) : if self . hasz : if not GEOS_PREPARE : raise GEOSException ( 'Upgrade GEOS to 3.1 to get valid 3D HEXEWKB.' ) return ewkb_w3d ( ) . write_hex ( self ) else : return ewkb_w ( ) . write_hex ( self ) @ property def json ( self ) : if gdal . GEOJSON : return self . ogr . json else : raise GEOSException ( 'GeoJSON output only supported on GDAL 1.5+.' ) geojson = json @ property def wkb ( self ) : return wkb_w ( ) . write ( self ) @ property def ewkb ( self ) : if self . hasz : if not GEOS_PREPARE : raise GEOSException ( 'Upgrade GEOS to 3.1 to get valid 3D EWKB.' ) return ewkb_w3d ( ) . write ( self ) else : return ewkb_w ( ) . write ( self ) @ property def kml ( self ) : gtype = self . geom_type return '<%s>%s</%s>' % ( gtype , self . coord_seq . kml , gtype ) @ property def prepared ( self ) : if GEOS_PREPARE : return PreparedGeometry ( self ) else : raise GEOSException ( 'GEOS 3.1+ required for prepared geometry support.' ) @ property def ogr ( self ) : if gdal . HAS_GDAL : if self . srid : return gdal . OGRGeometry ( self . wkb , self . srid ) else : return gdal . OGRGeometry ( self . wkb ) else : raise GEOSException ( 'GDAL required to convert to an OGRGeometry.' ) @ property def srs ( self ) : if gdal . HAS_GDAL : if self . srid : return gdal . SpatialReference ( self . srid ) else : return None else : raise GEOSException ( 'GDAL required to return a SpatialReference object.' ) @ property def crs ( self ) : return self . srs def transform ( self , ct , clone = False ) : srid = self . srid if ct == srid : if clone : return self . clone ( ) else : return if ( srid is None ) or ( srid < 0 ) : warnings . warn ( "Calling transform() with no SRID set does no transformation!" , stacklevel = 2 ) warnings . warn ( "Calling transform() with no SRID will raise GEOSException in v1.5" , FutureWarning , stacklevel = 2 ) return if not gdal . HAS_GDAL : raise GEOSException ( "GDAL library is not available to transform() geometry." ) g = gdal . OGRGeometry ( self . wkb , srid ) g . transform ( ct ) ptr = wkb_r ( ) . read ( g . wkb ) if clone : return GEOSGeometry ( ptr , srid = g . srid ) if ptr : capi . destroy_geom ( self . ptr ) self . ptr = ptr self . _post_init ( g . srid ) else : raise GEOSException ( 'Transformed WKB was invalid.' ) def _topology ( self , gptr ) : return GEOSGeometry ( gptr , srid = self . srid ) @ property def boundary ( self ) : return self . _topology ( capi . geos_boundary ( self . ptr ) ) def buffer ( self , width , quadsegs = 8 ) : return self . _topology ( capi . geos_buffer ( self . ptr , width , quadsegs ) ) @ property def centroid ( self ) : return self . _topology ( capi . geos_centroid ( self . ptr ) ) @ property def convex_hull ( self ) : return self . _topology ( capi . geos_convexhull ( self . ptr ) ) def difference ( self , other ) : return self . _topology ( capi . geos_difference ( self . ptr , other . ptr ) ) @ property def envelope ( self ) : return self . _topology ( capi . geos_envelope ( self . ptr ) ) def intersection ( self , other ) : return self . _topology ( capi . geos_intersection ( self . ptr , other . ptr ) ) @ property def point_on_surface ( self ) : return self . _topology ( capi . geos_pointonsurface ( self . ptr ) ) def relate ( self , other ) : return capi . geos_relate ( self . ptr , other . ptr ) def simplify ( self , tolerance = 0.0 , preserve_topology = False ) : if preserve_topology : return self . _topology ( capi . geos_preservesimplify ( self . ptr , tolerance ) ) else : return self . _topology ( capi . geos_simplify ( self . ptr , tolerance ) ) def sym_difference ( self , other ) : return self . _topology ( capi . geos_symdifference ( self . ptr , other . ptr ) ) def union ( self , other ) : return self . _topology ( capi . geos_union ( self . ptr , other . ptr ) ) @ property def area ( self ) : return capi . geos_area ( self . ptr , byref ( c_double ( ) ) ) def distance ( self , other ) : if not isinstance ( other , GEOSGeometry ) : raise TypeError ( 'distance() works only on other GEOS Geometries.' ) return capi . geos_distance ( self . ptr , other . ptr , byref ( c_double ( ) ) ) @ property def extent ( self ) : env = self . envelope if isinstance ( env , Point ) : xmin , ymin = env . tuple xmax , ymax = xmin , ymin else : xmin , ymin = env [ 0 ] [ 0 ] xmax , ymax = env [ 0 ] [ 2 ] return ( xmin , ymin , xmax , ymax ) @ property def length ( self ) : return capi . geos_length ( self . ptr , byref ( c_double ( ) ) ) def clone ( self ) : return GEOSGeometry ( capi . geom_clone ( self . ptr ) , srid = self . srid ) from django . contrib . gis . geos . linestring import LineString , LinearRing from django . contrib . gis . geos . point import Point from django . contrib . gis . geos . polygon import Polygon from django . contrib . gis . geos . collections import GeometryCollection , MultiPoint , MultiLineString , MultiPolygon GEOS_CLASSES = { 0 : Point , 1 : LineString , 2 : LinearRing , 3 : Polygon , 4 : MultiPoint , 5 : MultiLineString , 6 : MultiPolygon , 7 : GeometryCollection , } if GEOS_PREPARE : from django . contrib . gis . geos . prepared import PreparedGeometry

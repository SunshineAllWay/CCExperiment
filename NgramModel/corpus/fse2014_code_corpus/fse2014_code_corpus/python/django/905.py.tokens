import datetime from django . db import models from django . core . exceptions import ImproperlyConfigured from django . http import Http404 from django . utils . encoding import force_unicode from django . utils . translation import ugettext as _ from django . utils import timezone from django . views . generic . base import View from django . views . generic . detail import BaseDetailView , SingleObjectTemplateResponseMixin from django . views . generic . list import MultipleObjectMixin , MultipleObjectTemplateResponseMixin class YearMixin ( object ) : year_format = '%Y' year = None def get_year_format ( self ) : return self . year_format def get_year ( self ) : year = self . year if year is None : try : year = self . kwargs [ 'year' ] except KeyError : try : year = self . request . GET [ 'year' ] except KeyError : raise Http404 ( _ ( u"No year specified" ) ) return year class MonthMixin ( object ) : month_format = '%b' month = None def get_month_format ( self ) : return self . month_format def get_month ( self ) : month = self . month if month is None : try : month = self . kwargs [ 'month' ] except KeyError : try : month = self . request . GET [ 'month' ] except KeyError : raise Http404 ( _ ( u"No month specified" ) ) return month def get_next_month ( self , date ) : first_day , last_day = _month_bounds ( date ) next = ( last_day + datetime . timedelta ( days = 1 ) ) . replace ( day = 1 ) return _get_next_prev_month ( self , next , is_previous = False , use_first_day = True ) def get_previous_month ( self , date ) : first_day , last_day = _month_bounds ( date ) prev = ( first_day - datetime . timedelta ( days = 1 ) ) return _get_next_prev_month ( self , prev , is_previous = True , use_first_day = True ) class DayMixin ( object ) : day_format = '%d' day = None def get_day_format ( self ) : return self . day_format def get_day ( self ) : day = self . day if day is None : try : day = self . kwargs [ 'day' ] except KeyError : try : day = self . request . GET [ 'day' ] except KeyError : raise Http404 ( _ ( u"No day specified" ) ) return day def get_next_day ( self , date ) : next = date + datetime . timedelta ( days = 1 ) return _get_next_prev_month ( self , next , is_previous = False , use_first_day = False ) def get_previous_day ( self , date ) : prev = date - datetime . timedelta ( days = 1 ) return _get_next_prev_month ( self , prev , is_previous = True , use_first_day = False ) class WeekMixin ( object ) : week_format = '%U' week = None def get_week_format ( self ) : return self . week_format def get_week ( self ) : week = self . week if week is None : try : week = self . kwargs [ 'week' ] except KeyError : try : week = self . request . GET [ 'week' ] except KeyError : raise Http404 ( _ ( u"No week specified" ) ) return week class DateMixin ( object ) : date_field = None allow_future = False def get_date_field ( self ) : if self . date_field is None : raise ImproperlyConfigured ( u"%s.date_field is required." % self . __class__ . __name__ ) return self . date_field def get_allow_future ( self ) : return self . allow_future class BaseDateListView ( MultipleObjectMixin , DateMixin , View ) : allow_empty = False def get ( self , request , * args , ** kwargs ) : self . date_list , self . object_list , extra_context = self . get_dated_items ( ) context = self . get_context_data ( object_list = self . object_list , date_list = self . date_list ) context . update ( extra_context ) return self . render_to_response ( context ) def get_dated_items ( self ) : raise NotImplementedError ( 'A DateView must provide an implementation of get_dated_items()' ) def get_dated_queryset ( self , ** lookup ) : qs = self . get_queryset ( ) . filter ( ** lookup ) date_field = self . get_date_field ( ) allow_future = self . get_allow_future ( ) allow_empty = self . get_allow_empty ( ) if not allow_future : qs = qs . filter ( ** { '%s__lte' % date_field : timezone . now ( ) } ) if not allow_empty and not qs : raise Http404 ( _ ( u"No %(verbose_name_plural)s available" ) % { : force_unicode ( qs . model . _meta . verbose_name_plural ) } ) return qs def get_date_list ( self , queryset , date_type ) : date_field = self . get_date_field ( ) allow_empty = self . get_allow_empty ( ) date_list = queryset . dates ( date_field , date_type ) [ : : - 1 ] if date_list is not None and not date_list and not allow_empty : name = force_unicode ( queryset . model . _meta . verbose_name_plural ) raise Http404 ( _ ( u"No %(verbose_name_plural)s available" ) % { 'verbose_name_plural' : name } ) return date_list def get_context_data ( self , ** kwargs ) : items = kwargs . pop ( 'object_list' ) context = super ( BaseDateListView , self ) . get_context_data ( object_list = items ) context . update ( kwargs ) return context class BaseArchiveIndexView ( BaseDateListView ) : context_object_name = 'latest' def get_dated_items ( self ) : qs = self . get_dated_queryset ( ) date_list = self . get_date_list ( qs , 'year' ) if date_list : object_list = qs . order_by ( '-' + self . get_date_field ( ) ) else : object_list = qs . none ( ) return ( date_list , object_list , { } ) class ArchiveIndexView ( MultipleObjectTemplateResponseMixin , BaseArchiveIndexView ) : template_name_suffix = '_archive' class BaseYearArchiveView ( YearMixin , BaseDateListView ) : make_object_list = False def get_dated_items ( self ) : year = self . get_year ( ) date_field = self . get_date_field ( ) qs = self . get_dated_queryset ( ** { date_field + '__year' : year } ) date_list = self . get_date_list ( qs , 'month' ) if self . get_make_object_list ( ) : object_list = qs . order_by ( '-' + date_field ) else : object_list = qs . none ( ) return ( date_list , object_list , { 'year' : year } ) def get_make_object_list ( self ) : return self . make_object_list class YearArchiveView ( MultipleObjectTemplateResponseMixin , BaseYearArchiveView ) : template_name_suffix = '_archive_year' class BaseMonthArchiveView ( YearMixin , MonthMixin , BaseDateListView ) : def get_dated_items ( self ) : year = self . get_year ( ) month = self . get_month ( ) date_field = self . get_date_field ( ) date = _date_from_string ( year , self . get_year_format ( ) , month , self . get_month_format ( ) ) first_day , last_day = _month_bounds ( date ) lookup_kwargs = { % date_field : first_day , % date_field : last_day , } qs = self . get_dated_queryset ( ** lookup_kwargs ) date_list = self . get_date_list ( qs , 'day' ) return ( date_list , qs , { : date , : self . get_next_month ( date ) , : self . get_previous_month ( date ) , } ) class MonthArchiveView ( MultipleObjectTemplateResponseMixin , BaseMonthArchiveView ) : template_name_suffix = '_archive_month' class BaseWeekArchiveView ( YearMixin , WeekMixin , BaseDateListView ) : def get_dated_items ( self ) : year = self . get_year ( ) week = self . get_week ( ) date_field = self . get_date_field ( ) week_format = self . get_week_format ( ) week_start = { : '1' , : '0' , } [ week_format ] date = _date_from_string ( year , self . get_year_format ( ) , week_start , '%w' , week , week_format ) first_day = date last_day = date + datetime . timedelta ( days = 7 ) lookup_kwargs = { % date_field : first_day , % date_field : last_day , } qs = self . get_dated_queryset ( ** lookup_kwargs ) return ( None , qs , { 'week' : date } ) class WeekArchiveView ( MultipleObjectTemplateResponseMixin , BaseWeekArchiveView ) : template_name_suffix = '_archive_week' class BaseDayArchiveView ( YearMixin , MonthMixin , DayMixin , BaseDateListView ) : def get_dated_items ( self ) : year = self . get_year ( ) month = self . get_month ( ) day = self . get_day ( ) date = _date_from_string ( year , self . get_year_format ( ) , month , self . get_month_format ( ) , day , self . get_day_format ( ) ) return self . _get_dated_items ( date ) def _get_dated_items ( self , date ) : date_field = self . get_date_field ( ) field = self . get_queryset ( ) . model . _meta . get_field ( date_field ) lookup_kwargs = _date_lookup_for_field ( field , date ) qs = self . get_dated_queryset ( ** lookup_kwargs ) return ( None , qs , { : date , : self . get_previous_day ( date ) , : self . get_next_day ( date ) , : self . get_previous_month ( date ) , : self . get_next_month ( date ) } ) class DayArchiveView ( MultipleObjectTemplateResponseMixin , BaseDayArchiveView ) : template_name_suffix = "_archive_day" class BaseTodayArchiveView ( BaseDayArchiveView ) : def get_dated_items ( self ) : return self . _get_dated_items ( datetime . date . today ( ) ) class TodayArchiveView ( MultipleObjectTemplateResponseMixin , BaseTodayArchiveView ) : template_name_suffix = "_archive_day" class BaseDateDetailView ( YearMixin , MonthMixin , DayMixin , DateMixin , BaseDetailView ) : def get_object ( self , queryset = None ) : year = self . get_year ( ) month = self . get_month ( ) day = self . get_day ( ) date = _date_from_string ( year , self . get_year_format ( ) , month , self . get_month_format ( ) , day , self . get_day_format ( ) ) qs = queryset or self . get_queryset ( ) if not self . get_allow_future ( ) and date > datetime . date . today ( ) : raise Http404 ( _ ( u"Future %(verbose_name_plural)s not available because %(class_name)s.allow_future is False." ) % { : qs . model . _meta . verbose_name_plural , : self . __class__ . __name__ , } ) date_field = self . get_date_field ( ) field = qs . model . _meta . get_field ( date_field ) lookup = _date_lookup_for_field ( field , date ) qs = qs . filter ( ** lookup ) return super ( BaseDetailView , self ) . get_object ( queryset = qs ) class DateDetailView ( SingleObjectTemplateResponseMixin , BaseDateDetailView ) : template_name_suffix = '_detail' def _date_from_string ( year , year_format , month , month_format , day = '' , day_format = '' , delim = '__' ) : format = delim . join ( ( year_format , month_format , day_format ) ) datestr = delim . join ( ( year , month , day ) ) try : return datetime . datetime . strptime ( datestr , format ) . date ( ) except ValueError : raise Http404 ( _ ( u"Invalid date string '%(datestr)s' given format '%(format)s'" ) % { : datestr , : format , } ) def _month_bounds ( date ) : first_day = date . replace ( day = 1 ) if first_day . month == 12 : last_day = first_day . replace ( year = first_day . year + 1 , month = 1 ) else : last_day = first_day . replace ( month = first_day . month + 1 ) return first_day , last_day def _get_next_prev_month ( generic_view , naive_result , is_previous , use_first_day ) : date_field = generic_view . get_date_field ( ) allow_empty = generic_view . get_allow_empty ( ) allow_future = generic_view . get_allow_future ( ) if allow_empty : result = naive_result else : if is_previous : lookup = { '%s__lte' % date_field : naive_result } ordering = '-%s' % date_field else : lookup = { '%s__gte' % date_field : naive_result } ordering = date_field qs = generic_view . get_queryset ( ) . filter ( ** lookup ) . order_by ( ordering ) try : result = getattr ( qs [ 0 ] , date_field ) except IndexError : result = None if hasattr ( result , 'date' ) : result = result . date ( ) if result and use_first_day : result = result . replace ( day = 1 ) if result and ( allow_future or result < datetime . date . today ( ) ) : return result else : return None def _date_lookup_for_field ( field , date ) : if isinstance ( field , models . DateTimeField ) : date_range = ( datetime . datetime . combine ( date , datetime . time . min ) , datetime . datetime . combine ( date , datetime . time . max ) ) return { '%s__range' % field . name : date_range } else : return { field . name : date }

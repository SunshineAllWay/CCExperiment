"""JsLex: a lexer for Javascript""" import re class Tok ( object ) : num = 0 def __init__ ( self , name , regex , next = None ) : self . id = Tok . num Tok . num += 1 self . name = name self . regex = regex self . next = next def literals ( choices , prefix = "" , suffix = "" ) : return "|" . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) ) class Lexer ( object ) : def __init__ ( self , states , first ) : self . regexes = { } self . toks = { } for state , rules in states . items ( ) : parts = [ ] for tok in rules : groupid = "t%d" % tok . id self . toks [ groupid ] = tok parts . append ( "(?P<%s>%s)" % ( groupid , tok . regex ) ) self . regexes [ state ] = re . compile ( "|" . join ( parts ) , re . MULTILINE | re . VERBOSE ) self . state = first def lex ( self , text ) : end = len ( text ) state = self . state regexes = self . regexes toks = self . toks start = 0 while start < end : for match in regexes [ state ] . finditer ( text , start ) : name = match . lastgroup tok = toks [ name ] toktext = match . group ( name ) start += len ( toktext ) yield ( tok . name , toktext ) if tok . next : state = tok . next break self . state = state class JsLexer ( Lexer ) : both_before = [ Tok ( "comment" , r"/\*(.|\n)*?\*/" ) , Tok ( "linecomment" , r"//.*?$" ) , Tok ( "ws" , r"\s+" ) , Tok ( "keyword" , literals ( """ break case catch class const continue debugger default delete do else enum export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with """ , suffix = r"\b" ) , next = 'reg' ) , Tok ( "reserved" , literals ( "null true false" , suffix = r"\b" ) , next = 'div' ) , Tok ( "id" , r""" ([a-zA-Z_$ ]|\\u[0-9a-fA-Z]{4}) # first char ([a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})* # rest chars """ , next = 'div' ) , Tok ( "hnum" , r"0[xX][0-9a-fA-F]+" , next = 'div' ) , Tok ( "onum" , r"0[0-7]+" ) , Tok ( "dnum" , r""" ( (0|[1-9][0-9]*) # DecimalIntegerLiteral \. # dot [0-9]* # DecimalDigits-opt ([eE][-+]?[0-9]+)? # ExponentPart-opt | \. # dot [0-9]+ # DecimalDigits ([eE][-+]?[0-9]+)? # ExponentPart-opt | (0|[1-9][0-9]*) # DecimalIntegerLiteral ([eE][-+]?[0-9]+)? # ExponentPart-opt ) """ , next = 'div' ) , Tok ( "punct" , literals ( """ >>>= === !== >>> <<= >>= <= >= == != << >> && || += -= *= %= &= |= ^= """ ) , next = "reg" ) , Tok ( "punct" , literals ( "++ -- ) ]" ) , next = 'div' ) , Tok ( "punct" , literals ( "{ } ( [ . ; , < > + - * % & | ^ ! ~ ? : =" ) , next = 'reg' ) , Tok ( "string" , r'"([^"\\]|(\\(.|\n)))*?"' , next = 'div' ) , Tok ( "string" , r"'([^'\\]|(\\(.|\n)))*?'" , next = 'div' ) , ] both_after = [ Tok ( "other" , r"." ) , ] states = { : both_before + [ Tok ( "punct" , literals ( "/= /" ) , next = 'reg' ) , ] + both_after , : both_before + [ Tok ( "regex" , , next = 'div' ) , ] + both_after , } def __init__ ( self ) : super ( JsLexer , self ) . __init__ ( self . states , 'reg' ) def prepare_js_for_gettext ( js ) : def escape_quotes ( m ) : s = m . group ( 0 ) if s == '"' : return r'\"' else : return s lexer = JsLexer ( ) c = [ ] for name , tok in lexer . lex ( js ) : if name == 'regex' : tok = '"REGEX"' ; elif name == 'string' : if tok . startswith ( "'" ) : guts = re . sub ( r"\\.|." , escape_quotes , tok [ 1 : - 1 ] ) tok = '"' + guts + '"' elif name == 'id' : tok = tok . replace ( "\\" , "U" ) ; c . append ( tok ) return '' . join ( c )

""" This module converts requested URLs to callback view functions. RegexURLResolver is the main class here. Its resolve() method takes a URL (as a string) and returns a tuple in this format: (view_function, function_args, function_kwargs) """ import re from threading import local from django . http import Http404 from django . core . exceptions import ImproperlyConfigured , ViewDoesNotExist from django . utils . datastructures import MultiValueDict from django . utils . encoding import iri_to_uri , force_unicode , smart_str from django . utils . functional import memoize , lazy from django . utils . importlib import import_module from django . utils . module_loading import module_has_submodule from django . utils . regex_helper import normalize from django . utils . translation import get_language _resolver_cache = { } _ns_resolver_cache = { } _callable_cache = { } _prefixes = local ( ) _urlconfs = local ( ) class ResolverMatch ( object ) : def __init__ ( self , func , args , kwargs , url_name = None , app_name = None , namespaces = None ) : self . func = func self . args = args self . kwargs = kwargs self . app_name = app_name if namespaces : self . namespaces = [ x for x in namespaces if x ] else : self . namespaces = [ ] if not url_name : if not hasattr ( func , '__name__' ) : url_name = '.' . join ( [ func . __class__ . __module__ , func . __class__ . __name__ ] ) else : url_name = '.' . join ( [ func . __module__ , func . __name__ ] ) self . url_name = url_name @ property def namespace ( self ) : return ':' . join ( self . namespaces ) @ property def view_name ( self ) : return ':' . join ( [ x for x in [ self . namespace , self . url_name ] if x ] ) def __getitem__ ( self , index ) : return ( self . func , self . args , self . kwargs ) [ index ] def __repr__ ( self ) : return "ResolverMatch(func=%s, args=%s, kwargs=%s, url_name='%s', app_name='%s', namespace='%s')" % ( self . func , self . args , self . kwargs , self . url_name , self . app_name , self . namespace ) class Resolver404 ( Http404 ) : pass class NoReverseMatch ( Exception ) : silent_variable_failure = True def get_callable ( lookup_view , can_fail = False ) : if not callable ( lookup_view ) : mod_name , func_name = get_mod_func ( lookup_view ) try : if func_name != '' : lookup_view = getattr ( import_module ( mod_name ) , func_name ) if not callable ( lookup_view ) : raise ViewDoesNotExist ( % ( mod_name , func_name ) ) except AttributeError : if not can_fail : raise ViewDoesNotExist ( % ( lookup_view , mod_name ) ) except ImportError : parentmod , submod = get_mod_func ( mod_name ) if ( not can_fail and submod != '' and not module_has_submodule ( import_module ( parentmod ) , submod ) ) : raise ViewDoesNotExist ( % ( lookup_view , mod_name ) ) if not can_fail : raise return lookup_view get_callable = memoize ( get_callable , _callable_cache , 1 ) def get_resolver ( urlconf ) : if urlconf is None : from django . conf import settings urlconf = settings . ROOT_URLCONF return RegexURLResolver ( r'^/' , urlconf ) get_resolver = memoize ( get_resolver , _resolver_cache , 1 ) def get_ns_resolver ( ns_pattern , resolver ) : ns_resolver = RegexURLResolver ( ns_pattern , resolver . url_patterns ) return RegexURLResolver ( r'^/' , [ ns_resolver ] ) get_ns_resolver = memoize ( get_ns_resolver , _ns_resolver_cache , 2 ) def get_mod_func ( callback ) : try : dot = callback . rindex ( '.' ) except ValueError : return callback , '' return callback [ : dot ] , callback [ dot + 1 : ] class LocaleRegexProvider ( object ) : def __init__ ( self , regex ) : self . _regex = regex self . _regex_dict = { } @ property def regex ( self ) : language_code = get_language ( ) if language_code not in self . _regex_dict : if isinstance ( self . _regex , basestring ) : compiled_regex = re . compile ( self . _regex , re . UNICODE ) else : regex = force_unicode ( self . _regex ) compiled_regex = re . compile ( regex , re . UNICODE ) self . _regex_dict [ language_code ] = compiled_regex return self . _regex_dict [ language_code ] class RegexURLPattern ( LocaleRegexProvider ) : def __init__ ( self , regex , callback , default_args = None , name = None ) : LocaleRegexProvider . __init__ ( self , regex ) if callable ( callback ) : self . _callback = callback else : self . _callback = None self . _callback_str = callback self . default_args = default_args or { } self . name = name def __repr__ ( self ) : return smart_str ( u'<%s %s %s>' % ( self . __class__ . __name__ , self . name , self . regex . pattern ) ) def add_prefix ( self , prefix ) : if not prefix or not hasattr ( self , '_callback_str' ) : return self . _callback_str = prefix + '.' + self . _callback_str def resolve ( self , path ) : match = self . regex . search ( path ) if match : kwargs = match . groupdict ( ) if kwargs : args = ( ) else : args = match . groups ( ) kwargs . update ( self . default_args ) return ResolverMatch ( self . callback , args , kwargs , self . name ) @ property def callback ( self ) : if self . _callback is not None : return self . _callback self . _callback = get_callable ( self . _callback_str ) return self . _callback class RegexURLResolver ( LocaleRegexProvider ) : def __init__ ( self , regex , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) : LocaleRegexProvider . __init__ ( self , regex ) self . urlconf_name = urlconf_name if not isinstance ( urlconf_name , basestring ) : self . _urlconf_module = self . urlconf_name self . callback = None self . default_kwargs = default_kwargs or { } self . namespace = namespace self . app_name = app_name self . _reverse_dict = { } self . _namespace_dict = { } self . _app_dict = { } def __repr__ ( self ) : return smart_str ( u'<%s %s (%s:%s) %s>' % ( self . __class__ . __name__ , self . urlconf_name , self . app_name , self . namespace , self . regex . pattern ) ) def _populate ( self ) : lookups = MultiValueDict ( ) namespaces = { } apps = { } language_code = get_language ( ) for pattern in reversed ( self . url_patterns ) : p_pattern = pattern . regex . pattern if p_pattern . startswith ( '^' ) : p_pattern = p_pattern [ 1 : ] if isinstance ( pattern , RegexURLResolver ) : if pattern . namespace : namespaces [ pattern . namespace ] = ( p_pattern , pattern ) if pattern . app_name : apps . setdefault ( pattern . app_name , [ ] ) . append ( pattern . namespace ) else : parent = normalize ( pattern . regex . pattern ) for name in pattern . reverse_dict : for matches , pat , defaults in pattern . reverse_dict . getlist ( name ) : new_matches = [ ] for piece , p_args in parent : new_matches . extend ( [ ( piece + suffix , p_args + args ) for ( suffix , args ) in matches ] ) lookups . appendlist ( name , ( new_matches , p_pattern + pat , dict ( defaults , ** pattern . default_kwargs ) ) ) for namespace , ( prefix , sub_pattern ) in pattern . namespace_dict . items ( ) : namespaces [ namespace ] = ( p_pattern + prefix , sub_pattern ) for app_name , namespace_list in pattern . app_dict . items ( ) : apps . setdefault ( app_name , [ ] ) . extend ( namespace_list ) else : bits = normalize ( p_pattern ) lookups . appendlist ( pattern . callback , ( bits , p_pattern , pattern . default_args ) ) if pattern . name is not None : lookups . appendlist ( pattern . name , ( bits , p_pattern , pattern . default_args ) ) self . _reverse_dict [ language_code ] = lookups self . _namespace_dict [ language_code ] = namespaces self . _app_dict [ language_code ] = apps @ property def reverse_dict ( self ) : language_code = get_language ( ) if language_code not in self . _reverse_dict : self . _populate ( ) return self . _reverse_dict [ language_code ] @ property def namespace_dict ( self ) : language_code = get_language ( ) if language_code not in self . _namespace_dict : self . _populate ( ) return self . _namespace_dict [ language_code ] @ property def app_dict ( self ) : language_code = get_language ( ) if language_code not in self . _app_dict : self . _populate ( ) return self . _app_dict [ language_code ] def resolve ( self , path ) : tried = [ ] match = self . regex . search ( path ) if match : new_path = path [ match . end ( ) : ] for pattern in self . url_patterns : try : sub_match = pattern . resolve ( new_path ) except Resolver404 , e : sub_tried = e . args [ 0 ] . get ( 'tried' ) if sub_tried is not None : tried . extend ( [ [ pattern ] + t for t in sub_tried ] ) else : tried . append ( [ pattern ] ) else : if sub_match : sub_match_dict = dict ( [ ( smart_str ( k ) , v ) for k , v in match . groupdict ( ) . items ( ) ] ) sub_match_dict . update ( self . default_kwargs ) for k , v in sub_match . kwargs . iteritems ( ) : sub_match_dict [ smart_str ( k ) ] = v return ResolverMatch ( sub_match . func , sub_match . args , sub_match_dict , sub_match . url_name , self . app_name or sub_match . app_name , [ self . namespace ] + sub_match . namespaces ) tried . append ( [ pattern ] ) raise Resolver404 ( { 'tried' : tried , 'path' : new_path } ) raise Resolver404 ( { 'path' : path } ) @ property def urlconf_module ( self ) : try : return self . _urlconf_module except AttributeError : self . _urlconf_module = import_module ( self . urlconf_name ) return self . _urlconf_module @ property def url_patterns ( self ) : patterns = getattr ( self . urlconf_module , "urlpatterns" , self . urlconf_module ) try : iter ( patterns ) except TypeError : raise ImproperlyConfigured ( "The included urlconf %s doesn't have any patterns in it" % self . urlconf_name ) return patterns def _resolve_special ( self , view_type ) : callback = getattr ( self . urlconf_module , 'handler%s' % view_type , None ) if not callback : from django . conf import urls callback = getattr ( urls , 'handler%s' % view_type ) return get_callable ( callback ) , { } def resolve403 ( self ) : return self . _resolve_special ( '403' ) def resolve404 ( self ) : return self . _resolve_special ( '404' ) def resolve500 ( self ) : return self . _resolve_special ( '500' ) def reverse ( self , lookup_view , * args , ** kwargs ) : return self . _reverse_with_prefix ( lookup_view , '' , * args , ** kwargs ) def _reverse_with_prefix ( self , lookup_view , _prefix , * args , ** kwargs ) : if args and kwargs : raise ValueError ( "Don't mix *args and **kwargs in call to reverse()!" ) try : lookup_view = get_callable ( lookup_view , True ) except ( ImportError , AttributeError ) , e : raise NoReverseMatch ( "Error importing '%s': %s." % ( lookup_view , e ) ) possibilities = self . reverse_dict . getlist ( lookup_view ) prefix_norm , prefix_args = normalize ( _prefix ) [ 0 ] for possibility , pattern , defaults in possibilities : for result , params in possibility : if args : if len ( args ) != len ( params ) + len ( prefix_args ) : continue unicode_args = [ force_unicode ( val ) for val in args ] candidate = ( prefix_norm + result ) % dict ( zip ( prefix_args + params , unicode_args ) ) else : if set ( kwargs . keys ( ) + defaults . keys ( ) ) != set ( params + defaults . keys ( ) + prefix_args ) : continue matches = True for k , v in defaults . items ( ) : if kwargs . get ( k , v ) != v : matches = False break if not matches : continue unicode_kwargs = dict ( [ ( k , force_unicode ( v ) ) for ( k , v ) in kwargs . items ( ) ] ) candidate = ( prefix_norm + result ) % unicode_kwargs if re . search ( u'^%s%s' % ( _prefix , pattern ) , candidate , re . UNICODE ) : return candidate m = getattr ( lookup_view , '__module__' , None ) n = getattr ( lookup_view , '__name__' , None ) if m is not None and n is not None : lookup_view_s = "%s.%s" % ( m , n ) else : lookup_view_s = lookup_view raise NoReverseMatch ( "Reverse for '%s' with arguments '%s' and keyword " % ( lookup_view_s , args , kwargs ) ) class LocaleRegexURLResolver ( RegexURLResolver ) : def __init__ ( self , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) : super ( LocaleRegexURLResolver , self ) . __init__ ( None , urlconf_name , default_kwargs , app_name , namespace ) @ property def regex ( self ) : language_code = get_language ( ) if language_code not in self . _regex_dict : regex_compiled = re . compile ( '^%s/' % language_code , re . UNICODE ) self . _regex_dict [ language_code ] = regex_compiled return self . _regex_dict [ language_code ] def resolve ( path , urlconf = None ) : if urlconf is None : urlconf = get_urlconf ( ) return get_resolver ( urlconf ) . resolve ( path ) def reverse ( viewname , urlconf = None , args = None , kwargs = None , prefix = None , current_app = None ) : if urlconf is None : urlconf = get_urlconf ( ) resolver = get_resolver ( urlconf ) args = args or [ ] kwargs = kwargs or { } if prefix is None : prefix = get_script_prefix ( ) if not isinstance ( viewname , basestring ) : view = viewname else : parts = viewname . split ( ':' ) parts . reverse ( ) view = parts [ 0 ] path = parts [ 1 : ] resolved_path = [ ] ns_pattern = '' while path : ns = path . pop ( ) try : app_list = resolver . app_dict [ ns ] if current_app and current_app in app_list : ns = current_app elif ns not in app_list : ns = app_list [ 0 ] except KeyError : pass try : extra , resolver = resolver . namespace_dict [ ns ] resolved_path . append ( ns ) ns_pattern = ns_pattern + extra except KeyError , key : if resolved_path : raise NoReverseMatch ( % ( key , ':' . join ( resolved_path ) ) ) else : raise NoReverseMatch ( "%s is not a registered namespace" % key ) if ns_pattern : resolver = get_ns_resolver ( ns_pattern , resolver ) return iri_to_uri ( resolver . _reverse_with_prefix ( view , prefix , * args , ** kwargs ) ) reverse_lazy = lazy ( reverse , str ) def clear_url_caches ( ) : global _resolver_cache global _ns_resolver_cache global _callable_cache _resolver_cache . clear ( ) _ns_resolver_cache . clear ( ) _callable_cache . clear ( ) def set_script_prefix ( prefix ) : if not prefix . endswith ( '/' ) : prefix += '/' _prefixes . value = prefix def get_script_prefix ( ) : return getattr ( _prefixes , "value" , u'/' ) def set_urlconf ( urlconf_name ) : if urlconf_name : _urlconfs . value = urlconf_name else : if hasattr ( _urlconfs , "value" ) : del _urlconfs . value def get_urlconf ( default = None ) : return getattr ( _urlconfs , "value" , default )

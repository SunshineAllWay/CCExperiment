import re from decimal import Decimal from django . contrib . gis . db . backends . base import BaseSpatialOperations from django . contrib . gis . db . backends . util import SpatialOperation , SpatialFunction from django . contrib . gis . db . backends . spatialite . adapter import SpatiaLiteAdapter from django . contrib . gis . geometry . backend import Geometry from django . contrib . gis . measure import Distance from django . core . exceptions import ImproperlyConfigured from django . db . backends . sqlite3 . base import DatabaseOperations from django . db . utils import DatabaseError class SpatiaLiteOperator ( SpatialOperation ) : def __init__ ( self , operator ) : super ( SpatiaLiteOperator , self ) . __init__ ( operator = operator ) class SpatiaLiteFunction ( SpatialFunction ) : def __init__ ( self , function , ** kwargs ) : super ( SpatiaLiteFunction , self ) . __init__ ( function , ** kwargs ) class SpatiaLiteFunctionParam ( SpatiaLiteFunction ) : sql_template = '%(function)s(%(geo_col)s, %(geometry)s, %%s)' class SpatiaLiteDistance ( SpatiaLiteFunction ) : dist_func = 'Distance' sql_template = '%(function)s(%(geo_col)s, %(geometry)s) %(operator)s %%s' def __init__ ( self , operator ) : super ( SpatiaLiteDistance , self ) . __init__ ( self . dist_func , operator = operator ) class SpatiaLiteRelate ( SpatiaLiteFunctionParam ) : pattern_regex = re . compile ( r'^[012TF\*]{9}$' ) def __init__ ( self , pattern ) : if not self . pattern_regex . match ( pattern ) : raise ValueError ( 'Invalid intersection matrix pattern "%s".' % pattern ) super ( SpatiaLiteRelate , self ) . __init__ ( 'Relate' ) dtypes = ( Decimal , Distance , float , int , long ) def get_dist_ops ( operator ) : return ( SpatiaLiteDistance ( operator ) , ) class SpatiaLiteOperations ( DatabaseOperations , BaseSpatialOperations ) : compiler_module = 'django.contrib.gis.db.models.sql.compiler' name = 'spatialite' spatialite = True version_regex = re . compile ( r'^(?P<major>\d)\.(?P<minor1>\d)\.(?P<minor2>\d+)' ) valid_aggregates = dict ( [ ( k , None ) for k in ( 'Extent' , 'Union' ) ] ) Adapter = SpatiaLiteAdapter Adaptor = Adapter area = 'Area' centroid = 'Centroid' contained = 'MbrWithin' difference = 'Difference' distance = 'Distance' envelope = 'Envelope' intersection = 'Intersection' length = 'GLength' num_geom = 'NumGeometries' num_points = 'NumPoints' point_on_surface = 'PointOnSurface' scale = 'ScaleCoords' svg = 'AsSVG' sym_difference = 'SymDifference' transform = 'Transform' translate = 'ShiftCoords' union = 'GUnion' unionagg = 'GUnion' from_text = 'GeomFromText' from_wkb = 'GeomFromWKB' select = 'AsText(%s)' geometry_functions = { : SpatiaLiteFunction ( 'Equals' ) , : SpatiaLiteFunction ( 'Disjoint' ) , : SpatiaLiteFunction ( 'Touches' ) , : SpatiaLiteFunction ( 'Crosses' ) , : SpatiaLiteFunction ( 'Within' ) , : SpatiaLiteFunction ( 'Overlaps' ) , : SpatiaLiteFunction ( 'Contains' ) , : SpatiaLiteFunction ( 'Intersects' ) , : ( SpatiaLiteRelate , basestring ) , : SpatiaLiteFunction ( 'MbrWithin' ) , : SpatiaLiteFunction ( 'MbrContains' ) , : SpatiaLiteFunction ( 'MbrOverlaps' ) , : SpatiaLiteFunction ( 'Equals' ) , : SpatiaLiteFunction ( 'Equals' ) , } distance_functions = { : ( get_dist_ops ( '>' ) , dtypes ) , : ( get_dist_ops ( '>=' ) , dtypes ) , : ( get_dist_ops ( '<' ) , dtypes ) , : ( get_dist_ops ( '<=' ) , dtypes ) , } geometry_functions . update ( distance_functions ) def __init__ ( self , connection ) : super ( DatabaseOperations , self ) . __init__ ( connection ) try : vtup = self . spatialite_version_tuple ( ) version = vtup [ 1 : ] if version < ( 2 , 3 , 0 ) : raise ImproperlyConfigured ( 'GeoDjango only supports SpatiaLite versions ' ) self . spatial_version = version except ImproperlyConfigured : raise except Exception , msg : raise ImproperlyConfigured ( 'Cannot determine the SpatiaLite version for the "%s" ' % ( self . connection . settings_dict [ 'NAME' ] , msg ) ) gis_terms = [ 'isnull' ] gis_terms += self . geometry_functions . keys ( ) self . gis_terms = dict ( [ ( term , None ) for term in gis_terms ] ) if version >= ( 2 , 4 , 0 ) : try : self . _get_spatialite_func ( "AsGML(GeomFromText('POINT(1 1)'))" ) self . gml = 'AsGML' self . kml = 'AsKML' except DatabaseError : pass def check_aggregate_support ( self , aggregate ) : agg_name = aggregate . __class__ . __name__ return agg_name in self . valid_aggregates def convert_geom ( self , wkt , geo_field ) : if wkt : return Geometry ( wkt , geo_field . srid ) else : return None def geo_db_type ( self , f ) : return None def get_distance ( self , f , value , lookup_type ) : if not value : return [ ] value = value [ 0 ] if isinstance ( value , Distance ) : if f . geodetic ( self . connection ) : raise ValueError ( 'SpatiaLite does not support distance queries on ' ) else : dist_param = getattr ( value , Distance . unit_attname ( f . units_name ( self . connection ) ) ) else : dist_param = value return [ dist_param ] def get_geom_placeholder ( self , f , value ) : def transform_value ( value , srid ) : return not ( value is None or value . srid == srid ) if hasattr ( value , 'expression' ) : if transform_value ( value , f . srid ) : placeholder = '%s(%%s, %s)' % ( self . transform , f . srid ) else : placeholder = '%s' return placeholder % '%s.%s' % tuple ( map ( self . quote_name , value . cols [ value . expression ] ) ) else : if transform_value ( value , f . srid ) : return '%s(%s(%%s,%s), %s)' % ( self . transform , self . from_text , value . srid , f . srid ) else : return '%s(%%s,%s)' % ( self . from_text , f . srid ) def _get_spatialite_func ( self , func ) : cursor = self . connection . _cursor ( ) try : try : cursor . execute ( 'SELECT %s' % func ) row = cursor . fetchone ( ) except : raise finally : cursor . close ( ) return row [ 0 ] def geos_version ( self ) : return self . _get_spatialite_func ( 'geos_version()' ) def proj4_version ( self ) : return self . _get_spatialite_func ( 'proj4_version()' ) def spatialite_version ( self ) : return self . _get_spatialite_func ( 'spatialite_version()' ) def spatialite_version_tuple ( self ) : try : version = self . spatialite_version ( ) except DatabaseError : version = None try : tmp = self . _get_spatialite_func ( "X(GeomFromText('POINT(1 1)'))" ) if tmp == 1.0 : version = '2.3.0' except DatabaseError : pass if version is None : raise m = self . version_regex . match ( version ) if m : major = int ( m . group ( 'major' ) ) minor1 = int ( m . group ( 'minor1' ) ) minor2 = int ( m . group ( 'minor2' ) ) else : raise Exception ( 'Could not parse SpatiaLite version string: %s' % version ) return ( version , major , minor1 , minor2 ) def spatial_aggregate_sql ( self , agg ) : agg_name = agg . __class__ . __name__ if not self . check_aggregate_support ( agg ) : raise NotImplementedError ( '%s spatial aggregate is not implmented for this backend.' % agg_name ) agg_name = agg_name . lower ( ) if agg_name == 'union' : agg_name += 'agg' sql_template = self . select % '%(function)s(%(field)s)' sql_function = getattr ( self , agg_name ) return sql_template , sql_function def spatial_lookup_sql ( self , lvalue , lookup_type , value , field , qn ) : alias , col , db_type = lvalue geo_col = '%s.%s' % ( qn ( alias ) , qn ( col ) ) if lookup_type in self . geometry_functions : tmp = self . geometry_functions [ lookup_type ] if isinstance ( tmp , tuple ) : op , arg_type = tmp if not isinstance ( value , ( tuple , list ) ) : raise ValueError ( 'Tuple required for `%s` lookup type.' % lookup_type ) geom = value [ 0 ] if len ( value ) != 2 : raise ValueError ( 'Incorrect number of parameters given for `%s` lookup type.' % lookup_type ) if not isinstance ( value [ 1 ] , arg_type ) : raise ValueError ( 'Argument type should be %s, got %s instead.' % ( arg_type , type ( value [ 1 ] ) ) ) if lookup_type == 'relate' : op = op ( value [ 1 ] ) elif lookup_type in self . distance_functions : op = op [ 0 ] else : op = tmp geom = value return op . as_sql ( geo_col , self . get_geom_placeholder ( field , geom ) ) elif lookup_type == 'isnull' : return "%s IS %sNULL" % ( geo_col , ( not value and 'NOT ' or '' ) ) raise TypeError ( "Got invalid lookup_type: %s" % repr ( lookup_type ) ) def geometry_columns ( self ) : from django . contrib . gis . db . backends . spatialite . models import GeometryColumns return GeometryColumns def spatial_ref_sys ( self ) : from django . contrib . gis . db . backends . spatialite . models import SpatialRefSys return SpatialRefSys

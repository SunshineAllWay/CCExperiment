""" Decorators for views based on HTTP headers. """ from calendar import timegm from functools import wraps from django . utils . decorators import decorator_from_middleware , available_attrs from django . utils . http import http_date , parse_http_date_safe , parse_etags , quote_etag from django . utils . log import getLogger from django . middleware . http import ConditionalGetMiddleware from django . http import HttpResponseNotAllowed , HttpResponseNotModified , HttpResponse conditional_page = decorator_from_middleware ( ConditionalGetMiddleware ) logger = getLogger ( 'django.request' ) def require_http_methods ( request_method_list ) : def decorator ( func ) : @ wraps ( func , assigned = available_attrs ( func ) ) def inner ( request , * args , ** kwargs ) : if request . method not in request_method_list : logger . warning ( 'Method Not Allowed (%s): %s' , request . method , request . path , extra = { : 405 , : request } ) return HttpResponseNotAllowed ( request_method_list ) return func ( request , * args , ** kwargs ) return inner return decorator require_GET = require_http_methods ( [ "GET" ] ) require_GET . __doc__ = "Decorator to require that a view only accept the GET method." require_POST = require_http_methods ( [ "POST" ] ) require_POST . __doc__ = "Decorator to require that a view only accept the POST method." require_safe = require_http_methods ( [ "GET" , "HEAD" ] ) require_safe . __doc__ = "Decorator to require that a view only accept safe methods: GET and HEAD." def condition ( etag_func = None , last_modified_func = None ) : def decorator ( func ) : @ wraps ( func , assigned = available_attrs ( func ) ) def inner ( request , * args , ** kwargs ) : if_modified_since = request . META . get ( "HTTP_IF_MODIFIED_SINCE" ) if if_modified_since : if_modified_since = parse_http_date_safe ( if_modified_since ) if_none_match = request . META . get ( "HTTP_IF_NONE_MATCH" ) if_match = request . META . get ( "HTTP_IF_MATCH" ) if if_none_match or if_match : try : etags = parse_etags ( if_none_match or if_match ) except ValueError : if_none_match = None if_match = None if etag_func : res_etag = etag_func ( request , * args , ** kwargs ) else : res_etag = None if last_modified_func : dt = last_modified_func ( request , * args , ** kwargs ) if dt : res_last_modified = timegm ( dt . utctimetuple ( ) ) else : res_last_modified = None else : res_last_modified = None response = None if not ( ( if_match and ( if_modified_since or if_none_match ) ) or ( if_match and if_none_match ) ) : if ( ( if_none_match and ( res_etag in etags or in etags and res_etag ) ) and ( not if_modified_since or ( res_last_modified and if_modified_since and res_last_modified <= if_modified_since ) ) ) : if request . method in ( "GET" , "HEAD" ) : response = HttpResponseNotModified ( ) else : logger . warning ( 'Precondition Failed: %s' , request . path , extra = { : 412 , : request } ) response = HttpResponse ( status = 412 ) elif if_match and ( ( not res_etag and "*" in etags ) or ( res_etag and res_etag not in etags ) ) : logger . warning ( 'Precondition Failed: %s' , request . path , extra = { : 412 , : request } ) response = HttpResponse ( status = 412 ) elif ( not if_none_match and request . method == "GET" and res_last_modified and if_modified_since and res_last_modified <= if_modified_since ) : response = HttpResponseNotModified ( ) if response is None : response = func ( request , * args , ** kwargs ) if res_last_modified and not response . has_header ( 'Last-Modified' ) : response [ 'Last-Modified' ] = http_date ( res_last_modified ) if res_etag and not response . has_header ( 'ETag' ) : response [ 'ETag' ] = quote_etag ( res_etag ) return response return inner return decorator def etag ( etag_func ) : return condition ( etag_func = etag_func ) def last_modified ( last_modified_func ) : return condition ( last_modified_func = last_modified_func )

""" This module contains a base type which provides list-style mutations without specific data storage methods. See also http://www.aryehleib.com/MutableLists.html Author: Aryeh Leib Taurog. """ class ListMixin ( object ) : _minlength = 0 _maxlength = None _IndexError = IndexError def __init__ ( self , * args , ** kwargs ) : if not hasattr ( self , '_get_single_internal' ) : self . _get_single_internal = self . _get_single_external if not hasattr ( self , '_set_single' ) : self . _set_single = self . _set_single_rebuild self . _assign_extended_slice = self . _assign_extended_slice_rebuild super ( ListMixin , self ) . __init__ ( * args , ** kwargs ) def __getitem__ ( self , index ) : if isinstance ( index , slice ) : return [ self . _get_single_external ( i ) for i in xrange ( * index . indices ( len ( self ) ) ) ] else : index = self . _checkindex ( index ) return self . _get_single_external ( index ) def __delitem__ ( self , index ) : if not isinstance ( index , ( int , long , slice ) ) : raise TypeError ( "%s is not a legal index" % index ) origLen = len ( self ) if isinstance ( index , ( int , long ) ) : index = self . _checkindex ( index ) indexRange = [ index ] else : indexRange = range ( * index . indices ( origLen ) ) newLen = origLen - len ( indexRange ) newItems = ( self . _get_single_internal ( i ) for i in xrange ( origLen ) if i not in indexRange ) self . _rebuild ( newLen , newItems ) def __setitem__ ( self , index , val ) : if isinstance ( index , slice ) : self . _set_slice ( index , val ) else : index = self . _checkindex ( index ) self . _check_allowed ( ( val , ) ) self . _set_single ( index , val ) def __iter__ ( self ) : for i in xrange ( len ( self ) ) : yield self [ i ] def __add__ ( self , other ) : return self . __class__ ( list ( self ) + list ( other ) ) def __radd__ ( self , other ) : return other . __class__ ( list ( other ) + list ( self ) ) def __iadd__ ( self , other ) : self . extend ( list ( other ) ) return self def __mul__ ( self , n ) : return self . __class__ ( list ( self ) * n ) def __rmul__ ( self , n ) : return self . __class__ ( list ( self ) * n ) def __imul__ ( self , n ) : if n <= 0 : del self [ : ] else : cache = list ( self ) for i in range ( n - 1 ) : self . extend ( cache ) return self def __cmp__ ( self , other ) : slen = len ( self ) for i in range ( slen ) : try : c = cmp ( self [ i ] , other [ i ] ) except IndexError : return 1 else : if c : return c return cmp ( slen , len ( other ) ) def count ( self , val ) : count = 0 for i in self : if val == i : count += 1 return count def index ( self , val ) : for i in xrange ( 0 , len ( self ) ) : if self [ i ] == val : return i raise ValueError ( '%s not found in object' % str ( val ) ) def append ( self , val ) : self [ len ( self ) : ] = [ val ] def extend ( self , vals ) : self [ len ( self ) : ] = vals def insert ( self , index , val ) : if not isinstance ( index , ( int , long ) ) : raise TypeError ( "%s is not a legal index" % index ) self [ index : index ] = [ val ] def pop ( self , index = - 1 ) : result = self [ index ] del self [ index ] return result def remove ( self , val ) : del self [ self . index ( val ) ] def reverse ( self ) : self [ : ] = self [ - 1 : : - 1 ] def sort ( self , cmp = cmp , key = None , reverse = False ) : if key : temp = [ ( key ( v ) , v ) for v in self ] temp . sort ( cmp = cmp , key = lambda x : x [ 0 ] , reverse = reverse ) self [ : ] = [ v [ 1 ] for v in temp ] else : temp = list ( self ) temp . sort ( cmp = cmp , reverse = reverse ) self [ : ] = temp def _rebuild ( self , newLen , newItems ) : if newLen < self . _minlength : raise ValueError ( 'Must have at least %d items' % self . _minlength ) if self . _maxlength is not None and newLen > self . _maxlength : raise ValueError ( 'Cannot have more than %d items' % self . _maxlength ) self . _set_list ( newLen , newItems ) def _set_single_rebuild ( self , index , value ) : self . _set_slice ( slice ( index , index + 1 , 1 ) , [ value ] ) def _checkindex ( self , index , correct = True ) : length = len ( self ) if 0 <= index < length : return index if correct and - length <= index < 0 : return index + length raise self . _IndexError ( 'invalid index: %s' % str ( index ) ) def _check_allowed ( self , items ) : if hasattr ( self , '_allowed' ) : if False in [ isinstance ( val , self . _allowed ) for val in items ] : raise TypeError ( 'Invalid type encountered in the arguments.' ) def _set_slice ( self , index , values ) : try : iter ( values ) except TypeError : raise TypeError ( 'can only assign an iterable to a slice' ) self . _check_allowed ( values ) origLen = len ( self ) valueList = list ( values ) start , stop , step = index . indices ( origLen ) if index . step is None : self . _assign_simple_slice ( start , stop , valueList ) else : self . _assign_extended_slice ( start , stop , step , valueList ) def _assign_extended_slice_rebuild ( self , start , stop , step , valueList ) : indexList = range ( start , stop , step ) if len ( valueList ) != len ( indexList ) : raise ValueError ( 'attempt to assign sequence of size %d ' % ( len ( valueList ) , len ( indexList ) ) ) newLen = len ( self ) newVals = dict ( zip ( indexList , valueList ) ) def newItems ( ) : for i in xrange ( newLen ) : if i in newVals : yield newVals [ i ] else : yield self . _get_single_internal ( i ) self . _rebuild ( newLen , newItems ( ) ) def _assign_extended_slice ( self , start , stop , step , valueList ) : indexList = range ( start , stop , step ) if len ( valueList ) != len ( indexList ) : raise ValueError ( 'attempt to assign sequence of size %d ' % ( len ( valueList ) , len ( indexList ) ) ) for i , val in zip ( indexList , valueList ) : self . _set_single ( i , val ) def _assign_simple_slice ( self , start , stop , valueList ) : origLen = len ( self ) stop = max ( start , stop ) newLen = origLen - stop + start + len ( valueList ) def newItems ( ) : for i in xrange ( origLen + 1 ) : if i == start : for val in valueList : yield val if i < origLen : if i < start or i >= stop : yield self . _get_single_internal ( i ) self . _rebuild ( newLen , newItems ( ) )

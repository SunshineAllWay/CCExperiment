import urllib import sys import os import re import mimetypes import warnings from copy import copy from urlparse import urlparse , urlsplit try : from cStringIO import StringIO except ImportError : from StringIO import StringIO from django . conf import settings from django . contrib . auth import authenticate , login from django . core . handlers . base import BaseHandler from django . core . handlers . wsgi import WSGIRequest from django . core . signals import got_request_exception from django . http import SimpleCookie , HttpRequest , QueryDict from django . template import TemplateDoesNotExist from django . test import signals from django . utils . functional import curry from django . utils . encoding import smart_str from django . utils . http import urlencode from django . utils . importlib import import_module from django . utils . itercompat import is_iterable from django . db import close_connection from django . test . utils import ContextList __all__ = ( 'Client' , 'RequestFactory' , 'encode_file' , 'encode_multipart' ) BOUNDARY = 'BoUnDaRyStRiNg' MULTIPART_CONTENT = 'multipart/form-data; boundary=%s' % BOUNDARY CONTENT_TYPE_RE = re . compile ( '.*; charset=([\w\d-]+);?' ) class FakePayload ( object ) : def __init__ ( self , content ) : self . __content = StringIO ( content ) self . __len = len ( content ) def read ( self , num_bytes = None ) : if num_bytes is None : num_bytes = self . __len or 0 assert self . __len >= num_bytes , "Cannot read more than the available bytes from the HTTP incoming data." content = self . __content . read ( num_bytes ) self . __len -= num_bytes return content class ClientHandler ( BaseHandler ) : def __init__ ( self , enforce_csrf_checks = True , * args , ** kwargs ) : self . enforce_csrf_checks = enforce_csrf_checks super ( ClientHandler , self ) . __init__ ( * args , ** kwargs ) def __call__ ( self , environ ) : from django . conf import settings from django . core import signals if self . _request_middleware is None : self . load_middleware ( ) signals . request_started . send ( sender = self . __class__ ) try : request = WSGIRequest ( environ ) request . _dont_enforce_csrf_checks = not self . enforce_csrf_checks response = self . get_response ( request ) finally : signals . request_finished . disconnect ( close_connection ) signals . request_finished . send ( sender = self . __class__ ) signals . request_finished . connect ( close_connection ) return response def store_rendered_templates ( store , signal , sender , template , context , ** kwargs ) : store . setdefault ( 'templates' , [ ] ) . append ( template ) store . setdefault ( 'context' , ContextList ( ) ) . append ( copy ( context ) ) def encode_multipart ( boundary , data ) : lines = [ ] to_str = lambda s : smart_str ( s , settings . DEFAULT_CHARSET ) is_file = lambda thing : hasattr ( thing , "read" ) and callable ( thing . read ) for ( key , value ) in data . items ( ) : if is_file ( value ) : lines . extend ( encode_file ( boundary , key , value ) ) elif not isinstance ( value , basestring ) and is_iterable ( value ) : for item in value : if is_file ( item ) : lines . extend ( encode_file ( boundary , key , item ) ) else : lines . extend ( [ + boundary , % to_str ( key ) , , to_str ( item ) ] ) else : lines . extend ( [ + boundary , % to_str ( key ) , , to_str ( value ) ] ) lines . extend ( [ + boundary + '--' , , ] ) return '\r\n' . join ( lines ) def encode_file ( boundary , key , file ) : to_str = lambda s : smart_str ( s , settings . DEFAULT_CHARSET ) content_type = mimetypes . guess_type ( file . name ) [ 0 ] if content_type is None : content_type = 'application/octet-stream' return [ + boundary , % ( to_str ( key ) , to_str ( os . path . basename ( file . name ) ) ) , % content_type , , file . read ( ) ] class RequestFactory ( object ) : def __init__ ( self , ** defaults ) : self . defaults = defaults self . cookies = SimpleCookie ( ) self . errors = StringIO ( ) def _base_environ ( self , ** request ) : environ = { : self . cookies . output ( header = '' , sep = '; ' ) , : '/' , : '127.0.0.1' , : 'GET' , : '' , : 'testserver' , : '80' , : 'HTTP/1.1' , : ( 1 , 0 ) , : 'http' , : FakePayload ( '' ) , : self . errors , : True , : False , : False , } environ . update ( self . defaults ) environ . update ( request ) return environ def request ( self , ** request ) : return WSGIRequest ( self . _base_environ ( ** request ) ) def _encode_data ( self , data , content_type , ) : if content_type is MULTIPART_CONTENT : return encode_multipart ( BOUNDARY , data ) else : match = CONTENT_TYPE_RE . match ( content_type ) if match : charset = match . group ( 1 ) else : charset = settings . DEFAULT_CHARSET return smart_str ( data , encoding = charset ) def _get_path ( self , parsed ) : if parsed [ 3 ] : return urllib . unquote ( parsed [ 2 ] + ";" + parsed [ 3 ] ) else : return urllib . unquote ( parsed [ 2 ] ) def get ( self , path , data = { } , ** extra ) : parsed = urlparse ( path ) r = { : 'text/html; charset=utf-8' , : self . _get_path ( parsed ) , : urlencode ( data , doseq = True ) or parsed [ 4 ] , : 'GET' , } r . update ( extra ) return self . request ( ** r ) def post ( self , path , data = { } , content_type = MULTIPART_CONTENT , ** extra ) : post_data = self . _encode_data ( data , content_type ) parsed = urlparse ( path ) r = { : len ( post_data ) , : content_type , : self . _get_path ( parsed ) , : parsed [ 4 ] , : 'POST' , : FakePayload ( post_data ) , } r . update ( extra ) return self . request ( ** r ) def head ( self , path , data = { } , ** extra ) : parsed = urlparse ( path ) r = { : 'text/html; charset=utf-8' , : self . _get_path ( parsed ) , : urlencode ( data , doseq = True ) or parsed [ 4 ] , : 'HEAD' , } r . update ( extra ) return self . request ( ** r ) def options ( self , path , data = { } , ** extra ) : parsed = urlparse ( path ) r = { : self . _get_path ( parsed ) , : urlencode ( data , doseq = True ) or parsed [ 4 ] , : 'OPTIONS' , } r . update ( extra ) return self . request ( ** r ) def put ( self , path , data = { } , content_type = MULTIPART_CONTENT , ** extra ) : put_data = self . _encode_data ( data , content_type ) parsed = urlparse ( path ) r = { : len ( put_data ) , : content_type , : self . _get_path ( parsed ) , : parsed [ 4 ] , : 'PUT' , : FakePayload ( put_data ) , } r . update ( extra ) return self . request ( ** r ) def delete ( self , path , data = { } , ** extra ) : parsed = urlparse ( path ) r = { : self . _get_path ( parsed ) , : urlencode ( data , doseq = True ) or parsed [ 4 ] , : 'DELETE' , } r . update ( extra ) return self . request ( ** r ) class Client ( RequestFactory ) : def __init__ ( self , enforce_csrf_checks = False , ** defaults ) : super ( Client , self ) . __init__ ( ** defaults ) self . handler = ClientHandler ( enforce_csrf_checks ) self . exc_info = None def store_exc_info ( self , ** kwargs ) : self . exc_info = sys . exc_info ( ) def _session ( self ) : if 'django.contrib.sessions.middleware.SessionMiddleware' in settings . MIDDLEWARE_CLASSES : engine = import_module ( settings . SESSION_ENGINE ) cookie = self . cookies . get ( settings . SESSION_COOKIE_NAME , None ) if cookie : return engine . SessionStore ( cookie . value ) return { } session = property ( _session ) def request ( self , ** request ) : environ = self . _base_environ ( ** request ) data = { } on_template_render = curry ( store_rendered_templates , data ) signals . template_rendered . connect ( on_template_render , dispatch_uid = "template-render" ) got_request_exception . connect ( self . store_exc_info , dispatch_uid = "request-exception" ) try : try : response = self . handler ( environ ) except TemplateDoesNotExist , e : if e . args != ( '500.html' , ) : raise if self . exc_info : exc_info = self . exc_info self . exc_info = None raise exc_info [ 1 ] , None , exc_info [ 2 ] response . client = self response . request = request response . templates = data . get ( "templates" , [ ] ) response . context = data . get ( "context" ) if response . context and len ( response . context ) == 1 : response . context = response . context [ 0 ] def _get_template ( self ) : warnings . warn ( "response.template is deprecated; use response.templates instead (which is always a list)" , DeprecationWarning , stacklevel = 2 ) if not self . templates : return None elif len ( self . templates ) == 1 : return self . templates [ 0 ] return self . templates response . __class__ . template = property ( _get_template ) if response . cookies : self . cookies . update ( response . cookies ) return response finally : signals . template_rendered . disconnect ( dispatch_uid = "template-render" ) got_request_exception . disconnect ( dispatch_uid = "request-exception" ) def get ( self , path , data = { } , follow = False , ** extra ) : response = super ( Client , self ) . get ( path , data = data , ** extra ) if follow : response = self . _handle_redirects ( response , ** extra ) return response def post ( self , path , data = { } , content_type = MULTIPART_CONTENT , follow = False , ** extra ) : response = super ( Client , self ) . post ( path , data = data , content_type = content_type , ** extra ) if follow : response = self . _handle_redirects ( response , ** extra ) return response def head ( self , path , data = { } , follow = False , ** extra ) : response = super ( Client , self ) . head ( path , data = data , ** extra ) if follow : response = self . _handle_redirects ( response , ** extra ) return response def options ( self , path , data = { } , follow = False , ** extra ) : response = super ( Client , self ) . options ( path , data = data , ** extra ) if follow : response = self . _handle_redirects ( response , ** extra ) return response def put ( self , path , data = { } , content_type = MULTIPART_CONTENT , follow = False , ** extra ) : response = super ( Client , self ) . put ( path , data = data , content_type = content_type , ** extra ) if follow : response = self . _handle_redirects ( response , ** extra ) return response def delete ( self , path , data = { } , follow = False , ** extra ) : response = super ( Client , self ) . delete ( path , data = data , ** extra ) if follow : response = self . _handle_redirects ( response , ** extra ) return response def login ( self , ** credentials ) : user = authenticate ( ** credentials ) if user and user . is_active and 'django.contrib.sessions.middleware.SessionMiddleware' in settings . MIDDLEWARE_CLASSES : engine = import_module ( settings . SESSION_ENGINE ) request = HttpRequest ( ) if self . session : request . session = self . session else : request . session = engine . SessionStore ( ) login ( request , user ) request . session . save ( ) session_cookie = settings . SESSION_COOKIE_NAME self . cookies [ session_cookie ] = request . session . session_key cookie_data = { : None , : '/' , : settings . SESSION_COOKIE_DOMAIN , : settings . SESSION_COOKIE_SECURE or None , : None , } self . cookies [ session_cookie ] . update ( cookie_data ) return True else : return False def logout ( self ) : session = import_module ( settings . SESSION_ENGINE ) . SessionStore ( ) session_cookie = self . cookies . get ( settings . SESSION_COOKIE_NAME ) if session_cookie : session . delete ( session_key = session_cookie . value ) self . cookies = SimpleCookie ( ) def _handle_redirects ( self , response , ** extra ) : response . redirect_chain = [ ] while response . status_code in ( 301 , 302 , 303 , 307 ) : url = response [ 'Location' ] redirect_chain = response . redirect_chain redirect_chain . append ( ( url , response . status_code ) ) url = urlsplit ( url ) if url . scheme : extra [ 'wsgi.url_scheme' ] = url . scheme if url . hostname : extra [ 'SERVER_NAME' ] = url . hostname if url . port : extra [ 'SERVER_PORT' ] = str ( url . port ) response = self . get ( url . path , QueryDict ( url . query ) , follow = False , ** extra ) response . redirect_chain = redirect_chain if response . redirect_chain [ - 1 ] in response . redirect_chain [ 0 : - 1 ] : break return response

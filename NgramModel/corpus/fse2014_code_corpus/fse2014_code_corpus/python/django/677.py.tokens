from __future__ import absolute_import from django . core . exceptions import ImproperlyConfigured from django . db import connection , transaction from django . db . transaction import commit_on_success , commit_manually , TransactionManagementError from django . test import TransactionTestCase , skipUnlessDBFeature from django . test . utils import override_settings from django . utils . unittest import skipIf from . models import Mod , M2mA , M2mB class TestTransactionClosing ( TransactionTestCase ) : def test_raw_committed_on_success ( self ) : @ commit_on_success def raw_sql ( ) : cursor = connection . cursor ( ) cursor . execute ( "INSERT into transactions_regress_mod (id,fld) values (17,18)" ) raw_sql ( ) transaction . rollback ( ) try : obj = Mod . objects . get ( pk = 17 ) self . assertEqual ( obj . fld , 18 ) except Mod . DoesNotExist : self . fail ( "transaction with raw sql not committed" ) def test_commit_manually_enforced ( self ) : @ commit_manually def non_comitter ( ) : _ = Mod . objects . count ( ) self . assertRaises ( TransactionManagementError , non_comitter ) def test_commit_manually_commit_ok ( self ) : @ commit_manually def committer ( ) : _ = Mod . objects . count ( ) transaction . commit ( ) try : committer ( ) except TransactionManagementError : self . fail ( "Commit did not clear the transaction state" ) def test_commit_manually_rollback_ok ( self ) : @ commit_manually def roller_back ( ) : _ = Mod . objects . count ( ) transaction . rollback ( ) try : roller_back ( ) except TransactionManagementError : self . fail ( "Rollback did not clear the transaction state" ) def test_commit_manually_enforced_after_commit ( self ) : @ commit_manually def fake_committer ( ) : _ = Mod . objects . count ( ) transaction . commit ( ) _ = Mod . objects . count ( ) self . assertRaises ( TransactionManagementError , fake_committer ) @ skipUnlessDBFeature ( 'supports_transactions' ) def test_reuse_cursor_reference ( self ) : @ commit_on_success def reuse_cursor_ref ( ) : cursor = connection . cursor ( ) cursor . execute ( "INSERT into transactions_regress_mod (id,fld) values (1,2)" ) transaction . rollback ( ) cursor . execute ( "INSERT into transactions_regress_mod (id,fld) values (1,2)" ) reuse_cursor_ref ( ) transaction . rollback ( ) try : obj = Mod . objects . get ( pk = 1 ) self . assertEqual ( obj . fld , 2 ) except Mod . DoesNotExist : self . fail ( "After ending a transaction, cursor use no longer sets dirty" ) def test_failing_query_transaction_closed ( self ) : from django . contrib . auth . models import User @ transaction . commit_on_success def create_system_user ( ) : user = User . objects . create_user ( username = 'system' , password = 'iamr00t' , email = 'root@SITENAME.com' ) Mod . objects . create ( fld = user . id ) create_system_user ( ) try : create_system_user ( ) except : pass else : raise ImproperlyConfigured ( 'Unique constraint not enforced on django.contrib.auth.models.User' ) try : _ = User . objects . all ( ) [ 0 ] except : self . fail ( "A transaction consisting of a failed operation was not closed." ) @ override_settings ( DEBUG = True ) def test_failing_query_transaction_closed_debug ( self ) : self . test_failing_query_transaction_closed ( ) class TestManyToManyAddTransaction ( TransactionTestCase ) : def test_manyrelated_add_commit ( self ) : a = M2mA . objects . create ( ) b = M2mB . objects . create ( fld = 10 ) a . others . add ( b ) transaction . rollback ( ) self . assertEqual ( a . others . count ( ) , 1 ) class SavepointTest ( TransactionTestCase ) : @ skipUnlessDBFeature ( 'uses_savepoints' ) def test_savepoint_commit ( self ) : @ commit_manually def work ( ) : mod = Mod . objects . create ( fld = 1 ) pk = mod . pk sid = transaction . savepoint ( ) mod1 = Mod . objects . filter ( pk = pk ) . update ( fld = 10 ) transaction . savepoint_commit ( sid ) mod2 = Mod . objects . get ( pk = pk ) transaction . commit ( ) self . assertEqual ( mod2 . fld , 10 ) work ( ) @ skipIf ( connection . vendor == 'mysql' and connection . features . _mysql_storage_engine ( ) == 'MyISAM' , ) @ skipUnlessDBFeature ( 'uses_savepoints' ) def test_savepoint_rollback ( self ) : @ commit_manually def work ( ) : mod = Mod . objects . create ( fld = 1 ) pk = mod . pk sid = transaction . savepoint ( ) mod1 = Mod . objects . filter ( pk = pk ) . update ( fld = 20 ) transaction . savepoint_rollback ( sid ) mod2 = Mod . objects . get ( pk = pk ) transaction . commit ( ) self . assertEqual ( mod2 . fld , 1 ) work ( )

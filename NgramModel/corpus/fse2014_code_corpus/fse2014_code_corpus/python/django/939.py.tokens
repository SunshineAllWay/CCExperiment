"""Default tags used by the template system, available to all templates.""" import sys import re from datetime import datetime from itertools import groupby , cycle as itertools_cycle from django . conf import settings from django . template . base import ( Node , NodeList , Template , Library , TemplateSyntaxError , VariableDoesNotExist , InvalidTemplateLibrary , BLOCK_TAG_START , BLOCK_TAG_END , VARIABLE_TAG_START , VARIABLE_TAG_END , SINGLE_BRACE_START , SINGLE_BRACE_END , COMMENT_TAG_START , COMMENT_TAG_END , VARIABLE_ATTRIBUTE_SEPARATOR , get_library , token_kwargs , kwarg_re ) from django . template . smartif import IfParser , Literal from django . template . defaultfilters import date from django . utils . encoding import smart_str , smart_unicode from django . utils . safestring import mark_safe from django . utils import timezone register = Library ( ) class AutoEscapeControlNode ( Node ) : def __init__ ( self , setting , nodelist ) : self . setting , self . nodelist = setting , nodelist def render ( self , context ) : old_setting = context . autoescape context . autoescape = self . setting output = self . nodelist . render ( context ) context . autoescape = old_setting if self . setting : return mark_safe ( output ) else : return output class CommentNode ( Node ) : def render ( self , context ) : return '' class CsrfTokenNode ( Node ) : def render ( self , context ) : csrf_token = context . get ( 'csrf_token' , None ) if csrf_token : if csrf_token == 'NOTPROVIDED' : return mark_safe ( u"" ) else : return mark_safe ( u"<div style='display:none'><input type='hidden' name='csrfmiddlewaretoken' value='%s' /></div>" % csrf_token ) else : from django . conf import settings if settings . DEBUG : import warnings warnings . warn ( "A {% csrf_token %} was used in a template, but the context did not provide the value. This is usually caused by not using RequestContext." ) return u'' class CycleNode ( Node ) : def __init__ ( self , cyclevars , variable_name = None , silent = False ) : self . cyclevars = cyclevars self . variable_name = variable_name self . silent = silent def render ( self , context ) : if self not in context . render_context : context . render_context [ self ] = itertools_cycle ( self . cyclevars ) cycle_iter = context . render_context [ self ] value = cycle_iter . next ( ) . resolve ( context ) if self . variable_name : context [ self . variable_name ] = value if self . silent : return '' return value class DebugNode ( Node ) : def render ( self , context ) : from pprint import pformat output = [ pformat ( val ) for val in context ] output . append ( '\n\n' ) output . append ( pformat ( sys . modules ) ) return '' . join ( output ) class FilterNode ( Node ) : def __init__ ( self , filter_expr , nodelist ) : self . filter_expr , self . nodelist = filter_expr , nodelist def render ( self , context ) : output = self . nodelist . render ( context ) context . update ( { 'var' : output } ) filtered = self . filter_expr . resolve ( context ) context . pop ( ) return filtered class FirstOfNode ( Node ) : def __init__ ( self , vars ) : self . vars = vars def render ( self , context ) : for var in self . vars : value = var . resolve ( context , True ) if value : return smart_unicode ( value ) return u'' class ForNode ( Node ) : child_nodelists = ( 'nodelist_loop' , 'nodelist_empty' ) def __init__ ( self , loopvars , sequence , is_reversed , nodelist_loop , nodelist_empty = None ) : self . loopvars , self . sequence = loopvars , sequence self . is_reversed = is_reversed self . nodelist_loop = nodelist_loop if nodelist_empty is None : self . nodelist_empty = NodeList ( ) else : self . nodelist_empty = nodelist_empty def __repr__ ( self ) : reversed_text = self . is_reversed and ' reversed' or '' return "<For Node: for %s in %s, tail_len: %d%s>" % ( ', ' . join ( self . loopvars ) , self . sequence , len ( self . nodelist_loop ) , reversed_text ) def __iter__ ( self ) : for node in self . nodelist_loop : yield node for node in self . nodelist_empty : yield node def render ( self , context ) : if 'forloop' in context : parentloop = context [ 'forloop' ] else : parentloop = { } context . push ( ) try : values = self . sequence . resolve ( context , True ) except VariableDoesNotExist : values = [ ] if values is None : values = [ ] if not hasattr ( values , '__len__' ) : values = list ( values ) len_values = len ( values ) if len_values < 1 : context . pop ( ) return self . nodelist_empty . render ( context ) nodelist = NodeList ( ) if self . is_reversed : values = reversed ( values ) unpack = len ( self . loopvars ) > 1 loop_dict = context [ 'forloop' ] = { 'parentloop' : parentloop } for i , item in enumerate ( values ) : loop_dict [ 'counter0' ] = i loop_dict [ 'counter' ] = i + 1 loop_dict [ 'revcounter' ] = len_values - i loop_dict [ 'revcounter0' ] = len_values - i - 1 loop_dict [ 'first' ] = ( i == 0 ) loop_dict [ 'last' ] = ( i == len_values - 1 ) pop_context = False if unpack : try : unpacked_vars = dict ( zip ( self . loopvars , item ) ) except TypeError : pass else : pop_context = True context . update ( unpacked_vars ) else : context [ self . loopvars [ 0 ] ] = item if settings . TEMPLATE_DEBUG : for node in self . nodelist_loop : try : nodelist . append ( node . render ( context ) ) except Exception , e : if not hasattr ( e , 'django_template_source' ) : e . django_template_source = node . source raise else : for node in self . nodelist_loop : nodelist . append ( node . render ( context ) ) if pop_context : context . pop ( ) context . pop ( ) return nodelist . render ( context ) class IfChangedNode ( Node ) : child_nodelists = ( 'nodelist_true' , 'nodelist_false' ) def __init__ ( self , nodelist_true , nodelist_false , * varlist ) : self . nodelist_true , self . nodelist_false = nodelist_true , nodelist_false self . _last_seen = None self . _varlist = varlist self . _id = str ( id ( self ) ) def render ( self , context ) : if 'forloop' in context and self . _id not in context [ 'forloop' ] : self . _last_seen = None context [ 'forloop' ] [ self . _id ] = 1 try : if self . _varlist : compare_to = [ var . resolve ( context , True ) for var in self . _varlist ] else : compare_to = self . nodelist_true . render ( context ) except VariableDoesNotExist : compare_to = None if compare_to != self . _last_seen : self . _last_seen = compare_to content = self . nodelist_true . render ( context ) return content elif self . nodelist_false : return self . nodelist_false . render ( context ) return '' class IfEqualNode ( Node ) : child_nodelists = ( 'nodelist_true' , 'nodelist_false' ) def __init__ ( self , var1 , var2 , nodelist_true , nodelist_false , negate ) : self . var1 , self . var2 = var1 , var2 self . nodelist_true , self . nodelist_false = nodelist_true , nodelist_false self . negate = negate def __repr__ ( self ) : return "<IfEqualNode>" def render ( self , context ) : val1 = self . var1 . resolve ( context , True ) val2 = self . var2 . resolve ( context , True ) if ( self . negate and val1 != val2 ) or ( not self . negate and val1 == val2 ) : return self . nodelist_true . render ( context ) return self . nodelist_false . render ( context ) class IfNode ( Node ) : def __init__ ( self , conditions_nodelists ) : self . conditions_nodelists = conditions_nodelists def __repr__ ( self ) : return "<IfNode>" def __iter__ ( self ) : for _ , nodelist in self . conditions_nodelists : for node in nodelist : yield node @ property def nodelist ( self ) : return NodeList ( node for _ , nodelist in self . conditions_nodelists for node in nodelist ) def render ( self , context ) : for condition , nodelist in self . conditions_nodelists : if condition is not None : try : match = condition . eval ( context ) except VariableDoesNotExist : match = None else : match = True if match : return nodelist . render ( context ) return '' class RegroupNode ( Node ) : def __init__ ( self , target , expression , var_name ) : self . target , self . expression = target , expression self . var_name = var_name def resolve_expression ( self , obj , context ) : context [ self . var_name ] = obj return self . expression . resolve ( context , True ) def render ( self , context ) : obj_list = self . target . resolve ( context , True ) if obj_list == None : context [ self . var_name ] = [ ] return '' context [ self . var_name ] = [ { 'grouper' : key , 'list' : list ( val ) } for key , val in groupby ( obj_list , lambda obj : self . resolve_expression ( obj , context ) ) ] return '' def include_is_allowed ( filepath ) : for root in settings . ALLOWED_INCLUDE_ROOTS : if filepath . startswith ( root ) : return True return False class SsiNode ( Node ) : def __init__ ( self , filepath , parsed , legacy_filepath = True ) : self . filepath = filepath self . parsed = parsed self . legacy_filepath = legacy_filepath def render ( self , context ) : filepath = self . filepath if not self . legacy_filepath : filepath = filepath . resolve ( context ) if not include_is_allowed ( filepath ) : if settings . DEBUG : return "[Didn't have permission to include file]" else : return '' try : fp = open ( filepath , 'r' ) output = fp . read ( ) fp . close ( ) except IOError : output = '' if self . parsed : try : t = Template ( output , name = filepath ) return t . render ( context ) except TemplateSyntaxError , e : if settings . DEBUG : return "[Included template had syntax error: %s]" % e else : return '' return output class LoadNode ( Node ) : def render ( self , context ) : return '' class NowNode ( Node ) : def __init__ ( self , format_string ) : self . format_string = format_string def render ( self , context ) : tzinfo = timezone . get_current_timezone ( ) if settings . USE_TZ else None return date ( datetime . now ( tz = tzinfo ) , self . format_string ) class SpacelessNode ( Node ) : def __init__ ( self , nodelist ) : self . nodelist = nodelist def render ( self , context ) : from django . utils . html import strip_spaces_between_tags return strip_spaces_between_tags ( self . nodelist . render ( context ) . strip ( ) ) class TemplateTagNode ( Node ) : mapping = { 'openblock' : BLOCK_TAG_START , : BLOCK_TAG_END , : VARIABLE_TAG_START , : VARIABLE_TAG_END , : SINGLE_BRACE_START , : SINGLE_BRACE_END , : COMMENT_TAG_START , : COMMENT_TAG_END , } def __init__ ( self , tagtype ) : self . tagtype = tagtype def render ( self , context ) : return self . mapping . get ( self . tagtype , '' ) class URLNode ( Node ) : def __init__ ( self , view_name , args , kwargs , asvar , legacy_view_name = True ) : self . view_name = view_name self . legacy_view_name = legacy_view_name self . args = args self . kwargs = kwargs self . asvar = asvar def render ( self , context ) : from django . core . urlresolvers import reverse , NoReverseMatch args = [ arg . resolve ( context ) for arg in self . args ] kwargs = dict ( [ ( smart_str ( k , 'ascii' ) , v . resolve ( context ) ) for k , v in self . kwargs . items ( ) ] ) view_name = self . view_name if not self . legacy_view_name : view_name = view_name . resolve ( context ) url = '' try : url = reverse ( view_name , args = args , kwargs = kwargs , current_app = context . current_app ) except NoReverseMatch , e : if settings . SETTINGS_MODULE : project_name = settings . SETTINGS_MODULE . split ( '.' ) [ 0 ] try : url = reverse ( project_name + '.' + view_name , args = args , kwargs = kwargs , current_app = context . current_app ) except NoReverseMatch : if self . asvar is None : raise e else : if self . asvar is None : raise e if self . asvar : context [ self . asvar ] = url return '' else : return url class WidthRatioNode ( Node ) : def __init__ ( self , val_expr , max_expr , max_width ) : self . val_expr = val_expr self . max_expr = max_expr self . max_width = max_width def render ( self , context ) : try : value = self . val_expr . resolve ( context ) max_value = self . max_expr . resolve ( context ) max_width = int ( self . max_width . resolve ( context ) ) except VariableDoesNotExist : return '' except ValueError : raise TemplateSyntaxError ( "widthratio final argument must be an number" ) try : value = float ( value ) max_value = float ( max_value ) ratio = ( value / max_value ) * max_width except ZeroDivisionError : return '0' except ValueError : return '' return str ( int ( round ( ratio ) ) ) class WithNode ( Node ) : def __init__ ( self , var , name , nodelist , extra_context = None ) : self . nodelist = nodelist self . extra_context = extra_context or { } if name : self . extra_context [ name ] = var def __repr__ ( self ) : return "<WithNode>" def render ( self , context ) : values = dict ( [ ( key , val . resolve ( context ) ) for key , val in self . extra_context . iteritems ( ) ] ) context . update ( values ) output = self . nodelist . render ( context ) context . pop ( ) return output @ register . tag def autoescape ( parser , token ) : args = token . contents . split ( ) if len ( args ) != 2 : raise TemplateSyntaxError ( "'autoescape' tag requires exactly one argument." ) arg = args [ 1 ] if arg not in ( u'on' , u'off' ) : raise TemplateSyntaxError ( "'autoescape' argument should be 'on' or 'off'" ) nodelist = parser . parse ( ( 'endautoescape' , ) ) parser . delete_first_token ( ) return AutoEscapeControlNode ( ( arg == 'on' ) , nodelist ) @ register . tag def comment ( parser , token ) : parser . skip_past ( 'endcomment' ) return CommentNode ( ) @ register . tag def cycle ( parser , token ) : args = token . split_contents ( ) if len ( args ) < 2 : raise TemplateSyntaxError ( "'cycle' tag requires at least two arguments" ) if ',' in args [ 1 ] : args [ 1 : 2 ] = [ '"%s"' % arg for arg in args [ 1 ] . split ( "," ) ] if len ( args ) == 2 : name = args [ 1 ] if not hasattr ( parser , '_namedCycleNodes' ) : raise TemplateSyntaxError ( "No named cycles in template. '%s' is not defined" % name ) if not name in parser . _namedCycleNodes : raise TemplateSyntaxError ( "Named cycle '%s' does not exist" % name ) return parser . _namedCycleNodes [ name ] as_form = False if len ( args ) > 4 : if args [ - 3 ] == "as" : if args [ - 1 ] != "silent" : raise TemplateSyntaxError ( "Only 'silent' flag is allowed after cycle's name, not '%s'." % args [ - 1 ] ) as_form = True silent = True args = args [ : - 1 ] elif args [ - 2 ] == "as" : as_form = True silent = False if as_form : name = args [ - 1 ] values = [ parser . compile_filter ( arg ) for arg in args [ 1 : - 2 ] ] node = CycleNode ( values , name , silent = silent ) if not hasattr ( parser , '_namedCycleNodes' ) : parser . _namedCycleNodes = { } parser . _namedCycleNodes [ name ] = node else : values = [ parser . compile_filter ( arg ) for arg in args [ 1 : ] ] node = CycleNode ( values ) return node @ register . tag def csrf_token ( parser , token ) : return CsrfTokenNode ( ) @ register . tag def debug ( parser , token ) : return DebugNode ( ) @ register . tag ( 'filter' ) def do_filter ( parser , token ) : _ , rest = token . contents . split ( None , 1 ) filter_expr = parser . compile_filter ( "var|%s" % ( rest ) ) for func , unused in filter_expr . filters : if getattr ( func , '_decorated_function' , func ) . __name__ in ( 'escape' , 'safe' ) : raise TemplateSyntaxError ( '"filter %s" is not permitted. Use the "autoescape" tag instead.' % func . __name__ ) nodelist = parser . parse ( ( 'endfilter' , ) ) parser . delete_first_token ( ) return FilterNode ( filter_expr , nodelist ) @ register . tag def firstof ( parser , token ) : bits = token . split_contents ( ) [ 1 : ] if len ( bits ) < 1 : raise TemplateSyntaxError ( "'firstof' statement requires at least one argument" ) return FirstOfNode ( [ parser . compile_filter ( bit ) for bit in bits ] ) @ register . tag ( 'for' ) def do_for ( parser , token ) : bits = token . contents . split ( ) if len ( bits ) < 4 : raise TemplateSyntaxError ( "'for' statements should have at least four" % token . contents ) is_reversed = bits [ - 1 ] == 'reversed' in_index = is_reversed and - 3 or - 2 if bits [ in_index ] != 'in' : raise TemplateSyntaxError ( "'for' statements should use the format" % token . contents ) loopvars = re . split ( r' *, *' , ' ' . join ( bits [ 1 : in_index ] ) ) for var in loopvars : if not var or ' ' in var : raise TemplateSyntaxError ( "'for' tag received an invalid argument:" % token . contents ) sequence = parser . compile_filter ( bits [ in_index + 1 ] ) nodelist_loop = parser . parse ( ( 'empty' , 'endfor' , ) ) token = parser . next_token ( ) if token . contents == 'empty' : nodelist_empty = parser . parse ( ( 'endfor' , ) ) parser . delete_first_token ( ) else : nodelist_empty = None return ForNode ( loopvars , sequence , is_reversed , nodelist_loop , nodelist_empty ) def do_ifequal ( parser , token , negate ) : bits = list ( token . split_contents ( ) ) if len ( bits ) != 3 : raise TemplateSyntaxError ( "%r takes two arguments" % bits [ 0 ] ) end_tag = 'end' + bits [ 0 ] nodelist_true = parser . parse ( ( 'else' , end_tag ) ) token = parser . next_token ( ) if token . contents == 'else' : nodelist_false = parser . parse ( ( end_tag , ) ) parser . delete_first_token ( ) else : nodelist_false = NodeList ( ) val1 = parser . compile_filter ( bits [ 1 ] ) val2 = parser . compile_filter ( bits [ 2 ] ) return IfEqualNode ( val1 , val2 , nodelist_true , nodelist_false , negate ) @ register . tag def ifequal ( parser , token ) : return do_ifequal ( parser , token , False ) @ register . tag def ifnotequal ( parser , token ) : return do_ifequal ( parser , token , True ) class TemplateLiteral ( Literal ) : def __init__ ( self , value , text ) : self . value = value self . text = text def display ( self ) : return self . text def eval ( self , context ) : return self . value . resolve ( context , ignore_failures = True ) class TemplateIfParser ( IfParser ) : error_class = TemplateSyntaxError def __init__ ( self , parser , * args , ** kwargs ) : self . template_parser = parser super ( TemplateIfParser , self ) . __init__ ( * args , ** kwargs ) def create_var ( self , value ) : return TemplateLiteral ( self . template_parser . compile_filter ( value ) , value ) @ register . tag ( 'if' ) def do_if ( parser , token ) : bits = token . split_contents ( ) [ 1 : ] condition = TemplateIfParser ( parser , bits ) . parse ( ) nodelist = parser . parse ( ( 'elif' , 'else' , 'endif' ) ) conditions_nodelists = [ ( condition , nodelist ) ] token = parser . next_token ( ) while token . contents . startswith ( 'elif' ) : bits = token . split_contents ( ) [ 1 : ] condition = TemplateIfParser ( parser , bits ) . parse ( ) nodelist = parser . parse ( ( 'elif' , 'else' , 'endif' ) ) conditions_nodelists . append ( ( condition , nodelist ) ) token = parser . next_token ( ) if token . contents == 'else' : nodelist = parser . parse ( ( 'endif' , ) ) conditions_nodelists . append ( ( None , nodelist ) ) token = parser . next_token ( ) assert token . contents == 'endif' return IfNode ( conditions_nodelists ) @ register . tag def ifchanged ( parser , token ) : bits = token . contents . split ( ) nodelist_true = parser . parse ( ( 'else' , 'endifchanged' ) ) token = parser . next_token ( ) if token . contents == 'else' : nodelist_false = parser . parse ( ( 'endifchanged' , ) ) parser . delete_first_token ( ) else : nodelist_false = NodeList ( ) values = [ parser . compile_filter ( bit ) for bit in bits [ 1 : ] ] return IfChangedNode ( nodelist_true , nodelist_false , * values ) @ register . tag def ssi ( parser , token ) : import warnings warnings . warn ( 'The syntax for the ssi template tag is changing. Load the `ssi` tag from the `future` tag library to start using the new behavior.' , category = DeprecationWarning ) bits = token . contents . split ( ) parsed = False if len ( bits ) not in ( 2 , 3 ) : raise TemplateSyntaxError ( "'ssi' tag takes one argument: the path to" ) if len ( bits ) == 3 : if bits [ 2 ] == 'parsed' : parsed = True else : raise TemplateSyntaxError ( "Second (optional) argument to %s tag" % bits [ 0 ] ) return SsiNode ( bits [ 1 ] , parsed , legacy_filepath = True ) @ register . tag def load ( parser , token ) : bits = token . contents . split ( ) if len ( bits ) >= 4 and bits [ - 2 ] == "from" : try : taglib = bits [ - 1 ] lib = get_library ( taglib ) except InvalidTemplateLibrary , e : raise TemplateSyntaxError ( "'%s' is not a valid tag library: %s" % ( taglib , e ) ) else : temp_lib = Library ( ) for name in bits [ 1 : - 2 ] : if name in lib . tags : temp_lib . tags [ name ] = lib . tags [ name ] if name in lib . filters : temp_lib . filters [ name ] = lib . filters [ name ] elif name in lib . filters : temp_lib . filters [ name ] = lib . filters [ name ] else : raise TemplateSyntaxError ( "'%s' is not a valid tag or filter in tag library '%s'" % ( name , taglib ) ) parser . add_library ( temp_lib ) else : for taglib in bits [ 1 : ] : try : lib = get_library ( taglib ) parser . add_library ( lib ) except InvalidTemplateLibrary , e : raise TemplateSyntaxError ( "'%s' is not a valid tag library: %s" % ( taglib , e ) ) return LoadNode ( ) @ register . tag def now ( parser , token ) : bits = token . split_contents ( ) if len ( bits ) != 2 : raise TemplateSyntaxError ( "'now' statement takes one argument" ) format_string = bits [ 1 ] [ 1 : - 1 ] return NowNode ( format_string ) @ register . tag def regroup ( parser , token ) : firstbits = token . contents . split ( None , 3 ) if len ( firstbits ) != 4 : raise TemplateSyntaxError ( "'regroup' tag takes five arguments" ) target = parser . compile_filter ( firstbits [ 1 ] ) if firstbits [ 2 ] != 'by' : raise TemplateSyntaxError ( "second argument to 'regroup' tag must be 'by'" ) lastbits_reversed = firstbits [ 3 ] [ : : - 1 ] . split ( None , 2 ) if lastbits_reversed [ 1 ] [ : : - 1 ] != 'as' : raise TemplateSyntaxError ( "next-to-last argument to 'regroup' tag must" ) var_name = lastbits_reversed [ 0 ] [ : : - 1 ] expression = parser . compile_filter ( var_name + VARIABLE_ATTRIBUTE_SEPARATOR + lastbits_reversed [ 2 ] [ : : - 1 ] ) return RegroupNode ( target , expression , var_name ) @ register . tag def spaceless ( parser , token ) : nodelist = parser . parse ( ( 'endspaceless' , ) ) parser . delete_first_token ( ) return SpacelessNode ( nodelist ) @ register . tag def templatetag ( parser , token ) : bits = token . contents . split ( ) if len ( bits ) != 2 : raise TemplateSyntaxError ( "'templatetag' statement takes one argument" ) tag = bits [ 1 ] if tag not in TemplateTagNode . mapping : raise TemplateSyntaxError ( "Invalid templatetag argument: '%s'." % ( tag , TemplateTagNode . mapping . keys ( ) ) ) return TemplateTagNode ( tag ) @ register . tag def url ( parser , token ) : import warnings warnings . warn ( 'The syntax for the url template tag is changing. Load the `url` tag from the `future` tag library to start using the new behavior.' , category = DeprecationWarning ) bits = token . split_contents ( ) if len ( bits ) < 2 : raise TemplateSyntaxError ( "'%s' takes at least one argument" % bits [ 0 ] ) viewname = bits [ 1 ] args = [ ] kwargs = { } asvar = None bits = bits [ 2 : ] if len ( bits ) >= 2 and bits [ - 2 ] == 'as' : asvar = bits [ - 1 ] bits = bits [ : - 2 ] if bits and ',' in bits [ 0 ] : check_old_format = True for bit in bits [ 1 : - 1 ] : if ',' not in bit : check_old_format = False break else : check_old_format = False if check_old_format : match = kwarg_re . match ( bits [ 0 ] ) if match : value = match . groups ( ) [ 1 ] try : parser . compile_filter ( value ) except TemplateSyntaxError : bits = '' . join ( bits ) . split ( ',' ) if len ( bits ) : for bit in bits : match = kwarg_re . match ( bit ) if not match : raise TemplateSyntaxError ( "Malformed arguments to url tag" ) name , value = match . groups ( ) if name : kwargs [ name ] = parser . compile_filter ( value ) else : args . append ( parser . compile_filter ( value ) ) return URLNode ( viewname , args , kwargs , asvar , legacy_view_name = True ) @ register . tag def widthratio ( parser , token ) : bits = token . contents . split ( ) if len ( bits ) != 4 : raise TemplateSyntaxError ( "widthratio takes three arguments" ) tag , this_value_expr , max_value_expr , max_width = bits return WidthRatioNode ( parser . compile_filter ( this_value_expr ) , parser . compile_filter ( max_value_expr ) , parser . compile_filter ( max_width ) ) @ register . tag ( 'with' ) def do_with ( parser , token ) : bits = token . split_contents ( ) remaining_bits = bits [ 1 : ] extra_context = token_kwargs ( remaining_bits , parser , support_legacy = True ) if not extra_context : raise TemplateSyntaxError ( "%r expected at least one variable " % bits [ 0 ] ) if remaining_bits : raise TemplateSyntaxError ( "%r received an invalid token: %r" % ( bits [ 0 ] , remaining_bits [ 0 ] ) ) nodelist = parser . parse ( ( 'endwith' , ) ) parser . delete_first_token ( ) return WithNode ( None , None , nodelist , extra_context = extra_context )

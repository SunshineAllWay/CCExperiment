import hashlib import re from django . conf import settings from django import http from django . core . mail import mail_managers from django . utils . http import urlquote from django . core import urlresolvers from django . utils . log import getLogger logger = getLogger ( 'django.request' ) class CommonMiddleware ( object ) : def process_request ( self , request ) : if 'HTTP_USER_AGENT' in request . META : for user_agent_regex in settings . DISALLOWED_USER_AGENTS : if user_agent_regex . search ( request . META [ 'HTTP_USER_AGENT' ] ) : logger . warning ( 'Forbidden (User agent): %s' , request . path , extra = { : 403 , : request } ) return http . HttpResponseForbidden ( '<h1>Forbidden</h1>' ) host = request . get_host ( ) old_url = [ host , request . path ] new_url = old_url [ : ] if ( settings . PREPEND_WWW and old_url [ 0 ] and not old_url [ 0 ] . startswith ( 'www.' ) ) : new_url [ 0 ] = 'www.' + old_url [ 0 ] if settings . APPEND_SLASH and ( not old_url [ 1 ] . endswith ( '/' ) ) : urlconf = getattr ( request , 'urlconf' , None ) if ( not _is_valid_path ( request . path_info , urlconf ) and _is_valid_path ( "%s/" % request . path_info , urlconf ) ) : new_url [ 1 ] = new_url [ 1 ] + '/' if settings . DEBUG and request . method == 'POST' : raise RuntimeError ( ( "" ) % ( new_url [ 0 ] , new_url [ 1 ] ) ) if new_url == old_url : return if new_url [ 0 ] : newurl = "%s://%s%s" % ( request . is_secure ( ) and 'https' or 'http' , new_url [ 0 ] , urlquote ( new_url [ 1 ] ) ) else : newurl = urlquote ( new_url [ 1 ] ) if request . META . get ( 'QUERY_STRING' , '' ) : newurl += '?' + request . META [ 'QUERY_STRING' ] return http . HttpResponsePermanentRedirect ( newurl ) def process_response ( self , request , response ) : if response . status_code == 404 : if settings . SEND_BROKEN_LINK_EMAILS and not settings . DEBUG : domain = request . get_host ( ) referer = request . META . get ( 'HTTP_REFERER' , None ) is_internal = _is_internal_request ( domain , referer ) path = request . get_full_path ( ) if referer and not _is_ignorable_404 ( path ) and ( is_internal or '?' not in referer ) : ua = request . META . get ( 'HTTP_USER_AGENT' , '<none>' ) ip = request . META . get ( 'REMOTE_ADDR' , '<none>' ) mail_managers ( "Broken %slink on %s" % ( ( is_internal and 'INTERNAL ' or '' ) , domain ) , % ( referer , request . get_full_path ( ) , ua , ip ) , fail_silently = True ) return response if settings . USE_ETAGS : if response . has_header ( 'ETag' ) : etag = response [ 'ETag' ] else : etag = '"%s"' % hashlib . md5 ( response . content ) . hexdigest ( ) if response . status_code >= 200 and response . status_code < 300 and request . META . get ( 'HTTP_IF_NONE_MATCH' ) == etag : cookies = response . cookies response = http . HttpResponseNotModified ( ) response . cookies = cookies else : response [ 'ETag' ] = etag return response def _is_ignorable_404 ( uri ) : if getattr ( settings , 'IGNORABLE_404_STARTS' , ( ) ) : import warnings warnings . warn ( 'The IGNORABLE_404_STARTS setting has been deprecated ' , PendingDeprecationWarning ) for start in settings . IGNORABLE_404_STARTS : if uri . startswith ( start ) : return True if getattr ( settings , 'IGNORABLE_404_ENDS' , ( ) ) : import warnings warnings . warn ( 'The IGNORABLE_404_ENDS setting has been deprecated ' , PendingDeprecationWarning ) for end in settings . IGNORABLE_404_ENDS : if uri . endswith ( end ) : return True return any ( pattern . search ( uri ) for pattern in settings . IGNORABLE_404_URLS ) def _is_internal_request ( domain , referer ) : return referer is not None and re . match ( "^https?://%s/" % re . escape ( domain ) , referer ) def _is_valid_path ( path , urlconf = None ) : try : urlresolvers . resolve ( path , urlconf ) return True except urlresolvers . Resolver404 : return False

import copy from types import GeneratorType class MergeDict ( object ) : def __init__ ( self , * dicts ) : self . dicts = dicts def __getitem__ ( self , key ) : for dict_ in self . dicts : try : return dict_ [ key ] except KeyError : pass raise KeyError def __copy__ ( self ) : return self . __class__ ( * self . dicts ) def get ( self , key , default = None ) : try : return self [ key ] except KeyError : return default def getlist ( self , key ) : for dict_ in self . dicts : if key in dict_ . keys ( ) : return dict_ . getlist ( key ) return [ ] def iteritems ( self ) : seen = set ( ) for dict_ in self . dicts : for item in dict_ . iteritems ( ) : k , v = item if k in seen : continue seen . add ( k ) yield item def iterkeys ( self ) : for k , v in self . iteritems ( ) : yield k def itervalues ( self ) : for k , v in self . iteritems ( ) : yield v def items ( self ) : return list ( self . iteritems ( ) ) def keys ( self ) : return list ( self . iterkeys ( ) ) def values ( self ) : return list ( self . itervalues ( ) ) def has_key ( self , key ) : for dict_ in self . dicts : if key in dict_ : return True return False __contains__ = has_key __iter__ = iterkeys def copy ( self ) : return self . __copy__ ( ) def __str__ ( self ) : return str ( dict ( self . items ( ) ) ) def __repr__ ( self ) : dictreprs = ', ' . join ( repr ( d ) for d in self . dicts ) return '%s(%s)' % ( self . __class__ . __name__ , dictreprs ) class SortedDict ( dict ) : def __new__ ( cls , * args , ** kwargs ) : instance = super ( SortedDict , cls ) . __new__ ( cls , * args , ** kwargs ) instance . keyOrder = [ ] return instance def __init__ ( self , data = None ) : if data is None : data = { } elif isinstance ( data , GeneratorType ) : data = list ( data ) super ( SortedDict , self ) . __init__ ( data ) if isinstance ( data , dict ) : self . keyOrder = data . keys ( ) else : self . keyOrder = [ ] seen = set ( ) for key , value in data : if key not in seen : self . keyOrder . append ( key ) seen . add ( key ) def __deepcopy__ ( self , memo ) : return self . __class__ ( [ ( key , copy . deepcopy ( value , memo ) ) for key , value in self . iteritems ( ) ] ) def __setitem__ ( self , key , value ) : if key not in self : self . keyOrder . append ( key ) super ( SortedDict , self ) . __setitem__ ( key , value ) def __delitem__ ( self , key ) : super ( SortedDict , self ) . __delitem__ ( key ) self . keyOrder . remove ( key ) def __iter__ ( self ) : return iter ( self . keyOrder ) def pop ( self , k , * args ) : result = super ( SortedDict , self ) . pop ( k , * args ) try : self . keyOrder . remove ( k ) except ValueError : pass return result def popitem ( self ) : result = super ( SortedDict , self ) . popitem ( ) self . keyOrder . remove ( result [ 0 ] ) return result def items ( self ) : return zip ( self . keyOrder , self . values ( ) ) def iteritems ( self ) : for key in self . keyOrder : yield key , self [ key ] def keys ( self ) : return self . keyOrder [ : ] def iterkeys ( self ) : return iter ( self . keyOrder ) def values ( self ) : return map ( self . __getitem__ , self . keyOrder ) def itervalues ( self ) : for key in self . keyOrder : yield self [ key ] def update ( self , dict_ ) : for k , v in dict_ . iteritems ( ) : self [ k ] = v def setdefault ( self , key , default ) : if key not in self : self . keyOrder . append ( key ) return super ( SortedDict , self ) . setdefault ( key , default ) def value_for_index ( self , index ) : return self [ self . keyOrder [ index ] ] def insert ( self , index , key , value ) : if key in self . keyOrder : n = self . keyOrder . index ( key ) del self . keyOrder [ n ] if n < index : index -= 1 self . keyOrder . insert ( index , key ) super ( SortedDict , self ) . __setitem__ ( key , value ) def copy ( self ) : obj = self . __class__ ( self ) obj . keyOrder = self . keyOrder [ : ] return obj def __repr__ ( self ) : return '{%s}' % ', ' . join ( [ '%r: %r' % ( k , v ) for k , v in self . items ( ) ] ) def clear ( self ) : super ( SortedDict , self ) . clear ( ) self . keyOrder = [ ] class MultiValueDictKeyError ( KeyError ) : pass class MultiValueDict ( dict ) : def __init__ ( self , key_to_list_mapping = ( ) ) : super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping ) def __repr__ ( self ) : return "<%s: %s>" % ( self . __class__ . __name__ , super ( MultiValueDict , self ) . __repr__ ( ) ) def __getitem__ ( self , key ) : try : list_ = super ( MultiValueDict , self ) . __getitem__ ( key ) except KeyError : raise MultiValueDictKeyError ( "Key %r not found in %r" % ( key , self ) ) try : return list_ [ - 1 ] except IndexError : return [ ] def __setitem__ ( self , key , value ) : super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] ) def __copy__ ( self ) : return self . __class__ ( [ ( k , v [ : ] ) for k , v in self . lists ( ) ] ) def __deepcopy__ ( self , memo = None ) : if memo is None : memo = { } result = self . __class__ ( ) memo [ id ( self ) ] = result for key , value in dict . items ( self ) : dict . __setitem__ ( result , copy . deepcopy ( key , memo ) , copy . deepcopy ( value , memo ) ) return result def __getstate__ ( self ) : obj_dict = self . __dict__ . copy ( ) obj_dict [ '_data' ] = dict ( [ ( k , self . getlist ( k ) ) for k in self ] ) return obj_dict def __setstate__ ( self , obj_dict ) : data = obj_dict . pop ( '_data' , { } ) for k , v in data . items ( ) : self . setlist ( k , v ) self . __dict__ . update ( obj_dict ) def get ( self , key , default = None ) : try : val = self [ key ] except KeyError : return default if val == [ ] : return default return val def getlist ( self , key , default = None ) : try : return super ( MultiValueDict , self ) . __getitem__ ( key ) except KeyError : if default is None : return [ ] return default def setlist ( self , key , list_ ) : super ( MultiValueDict , self ) . __setitem__ ( key , list_ ) def setdefault ( self , key , default = None ) : if key not in self : self [ key ] = default return default return self [ key ] def setlistdefault ( self , key , default_list = None ) : if key not in self : if default_list is None : default_list = [ ] self . setlist ( key , default_list ) return default_list return self . getlist ( key ) def appendlist ( self , key , value ) : self . setlistdefault ( key ) . append ( value ) def items ( self ) : return [ ( key , self [ key ] ) for key in self . keys ( ) ] def iteritems ( self ) : for key in self . keys ( ) : yield ( key , self [ key ] ) def lists ( self ) : return super ( MultiValueDict , self ) . items ( ) def iterlists ( self ) : return super ( MultiValueDict , self ) . iteritems ( ) def values ( self ) : return [ self [ key ] for key in self . keys ( ) ] def itervalues ( self ) : for key in self . iterkeys ( ) : yield self [ key ] def copy ( self ) : return copy . copy ( self ) def update ( self , * args , ** kwargs ) : if len ( args ) > 1 : raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) ) if args : other_dict = args [ 0 ] if isinstance ( other_dict , MultiValueDict ) : for key , value_list in other_dict . lists ( ) : self . setlistdefault ( key ) . extend ( value_list ) else : try : for key , value in other_dict . items ( ) : self . setlistdefault ( key ) . append ( value ) except TypeError : raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" ) for key , value in kwargs . iteritems ( ) : self . setlistdefault ( key ) . append ( value ) def dict ( self ) : return dict ( ( key , self [ key ] ) for key in self ) class DotExpandedDict ( dict ) : def __init__ ( self , key_to_list_mapping ) : for k , v in key_to_list_mapping . items ( ) : current = self bits = k . split ( '.' ) for bit in bits [ : - 1 ] : current = current . setdefault ( bit , { } ) try : current [ bits [ - 1 ] ] = v except TypeError : current = { bits [ - 1 ] : v } class ImmutableList ( tuple ) : def __new__ ( cls , * args , ** kwargs ) : if 'warning' in kwargs : warning = kwargs [ 'warning' ] del kwargs [ 'warning' ] else : warning = 'ImmutableList object is immutable.' self = tuple . __new__ ( cls , * args , ** kwargs ) self . warning = warning return self def complain ( self , * wargs , ** kwargs ) : if isinstance ( self . warning , Exception ) : raise self . warning else : raise AttributeError ( self . warning ) __delitem__ = complain __delslice__ = complain __iadd__ = complain __imul__ = complain __setitem__ = complain __setslice__ = complain append = complain extend = complain insert = complain pop = complain remove = complain sort = complain reverse = complain class DictWrapper ( dict ) : def __init__ ( self , data , func , prefix ) : super ( DictWrapper , self ) . __init__ ( data ) self . func = func self . prefix = prefix def __getitem__ ( self , key ) : if key . startswith ( self . prefix ) : use_func = True key = key [ len ( self . prefix ) : ] else : use_func = False value = super ( DictWrapper , self ) . __getitem__ ( key ) if use_func : return self . func ( value ) return value

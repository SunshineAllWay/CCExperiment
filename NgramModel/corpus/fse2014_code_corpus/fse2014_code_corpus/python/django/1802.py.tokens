import base64 import hashlib import os import random import time from datetime import datetime , timedelta try : import cPickle as pickle except ImportError : import pickle from django . conf import settings from django . core . exceptions import SuspiciousOperation from django . utils . crypto import constant_time_compare , salted_hmac from django . utils import timezone if hasattr ( random , 'SystemRandom' ) : randrange = random . SystemRandom ( ) . randrange else : randrange = random . randrange MAX_SESSION_KEY = 18446744073709551616L class CreateError ( Exception ) : pass class SessionBase ( object ) : TEST_COOKIE_NAME = 'testcookie' TEST_COOKIE_VALUE = 'worked' def __init__ ( self , session_key = None ) : self . _session_key = session_key self . accessed = False self . modified = False def __contains__ ( self , key ) : return key in self . _session def __getitem__ ( self , key ) : return self . _session [ key ] def __setitem__ ( self , key , value ) : self . _session [ key ] = value self . modified = True def __delitem__ ( self , key ) : del self . _session [ key ] self . modified = True def get ( self , key , default = None ) : return self . _session . get ( key , default ) def pop ( self , key , * args ) : self . modified = self . modified or key in self . _session return self . _session . pop ( key , * args ) def setdefault ( self , key , value ) : if key in self . _session : return self . _session [ key ] else : self . modified = True self . _session [ key ] = value return value def set_test_cookie ( self ) : self [ self . TEST_COOKIE_NAME ] = self . TEST_COOKIE_VALUE def test_cookie_worked ( self ) : return self . get ( self . TEST_COOKIE_NAME ) == self . TEST_COOKIE_VALUE def delete_test_cookie ( self ) : del self [ self . TEST_COOKIE_NAME ] def _hash ( self , value ) : key_salt = "django.contrib.sessions" + self . __class__ . __name__ return salted_hmac ( key_salt , value ) . hexdigest ( ) def encode ( self , session_dict ) : pickled = pickle . dumps ( session_dict , pickle . HIGHEST_PROTOCOL ) hash = self . _hash ( pickled ) return base64 . encodestring ( hash + ":" + pickled ) def decode ( self , session_data ) : encoded_data = base64 . decodestring ( session_data ) try : hash , pickled = encoded_data . split ( ':' , 1 ) expected_hash = self . _hash ( pickled ) if not constant_time_compare ( hash , expected_hash ) : raise SuspiciousOperation ( "Session data corrupted" ) else : return pickle . loads ( pickled ) except Exception : return { } def update ( self , dict_ ) : self . _session . update ( dict_ ) self . modified = True def has_key ( self , key ) : return key in self . _session def keys ( self ) : return self . _session . keys ( ) def values ( self ) : return self . _session . values ( ) def items ( self ) : return self . _session . items ( ) def iterkeys ( self ) : return self . _session . iterkeys ( ) def itervalues ( self ) : return self . _session . itervalues ( ) def iteritems ( self ) : return self . _session . iteritems ( ) def clear ( self ) : self . _session_cache = { } self . accessed = True self . modified = True def _get_new_session_key ( self ) : try : pid = os . getpid ( ) except AttributeError : pid = 1 while True : session_key = hashlib . md5 ( "%s%s%s%s" % ( randrange ( 0 , MAX_SESSION_KEY ) , pid , time . time ( ) , settings . SECRET_KEY ) ) . hexdigest ( ) if not self . exists ( session_key ) : break return session_key def _get_or_create_session_key ( self ) : if self . _session_key is None : self . _session_key = self . _get_new_session_key ( ) return self . _session_key def _get_session_key ( self ) : return self . _session_key session_key = property ( _get_session_key ) def _get_session ( self , no_load = False ) : self . accessed = True try : return self . _session_cache except AttributeError : if self . session_key is None or no_load : self . _session_cache = { } else : self . _session_cache = self . load ( ) return self . _session_cache _session = property ( _get_session ) def get_expiry_age ( self ) : expiry = self . get ( '_session_expiry' ) if not expiry : return settings . SESSION_COOKIE_AGE if not isinstance ( expiry , datetime ) : return expiry delta = expiry - timezone . now ( ) return delta . days * 86400 + delta . seconds def get_expiry_date ( self ) : expiry = self . get ( '_session_expiry' ) if isinstance ( expiry , datetime ) : return expiry if not expiry : expiry = settings . SESSION_COOKIE_AGE return timezone . now ( ) + timedelta ( seconds = expiry ) def set_expiry ( self , value ) : if value is None : try : del self [ '_session_expiry' ] except KeyError : pass return if isinstance ( value , timedelta ) : value = timezone . now ( ) + value self [ '_session_expiry' ] = value def get_expire_at_browser_close ( self ) : if self . get ( '_session_expiry' ) is None : return settings . SESSION_EXPIRE_AT_BROWSER_CLOSE return self . get ( '_session_expiry' ) == 0 def flush ( self ) : self . clear ( ) self . delete ( ) self . create ( ) def cycle_key ( self ) : data = self . _session_cache key = self . session_key self . create ( ) self . _session_cache = data self . delete ( key ) def exists ( self , session_key ) : raise NotImplementedError def create ( self ) : raise NotImplementedError def save ( self , must_create = False ) : raise NotImplementedError def delete ( self , session_key = None ) : raise NotImplementedError def load ( self ) : raise NotImplementedError

from __future__ import absolute_import from functools import update_wrapper from django . db import connection from django . test import TestCase , skipUnlessDBFeature from . models import Reporter , Article def ignore_not_implemented ( func ) : def _inner ( * args , ** kwargs ) : try : return func ( * args , ** kwargs ) except NotImplementedError : return None update_wrapper ( _inner , func ) return _inner class IgnoreNotimplementedError ( type ) : def __new__ ( cls , name , bases , attrs ) : for k , v in attrs . items ( ) : if k . startswith ( 'test' ) : attrs [ k ] = ignore_not_implemented ( v ) return type . __new__ ( cls , name , bases , attrs ) class IntrospectionTests ( TestCase ) : __metaclass__ = IgnoreNotimplementedError def test_table_names ( self ) : tl = connection . introspection . table_names ( ) self . assertTrue ( Reporter . _meta . db_table in tl , % Reporter . _meta . db_table ) self . assertTrue ( Article . _meta . db_table in tl , % Article . _meta . db_table ) def test_django_table_names ( self ) : cursor = connection . cursor ( ) cursor . execute ( 'CREATE TABLE django_ixn_test_table (id INTEGER);' ) tl = connection . introspection . django_table_names ( ) cursor . execute ( "DROP TABLE django_ixn_test_table;" ) self . assertTrue ( 'django_ixn_testcase_table' not in tl , ) def test_django_table_names_retval_type ( self ) : cursor = connection . cursor ( ) cursor . execute ( 'CREATE TABLE django_ixn_test_table (id INTEGER);' ) tl = connection . introspection . django_table_names ( only_existing = True ) self . assertIs ( type ( tl ) , list ) tl = connection . introspection . django_table_names ( only_existing = False ) self . assertIs ( type ( tl ) , list ) def test_installed_models ( self ) : tables = [ Article . _meta . db_table , Reporter . _meta . db_table ] models = connection . introspection . installed_models ( tables ) self . assertEqual ( models , set ( [ Article , Reporter ] ) ) def test_sequence_list ( self ) : sequences = connection . introspection . sequence_list ( ) expected = { 'table' : Reporter . _meta . db_table , 'column' : 'id' } self . assertTrue ( expected in sequences , ) def test_get_table_description_names ( self ) : cursor = connection . cursor ( ) desc = connection . introspection . get_table_description ( cursor , Reporter . _meta . db_table ) self . assertEqual ( [ r [ 0 ] for r in desc ] , [ f . column for f in Reporter . _meta . fields ] ) def test_get_table_description_types ( self ) : cursor = connection . cursor ( ) desc = connection . introspection . get_table_description ( cursor , Reporter . _meta . db_table ) self . assertEqual ( [ datatype ( r [ 1 ] , r ) for r in desc ] , [ 'IntegerField' , 'CharField' , 'CharField' , 'CharField' , 'BigIntegerField' ] ) def test_get_table_description_nullable ( self ) : cursor = connection . cursor ( ) desc = connection . introspection . get_table_description ( cursor , Reporter . _meta . db_table ) self . assertEqual ( [ r [ 6 ] for r in desc ] , [ False , False , False , False , True ] ) @ skipUnlessDBFeature ( 'has_real_datatype' ) def test_postgresql_real_type ( self ) : cursor = connection . cursor ( ) cursor . execute ( "CREATE TABLE django_ixn_real_test_table (number REAL);" ) desc = connection . introspection . get_table_description ( cursor , 'django_ixn_real_test_table' ) cursor . execute ( 'DROP TABLE django_ixn_real_test_table;' ) self . assertEqual ( datatype ( desc [ 0 ] [ 1 ] , desc [ 0 ] ) , 'FloatField' ) def test_get_relations ( self ) : cursor = connection . cursor ( ) relations = connection . introspection . get_relations ( cursor , Article . _meta . db_table ) if relations : self . assertEqual ( relations , { 3 : ( 0 , Reporter . _meta . db_table ) } ) def test_get_key_columns ( self ) : cursor = connection . cursor ( ) key_columns = connection . introspection . get_key_columns ( cursor , Article . _meta . db_table ) self . assertEqual ( key_columns , [ ( u'reporter_id' , Reporter . _meta . db_table , u'id' ) ] ) def test_get_primary_key_column ( self ) : cursor = connection . cursor ( ) primary_key_column = connection . introspection . get_primary_key_column ( cursor , Article . _meta . db_table ) self . assertEqual ( primary_key_column , u'id' ) def test_get_indexes ( self ) : cursor = connection . cursor ( ) indexes = connection . introspection . get_indexes ( cursor , Article . _meta . db_table ) self . assertEqual ( indexes [ 'reporter_id' ] , { 'unique' : False , 'primary_key' : False } ) def datatype ( dbtype , description ) : dt = connection . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt

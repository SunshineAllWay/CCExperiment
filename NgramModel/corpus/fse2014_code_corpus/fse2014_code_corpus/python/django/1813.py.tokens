""" Various data structures used in query construction. Factored out from django.db.models.query to avoid making the main module very large and/or so that they can be used by other modules without getting into circular import difficulties. """ import weakref from django . db . backends import util from django . utils import tree class InvalidQuery ( Exception ) : pass class QueryWrapper ( object ) : def __init__ ( self , sql , params ) : self . data = sql , params def as_sql ( self , qn = None , connection = None ) : return self . data class Q ( tree . Node ) : AND = 'AND' OR = 'OR' default = AND def __init__ ( self , * args , ** kwargs ) : super ( Q , self ) . __init__ ( children = list ( args ) + kwargs . items ( ) ) def _combine ( self , other , conn ) : if not isinstance ( other , Q ) : raise TypeError ( other ) obj = type ( self ) ( ) obj . add ( self , conn ) obj . add ( other , conn ) return obj def __or__ ( self , other ) : return self . _combine ( other , self . OR ) def __and__ ( self , other ) : return self . _combine ( other , self . AND ) def __invert__ ( self ) : obj = type ( self ) ( ) obj . add ( self , self . AND ) obj . negate ( ) return obj class DeferredAttribute ( object ) : def __init__ ( self , field_name , model ) : self . field_name = field_name self . model_ref = weakref . ref ( model ) self . loaded = False def __get__ ( self , instance , owner ) : from django . db . models . fields import FieldDoesNotExist assert instance is not None cls = self . model_ref ( ) data = instance . __dict__ if data . get ( self . field_name , self ) is self : try : cls . _meta . get_field_by_name ( self . field_name ) name = self . field_name except FieldDoesNotExist : name = [ f . name for f in cls . _meta . fields if f . attname == self . field_name ] [ 0 ] val = getattr ( cls . _base_manager . filter ( pk = instance . pk ) . only ( name ) . using ( instance . _state . db ) . get ( ) , self . field_name ) data [ self . field_name ] = val return data [ self . field_name ] def __set__ ( self , instance , value ) : instance . __dict__ [ self . field_name ] = value def select_related_descend ( field , restricted , requested , reverse = False ) : if not field . rel : return False if field . rel . parent_link and not reverse : return False if restricted : if reverse and field . related_query_name ( ) not in requested : return False if not reverse and field . name not in requested : return False if not restricted and field . null : return False return True def deferred_class_factory ( model , attrs ) : class Meta : proxy = True app_label = model . _meta . app_label name = "%s_Deferred_%s" % ( model . __name__ , '_' . join ( sorted ( list ( attrs ) ) ) ) name = util . truncate_name ( name , 80 , 32 ) overrides = dict ( [ ( attr , DeferredAttribute ( attr , model ) ) for attr in attrs ] ) overrides [ "Meta" ] = Meta overrides [ "__module__" ] = model . __module__ overrides [ "_deferred" ] = True return type ( name , ( model , ) , overrides ) deferred_class_factory . __safe_for_unpickling__ = True

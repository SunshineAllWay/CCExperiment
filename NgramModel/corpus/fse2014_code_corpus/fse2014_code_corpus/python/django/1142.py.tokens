"Base Cache class." import warnings from django . core . exceptions import ImproperlyConfigured , DjangoRuntimeWarning from django . utils . encoding import smart_str from django . utils . importlib import import_module class InvalidCacheBackendError ( ImproperlyConfigured ) : pass class CacheKeyWarning ( DjangoRuntimeWarning ) : pass MEMCACHE_MAX_KEY_LENGTH = 250 def default_key_func ( key , key_prefix , version ) : return ':' . join ( [ key_prefix , str ( version ) , smart_str ( key ) ] ) def get_key_func ( key_func ) : if key_func is not None : if callable ( key_func ) : return key_func else : key_func_module_path , key_func_name = key_func . rsplit ( '.' , 1 ) key_func_module = import_module ( key_func_module_path ) return getattr ( key_func_module , key_func_name ) return default_key_func class BaseCache ( object ) : def __init__ ( self , params ) : timeout = params . get ( 'timeout' , params . get ( 'TIMEOUT' , 300 ) ) try : timeout = int ( timeout ) except ( ValueError , TypeError ) : timeout = 300 self . default_timeout = timeout options = params . get ( 'OPTIONS' , { } ) max_entries = params . get ( 'max_entries' , options . get ( 'MAX_ENTRIES' , 300 ) ) try : self . _max_entries = int ( max_entries ) except ( ValueError , TypeError ) : self . _max_entries = 300 cull_frequency = params . get ( 'cull_frequency' , options . get ( 'CULL_FREQUENCY' , 3 ) ) try : self . _cull_frequency = int ( cull_frequency ) except ( ValueError , TypeError ) : self . _cull_frequency = 3 self . key_prefix = smart_str ( params . get ( 'KEY_PREFIX' , '' ) ) self . version = params . get ( 'VERSION' , 1 ) self . key_func = get_key_func ( params . get ( 'KEY_FUNCTION' , None ) ) def make_key ( self , key , version = None ) : if version is None : version = self . version new_key = self . key_func ( key , self . key_prefix , version ) return new_key def add ( self , key , value , timeout = None , version = None ) : raise NotImplementedError def get ( self , key , default = None , version = None ) : raise NotImplementedError def set ( self , key , value , timeout = None , version = None ) : raise NotImplementedError def delete ( self , key , version = None ) : raise NotImplementedError def get_many ( self , keys , version = None ) : d = { } for k in keys : val = self . get ( k , version = version ) if val is not None : d [ k ] = val return d def has_key ( self , key , version = None ) : return self . get ( key , version = version ) is not None def incr ( self , key , delta = 1 , version = None ) : value = self . get ( key , version = version ) if value is None : raise ValueError ( "Key '%s' not found" % key ) new_value = value + delta self . set ( key , new_value , version = version ) return new_value def decr ( self , key , delta = 1 , version = None ) : return self . incr ( key , - delta , version = version ) def __contains__ ( self , key ) : return self . has_key ( key ) def set_many ( self , data , timeout = None , version = None ) : for key , value in data . items ( ) : self . set ( key , value , timeout = timeout , version = version ) def delete_many ( self , keys , version = None ) : for key in keys : self . delete ( key , version = version ) def clear ( self ) : raise NotImplementedError def validate_key ( self , key ) : if len ( key ) > MEMCACHE_MAX_KEY_LENGTH : warnings . warn ( 'Cache key will cause errors if used with memcached: ' % ( key , MEMCACHE_MAX_KEY_LENGTH ) , CacheKeyWarning ) for char in key : if ord ( char ) < 33 or ord ( char ) == 127 : warnings . warn ( 'Cache key contains characters that will cause ' % key , CacheKeyWarning ) def incr_version ( self , key , delta = 1 , version = None ) : if version is None : version = self . version value = self . get ( key , version = version ) if value is None : raise ValueError ( "Key '%s' not found" % key ) self . set ( key , value , version = version + delta ) self . delete ( key , version = version ) return version + delta def decr_version ( self , key , delta = 1 , version = None ) : return self . incr_version ( key , - delta , version )

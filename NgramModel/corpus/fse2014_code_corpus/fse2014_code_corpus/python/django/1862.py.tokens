""" SQLite3 backend for django. Works with either the pysqlite2 module or the sqlite3 module in the standard library. """ import datetime import decimal import warnings import re import sys from django . db import utils from django . db . backends import * from django . db . backends . signals import connection_created from django . db . backends . sqlite3 . client import DatabaseClient from django . db . backends . sqlite3 . creation import DatabaseCreation from django . db . backends . sqlite3 . introspection import DatabaseIntrospection from django . utils . dateparse import parse_date , parse_datetime , parse_time from django . utils . safestring import SafeString from django . utils . timezone import is_aware , is_naive , utc try : try : from pysqlite2 import dbapi2 as Database except ImportError , e1 : from sqlite3 import dbapi2 as Database except ImportError , exc : from django . core . exceptions import ImproperlyConfigured raise ImproperlyConfigured ( "Error loading either pysqlite2 or sqlite3 modules (tried in that order): %s" % exc ) DatabaseError = Database . DatabaseError IntegrityError = Database . IntegrityError def parse_datetime_with_timezone_support ( value ) : dt = parse_datetime ( value ) if dt is not None and settings . USE_TZ and is_naive ( dt ) : dt = dt . replace ( tzinfo = utc ) return dt Database . register_converter ( "bool" , lambda s : str ( s ) == '1' ) Database . register_converter ( "time" , parse_time ) Database . register_converter ( "date" , parse_date ) Database . register_converter ( "datetime" , parse_datetime_with_timezone_support ) Database . register_converter ( "timestamp" , parse_datetime_with_timezone_support ) Database . register_converter ( "TIMESTAMP" , parse_datetime_with_timezone_support ) Database . register_converter ( "decimal" , util . typecast_decimal ) Database . register_adapter ( decimal . Decimal , util . rev_typecast_decimal ) if Database . version_info >= ( 2 , 4 , 1 ) : Database . register_adapter ( str , lambda s : s . decode ( 'utf-8' ) ) Database . register_adapter ( SafeString , lambda s : s . decode ( 'utf-8' ) ) class DatabaseFeatures ( BaseDatabaseFeatures ) : can_use_chunked_reads = False test_db_allows_multiple_connections = False supports_unspecified_pk = True supports_timezones = False supports_1000_query_parameters = False supports_mixed_date_datetime_comparisons = False has_bulk_insert = True can_combine_inserts_with_and_without_auto_increment_pk = True def _supports_stddev ( self ) : cursor = self . connection . cursor ( ) cursor . execute ( 'CREATE TABLE STDDEV_TEST (X INT)' ) try : cursor . execute ( 'SELECT STDDEV(*) FROM STDDEV_TEST' ) has_support = True except utils . DatabaseError : has_support = False cursor . execute ( 'DROP TABLE STDDEV_TEST' ) return has_support class DatabaseOperations ( BaseDatabaseOperations ) : def date_extract_sql ( self , lookup_type , field_name ) : return "django_extract('%s', %s)" % ( lookup_type . lower ( ) , field_name ) def date_interval_sql ( self , sql , connector , timedelta ) : return u'django_format_dtdelta(%s, "%s", "%d", "%d", "%d")' % ( sql , connector , timedelta . days , timedelta . seconds , timedelta . microseconds ) def date_trunc_sql ( self , lookup_type , field_name ) : return "django_date_trunc('%s', %s)" % ( lookup_type . lower ( ) , field_name ) def drop_foreignkey_sql ( self ) : return "" def pk_default_value ( self ) : return "NULL" def quote_name ( self , name ) : if name . startswith ( '"' ) and name . endswith ( '"' ) : return name return '"%s"' % name def no_limit_value ( self ) : return - 1 def sql_flush ( self , style , tables , sequences ) : sql = [ '%s %s %s;' % ( style . SQL_KEYWORD ( 'DELETE' ) , style . SQL_KEYWORD ( 'FROM' ) , style . SQL_FIELD ( self . quote_name ( table ) ) ) for table in tables ] return sql def value_to_db_datetime ( self , value ) : if value is None : return None if is_aware ( value ) : if settings . USE_TZ : value = value . astimezone ( utc ) . replace ( tzinfo = None ) else : raise ValueError ( "SQLite backend does not support timezone-aware datetimes when USE_TZ is False." ) return unicode ( value ) def value_to_db_time ( self , value ) : if value is None : return None if is_aware ( value ) : raise ValueError ( "SQLite backend does not support timezone-aware times." ) return unicode ( value ) def year_lookup_bounds ( self , value ) : first = '%s-01-01' second = '%s-12-31 23:59:59.999999' return [ first % value , second % value ] def convert_values ( self , value , field ) : internal_type = field . get_internal_type ( ) if internal_type == 'DecimalField' : return util . typecast_decimal ( field . format_number ( value ) ) elif internal_type and internal_type . endswith ( 'IntegerField' ) or internal_type == 'AutoField' : return int ( value ) elif internal_type == 'DateField' : return parse_date ( value ) elif internal_type == 'DateTimeField' : return parse_datetime_with_timezone_support ( value ) elif internal_type == 'TimeField' : return parse_time ( value ) return value def bulk_insert_sql ( self , fields , num_values ) : res = [ ] res . append ( "SELECT %s" % ", " . join ( % self . quote_name ( f . column ) for f in fields ) ) res . extend ( [ "UNION SELECT %s" % ", " . join ( [ "%s" ] * len ( fields ) ) ] * ( num_values - 1 ) ) return " " . join ( res ) class DatabaseWrapper ( BaseDatabaseWrapper ) : vendor = 'sqlite' operators = { : '= %s' , : "LIKE %s ESCAPE '\\'" , : "LIKE %s ESCAPE '\\'" , : "LIKE %s ESCAPE '\\'" , : 'REGEXP %s' , : "REGEXP '(?i)' || %s" , : '> %s' , : '>= %s' , : '< %s' , : '<= %s' , : "LIKE %s ESCAPE '\\'" , : "LIKE %s ESCAPE '\\'" , : "LIKE %s ESCAPE '\\'" , : "LIKE %s ESCAPE '\\'" , } def __init__ ( self , * args , ** kwargs ) : super ( DatabaseWrapper , self ) . __init__ ( * args , ** kwargs ) self . features = DatabaseFeatures ( self ) self . ops = DatabaseOperations ( self ) self . client = DatabaseClient ( self ) self . creation = DatabaseCreation ( self ) self . introspection = DatabaseIntrospection ( self ) self . validation = BaseDatabaseValidation ( self ) def _sqlite_create_connection ( self ) : settings_dict = self . settings_dict if not settings_dict [ 'NAME' ] : from django . core . exceptions import ImproperlyConfigured raise ImproperlyConfigured ( "Please fill out the database NAME in the settings module before using the database." ) kwargs = { : settings_dict [ 'NAME' ] , : Database . PARSE_DECLTYPES | Database . PARSE_COLNAMES , } kwargs . update ( settings_dict [ 'OPTIONS' ] ) if 'check_same_thread' in kwargs and kwargs [ 'check_same_thread' ] : warnings . warn ( , RuntimeWarning ) kwargs . update ( { 'check_same_thread' : False } ) self . connection = Database . connect ( ** kwargs ) self . connection . create_function ( "django_extract" , 2 , _sqlite_extract ) self . connection . create_function ( "django_date_trunc" , 2 , _sqlite_date_trunc ) self . connection . create_function ( "regexp" , 2 , _sqlite_regexp ) self . connection . create_function ( "django_format_dtdelta" , 5 , _sqlite_format_dtdelta ) connection_created . send ( sender = self . __class__ , connection = self ) def _cursor ( self ) : if self . connection is None : self . _sqlite_create_connection ( ) return self . connection . cursor ( factory = SQLiteCursorWrapper ) def check_constraints ( self , table_names = None ) : cursor = self . cursor ( ) if table_names is None : table_names = self . introspection . get_table_list ( cursor ) for table_name in table_names : primary_key_column_name = self . introspection . get_primary_key_column ( cursor , table_name ) if not primary_key_column_name : continue key_columns = self . introspection . get_key_columns ( cursor , table_name ) for column_name , referenced_table_name , referenced_column_name in key_columns : cursor . execute ( """ SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING LEFT JOIN `%s` as REFERRED ON (REFERRING.`%s` = REFERRED.`%s`) WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL""" % ( primary_key_column_name , column_name , table_name , referenced_table_name , column_name , referenced_column_name , column_name , referenced_column_name ) ) for bad_row in cursor . fetchall ( ) : raise utils . IntegrityError ( "The row in table '%s' with primary key '%s' has an invalid " % ( table_name , bad_row [ 0 ] , table_name , column_name , bad_row [ 1 ] , referenced_table_name , referenced_column_name ) ) def close ( self ) : self . validate_thread_sharing ( ) if self . settings_dict [ 'NAME' ] != ":memory:" : BaseDatabaseWrapper . close ( self ) FORMAT_QMARK_REGEX = re . compile ( r'(?<!%)%s' ) class SQLiteCursorWrapper ( Database . Cursor ) : def execute ( self , query , params = ( ) ) : query = self . convert_query ( query ) try : return Database . Cursor . execute ( self , query , params ) except Database . IntegrityError , e : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] except Database . DatabaseError , e : raise utils . DatabaseError , utils . DatabaseError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] def executemany ( self , query , param_list ) : query = self . convert_query ( query ) try : return Database . Cursor . executemany ( self , query , param_list ) except Database . IntegrityError , e : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] except Database . DatabaseError , e : raise utils . DatabaseError , utils . DatabaseError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] def convert_query ( self , query ) : return FORMAT_QMARK_REGEX . sub ( '?' , query ) . replace ( '%%' , '%' ) def _sqlite_extract ( lookup_type , dt ) : if dt is None : return None try : dt = util . typecast_timestamp ( dt ) except ( ValueError , TypeError ) : return None if lookup_type == 'week_day' : return ( dt . isoweekday ( ) % 7 ) + 1 else : return getattr ( dt , lookup_type ) def _sqlite_date_trunc ( lookup_type , dt ) : try : dt = util . typecast_timestamp ( dt ) except ( ValueError , TypeError ) : return None if lookup_type == 'year' : return "%i-01-01 00:00:00" % dt . year elif lookup_type == 'month' : return "%i-%02i-01 00:00:00" % ( dt . year , dt . month ) elif lookup_type == 'day' : return "%i-%02i-%02i 00:00:00" % ( dt . year , dt . month , dt . day ) def _sqlite_format_dtdelta ( dt , conn , days , secs , usecs ) : try : dt = util . typecast_timestamp ( dt ) delta = datetime . timedelta ( int ( days ) , int ( secs ) , int ( usecs ) ) if conn . strip ( ) == '+' : dt = dt + delta else : dt = dt - delta except ( ValueError , TypeError ) : return None return str ( dt ) def _sqlite_regexp ( re_pattern , re_string ) : try : return bool ( re . search ( re_pattern , re_string ) ) except : return False

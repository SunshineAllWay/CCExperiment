from __future__ import absolute_import import os from copy import copy from decimal import Decimal from django . utils . unittest import TestCase from django . contrib . gis . gdal import DataSource from django . contrib . gis . tests . utils import mysql from django . contrib . gis . utils . layermapping import LayerMapping , LayerMapError , InvalidDecimal , MissingForeignKey from . models import ( City , County , CountyFeat , Interstate , ICity1 , ICity2 , Invalid , State , city_mapping , co_mapping , cofeat_mapping , inter_mapping ) shp_path = os . path . realpath ( os . path . join ( os . path . dirname ( __file__ ) , os . pardir , 'data' ) ) city_shp = os . path . join ( shp_path , 'cities' , 'cities.shp' ) co_shp = os . path . join ( shp_path , 'counties' , 'counties.shp' ) inter_shp = os . path . join ( shp_path , 'interstates' , 'interstates.shp' ) invalid_shp = os . path . join ( shp_path , 'invalid' , 'emptypoints.shp' ) NAMES = [ 'Bexar' , 'Galveston' , 'Harris' , 'Honolulu' , 'Pueblo' ] NUMS = [ 1 , 2 , 1 , 19 , 1 ] STATES = [ 'Texas' , 'Texas' , 'Texas' , 'Hawaii' , 'Colorado' ] class LayerMapTest ( TestCase ) : def test01_init ( self ) : bad1 = copy ( city_mapping ) bad1 [ 'foobar' ] = 'FooField' bad2 = copy ( city_mapping ) bad2 [ 'name' ] = 'Nombre' bad3 = copy ( city_mapping ) bad3 [ 'point' ] = 'CURVE' for bad_map in ( bad1 , bad2 , bad3 ) : try : lm = LayerMapping ( City , city_shp , bad_map ) except LayerMapError : pass else : self . fail ( 'Expected a LayerMapError.' ) try : lm = LayerMapping ( City , city_shp , city_mapping , encoding = 'foobar' ) except LookupError : pass else : self . fail ( 'Expected a LookupError' ) def test02_simple_layermap ( self ) : lm = LayerMapping ( City , city_shp , city_mapping ) lm . save ( ) self . assertEqual ( 3 , City . objects . count ( ) ) ds = DataSource ( city_shp ) layer = ds [ 0 ] for feat in layer : city = City . objects . get ( name = feat [ 'Name' ] . value ) self . assertEqual ( feat [ 'Population' ] . value , city . population ) self . assertEqual ( Decimal ( str ( feat [ 'Density' ] ) ) , city . density ) self . assertEqual ( feat [ 'Created' ] . value , city . dt ) pnt1 , pnt2 = feat . geom , city . point self . assertAlmostEqual ( pnt1 . x , pnt2 . x , 5 ) self . assertAlmostEqual ( pnt1 . y , pnt2 . y , 5 ) def test03_layermap_strict ( self ) : try : lm = LayerMapping ( Interstate , inter_shp , inter_mapping ) lm . save ( silent = True , strict = True ) except InvalidDecimal : if mysql : Interstate . objects . all ( ) . delete ( ) else : self . fail ( 'Should have failed on strict import with invalid decimal values.' ) lm = LayerMapping ( Interstate , inter_shp , inter_mapping ) lm . save ( silent = True ) self . assertEqual ( 2 , Interstate . objects . count ( ) ) ds = DataSource ( inter_shp ) valid_feats = ds [ 0 ] [ : 2 ] for feat in valid_feats : istate = Interstate . objects . get ( name = feat [ 'Name' ] . value ) if feat . fid == 0 : self . assertEqual ( Decimal ( str ( feat [ 'Length' ] ) ) , istate . length ) elif feat . fid == 1 : self . assertAlmostEqual ( feat . get ( 'Length' ) , float ( istate . length ) , 2 ) for p1 , p2 in zip ( feat . geom , istate . path ) : self . assertAlmostEqual ( p1 [ 0 ] , p2 [ 0 ] , 6 ) self . assertAlmostEqual ( p1 [ 1 ] , p2 [ 1 ] , 6 ) def county_helper ( self , county_feat = True ) : for name , n , st in zip ( NAMES , NUMS , STATES ) : c = County . objects . get ( name = name ) self . assertEqual ( n , len ( c . mpoly ) ) self . assertEqual ( st , c . state . name ) if county_feat : qs = CountyFeat . objects . filter ( name = name ) self . assertEqual ( n , qs . count ( ) ) def test04_layermap_unique_multigeometry_fk ( self ) : try : lm = LayerMapping ( County , co_shp , co_mapping , transform = False ) lm = LayerMapping ( County , co_shp , co_mapping , source_srs = 4269 ) lm = LayerMapping ( County , co_shp , co_mapping , source_srs = 'NAD83' ) for arg in ( 'name' , ( 'name' , 'mpoly' ) ) : lm = LayerMapping ( County , co_shp , co_mapping , transform = False , unique = arg ) except : self . fail ( 'No exception should be raised for proper use of keywords.' ) for e , arg in ( ( TypeError , 5.0 ) , ( ValueError , 'foobar' ) , ( ValueError , ( 'name' , 'mpolygon' ) ) ) : self . assertRaises ( e , LayerMapping , County , co_shp , co_mapping , transform = False , unique = arg ) if not mysql : self . assertRaises ( LayerMapError , LayerMapping , County , co_shp , co_mapping ) bad_fk_map1 = copy ( co_mapping ) ; bad_fk_map1 [ 'state' ] = 'name' bad_fk_map2 = copy ( co_mapping ) ; bad_fk_map2 [ 'state' ] = { 'nombre' : 'State' } self . assertRaises ( TypeError , LayerMapping , County , co_shp , bad_fk_map1 , transform = False ) self . assertRaises ( LayerMapError , LayerMapping , County , co_shp , bad_fk_map2 , transform = False ) lm = LayerMapping ( County , co_shp , co_mapping , transform = False , unique = 'name' ) self . assertRaises ( MissingForeignKey , lm . save , silent = True , strict = True ) co , hi , tx = State ( name = 'Colorado' ) , State ( name = 'Hawaii' ) , State ( name = 'Texas' ) co . save ( ) , hi . save ( ) , tx . save ( ) lm = LayerMapping ( County , co_shp , co_mapping , transform = False , unique = 'name' ) lm . save ( silent = True , strict = True ) lm = LayerMapping ( CountyFeat , co_shp , cofeat_mapping , transform = False ) lm . save ( silent = True , strict = True ) self . county_helper ( ) def test05_test_fid_range_step ( self ) : def clear_counties ( ) : County . objects . all ( ) . delete ( ) lm = LayerMapping ( County , co_shp , co_mapping , transform = False , unique = 'name' ) clear_counties ( ) bad_ranges = ( 5.0 , 'foo' , co_shp ) for bad in bad_ranges : self . assertRaises ( TypeError , lm . save , fid_range = bad ) fr = ( 3 , 5 ) self . assertRaises ( LayerMapError , lm . save , fid_range = fr , step = 10 ) lm . save ( fid_range = fr ) qs = County . objects . all ( ) self . assertEqual ( 1 , qs . count ( ) ) self . assertEqual ( 'Galveston' , qs [ 0 ] . name ) clear_counties ( ) lm . save ( fid_range = slice ( 5 , None ) , silent = True , strict = True ) lm . save ( fid_range = slice ( None , 1 ) , silent = True , strict = True ) qs = County . objects . order_by ( 'name' ) self . assertEqual ( 2 , qs . count ( ) ) hi , co = tuple ( qs ) hi_idx , co_idx = tuple ( map ( NAMES . index , ( 'Honolulu' , 'Pueblo' ) ) ) self . assertEqual ( 'Pueblo' , co . name ) ; self . assertEqual ( NUMS [ co_idx ] , len ( co . mpoly ) ) self . assertEqual ( 'Honolulu' , hi . name ) ; self . assertEqual ( NUMS [ hi_idx ] , len ( hi . mpoly ) ) for st in ( 4 , 7 , 1000 ) : clear_counties ( ) lm . save ( step = st , strict = True ) self . county_helper ( county_feat = False ) def test06_model_inheritance ( self ) : icity_mapping = { 'name' : 'Name' , : 'Population' , : 'Density' , : 'POINT' , : 'Created' , } lm1 = LayerMapping ( ICity1 , city_shp , icity_mapping ) lm1 . save ( ) lm2 = LayerMapping ( ICity2 , city_shp , icity_mapping ) lm2 . save ( ) self . assertEqual ( 6 , ICity1 . objects . count ( ) ) self . assertEqual ( 3 , ICity2 . objects . count ( ) ) def test07_invalid_layer ( self ) : invalid_mapping = { 'point' : 'POINT' } lm = LayerMapping ( Invalid , invalid_shp , invalid_mapping , source_srs = 4326 ) lm . save ( silent = True )

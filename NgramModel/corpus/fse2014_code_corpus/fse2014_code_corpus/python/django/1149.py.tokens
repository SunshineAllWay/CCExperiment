""" Base classes for writing management commands (named commands which can be executed through ``django-admin.py`` or ``manage.py``). """ from __future__ import with_statement import os import sys from optparse import make_option , OptionParser import traceback import django from django . core . exceptions import ImproperlyConfigured from django . core . management . color import color_style from django . utils . encoding import smart_str class CommandError ( Exception ) : pass def handle_default_options ( options ) : if options . settings : os . environ [ 'DJANGO_SETTINGS_MODULE' ] = options . settings if options . pythonpath : sys . path . insert ( 0 , options . pythonpath ) class BaseCommand ( object ) : option_list = ( make_option ( '-v' , '--verbosity' , action = 'store' , dest = 'verbosity' , default = '1' , type = 'choice' , choices = [ '0' , '1' , '2' , '3' ] , help = 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output' ) , make_option ( '--settings' , help = 'The Python path to a settings module, e.g. "myproject.settings.main". If this isn\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.' ) , make_option ( '--pythonpath' , help = 'A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".' ) , make_option ( '--traceback' , action = 'store_true' , help = 'Print traceback on exception' ) , ) help = '' args = '' can_import_settings = True requires_model_validation = True output_transaction = False def __init__ ( self ) : self . style = color_style ( ) def get_version ( self ) : return django . get_version ( ) def usage ( self , subcommand ) : usage = '%%prog %s [options] %s' % ( subcommand , self . args ) if self . help : return '%s\n\n%s' % ( usage , self . help ) else : return usage def create_parser ( self , prog_name , subcommand ) : return OptionParser ( prog = prog_name , usage = self . usage ( subcommand ) , version = self . get_version ( ) , option_list = self . option_list ) def print_help ( self , prog_name , subcommand ) : parser = self . create_parser ( prog_name , subcommand ) parser . print_help ( ) def run_from_argv ( self , argv ) : parser = self . create_parser ( argv [ 0 ] , argv [ 1 ] ) options , args = parser . parse_args ( argv [ 2 : ] ) handle_default_options ( options ) self . execute ( * args , ** options . __dict__ ) def execute ( self , * args , ** options ) : show_traceback = options . get ( 'traceback' , False ) saved_lang = None if self . can_import_settings : try : from django . utils import translation saved_lang = translation . get_language ( ) translation . activate ( 'en-us' ) except ImportError , e : if show_traceback : traceback . print_exc ( ) else : sys . stderr . write ( smart_str ( self . style . ERROR ( 'Error: %s\n' % e ) ) ) sys . exit ( 1 ) try : self . stdout = options . get ( 'stdout' , sys . stdout ) self . stderr = options . get ( 'stderr' , sys . stderr ) if self . requires_model_validation : self . validate ( ) output = self . handle ( * args , ** options ) if output : if self . output_transaction : from django . db import connections , DEFAULT_DB_ALIAS connection = connections [ options . get ( 'database' , DEFAULT_DB_ALIAS ) ] if connection . ops . start_transaction_sql ( ) : self . stdout . write ( self . style . SQL_KEYWORD ( connection . ops . start_transaction_sql ( ) ) + '\n' ) self . stdout . write ( output ) if self . output_transaction : self . stdout . write ( '\n' + self . style . SQL_KEYWORD ( "COMMIT;" ) + '\n' ) except CommandError , e : if show_traceback : traceback . print_exc ( ) else : self . stderr . write ( smart_str ( self . style . ERROR ( 'Error: %s\n' % e ) ) ) sys . exit ( 1 ) if saved_lang is not None : translation . activate ( saved_lang ) def validate ( self , app = None , display_num_errors = False ) : from django . core . management . validation import get_validation_errors try : from cStringIO import StringIO except ImportError : from StringIO import StringIO s = StringIO ( ) num_errors = get_validation_errors ( s , app ) if num_errors : s . seek ( 0 ) error_text = s . read ( ) raise CommandError ( "One or more models did not validate:\n%s" % error_text ) if display_num_errors : self . stdout . write ( "%s error%s found\n" % ( num_errors , num_errors != 1 and 's' or '' ) ) def handle ( self , * args , ** options ) : raise NotImplementedError ( ) class AppCommand ( BaseCommand ) : args = '<appname appname ...>' def handle ( self , * app_labels , ** options ) : from django . db import models if not app_labels : raise CommandError ( 'Enter at least one appname.' ) try : app_list = [ models . get_app ( app_label ) for app_label in app_labels ] except ( ImproperlyConfigured , ImportError ) , e : raise CommandError ( "%s. Are you sure your INSTALLED_APPS setting is correct?" % e ) output = [ ] for app in app_list : app_output = self . handle_app ( app , ** options ) if app_output : output . append ( app_output ) return '\n' . join ( output ) def handle_app ( self , app , ** options ) : raise NotImplementedError ( ) class LabelCommand ( BaseCommand ) : args = '<label label ...>' label = 'label' def handle ( self , * labels , ** options ) : if not labels : raise CommandError ( 'Enter at least one %s.' % self . label ) output = [ ] for label in labels : label_output = self . handle_label ( label , ** options ) if label_output : output . append ( label_output ) return '\n' . join ( output ) def handle_label ( self , label , ** options ) : raise NotImplementedError ( ) class NoArgsCommand ( BaseCommand ) : args = '' def handle ( self , * args , ** options ) : if args : raise CommandError ( "Command doesn't accept any arguments" ) return self . handle_noargs ( ** options ) def handle_noargs ( self , ** options ) : raise NotImplementedError ( )

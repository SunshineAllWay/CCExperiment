from django . core . exceptions import ImproperlyConfigured , ObjectDoesNotExist from django . http import Http404 from django . utils . encoding import smart_str from django . utils . translation import ugettext as _ from django . views . generic . base import TemplateResponseMixin , View class SingleObjectMixin ( object ) : model = None queryset = None slug_field = 'slug' context_object_name = None slug_url_kwarg = 'slug' pk_url_kwarg = 'pk' def get_object ( self , queryset = None ) : if queryset is None : queryset = self . get_queryset ( ) pk = self . kwargs . get ( self . pk_url_kwarg , None ) slug = self . kwargs . get ( self . slug_url_kwarg , None ) if pk is not None : queryset = queryset . filter ( pk = pk ) elif slug is not None : slug_field = self . get_slug_field ( ) queryset = queryset . filter ( ** { slug_field : slug } ) else : raise AttributeError ( u"Generic detail view %s must be called with " % self . __class__ . __name__ ) try : obj = queryset . get ( ) except ObjectDoesNotExist : raise Http404 ( _ ( u"No %(verbose_name)s found matching the query" ) % { 'verbose_name' : queryset . model . _meta . verbose_name } ) return obj def get_queryset ( self ) : if self . queryset is None : if self . model : return self . model . _default_manager . all ( ) else : raise ImproperlyConfigured ( u"%(cls)s is missing a queryset. Define " % { : self . __class__ . __name__ } ) return self . queryset . _clone ( ) def get_slug_field ( self ) : return self . slug_field def get_context_object_name ( self , obj ) : if self . context_object_name : return self . context_object_name elif hasattr ( obj , '_meta' ) : return smart_str ( obj . _meta . object_name . lower ( ) ) else : return None def get_context_data ( self , ** kwargs ) : context = kwargs context_object_name = self . get_context_object_name ( self . object ) if context_object_name : context [ context_object_name ] = self . object return context class BaseDetailView ( SingleObjectMixin , View ) : def get ( self , request , * args , ** kwargs ) : self . object = self . get_object ( ) context = self . get_context_data ( object = self . object ) return self . render_to_response ( context ) class SingleObjectTemplateResponseMixin ( TemplateResponseMixin ) : template_name_field = None template_name_suffix = '_detail' def get_template_names ( self ) : try : names = super ( SingleObjectTemplateResponseMixin , self ) . get_template_names ( ) except ImproperlyConfigured : names = [ ] if self . object and self . template_name_field : name = getattr ( self . object , self . template_name_field , None ) if name : names . insert ( 0 , name ) if hasattr ( self . object , '_meta' ) : names . append ( "%s/%s%s.html" % ( self . object . _meta . app_label , self . object . _meta . object_name . lower ( ) , self . template_name_suffix ) ) elif hasattr ( self , 'model' ) and hasattr ( self . model , '_meta' ) : names . append ( "%s/%s%s.html" % ( self . model . _meta . app_label , self . model . _meta . object_name . lower ( ) , self . template_name_suffix ) ) return names class DetailView ( SingleObjectTemplateResponseMixin , BaseDetailView ) :

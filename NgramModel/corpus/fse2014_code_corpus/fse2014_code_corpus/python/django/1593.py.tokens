import operator from django . core . exceptions import SuspiciousOperation , ImproperlyConfigured from django . core . paginator import InvalidPage from django . db import models from django . utils . datastructures import SortedDict from django . utils . encoding import force_unicode , smart_str from django . utils . translation import ugettext , ugettext_lazy from django . utils . http import urlencode from django . contrib . admin import FieldListFilter from django . contrib . admin . options import IncorrectLookupParameters from django . contrib . admin . util import ( quote , get_fields_from_path , lookup_needs_distinct , prepare_lookup_value ) ALL_VAR = 'all' ORDER_VAR = 'o' ORDER_TYPE_VAR = 'ot' PAGE_VAR = 'p' SEARCH_VAR = 'q' TO_FIELD_VAR = 't' IS_POPUP_VAR = 'pop' ERROR_FLAG = 'e' IGNORED_PARAMS = ( ALL_VAR , ORDER_VAR , ORDER_TYPE_VAR , SEARCH_VAR , IS_POPUP_VAR , TO_FIELD_VAR ) EMPTY_CHANGELIST_VALUE = ugettext_lazy ( '(None)' ) class ChangeList ( object ) : def __init__ ( self , request , model , list_display , list_display_links , list_filter , date_hierarchy , search_fields , list_select_related , list_per_page , list_max_show_all , list_editable , model_admin ) : self . model = model self . opts = model . _meta self . lookup_opts = self . opts self . root_query_set = model_admin . queryset ( request ) self . list_display = list_display self . list_display_links = list_display_links self . list_filter = list_filter self . date_hierarchy = date_hierarchy self . search_fields = search_fields self . list_select_related = list_select_related self . list_per_page = list_per_page self . list_max_show_all = list_max_show_all self . model_admin = model_admin try : self . page_num = int ( request . GET . get ( PAGE_VAR , 0 ) ) except ValueError : self . page_num = 0 self . show_all = ALL_VAR in request . GET self . is_popup = IS_POPUP_VAR in request . GET self . to_field = request . GET . get ( TO_FIELD_VAR ) self . params = dict ( request . GET . items ( ) ) if PAGE_VAR in self . params : del self . params [ PAGE_VAR ] if ERROR_FLAG in self . params : del self . params [ ERROR_FLAG ] if self . is_popup : self . list_editable = ( ) else : self . list_editable = list_editable self . ordering = self . get_ordering ( request ) self . query = request . GET . get ( SEARCH_VAR , '' ) self . query_set = self . get_query_set ( request ) self . get_results ( request ) if self . is_popup : title = ugettext ( 'Select %s' ) else : title = ugettext ( 'Select %s to change' ) self . title = title % force_unicode ( self . opts . verbose_name ) self . pk_attname = self . lookup_opts . pk . attname def get_filters ( self , request ) : lookup_params = self . params . copy ( ) use_distinct = False for ignored in IGNORED_PARAMS : if ignored in lookup_params : del lookup_params [ ignored ] for key , value in lookup_params . items ( ) : if not isinstance ( key , str ) : del lookup_params [ key ] lookup_params [ smart_str ( key ) ] = value if not self . model_admin . lookup_allowed ( key , value ) : raise SuspiciousOperation ( "Filtering by %s not allowed" % key ) filter_specs = [ ] if self . list_filter : for list_filter in self . list_filter : if callable ( list_filter ) : spec = list_filter ( request , lookup_params , self . model , self . model_admin ) else : field_path = None if isinstance ( list_filter , ( tuple , list ) ) : field , field_list_filter_class = list_filter else : field , field_list_filter_class = list_filter , FieldListFilter . create if not isinstance ( field , models . Field ) : field_path = field field = get_fields_from_path ( self . model , field_path ) [ - 1 ] spec = field_list_filter_class ( field , request , lookup_params , self . model , self . model_admin , field_path = field_path ) use_distinct = ( use_distinct or lookup_needs_distinct ( self . lookup_opts , field_path ) ) if spec and spec . has_output ( ) : filter_specs . append ( spec ) for key , value in lookup_params . items ( ) : lookup_params [ key ] = prepare_lookup_value ( key , value ) use_distinct = ( use_distinct or lookup_needs_distinct ( self . lookup_opts , key ) ) return filter_specs , bool ( filter_specs ) , lookup_params , use_distinct def get_query_string ( self , new_params = None , remove = None ) : if new_params is None : new_params = { } if remove is None : remove = [ ] p = self . params . copy ( ) for r in remove : for k in p . keys ( ) : if k . startswith ( r ) : del p [ k ] for k , v in new_params . items ( ) : if v is None : if k in p : del p [ k ] else : p [ k ] = v return '?%s' % urlencode ( p ) def get_results ( self , request ) : paginator = self . model_admin . get_paginator ( request , self . query_set , self . list_per_page ) result_count = paginator . count if not self . query_set . query . where : full_result_count = result_count else : full_result_count = self . root_query_set . count ( ) can_show_all = result_count <= self . list_max_show_all multi_page = result_count > self . list_per_page if ( self . show_all and can_show_all ) or not multi_page : result_list = self . query_set . _clone ( ) else : try : result_list = paginator . page ( self . page_num + 1 ) . object_list except InvalidPage : raise IncorrectLookupParameters self . result_count = result_count self . full_result_count = full_result_count self . result_list = result_list self . can_show_all = can_show_all self . multi_page = multi_page self . paginator = paginator def _get_default_ordering ( self ) : ordering = [ ] if self . model_admin . ordering : ordering = self . model_admin . ordering elif self . lookup_opts . ordering : ordering = self . lookup_opts . ordering return ordering def get_ordering_field ( self , field_name ) : try : field = self . lookup_opts . get_field ( field_name ) return field . name except models . FieldDoesNotExist : if callable ( field_name ) : attr = field_name elif hasattr ( self . model_admin , field_name ) : attr = getattr ( self . model_admin , field_name ) else : attr = getattr ( self . model , field_name ) return getattr ( attr , 'admin_order_field' , None ) def get_ordering ( self , request ) : params = self . params ordering = self . model_admin . get_ordering ( request ) or self . _get_default_ordering ( ) if ORDER_VAR in params : ordering = [ ] order_params = params [ ORDER_VAR ] . split ( '.' ) for p in order_params : try : none , pfx , idx = p . rpartition ( '-' ) field_name = self . list_display [ int ( idx ) ] order_field = self . get_ordering_field ( field_name ) if not order_field : continue ordering . append ( pfx + order_field ) except ( IndexError , ValueError ) : continue return ordering def get_ordering_field_columns ( self ) : ordering = self . _get_default_ordering ( ) ordering_fields = SortedDict ( ) if ORDER_VAR not in self . params : for field in ordering : if field . startswith ( '-' ) : field = field [ 1 : ] order_type = 'desc' else : order_type = 'asc' for index , attr in enumerate ( self . list_display ) : if self . get_ordering_field ( attr ) == field : ordering_fields [ index ] = order_type break else : for p in self . params [ ORDER_VAR ] . split ( '.' ) : none , pfx , idx = p . rpartition ( '-' ) try : idx = int ( idx ) except ValueError : continue ordering_fields [ idx ] = 'desc' if pfx == '-' else 'asc' return ordering_fields def get_query_set ( self , request ) : try : ( self . filter_specs , self . has_filters , remaining_lookup_params , use_distinct ) = self . get_filters ( request ) qs = self . root_query_set for filter_spec in self . filter_specs : new_qs = filter_spec . queryset ( request , qs ) if new_qs is not None : qs = new_qs qs = qs . filter ( ** remaining_lookup_params ) except ( SuspiciousOperation , ImproperlyConfigured ) : raise except Exception , e : raise IncorrectLookupParameters ( e ) if not qs . query . select_related : if self . list_select_related : qs = qs . select_related ( ) else : for field_name in self . list_display : try : field = self . lookup_opts . get_field ( field_name ) except models . FieldDoesNotExist : pass else : if isinstance ( field . rel , models . ManyToOneRel ) : qs = qs . select_related ( ) break if self . ordering : qs = qs . order_by ( * self . ordering ) def construct_search ( field_name ) : if field_name . startswith ( '^' ) : return "%s__istartswith" % field_name [ 1 : ] elif field_name . startswith ( '=' ) : return "%s__iexact" % field_name [ 1 : ] elif field_name . startswith ( '@' ) : return "%s__search" % field_name [ 1 : ] else : return "%s__icontains" % field_name if self . search_fields and self . query : orm_lookups = [ construct_search ( str ( search_field ) ) for search_field in self . search_fields ] for bit in self . query . split ( ) : or_queries = [ models . Q ( ** { orm_lookup : bit } ) for orm_lookup in orm_lookups ] qs = qs . filter ( reduce ( operator . or_ , or_queries ) ) if not use_distinct : for search_spec in orm_lookups : if lookup_needs_distinct ( self . lookup_opts , search_spec ) : use_distinct = True break if use_distinct : return qs . distinct ( ) else : return qs def url_for_result ( self , result ) : return "%s/" % quote ( getattr ( result , self . pk_attname ) )

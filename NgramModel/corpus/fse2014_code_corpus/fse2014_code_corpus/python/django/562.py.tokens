from __future__ import absolute_import import base64 import errno import hashlib import os import shutil from StringIO import StringIO from django . core . files import temp as tempfile from django . core . files . uploadedfile import SimpleUploadedFile from django . http . multipartparser import MultiPartParser from django . test import TestCase , client from django . utils import simplejson , unittest from . import uploadhandler from . models import FileModel , temp_storage , UPLOAD_TO UNICODE_FILENAME = u'test-0123456789_中文_Orléans.jpg' class FileUploadTests ( TestCase ) : def test_simple_upload ( self ) : post_data = { : 'Ringo' , : open ( __file__ ) , } response = self . client . post ( '/file_uploads/upload/' , post_data ) self . assertEqual ( response . status_code , 200 ) def test_large_upload ( self ) : tdir = tempfile . gettempdir ( ) file1 = tempfile . NamedTemporaryFile ( suffix = ".file1" , dir = tdir ) file1 . write ( 'a' * ( 2 ** 21 ) ) file1 . seek ( 0 ) file2 = tempfile . NamedTemporaryFile ( suffix = ".file2" , dir = tdir ) file2 . write ( 'a' * ( 10 * 2 ** 20 ) ) file2 . seek ( 0 ) post_data = { : 'Ringo' , : file1 , : file2 , } for key in post_data . keys ( ) : try : post_data [ key + '_hash' ] = hashlib . sha1 ( post_data [ key ] . read ( ) ) . hexdigest ( ) post_data [ key ] . seek ( 0 ) except AttributeError : post_data [ key + '_hash' ] = hashlib . sha1 ( post_data [ key ] ) . hexdigest ( ) response = self . client . post ( '/file_uploads/verify/' , post_data ) self . assertEqual ( response . status_code , 200 ) def test_base64_upload ( self ) : test_string = "This data will be transmitted base64-encoded." payload = "\r\n" . join ( [ + client . BOUNDARY , , , , , base64 . b64encode ( test_string ) , + client . BOUNDARY + '--' , , ] ) r = { : len ( payload ) , : client . MULTIPART_CONTENT , : "/file_uploads/echo_content/" , : 'POST' , : client . FakePayload ( payload ) , } response = self . client . request ( ** r ) received = simplejson . loads ( response . content ) self . assertEqual ( received [ 'file' ] , test_string ) def test_unicode_file_name ( self ) : tdir = tempfile . gettempdir ( ) file1 = open ( os . path . join ( tdir , UNICODE_FILENAME . encode ( 'utf-8' ) ) , 'w+b' ) file1 . write ( 'b' * ( 2 ** 10 ) ) file1 . seek ( 0 ) post_data = { : file1 , } response = self . client . post ( '/file_uploads/unicode_name/' , post_data ) file1 . close ( ) try : os . unlink ( file1 . name ) except : pass self . assertEqual ( response . status_code , 200 ) def test_dangerous_file_names ( self ) : scary_file_names = [ , , , , , , , , , , ] payload = [ ] for i , name in enumerate ( scary_file_names ) : payload . extend ( [ + client . BOUNDARY , % ( i , name ) , , , ] ) payload . extend ( [ + client . BOUNDARY + '--' , , ] ) payload = "\r\n" . join ( payload ) r = { : len ( payload ) , : client . MULTIPART_CONTENT , : "/file_uploads/echo/" , : 'POST' , : client . FakePayload ( payload ) , } response = self . client . request ( ** r ) recieved = simplejson . loads ( response . content ) for i , name in enumerate ( scary_file_names ) : got = recieved [ "file%s" % i ] self . assertEqual ( got , "hax0rd.txt" ) def test_filename_overflow ( self ) : name = "%s.txt" % ( "f" * 500 ) payload = "\r\n" . join ( [ + client . BOUNDARY , % name , , , + client . BOUNDARY + '--' , , ] ) r = { : len ( payload ) , : client . MULTIPART_CONTENT , : "/file_uploads/echo/" , : 'POST' , : client . FakePayload ( payload ) , } got = simplejson . loads ( self . client . request ( ** r ) . content ) self . assertTrue ( len ( got [ 'file' ] ) < 256 , "Got a long file name (%s characters)." % len ( got [ 'file' ] ) ) def test_truncated_multipart_handled_gracefully ( self ) : payload = "\r\n" . join ( [ + client . BOUNDARY , , , , + client . BOUNDARY + '--' , , ] ) payload = payload [ : - 10 ] r = { : len ( payload ) , : client . MULTIPART_CONTENT , : '/file_uploads/echo/' , : 'POST' , : client . FakePayload ( payload ) , } got = simplejson . loads ( self . client . request ( ** r ) . content ) self . assertEquals ( got , { } ) def test_empty_multipart_handled_gracefully ( self ) : r = { : 0 , : client . MULTIPART_CONTENT , : '/file_uploads/echo/' , : 'POST' , : client . FakePayload ( '' ) , } got = simplejson . loads ( self . client . request ( ** r ) . content ) self . assertEquals ( got , { } ) def test_custom_upload_handler ( self ) : smallfile = tempfile . NamedTemporaryFile ( ) smallfile . write ( 'a' * ( 2 ** 21 ) ) smallfile . seek ( 0 ) bigfile = tempfile . NamedTemporaryFile ( ) bigfile . write ( 'a' * ( 10 * 2 ** 20 ) ) bigfile . seek ( 0 ) response = self . client . post ( '/file_uploads/quota/' , { 'f' : smallfile } ) got = simplejson . loads ( response . content ) self . assertTrue ( 'f' in got ) response = self . client . post ( "/file_uploads/quota/" , { 'f' : bigfile } ) got = simplejson . loads ( response . content ) self . assertTrue ( 'f' not in got ) def test_broken_custom_upload_handler ( self ) : f = tempfile . NamedTemporaryFile ( ) f . write ( 'a' * ( 2 ** 21 ) ) f . seek ( 0 ) self . assertRaises ( AttributeError , self . client . post , , { 'f' : f } ) def test_fileupload_getlist ( self ) : file1 = tempfile . NamedTemporaryFile ( ) file1 . write ( 'a' * ( 2 ** 23 ) ) file1 . seek ( 0 ) file2 = tempfile . NamedTemporaryFile ( ) file2 . write ( 'a' * ( 2 * 2 ** 18 ) ) file2 . seek ( 0 ) file2a = tempfile . NamedTemporaryFile ( ) file2a . write ( 'a' * ( 5 * 2 ** 20 ) ) file2a . seek ( 0 ) response = self . client . post ( '/file_uploads/getlist_count/' , { : file1 , : u'test' , : u'test3' , : u'test5' , : u'test6' , : u'test7' , : ( file2 , file2a ) } ) got = simplejson . loads ( response . content ) self . assertEqual ( got . get ( 'file1' ) , 1 ) self . assertEqual ( got . get ( 'file2' ) , 2 ) def test_file_error_blocking ( self ) : class POSTAccessingHandler ( client . ClientHandler ) : def handle_uncaught_exception ( self , request , resolver , exc_info ) : ret = super ( POSTAccessingHandler , self ) . handle_uncaught_exception ( request , resolver , exc_info ) p = request . POST return ret post_data = { : 'Ringo' , : open ( __file__ ) , } try : client . FakePayload ( 'a' ) . read ( 2 ) except Exception , reference_error : pass self . client . handler = POSTAccessingHandler ( ) try : response = self . client . post ( '/file_uploads/upload_errors/' , post_data ) except reference_error . __class__ , err : self . failIf ( str ( err ) == str ( reference_error ) , ) except Exception , err : self . assertEqual ( err . __class__ , uploadhandler . CustomUploadError ) def test_filename_case_preservation ( self ) : vars = { 'boundary' : 'oUrBoUnDaRyStRiNg' } post_data = [ , , , , , , ] response = self . client . post ( , . join ( post_data ) % vars , % vars ) self . assertEqual ( response . status_code , 200 ) id = int ( response . content ) obj = FileModel . objects . get ( pk = id ) self . assertEqual ( os . path . basename ( obj . testfile . path ) , 'MiXeD_cAsE.txt' ) class DirectoryCreationTests ( unittest . TestCase ) : def setUp ( self ) : self . obj = FileModel ( ) if not os . path . isdir ( temp_storage . location ) : os . makedirs ( temp_storage . location ) if os . path . isdir ( UPLOAD_TO ) : os . chmod ( UPLOAD_TO , 0700 ) shutil . rmtree ( UPLOAD_TO ) def tearDown ( self ) : os . chmod ( temp_storage . location , 0700 ) shutil . rmtree ( temp_storage . location ) def test_readonly_root ( self ) : os . chmod ( temp_storage . location , 0500 ) try : self . obj . testfile . save ( 'foo.txt' , SimpleUploadedFile ( 'foo.txt' , 'x' ) ) except OSError , err : self . assertEqual ( err . errno , errno . EACCES ) except Exception , err : self . fail ( "OSError [Errno %s] not raised." % errno . EACCES ) def test_not_a_directory ( self ) : fd = open ( UPLOAD_TO , 'w' ) fd . close ( ) try : self . obj . testfile . save ( 'foo.txt' , SimpleUploadedFile ( 'foo.txt' , 'x' ) ) except IOError , err : self . assertEqual ( err . args [ 0 ] , % UPLOAD_TO ) except : self . fail ( "IOError not raised" ) class MultiParserTests ( unittest . TestCase ) : def test_empty_upload_handlers ( self ) : parser = MultiPartParser ( { : 'multipart/form-data; boundary=_foo' , : '1' } , StringIO ( 'x' ) , [ ] , 'utf-8' )

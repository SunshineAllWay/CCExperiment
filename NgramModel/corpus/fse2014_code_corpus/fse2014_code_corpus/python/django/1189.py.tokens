import os import sys from warnings import warn from django import http from django . core import signals from django . core . handlers . base import BaseHandler from django . core . urlresolvers import set_script_prefix from django . utils import datastructures from django . utils . encoding import force_unicode , iri_to_uri from django . utils . log import getLogger logger = getLogger ( 'django.request' ) class ModPythonRequest ( http . HttpRequest ) : def __init__ ( self , req ) : self . _req = req self . path = force_unicode ( req . uri ) root = req . get_options ( ) . get ( 'django.root' , '' ) self . django_root = root if root and req . uri . startswith ( root ) : self . path_info = force_unicode ( req . uri [ len ( root ) : ] ) else : self . path_info = self . path if not self . path_info : self . path_info = u'/' self . _post_parse_error = False self . _stream = self . _req self . _read_started = False def get_full_path ( self ) : return '%s%s' % ( self . path , self . _req . args and ( '?' + iri_to_uri ( self . _req . args ) ) or '' ) def _is_secure ( self ) : try : return self . _req . is_https ( ) except AttributeError : return self . _req . subprocess_env . get ( 'HTTPS' , '' ) . lower ( ) in ( 'on' , '1' ) def _get_request ( self ) : if not hasattr ( self , '_request' ) : self . _request = datastructures . MergeDict ( self . POST , self . GET ) return self . _request def _get_get ( self ) : if not hasattr ( self , '_get' ) : self . _get = http . QueryDict ( self . _req . args , encoding = self . _encoding ) return self . _get def _set_get ( self , get ) : self . _get = get def _get_post ( self ) : if not hasattr ( self , '_post' ) : self . _load_post_and_files ( ) return self . _post def _set_post ( self , post ) : self . _post = post def _get_cookies ( self ) : if not hasattr ( self , '_cookies' ) : self . _cookies = http . parse_cookie ( self . _req . headers_in . get ( 'cookie' , '' ) ) return self . _cookies def _set_cookies ( self , cookies ) : self . _cookies = cookies def _get_files ( self ) : if not hasattr ( self , '_files' ) : self . _load_post_and_files ( ) return self . _files def _get_meta ( self ) : if not hasattr ( self , '_meta' ) : self . _meta = { : self . _req . ap_auth_type , : self . _req . headers_in . get ( 'content-length' , 0 ) , : self . _req . headers_in . get ( 'content-type' ) , : 'CGI/1.1' , : self . path_info , : None , : self . _req . args , : self . _req . connection . remote_ip , : None , : self . _req . connection . remote_logname , : self . _req . user , : self . _req . method , : self . django_root , : self . _req . server . server_hostname , : self . _req . connection . local_addr [ 1 ] , : self . _req . protocol , : 'mod_python' } for key , value in self . _req . headers_in . items ( ) : key = 'HTTP_' + key . upper ( ) . replace ( '-' , '_' ) self . _meta [ key ] = value return self . _meta def _get_method ( self ) : return self . META [ 'REQUEST_METHOD' ] . upper ( ) GET = property ( _get_get , _set_get ) POST = property ( _get_post , _set_post ) COOKIES = property ( _get_cookies , _set_cookies ) FILES = property ( _get_files ) META = property ( _get_meta ) REQUEST = property ( _get_request ) method = property ( _get_method ) class ModPythonHandler ( BaseHandler ) : request_class = ModPythonRequest def __call__ ( self , req ) : warn ( ( 'The mod_python handler is deprecated; use a WSGI or FastCGI server instead.' ) , DeprecationWarning ) os . environ . update ( req . subprocess_env ) from django . conf import settings if self . _request_middleware is None : self . load_middleware ( ) set_script_prefix ( req . get_options ( ) . get ( 'django.root' , '' ) ) signals . request_started . send ( sender = self . __class__ ) try : try : request = self . request_class ( req ) except UnicodeDecodeError : logger . warning ( 'Bad Request (UnicodeDecodeError)' , exc_info = sys . exc_info ( ) , extra = { : 400 , } ) response = http . HttpResponseBadRequest ( ) else : response = self . get_response ( request ) finally : signals . request_finished . send ( sender = self . __class__ ) req . content_type = response [ 'Content-Type' ] for key , value in response . items ( ) : if key != 'content-type' : req . headers_out [ str ( key ) ] = str ( value ) for c in response . cookies . values ( ) : req . headers_out . add ( 'Set-Cookie' , c . output ( header = '' ) ) req . status = response . status_code try : for chunk in response : req . write ( chunk ) finally : response . close ( ) return 0 def handler ( req ) : return ModPythonHandler ( ) ( req )

from django . db . backends import BaseDatabaseOperations class DatabaseOperations ( BaseDatabaseOperations ) : def __init__ ( self , connection ) : super ( DatabaseOperations , self ) . __init__ ( connection ) def date_extract_sql ( self , lookup_type , field_name ) : if lookup_type == 'week_day' : return "EXTRACT('dow' FROM %s) + 1" % field_name else : return "EXTRACT('%s' FROM %s)" % ( lookup_type , field_name ) def date_interval_sql ( self , sql , connector , timedelta ) : modifiers = [ ] if timedelta . days : modifiers . append ( u'%s days' % timedelta . days ) if timedelta . seconds : modifiers . append ( u'%s seconds' % timedelta . seconds ) if timedelta . microseconds : modifiers . append ( u'%s microseconds' % timedelta . microseconds ) mods = u' ' . join ( modifiers ) conn = u' %s ' % connector return u'(%s)' % conn . join ( [ sql , u'interval \'%s\'' % mods ] ) def date_trunc_sql ( self , lookup_type , field_name ) : return "DATE_TRUNC('%s', %s)" % ( lookup_type , field_name ) def deferrable_sql ( self ) : return " DEFERRABLE INITIALLY DEFERRED" def lookup_cast ( self , lookup_type ) : lookup = '%s' if lookup_type in ( 'iexact' , 'contains' , 'icontains' , 'startswith' , , 'endswith' , 'iendswith' ) : lookup = "%s::text" if lookup_type in ( 'iexact' , 'icontains' , 'istartswith' , 'iendswith' ) : lookup = 'UPPER(%s)' % lookup return lookup def field_cast_sql ( self , db_type ) : if db_type == 'inet' : return 'HOST(%s)' return '%s' def last_insert_id ( self , cursor , table_name , pk_name ) : cursor . execute ( "SELECT CURRVAL(pg_get_serial_sequence('%s','%s'))" % ( self . quote_name ( table_name ) , pk_name ) ) return cursor . fetchone ( ) [ 0 ] def no_limit_value ( self ) : return None def quote_name ( self , name ) : if name . startswith ( '"' ) and name . endswith ( '"' ) : return name return '"%s"' % name def sql_flush ( self , style , tables , sequences ) : if tables : sql = [ '%s %s;' % ( style . SQL_KEYWORD ( 'TRUNCATE' ) , style . SQL_FIELD ( ', ' . join ( [ self . quote_name ( table ) for table in tables ] ) ) ) ] for sequence_info in sequences : table_name = sequence_info [ 'table' ] column_name = sequence_info [ 'column' ] if not ( column_name and len ( column_name ) > 0 ) : column_name = 'id' sql . append ( "%s setval(pg_get_serial_sequence('%s','%s'), 1, false);" % ( style . SQL_KEYWORD ( 'SELECT' ) , style . SQL_TABLE ( self . quote_name ( table_name ) ) , style . SQL_FIELD ( column_name ) ) ) return sql else : return [ ] def tablespace_sql ( self , tablespace , inline = False ) : if inline : return "USING INDEX TABLESPACE %s" % self . quote_name ( tablespace ) else : return "TABLESPACE %s" % self . quote_name ( tablespace ) def sequence_reset_sql ( self , style , model_list ) : from django . db import models output = [ ] qn = self . quote_name for model in model_list : for f in model . _meta . local_fields : if isinstance ( f , models . AutoField ) : output . append ( "%s setval(pg_get_serial_sequence('%s','%s'), coalesce(max(%s), 1), max(%s) %s null) %s %s;" % ( style . SQL_KEYWORD ( 'SELECT' ) , style . SQL_TABLE ( qn ( model . _meta . db_table ) ) , style . SQL_FIELD ( f . column ) , style . SQL_FIELD ( qn ( f . column ) ) , style . SQL_FIELD ( qn ( f . column ) ) , style . SQL_KEYWORD ( 'IS NOT' ) , style . SQL_KEYWORD ( 'FROM' ) , style . SQL_TABLE ( qn ( model . _meta . db_table ) ) ) ) break for f in model . _meta . many_to_many : if not f . rel . through : output . append ( "%s setval(pg_get_serial_sequence('%s','%s'), coalesce(max(%s), 1), max(%s) %s null) %s %s;" % ( style . SQL_KEYWORD ( 'SELECT' ) , style . SQL_TABLE ( qn ( f . m2m_db_table ( ) ) ) , style . SQL_FIELD ( 'id' ) , style . SQL_FIELD ( qn ( 'id' ) ) , style . SQL_FIELD ( qn ( 'id' ) ) , style . SQL_KEYWORD ( 'IS NOT' ) , style . SQL_KEYWORD ( 'FROM' ) , style . SQL_TABLE ( qn ( f . m2m_db_table ( ) ) ) ) ) return output def savepoint_create_sql ( self , sid ) : return "SAVEPOINT %s" % sid def savepoint_commit_sql ( self , sid ) : return "RELEASE SAVEPOINT %s" % sid def savepoint_rollback_sql ( self , sid ) : return "ROLLBACK TO SAVEPOINT %s" % sid def prep_for_iexact_query ( self , x ) : return x def check_aggregate_support ( self , aggregate ) : if aggregate . sql_function in ( 'STDDEV_POP' , 'VAR_POP' ) : pg_version = self . connection . pg_version if pg_version >= 80200 and pg_version <= 80204 : raise NotImplementedError ( 'PostgreSQL 8.2 to 8.2.4 is known to have a faulty implementation of %s. Please upgrade your version of PostgreSQL.' % aggregate . sql_function ) def max_name_length ( self ) : return 63 def distinct_sql ( self , fields ) : if fields : return 'DISTINCT ON (%s)' % ', ' . join ( fields ) else : return 'DISTINCT' def last_executed_query ( self , cursor , sql , params ) : return cursor . query def return_insert_id ( self ) : return "RETURNING %s" , ( ) def bulk_insert_sql ( self , fields , num_values ) : items_sql = "(%s)" % ", " . join ( [ "%s" ] * len ( fields ) ) return "VALUES " + ", " . join ( [ items_sql ] * num_values )

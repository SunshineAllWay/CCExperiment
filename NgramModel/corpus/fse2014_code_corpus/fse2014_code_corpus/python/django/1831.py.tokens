""" Query subclasses which provide extra functionality beyond simple data retrieval. """ from django . core . exceptions import FieldError from django . db . models . fields import DateField , FieldDoesNotExist from django . db . models . sql . constants import * from django . db . models . sql . datastructures import Date from django . db . models . sql . query import Query from django . db . models . sql . where import AND , Constraint __all__ = [ 'DeleteQuery' , 'UpdateQuery' , 'InsertQuery' , 'DateQuery' , ] class DeleteQuery ( Query ) : compiler = 'SQLDeleteCompiler' def do_query ( self , table , where , using ) : self . tables = [ table ] self . where = where self . get_compiler ( using ) . execute_sql ( None ) def delete_batch ( self , pk_list , using , field = None ) : if not field : field = self . model . _meta . pk for offset in range ( 0 , len ( pk_list ) , GET_ITERATOR_CHUNK_SIZE ) : where = self . where_class ( ) where . add ( ( Constraint ( None , field . column , field ) , 'in' , pk_list [ offset : offset + GET_ITERATOR_CHUNK_SIZE ] ) , AND ) self . do_query ( self . model . _meta . db_table , where , using = using ) class UpdateQuery ( Query ) : compiler = 'SQLUpdateCompiler' def __init__ ( self , * args , ** kwargs ) : super ( UpdateQuery , self ) . __init__ ( * args , ** kwargs ) self . _setup_query ( ) def _setup_query ( self ) : self . values = [ ] self . related_ids = None if not hasattr ( self , 'related_updates' ) : self . related_updates = { } def clone ( self , klass = None , ** kwargs ) : return super ( UpdateQuery , self ) . clone ( klass , related_updates = self . related_updates . copy ( ) , ** kwargs ) def update_batch ( self , pk_list , values , using ) : pk_field = self . model . _meta . pk self . add_update_values ( values ) for offset in range ( 0 , len ( pk_list ) , GET_ITERATOR_CHUNK_SIZE ) : self . where = self . where_class ( ) self . where . add ( ( Constraint ( None , pk_field . column , pk_field ) , 'in' , pk_list [ offset : offset + GET_ITERATOR_CHUNK_SIZE ] ) , AND ) self . get_compiler ( using ) . execute_sql ( None ) def add_update_values ( self , values ) : values_seq = [ ] for name , val in values . iteritems ( ) : field , model , direct , m2m = self . model . _meta . get_field_by_name ( name ) if not direct or m2m : raise FieldError ( 'Cannot update model field %r (only non-relations and foreign keys permitted).' % field ) if model : self . add_related_update ( model , field , val ) continue values_seq . append ( ( field , model , val ) ) return self . add_update_fields ( values_seq ) def add_update_fields ( self , values_seq ) : self . values . extend ( values_seq ) def add_related_update ( self , model , field , value ) : try : self . related_updates [ model ] . append ( ( field , None , value ) ) except KeyError : self . related_updates [ model ] = [ ( field , None , value ) ] def get_related_updates ( self ) : if not self . related_updates : return [ ] result = [ ] for model , values in self . related_updates . iteritems ( ) : query = UpdateQuery ( model ) query . values = values if self . related_ids is not None : query . add_filter ( ( 'pk__in' , self . related_ids ) ) result . append ( query ) return result class InsertQuery ( Query ) : compiler = 'SQLInsertCompiler' def __init__ ( self , * args , ** kwargs ) : super ( InsertQuery , self ) . __init__ ( * args , ** kwargs ) self . fields = [ ] self . objs = [ ] def clone ( self , klass = None , ** kwargs ) : extras = { : self . fields [ : ] , : self . objs [ : ] , : self . raw , } extras . update ( kwargs ) return super ( InsertQuery , self ) . clone ( klass , ** extras ) def insert_values ( self , fields , objs , raw = False ) : self . fields = fields self . objs = objs self . raw = raw class DateQuery ( Query ) : compiler = 'SQLDateCompiler' def add_date_select ( self , field_name , lookup_type , order = 'ASC' ) : try : result = self . setup_joins ( field_name . split ( LOOKUP_SEP ) , self . get_meta ( ) , self . get_initial_alias ( ) , False ) except FieldError : raise FieldDoesNotExist ( "%s has no field named '%s'" % ( self . model . _meta . object_name , field_name ) ) field = result [ 0 ] assert isinstance ( field , DateField ) , "%r isn't a DateField." % field . name alias = result [ 3 ] [ - 1 ] select = Date ( ( alias , field . column ) , lookup_type ) self . select = [ select ] self . select_fields = [ None ] self . select_related = False self . set_extra_mask ( [ ] ) self . distinct = True self . order_by = order == 'ASC' and [ 1 ] or [ - 1 ] if field . null : self . add_filter ( ( "%s__isnull" % field_name , False ) ) class AggregateQuery ( Query ) : compiler = 'SQLAggregateCompiler' def add_subquery ( self , query , using ) : self . subquery , self . sub_params = query . get_compiler ( using ) . as_sql ( with_col_aliases = True )

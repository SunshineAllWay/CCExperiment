from __future__ import with_statement import os import sys from optparse import make_option from django . core . files . storage import FileSystemStorage from django . core . management . base import CommandError , NoArgsCommand from django . utils . encoding import smart_str , smart_unicode from django . utils . datastructures import SortedDict from django . contrib . staticfiles import finders , storage class Command ( NoArgsCommand ) : option_list = NoArgsCommand . option_list + ( make_option ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True , help = "Do NOT prompt the user for input of any kind." ) , make_option ( '--no-post-process' , action = 'store_false' , dest = 'post_process' , default = True , help = "Do NOT post process collected files." ) , make_option ( '-i' , '--ignore' , action = 'append' , default = [ ] , dest = 'ignore_patterns' , metavar = 'PATTERN' , help = "Ignore files or directories matching this glob-style " ) , make_option ( '-n' , '--dry-run' , action = 'store_true' , dest = 'dry_run' , default = False , help = "Do everything except modify the filesystem." ) , make_option ( '-c' , '--clear' , action = 'store_true' , dest = 'clear' , default = False , help = "Clear the existing files using the storage " ) , make_option ( '-l' , '--link' , action = 'store_true' , dest = 'link' , default = False , help = "Create a symbolic link to each file instead of copying." ) , make_option ( '--no-default-ignore' , action = 'store_false' , dest = 'use_default_ignore_patterns' , default = True , help = "Don't ignore the common private glob-style patterns 'CVS', " ) , ) help = "Collect static files in a single location." requires_model_validation = False def __init__ ( self , * args , ** kwargs ) : super ( NoArgsCommand , self ) . __init__ ( * args , ** kwargs ) self . copied_files = [ ] self . symlinked_files = [ ] self . unmodified_files = [ ] self . post_processed_files = [ ] self . storage = storage . staticfiles_storage try : self . storage . path ( '' ) except NotImplementedError : self . local = False else : self . local = True if hasattr ( os , 'stat_float_times' ) : os . stat_float_times ( False ) def set_options ( self , ** options ) : self . interactive = options [ 'interactive' ] self . verbosity = int ( options . get ( 'verbosity' , 1 ) ) self . symlink = options [ 'link' ] self . clear = options [ 'clear' ] self . dry_run = options [ 'dry_run' ] ignore_patterns = options [ 'ignore_patterns' ] if options [ 'use_default_ignore_patterns' ] : ignore_patterns += [ 'CVS' , '.*' , '*~' ] self . ignore_patterns = list ( set ( ignore_patterns ) ) self . post_process = options [ 'post_process' ] def collect ( self ) : if self . symlink : if sys . platform == 'win32' : raise CommandError ( "Symlinking is not supported by this " % sys . platform ) if not self . local : raise CommandError ( "Can't symlink to a remote destination." ) if self . clear : self . clear_dir ( '' ) if self . symlink : handler = self . link_file else : handler = self . copy_file found_files = SortedDict ( ) for finder in finders . get_finders ( ) : for path , storage in finder . list ( self . ignore_patterns ) : if getattr ( storage , 'prefix' , None ) : prefixed_path = os . path . join ( storage . prefix , path ) else : prefixed_path = path found_files [ prefixed_path ] = ( storage , path ) handler ( path , prefixed_path , storage ) if self . post_process and hasattr ( self . storage , 'post_process' ) : processor = self . storage . post_process ( found_files , dry_run = self . dry_run ) for original_path , processed_path , processed in processor : if processed : self . log ( u"Post-processed '%s' as '%s" % ( original_path , processed_path ) , level = 1 ) self . post_processed_files . append ( original_path ) else : self . log ( u"Skipped post-processing '%s'" % original_path ) return { : self . copied_files + self . symlinked_files , : self . unmodified_files , : self . post_processed_files , } def handle_noargs ( self , ** options ) : self . set_options ( ** options ) if ( isinstance ( self . storage , FileSystemStorage ) and self . storage . location ) : destination_path = self . storage . location destination_display = ':\n\n %s' % destination_path else : destination_path = None destination_display = '.' if self . clear : clear_display = 'This will DELETE EXISTING FILES!' else : clear_display = 'This will overwrite existing files!' if self . interactive : confirm = raw_input ( u""" You have requested to collect static files at the destination location as specified in your settings%s %s Are you sure you want to do this? Type 'yes' to continue, or 'no' to cancel: """ % ( destination_display , clear_display ) ) if confirm != 'yes' : raise CommandError ( "Collecting static files cancelled." ) collected = self . collect ( ) modified_count = len ( collected [ 'modified' ] ) unmodified_count = len ( collected [ 'unmodified' ] ) post_processed_count = len ( collected [ 'post_processed' ] ) if self . verbosity >= 1 : template = ( "\n%(modified_count)s %(identifier)s %(action)s" ) summary = template % { : modified_count , : 'static file' + ( modified_count != 1 and 's' or '' ) , : self . symlink and 'symlinked' or 'copied' , : ( destination_path and " to '%s'" % destination_path or '' ) , : ( collected [ 'unmodified' ] and ', %s unmodified' % unmodified_count or '' ) , : ( collected [ 'post_processed' ] and % post_processed_count or '' ) , } self . stdout . write ( smart_str ( summary ) ) def log ( self , msg , level = 2 ) : msg = smart_str ( msg ) if not msg . endswith ( "\n" ) : msg += "\n" if self . verbosity >= level : self . stdout . write ( msg ) def clear_dir ( self , path ) : dirs , files = self . storage . listdir ( path ) for f in files : fpath = os . path . join ( path , f ) if self . dry_run : self . log ( u"Pretending to delete '%s'" % smart_unicode ( fpath ) , level = 1 ) else : self . log ( u"Deleting '%s'" % smart_unicode ( fpath ) , level = 1 ) self . storage . delete ( fpath ) for d in dirs : self . clear_dir ( os . path . join ( path , d ) ) def delete_file ( self , path , prefixed_path , source_storage ) : if self . storage . exists ( prefixed_path ) : try : target_last_modified = self . storage . modified_time ( prefixed_path ) except ( OSError , NotImplementedError , AttributeError ) : pass else : try : source_last_modified = source_storage . modified_time ( path ) except ( OSError , NotImplementedError , AttributeError ) : pass else : if self . local : full_path = self . storage . path ( prefixed_path ) else : full_path = None if target_last_modified >= source_last_modified : if not ( ( self . symlink and full_path and not os . path . islink ( full_path ) ) or ( not self . symlink and full_path and os . path . islink ( full_path ) ) ) : if prefixed_path not in self . unmodified_files : self . unmodified_files . append ( prefixed_path ) self . log ( u"Skipping '%s' (not modified)" % path ) return False if self . dry_run : self . log ( u"Pretending to delete '%s'" % path ) else : self . log ( u"Deleting '%s'" % path ) self . storage . delete ( prefixed_path ) return True def link_file ( self , path , prefixed_path , source_storage ) : if prefixed_path in self . symlinked_files : return self . log ( u"Skipping '%s' (already linked earlier)" % path ) if not self . delete_file ( path , prefixed_path , source_storage ) : return source_path = source_storage . path ( path ) if self . dry_run : self . log ( u"Pretending to link '%s'" % source_path , level = 1 ) else : self . log ( u"Linking '%s'" % source_path , level = 1 ) full_path = self . storage . path ( prefixed_path ) try : os . makedirs ( os . path . dirname ( full_path ) ) except OSError : pass os . symlink ( source_path , full_path ) if prefixed_path not in self . symlinked_files : self . symlinked_files . append ( prefixed_path ) def copy_file ( self , path , prefixed_path , source_storage ) : if prefixed_path in self . copied_files : return self . log ( u"Skipping '%s' (already copied earlier)" % path ) if not self . delete_file ( path , prefixed_path , source_storage ) : return source_path = source_storage . path ( path ) if self . dry_run : self . log ( u"Pretending to copy '%s'" % source_path , level = 1 ) else : self . log ( u"Copying '%s'" % source_path , level = 1 ) if self . local : full_path = self . storage . path ( prefixed_path ) try : os . makedirs ( os . path . dirname ( full_path ) ) except OSError : pass with source_storage . open ( path ) as source_file : self . storage . save ( prefixed_path , source_file ) if not prefixed_path in self . copied_files : self . copied_files . append ( prefixed_path )

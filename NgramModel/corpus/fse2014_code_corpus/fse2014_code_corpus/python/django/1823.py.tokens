import copy import datetime import decimal import math import warnings from itertools import tee from django . db import connection from django . db . models . query_utils import QueryWrapper from django . conf import settings from django import forms from django . core import exceptions , validators from django . utils . datastructures import DictWrapper from django . utils . dateparse import parse_date , parse_datetime , parse_time from django . utils . functional import curry from django . utils . text import capfirst from django . utils import timezone from django . utils . translation import ugettext_lazy as _ from django . utils . encoding import smart_unicode , force_unicode , smart_str from django . utils . ipv6 import clean_ipv6_address class NOT_PROVIDED : pass BLANK_CHOICE_DASH = [ ( "" , "---------" ) ] BLANK_CHOICE_NONE = [ ( "" , "None" ) ] class FieldDoesNotExist ( Exception ) : pass class Field ( object ) : empty_strings_allowed = True creation_counter = 0 auto_creation_counter = - 1 default_validators = [ ] default_error_messages = { : _ ( u'Value %r is not a valid choice.' ) , : _ ( u'This field cannot be null.' ) , : _ ( u'This field cannot be blank.' ) , : _ ( u'%(model_name)s with this %(field_label)s ' ) , } def _description ( self ) : return _ ( u'Field of type: %(field_type)s' ) % { : self . __class__ . __name__ } description = property ( _description ) def __init__ ( self , verbose_name = None , name = None , primary_key = False , max_length = None , unique = False , blank = False , null = False , db_index = False , rel = None , default = NOT_PROVIDED , editable = True , serialize = True , unique_for_date = None , unique_for_month = None , unique_for_year = None , choices = None , help_text = '' , db_column = None , db_tablespace = None , auto_created = False , validators = [ ] , error_messages = None ) : self . name = name self . verbose_name = verbose_name self . primary_key = primary_key self . max_length , self . _unique = max_length , unique self . blank , self . null = blank , null if ( self . empty_strings_allowed and connection . features . interprets_empty_strings_as_nulls ) : self . null = True self . rel = rel self . default = default self . editable = editable self . serialize = serialize self . unique_for_date , self . unique_for_month = ( unique_for_date , unique_for_month ) self . unique_for_year = unique_for_year self . _choices = choices or [ ] self . help_text = help_text self . db_column = db_column self . db_tablespace = db_tablespace or settings . DEFAULT_INDEX_TABLESPACE self . auto_created = auto_created self . db_index = db_index if auto_created : self . creation_counter = Field . auto_creation_counter Field . auto_creation_counter -= 1 else : self . creation_counter = Field . creation_counter Field . creation_counter += 1 self . validators = self . default_validators + validators messages = { } for c in reversed ( self . __class__ . __mro__ ) : messages . update ( getattr ( c , 'default_error_messages' , { } ) ) messages . update ( error_messages or { } ) self . error_messages = messages def __cmp__ ( self , other ) : return cmp ( self . creation_counter , other . creation_counter ) def __deepcopy__ ( self , memodict ) : obj = copy . copy ( self ) if self . rel : obj . rel = copy . copy ( self . rel ) memodict [ id ( self ) ] = obj return obj def to_python ( self , value ) : return value def run_validators ( self , value ) : if value in validators . EMPTY_VALUES : return errors = [ ] for v in self . validators : try : v ( value ) except exceptions . ValidationError , e : if hasattr ( e , 'code' ) and e . code in self . error_messages : message = self . error_messages [ e . code ] if e . params : message = message % e . params errors . append ( message ) else : errors . extend ( e . messages ) if errors : raise exceptions . ValidationError ( errors ) def validate ( self , value , model_instance ) : if not self . editable : return if self . _choices and value : for option_key , option_value in self . choices : if isinstance ( option_value , ( list , tuple ) ) : for optgroup_key , optgroup_value in option_value : if value == optgroup_key : return elif value == option_key : return msg = self . error_messages [ 'invalid_choice' ] % value raise exceptions . ValidationError ( msg ) if value is None and not self . null : raise exceptions . ValidationError ( self . error_messages [ 'null' ] ) if not self . blank and value in validators . EMPTY_VALUES : raise exceptions . ValidationError ( self . error_messages [ 'blank' ] ) def clean ( self , value , model_instance ) : value = self . to_python ( value ) self . validate ( value , model_instance ) self . run_validators ( value ) return value def db_type ( self , connection ) : data = DictWrapper ( self . __dict__ , connection . ops . quote_name , "qn_" ) try : return ( connection . creation . data_types [ self . get_internal_type ( ) ] % data ) except KeyError : return None @ property def unique ( self ) : return self . _unique or self . primary_key def set_attributes_from_name ( self , name ) : if not self . name : self . name = name self . attname , self . column = self . get_attname_column ( ) if self . verbose_name is None and self . name : self . verbose_name = self . name . replace ( '_' , ' ' ) def contribute_to_class ( self , cls , name ) : self . set_attributes_from_name ( name ) self . model = cls cls . _meta . add_field ( self ) if self . choices : setattr ( cls , 'get_%s_display' % self . name , curry ( cls . _get_FIELD_display , field = self ) ) def get_attname ( self ) : return self . name def get_attname_column ( self ) : attname = self . get_attname ( ) column = self . db_column or attname return attname , column def get_cache_name ( self ) : return '_%s_cache' % self . name def get_internal_type ( self ) : return self . __class__ . __name__ def pre_save ( self , model_instance , add ) : return getattr ( model_instance , self . attname ) def get_prep_value ( self , value ) : return value def get_db_prep_value ( self , value , connection , prepared = False ) : if not prepared : value = self . get_prep_value ( value ) return value def get_db_prep_save ( self , value , connection ) : return self . get_db_prep_value ( value , connection = connection , prepared = False ) def get_prep_lookup ( self , lookup_type , value ) : if hasattr ( value , 'prepare' ) : return value . prepare ( ) if hasattr ( value , '_prepare' ) : return value . _prepare ( ) if lookup_type in ( , 'iregex' , 'month' , 'day' , 'week_day' , 'search' , , 'icontains' , 'iexact' , 'startswith' , 'istartswith' , , 'iendswith' , 'isnull' ) : return value elif lookup_type in ( 'exact' , 'gt' , 'gte' , 'lt' , 'lte' ) : return self . get_prep_value ( value ) elif lookup_type in ( 'range' , 'in' ) : return [ self . get_prep_value ( v ) for v in value ] elif lookup_type == 'year' : try : return int ( value ) except ValueError : raise ValueError ( "The __year lookup type requires an integer " ) raise TypeError ( "Field has invalid lookup: %s" % lookup_type ) def get_db_prep_lookup ( self , lookup_type , value , connection , prepared = False ) : if not prepared : value = self . get_prep_lookup ( lookup_type , value ) if hasattr ( value , 'get_compiler' ) : value = value . get_compiler ( connection = connection ) if hasattr ( value , 'as_sql' ) or hasattr ( value , '_as_sql' ) : if hasattr ( value , 'relabel_aliases' ) : return value if hasattr ( value , 'as_sql' ) : sql , params = value . as_sql ( ) else : sql , params = value . _as_sql ( connection = connection ) return QueryWrapper ( ( '(%s)' % sql ) , params ) if lookup_type in ( 'regex' , 'iregex' , 'month' , 'day' , 'week_day' , ) : return [ value ] elif lookup_type in ( 'exact' , 'gt' , 'gte' , 'lt' , 'lte' ) : return [ self . get_db_prep_value ( value , connection = connection , prepared = prepared ) ] elif lookup_type in ( 'range' , 'in' ) : return [ self . get_db_prep_value ( v , connection = connection , prepared = prepared ) for v in value ] elif lookup_type in ( 'contains' , 'icontains' ) : return [ "%%%s%%" % connection . ops . prep_for_like_query ( value ) ] elif lookup_type == 'iexact' : return [ connection . ops . prep_for_iexact_query ( value ) ] elif lookup_type in ( 'startswith' , 'istartswith' ) : return [ "%s%%" % connection . ops . prep_for_like_query ( value ) ] elif lookup_type in ( 'endswith' , 'iendswith' ) : return [ "%%%s" % connection . ops . prep_for_like_query ( value ) ] elif lookup_type == 'isnull' : return [ ] elif lookup_type == 'year' : if self . get_internal_type ( ) == 'DateField' : return connection . ops . year_lookup_bounds_for_date_field ( value ) else : return connection . ops . year_lookup_bounds ( value ) def has_default ( self ) : return self . default is not NOT_PROVIDED def get_default ( self ) : if self . has_default ( ) : if callable ( self . default ) : return self . default ( ) return force_unicode ( self . default , strings_only = True ) if ( not self . empty_strings_allowed or ( self . null and not connection . features . interprets_empty_strings_as_nulls ) ) : return None return "" def get_validator_unique_lookup_type ( self ) : return '%s__exact' % self . name def get_choices ( self , include_blank = True , blank_choice = BLANK_CHOICE_DASH ) : first_choice = include_blank and blank_choice or [ ] if self . choices : return first_choice + list ( self . choices ) rel_model = self . rel . to if hasattr ( self . rel , 'get_related_field' ) : lst = [ ( getattr ( x , self . rel . get_related_field ( ) . attname ) , smart_unicode ( x ) ) for x in rel_model . _default_manager . complex_filter ( self . rel . limit_choices_to ) ] else : lst = [ ( x . _get_pk_val ( ) , smart_unicode ( x ) ) for x in rel_model . _default_manager . complex_filter ( self . rel . limit_choices_to ) ] return first_choice + lst def get_choices_default ( self ) : return self . get_choices ( ) def get_flatchoices ( self , include_blank = True , blank_choice = BLANK_CHOICE_DASH ) : first_choice = include_blank and blank_choice or [ ] return first_choice + list ( self . flatchoices ) def _get_val_from_obj ( self , obj ) : if obj is not None : return getattr ( obj , self . attname ) else : return self . get_default ( ) def value_to_string ( self , obj ) : return smart_unicode ( self . _get_val_from_obj ( obj ) ) def bind ( self , fieldmapping , original , bound_field_class ) : return bound_field_class ( self , fieldmapping , original ) def _get_choices ( self ) : if hasattr ( self . _choices , 'next' ) : choices , self . _choices = tee ( self . _choices ) return choices else : return self . _choices choices = property ( _get_choices ) def _get_flatchoices ( self ) : flat = [ ] for choice , value in self . choices : if isinstance ( value , ( list , tuple ) ) : flat . extend ( value ) else : flat . append ( ( choice , value ) ) return flat flatchoices = property ( _get_flatchoices ) def save_form_data ( self , instance , data ) : setattr ( instance , self . name , data ) def formfield ( self , form_class = forms . CharField , ** kwargs ) : defaults = { 'required' : not self . blank , : capfirst ( self . verbose_name ) , : self . help_text } if self . has_default ( ) : if callable ( self . default ) : defaults [ 'initial' ] = self . default defaults [ 'show_hidden_initial' ] = True else : defaults [ 'initial' ] = self . get_default ( ) if self . choices : include_blank = ( self . blank or not ( self . has_default ( ) or 'initial' in kwargs ) ) defaults [ 'choices' ] = self . get_choices ( include_blank = include_blank ) defaults [ 'coerce' ] = self . to_python if self . null : defaults [ 'empty_value' ] = None form_class = forms . TypedChoiceField for k in kwargs . keys ( ) : if k not in ( 'coerce' , 'empty_value' , 'choices' , 'required' , , 'label' , 'initial' , 'help_text' , , 'show_hidden_initial' ) : del kwargs [ k ] defaults . update ( kwargs ) return form_class ( ** defaults ) def value_from_object ( self , obj ) : return getattr ( obj , self . attname ) def __repr__ ( self ) : path = '%s.%s' % ( self . __class__ . __module__ , self . __class__ . __name__ ) name = getattr ( self , 'name' , None ) if name is not None : return '<%s: %s>' % ( path , name ) return '<%s>' % path class AutoField ( Field ) : description = _ ( "Integer" ) empty_strings_allowed = False default_error_messages = { : _ ( u"'%s' value must be an integer." ) , } def __init__ ( self , * args , ** kwargs ) : assert kwargs . get ( 'primary_key' , False ) is True , "%ss must have primary_key=True." % self . __class__ . __name__ kwargs [ 'blank' ] = True Field . __init__ ( self , * args , ** kwargs ) def get_internal_type ( self ) : return "AutoField" def to_python ( self , value ) : if value is None : return value try : return int ( value ) except ( TypeError , ValueError ) : msg = self . error_messages [ 'invalid' ] % str ( value ) raise exceptions . ValidationError ( msg ) def validate ( self , value , model_instance ) : pass def get_prep_value ( self , value ) : if value is None : return None return int ( value ) def contribute_to_class ( self , cls , name ) : assert not cls . _meta . has_auto_field , "A model can't have more than one AutoField." super ( AutoField , self ) . contribute_to_class ( cls , name ) cls . _meta . has_auto_field = True cls . _meta . auto_field = self def formfield ( self , ** kwargs ) : return None class BooleanField ( Field ) : empty_strings_allowed = False default_error_messages = { : _ ( u"'%s' value must be either True or False." ) , } description = _ ( "Boolean (Either True or False)" ) def __init__ ( self , * args , ** kwargs ) : kwargs [ 'blank' ] = True if 'default' not in kwargs and not kwargs . get ( 'null' ) : kwargs [ 'default' ] = False Field . __init__ ( self , * args , ** kwargs ) def get_internal_type ( self ) : return "BooleanField" def to_python ( self , value ) : if value in ( True , False ) : return bool ( value ) if value in ( 't' , 'True' , '1' ) : return True if value in ( 'f' , 'False' , '0' ) : return False msg = self . error_messages [ 'invalid' ] % str ( value ) raise exceptions . ValidationError ( msg ) def get_prep_lookup ( self , lookup_type , value ) : if value in ( '1' , '0' ) : value = bool ( int ( value ) ) return super ( BooleanField , self ) . get_prep_lookup ( lookup_type , value ) def get_prep_value ( self , value ) : if value is None : return None return bool ( value ) def formfield ( self , ** kwargs ) : if self . choices : include_blank = ( self . null or not ( self . has_default ( ) or 'initial' in kwargs ) ) defaults = { 'choices' : self . get_choices ( include_blank = include_blank ) } else : defaults = { 'form_class' : forms . BooleanField } defaults . update ( kwargs ) return super ( BooleanField , self ) . formfield ( ** defaults ) class CharField ( Field ) : description = _ ( "String (up to %(max_length)s)" ) def __init__ ( self , * args , ** kwargs ) : super ( CharField , self ) . __init__ ( * args , ** kwargs ) self . validators . append ( validators . MaxLengthValidator ( self . max_length ) ) def get_internal_type ( self ) : return "CharField" def to_python ( self , value ) : if isinstance ( value , basestring ) or value is None : return value return smart_unicode ( value ) def get_prep_value ( self , value ) : return self . to_python ( value ) def formfield ( self , ** kwargs ) : defaults = { 'max_length' : self . max_length } defaults . update ( kwargs ) return super ( CharField , self ) . formfield ( ** defaults ) class CommaSeparatedIntegerField ( CharField ) : default_validators = [ validators . validate_comma_separated_integer_list ] description = _ ( "Comma-separated integers" ) def formfield ( self , ** kwargs ) : defaults = { : { : _ ( u'Enter only digits separated by commas.' ) , } } defaults . update ( kwargs ) return super ( CommaSeparatedIntegerField , self ) . formfield ( ** defaults ) class DateField ( Field ) : empty_strings_allowed = False default_error_messages = { : _ ( u"'%s' value has an invalid date format. It must be " ) , : _ ( u"'%s' value has the correct format (YYYY-MM-DD) " ) , } description = _ ( "Date (without time)" ) def __init__ ( self , verbose_name = None , name = None , auto_now = False , auto_now_add = False , ** kwargs ) : self . auto_now , self . auto_now_add = auto_now , auto_now_add if auto_now or auto_now_add : kwargs [ 'editable' ] = False kwargs [ 'blank' ] = True Field . __init__ ( self , verbose_name , name , ** kwargs ) def get_internal_type ( self ) : return "DateField" def to_python ( self , value ) : if value is None : return value if isinstance ( value , datetime . datetime ) : return value . date ( ) if isinstance ( value , datetime . date ) : return value value = smart_str ( value ) try : parsed = parse_date ( value ) if parsed is not None : return parsed except ValueError : msg = self . error_messages [ 'invalid_date' ] % value raise exceptions . ValidationError ( msg ) msg = self . error_messages [ 'invalid' ] % value raise exceptions . ValidationError ( msg ) def pre_save ( self , model_instance , add ) : if self . auto_now or ( self . auto_now_add and add ) : value = datetime . date . today ( ) setattr ( model_instance , self . attname , value ) return value else : return super ( DateField , self ) . pre_save ( model_instance , add ) def contribute_to_class ( self , cls , name ) : super ( DateField , self ) . contribute_to_class ( cls , name ) if not self . null : setattr ( cls , 'get_next_by_%s' % self . name , curry ( cls . _get_next_or_previous_by_FIELD , field = self , is_next = True ) ) setattr ( cls , 'get_previous_by_%s' % self . name , curry ( cls . _get_next_or_previous_by_FIELD , field = self , is_next = False ) ) def get_prep_lookup ( self , lookup_type , value ) : if lookup_type in ( 'month' , 'day' , 'week_day' ) : return int ( value ) return super ( DateField , self ) . get_prep_lookup ( lookup_type , value ) def get_prep_value ( self , value ) : return self . to_python ( value ) def get_db_prep_value ( self , value , connection , prepared = False ) : if not prepared : value = self . get_prep_value ( value ) return connection . ops . value_to_db_date ( value ) def value_to_string ( self , obj ) : val = self . _get_val_from_obj ( obj ) return '' if val is None else val . isoformat ( ) def formfield ( self , ** kwargs ) : defaults = { 'form_class' : forms . DateField } defaults . update ( kwargs ) return super ( DateField , self ) . formfield ( ** defaults ) class DateTimeField ( DateField ) : empty_strings_allowed = False default_error_messages = { : _ ( u"'%s' value has an invalid format. It must be in " ) , : _ ( u"'%s' value has the correct format " ) , : _ ( u"'%s' value has the correct format " ) , } description = _ ( "Date (with time)" ) def get_internal_type ( self ) : return "DateTimeField" def to_python ( self , value ) : if value is None : return value if isinstance ( value , datetime . datetime ) : return value if isinstance ( value , datetime . date ) : value = datetime . datetime ( value . year , value . month , value . day ) if settings . USE_TZ : warnings . warn ( u"DateTimeField received a naive datetime (%s)" % value , RuntimeWarning ) default_timezone = timezone . get_default_timezone ( ) value = timezone . make_aware ( value , default_timezone ) return value value = smart_str ( value ) try : parsed = parse_datetime ( value ) if parsed is not None : return parsed except ValueError : msg = self . error_messages [ 'invalid_datetime' ] % value raise exceptions . ValidationError ( msg ) try : parsed = parse_date ( value ) if parsed is not None : return datetime . datetime ( parsed . year , parsed . month , parsed . day ) except ValueError : msg = self . error_messages [ 'invalid_date' ] % value raise exceptions . ValidationError ( msg ) msg = self . error_messages [ 'invalid' ] % value raise exceptions . ValidationError ( msg ) def pre_save ( self , model_instance , add ) : if self . auto_now or ( self . auto_now_add and add ) : value = timezone . now ( ) setattr ( model_instance , self . attname , value ) return value else : return super ( DateTimeField , self ) . pre_save ( model_instance , add ) def get_prep_value ( self , value ) : value = self . to_python ( value ) if value is not None and settings . USE_TZ and timezone . is_naive ( value ) : warnings . warn ( u"DateTimeField received a naive datetime (%s)" % value , RuntimeWarning ) default_timezone = timezone . get_default_timezone ( ) value = timezone . make_aware ( value , default_timezone ) return value def get_db_prep_value ( self , value , connection , prepared = False ) : if not prepared : value = self . get_prep_value ( value ) return connection . ops . value_to_db_datetime ( value ) def value_to_string ( self , obj ) : val = self . _get_val_from_obj ( obj ) return '' if val is None else val . isoformat ( ) def formfield ( self , ** kwargs ) : defaults = { 'form_class' : forms . DateTimeField } defaults . update ( kwargs ) return super ( DateTimeField , self ) . formfield ( ** defaults ) class DecimalField ( Field ) : empty_strings_allowed = False default_error_messages = { : _ ( u"'%s' value must be a decimal number." ) , } description = _ ( "Decimal number" ) def __init__ ( self , verbose_name = None , name = None , max_digits = None , decimal_places = None , ** kwargs ) : self . max_digits , self . decimal_places = max_digits , decimal_places Field . __init__ ( self , verbose_name , name , ** kwargs ) def get_internal_type ( self ) : return "DecimalField" def to_python ( self , value ) : if value is None : return value try : return decimal . Decimal ( value ) except decimal . InvalidOperation : msg = self . error_messages [ 'invalid' ] % str ( value ) raise exceptions . ValidationError ( msg ) def _format ( self , value ) : if isinstance ( value , basestring ) or value is None : return value else : return self . format_number ( value ) def format_number ( self , value ) : from django . db . backends import util return util . format_number ( value , self . max_digits , self . decimal_places ) def get_db_prep_save ( self , value , connection ) : return connection . ops . value_to_db_decimal ( self . to_python ( value ) , self . max_digits , self . decimal_places ) def get_prep_value ( self , value ) : return self . to_python ( value ) def formfield ( self , ** kwargs ) : defaults = { : self . max_digits , : self . decimal_places , : forms . DecimalField , } defaults . update ( kwargs ) return super ( DecimalField , self ) . formfield ( ** defaults ) class EmailField ( CharField ) : default_validators = [ validators . validate_email ] description = _ ( "E-mail address" ) def __init__ ( self , * args , ** kwargs ) : kwargs [ 'max_length' ] = kwargs . get ( 'max_length' , 75 ) CharField . __init__ ( self , * args , ** kwargs ) def formfield ( self , ** kwargs ) : defaults = { : forms . EmailField , } defaults . update ( kwargs ) return super ( EmailField , self ) . formfield ( ** defaults ) class FilePathField ( Field ) : description = _ ( "File path" ) def __init__ ( self , verbose_name = None , name = None , path = '' , match = None , recursive = False , ** kwargs ) : self . path , self . match , self . recursive = path , match , recursive kwargs [ 'max_length' ] = kwargs . get ( 'max_length' , 100 ) Field . __init__ ( self , verbose_name , name , ** kwargs ) def formfield ( self , ** kwargs ) : defaults = { : self . path , : self . match , : self . recursive , : forms . FilePathField , } defaults . update ( kwargs ) return super ( FilePathField , self ) . formfield ( ** defaults ) def get_internal_type ( self ) : return "FilePathField" class FloatField ( Field ) : empty_strings_allowed = False default_error_messages = { : _ ( "'%s' value must be a float." ) , } description = _ ( "Floating point number" ) def get_prep_value ( self , value ) : if value is None : return None return float ( value ) def get_internal_type ( self ) : return "FloatField" def to_python ( self , value ) : if value is None : return value try : return float ( value ) except ( TypeError , ValueError ) : msg = self . error_messages [ 'invalid' ] % str ( value ) raise exceptions . ValidationError ( msg ) def formfield ( self , ** kwargs ) : defaults = { 'form_class' : forms . FloatField } defaults . update ( kwargs ) return super ( FloatField , self ) . formfield ( ** defaults ) class IntegerField ( Field ) : empty_strings_allowed = False default_error_messages = { : _ ( "'%s' value must be an integer." ) , } description = _ ( "Integer" ) def get_prep_value ( self , value ) : if value is None : return None return int ( value ) def get_prep_lookup ( self , lookup_type , value ) : if ( ( lookup_type == 'gte' or lookup_type == 'lt' ) and isinstance ( value , float ) ) : value = math . ceil ( value ) return super ( IntegerField , self ) . get_prep_lookup ( lookup_type , value ) def get_internal_type ( self ) : return "IntegerField" def to_python ( self , value ) : if value is None : return value try : return int ( value ) except ( TypeError , ValueError ) : msg = self . error_messages [ 'invalid' ] % str ( value ) raise exceptions . ValidationError ( msg ) def formfield ( self , ** kwargs ) : defaults = { 'form_class' : forms . IntegerField } defaults . update ( kwargs ) return super ( IntegerField , self ) . formfield ( ** defaults ) class BigIntegerField ( IntegerField ) : empty_strings_allowed = False description = _ ( "Big (8 byte) integer" ) MAX_BIGINT = 9223372036854775807 def get_internal_type ( self ) : return "BigIntegerField" def formfield ( self , ** kwargs ) : defaults = { 'min_value' : - BigIntegerField . MAX_BIGINT - 1 , : BigIntegerField . MAX_BIGINT } defaults . update ( kwargs ) return super ( BigIntegerField , self ) . formfield ( ** defaults ) class IPAddressField ( Field ) : empty_strings_allowed = False description = _ ( "IPv4 address" ) def __init__ ( self , * args , ** kwargs ) : kwargs [ 'max_length' ] = 15 Field . __init__ ( self , * args , ** kwargs ) def get_internal_type ( self ) : return "IPAddressField" def formfield ( self , ** kwargs ) : defaults = { 'form_class' : forms . IPAddressField } defaults . update ( kwargs ) return super ( IPAddressField , self ) . formfield ( ** defaults ) class GenericIPAddressField ( Field ) : empty_strings_allowed = True description = _ ( "IP address" ) default_error_messages = { } def __init__ ( self , protocol = 'both' , unpack_ipv4 = False , * args , ** kwargs ) : self . unpack_ipv4 = unpack_ipv4 self . default_validators , invalid_error_message = validators . ip_address_validators ( protocol , unpack_ipv4 ) self . default_error_messages [ 'invalid' ] = invalid_error_message kwargs [ 'max_length' ] = 39 Field . __init__ ( self , * args , ** kwargs ) def get_internal_type ( self ) : return "GenericIPAddressField" def to_python ( self , value ) : if value and ':' in value : return clean_ipv6_address ( value , self . unpack_ipv4 , self . error_messages [ 'invalid' ] ) return value def get_db_prep_value ( self , value , connection , prepared = False ) : if not prepared : value = self . get_prep_value ( value ) return value or None def get_prep_value ( self , value ) : if value and ':' in value : try : return clean_ipv6_address ( value , self . unpack_ipv4 ) except exceptions . ValidationError : pass return value def formfield ( self , ** kwargs ) : defaults = { 'form_class' : forms . GenericIPAddressField } defaults . update ( kwargs ) return super ( GenericIPAddressField , self ) . formfield ( ** defaults ) class NullBooleanField ( Field ) : empty_strings_allowed = False default_error_messages = { : _ ( "'%s' value must be either None, True or False." ) , } description = _ ( "Boolean (Either True, False or None)" ) def __init__ ( self , * args , ** kwargs ) : kwargs [ 'null' ] = True kwargs [ 'blank' ] = True Field . __init__ ( self , * args , ** kwargs ) def get_internal_type ( self ) : return "NullBooleanField" def to_python ( self , value ) : if value is None : return None if value in ( True , False ) : return bool ( value ) if value in ( 'None' , ) : return None if value in ( 't' , 'True' , '1' ) : return True if value in ( 'f' , 'False' , '0' ) : return False msg = self . error_messages [ 'invalid' ] % str ( value ) raise exceptions . ValidationError ( msg ) def get_prep_lookup ( self , lookup_type , value ) : if value in ( '1' , '0' ) : value = bool ( int ( value ) ) return super ( NullBooleanField , self ) . get_prep_lookup ( lookup_type , value ) def get_prep_value ( self , value ) : if value is None : return None return bool ( value ) def formfield ( self , ** kwargs ) : defaults = { : forms . NullBooleanField , : not self . blank , : capfirst ( self . verbose_name ) , : self . help_text } defaults . update ( kwargs ) return super ( NullBooleanField , self ) . formfield ( ** defaults ) class PositiveIntegerField ( IntegerField ) : description = _ ( "Positive integer" ) def get_internal_type ( self ) : return "PositiveIntegerField" def formfield ( self , ** kwargs ) : defaults = { 'min_value' : 0 } defaults . update ( kwargs ) return super ( PositiveIntegerField , self ) . formfield ( ** defaults ) class PositiveSmallIntegerField ( IntegerField ) : description = _ ( "Positive small integer" ) def get_internal_type ( self ) : return "PositiveSmallIntegerField" def formfield ( self , ** kwargs ) : defaults = { 'min_value' : 0 } defaults . update ( kwargs ) return super ( PositiveSmallIntegerField , self ) . formfield ( ** defaults ) class SlugField ( CharField ) : description = _ ( "Slug (up to %(max_length)s)" ) def __init__ ( self , * args , ** kwargs ) : kwargs [ 'max_length' ] = kwargs . get ( 'max_length' , 50 ) if 'db_index' not in kwargs : kwargs [ 'db_index' ] = True super ( SlugField , self ) . __init__ ( * args , ** kwargs ) def get_internal_type ( self ) : return "SlugField" def formfield ( self , ** kwargs ) : defaults = { 'form_class' : forms . SlugField } defaults . update ( kwargs ) return super ( SlugField , self ) . formfield ( ** defaults ) class SmallIntegerField ( IntegerField ) : description = _ ( "Small integer" ) def get_internal_type ( self ) : return "SmallIntegerField" class TextField ( Field ) : description = _ ( "Text" ) def get_internal_type ( self ) : return "TextField" def get_prep_value ( self , value ) : if isinstance ( value , basestring ) or value is None : return value return smart_unicode ( value ) def formfield ( self , ** kwargs ) : defaults = { 'widget' : forms . Textarea } defaults . update ( kwargs ) return super ( TextField , self ) . formfield ( ** defaults ) class TimeField ( Field ) : empty_strings_allowed = False default_error_messages = { : _ ( u"'%s' value has an invalid format. It must be in " ) , : _ ( u"'%s' value has the correct format " ) , } description = _ ( "Time" ) def __init__ ( self , verbose_name = None , name = None , auto_now = False , auto_now_add = False , ** kwargs ) : self . auto_now , self . auto_now_add = auto_now , auto_now_add if auto_now or auto_now_add : kwargs [ 'editable' ] = False kwargs [ 'blank' ] = True Field . __init__ ( self , verbose_name , name , ** kwargs ) def get_internal_type ( self ) : return "TimeField" def to_python ( self , value ) : if value is None : return None if isinstance ( value , datetime . time ) : return value if isinstance ( value , datetime . datetime ) : return value . time ( ) value = smart_str ( value ) try : parsed = parse_time ( value ) if parsed is not None : return parsed except ValueError : msg = self . error_messages [ 'invalid_time' ] % value raise exceptions . ValidationError ( msg ) msg = self . error_messages [ 'invalid' ] % value raise exceptions . ValidationError ( msg ) def pre_save ( self , model_instance , add ) : if self . auto_now or ( self . auto_now_add and add ) : value = datetime . datetime . now ( ) . time ( ) setattr ( model_instance , self . attname , value ) return value else : return super ( TimeField , self ) . pre_save ( model_instance , add ) def get_prep_value ( self , value ) : return self . to_python ( value ) def get_db_prep_value ( self , value , connection , prepared = False ) : if not prepared : value = self . get_prep_value ( value ) return connection . ops . value_to_db_time ( value ) def value_to_string ( self , obj ) : val = self . _get_val_from_obj ( obj ) return '' if val is None else val . isoformat ( ) def formfield ( self , ** kwargs ) : defaults = { 'form_class' : forms . TimeField } defaults . update ( kwargs ) return super ( TimeField , self ) . formfield ( ** defaults ) class URLField ( CharField ) : description = _ ( "URL" ) def __init__ ( self , verbose_name = None , name = None , verify_exists = False , ** kwargs ) : kwargs [ 'max_length' ] = kwargs . get ( 'max_length' , 200 ) CharField . __init__ ( self , verbose_name , name , ** kwargs ) self . validators . append ( validators . URLValidator ( verify_exists = verify_exists ) ) def formfield ( self , ** kwargs ) : defaults = { : forms . URLField , } defaults . update ( kwargs ) return super ( URLField , self ) . formfield ( ** defaults )

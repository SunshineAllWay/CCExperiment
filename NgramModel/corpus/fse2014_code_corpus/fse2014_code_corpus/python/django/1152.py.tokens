from __future__ import with_statement import cgi import errno import mimetypes import os import posixpath import re import shutil import stat import sys import tempfile import urllib from optparse import make_option from os import path import django from django . template import Template , Context from django . utils import archive from django . utils . encoding import smart_str from django . utils . _os import rmtree_errorhandler from django . core . management . base import BaseCommand , CommandError from django . core . management . commands . makemessages import handle_extensions _drive_re = re . compile ( '^([a-z]):' , re . I ) _url_drive_re = re . compile ( '^([a-z])[:|]' , re . I ) class TemplateCommand ( BaseCommand ) : args = "[name] [optional destination directory]" option_list = BaseCommand . option_list + ( make_option ( '--template' , action = 'store' , dest = 'template' , help = 'The dotted import path to load the template from.' ) , make_option ( '--extension' , '-e' , dest = 'extensions' , action = 'append' , default = [ 'py' ] , help = 'The file extension(s) to render (default: "py"). ' ) , make_option ( '--name' , '-n' , dest = 'files' , action = 'append' , default = [ ] , help = 'The file name(s) to render. ' ) ) requires_model_validation = False can_import_settings = False url_schemes = [ 'http' , 'https' , 'ftp' ] def handle ( self , app_or_project , name , target = None , ** options ) : self . app_or_project = app_or_project self . paths_to_remove = [ ] self . verbosity = int ( options . get ( 'verbosity' ) ) if not re . search ( r'^[_a-zA-Z]\w*$' , name ) : if not re . search ( r'^[_a-zA-Z]' , name ) : message = ( 'make sure the name begins ' ) else : message = 'use only numbers, letters and underscores' raise CommandError ( "%r is not a valid %s name. Please %s." % ( name , app_or_project , message ) ) if target is None : top_dir = path . join ( os . getcwd ( ) , name ) try : os . makedirs ( top_dir ) except OSError , e : if e . errno == errno . EEXIST : message = "'%s' already exists" % top_dir else : message = e raise CommandError ( message ) else : top_dir = path . expanduser ( target ) extensions = tuple ( handle_extensions ( options . get ( 'extensions' ) , ignored = ( ) ) ) extra_files = [ ] for file in options . get ( 'files' ) : extra_files . extend ( map ( lambda x : x . strip ( ) , file . split ( ',' ) ) ) if self . verbosity >= 2 : self . stdout . write ( "Rendering %s template files with " % ( app_or_project , ', ' . join ( extensions ) ) ) self . stdout . write ( "Rendering %s template files with " % ( app_or_project , ', ' . join ( extra_files ) ) ) base_name = '%s_name' % app_or_project base_subdir = '%s_template' % app_or_project base_directory = '%s_directory' % app_or_project context = Context ( dict ( options , ** { base_name : name , base_directory : top_dir , } ) ) from django . conf import settings if not settings . configured : settings . configure ( ) template_dir = self . handle_template ( options . get ( 'template' ) , base_subdir ) prefix_length = len ( template_dir ) + 1 for root , dirs , files in os . walk ( template_dir ) : path_rest = root [ prefix_length : ] relative_dir = path_rest . replace ( base_name , name ) if relative_dir : target_dir = path . join ( top_dir , relative_dir ) if not path . exists ( target_dir ) : os . mkdir ( target_dir ) for dirname in dirs [ : ] : if dirname . startswith ( '.' ) : dirs . remove ( dirname ) for filename in files : if filename . endswith ( ( '.pyo' , '.pyc' , '.py.class' ) ) : continue old_path = path . join ( root , filename ) new_path = path . join ( top_dir , relative_dir , filename . replace ( base_name , name ) ) if path . exists ( new_path ) : raise CommandError ( "%s already exists, overlaying a " % new_path ) with open ( old_path , 'r' ) as template_file : content = template_file . read ( ) if filename . endswith ( extensions ) or filename in extra_files : template = Template ( content ) content = template . render ( context ) with open ( new_path , 'w' ) as new_file : new_file . write ( content ) if self . verbosity >= 2 : self . stdout . write ( "Creating %s\n" % new_path ) try : shutil . copymode ( old_path , new_path ) self . make_writeable ( new_path ) except OSError : notice = self . style . NOTICE ( % new_path ) sys . stderr . write ( smart_str ( notice ) ) if self . paths_to_remove : if self . verbosity >= 2 : self . stdout . write ( "Cleaning up temporary files.\n" ) for path_to_remove in self . paths_to_remove : if path . isfile ( path_to_remove ) : os . remove ( path_to_remove ) else : shutil . rmtree ( path_to_remove , onerror = rmtree_errorhandler ) def handle_template ( self , template , subdir ) : if template is None : return path . join ( django . __path__ [ 0 ] , 'conf' , subdir ) else : if template . startswith ( 'file://' ) : template = template [ 7 : ] expanded_template = path . expanduser ( template ) expanded_template = path . normpath ( expanded_template ) if path . isdir ( expanded_template ) : return expanded_template if self . is_url ( template ) : absolute_path = self . download ( template ) else : absolute_path = path . abspath ( expanded_template ) if path . exists ( absolute_path ) : return self . extract ( absolute_path ) raise CommandError ( "couldn't handle %s template %s." % ( self . app_or_project , template ) ) def download ( self , url ) : def cleanup_url ( url ) : tmp = url . rstrip ( '/' ) filename = tmp . split ( '/' ) [ - 1 ] if url . endswith ( '/' ) : display_url = tmp + '/' else : display_url = url return filename , display_url prefix = 'django_%s_template_' % self . app_or_project tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = '_download' ) self . paths_to_remove . append ( tempdir ) filename , display_url = cleanup_url ( url ) if self . verbosity >= 2 : self . stdout . write ( "Downloading %s\n" % display_url ) try : the_path , info = urllib . urlretrieve ( url , path . join ( tempdir , filename ) ) except IOError , e : raise CommandError ( "couldn't download URL %s to %s: %s" % ( url , filename , e ) ) used_name = the_path . split ( '/' ) [ - 1 ] content_disposition = info . get ( 'content-disposition' ) if content_disposition : _ , params = cgi . parse_header ( content_disposition ) guessed_filename = params . get ( 'filename' ) or used_name else : guessed_filename = used_name ext = self . splitext ( guessed_filename ) [ 1 ] content_type = info . get ( 'content-type' ) if not ext and content_type : ext = mimetypes . guess_extension ( content_type ) if ext : guessed_filename += ext if used_name != guessed_filename : guessed_path = path . join ( tempdir , guessed_filename ) shutil . move ( the_path , guessed_path ) return guessed_path return the_path def splitext ( self , the_path ) : base , ext = posixpath . splitext ( the_path ) if base . lower ( ) . endswith ( '.tar' ) : ext = base [ - 4 : ] + ext base = base [ : - 4 ] return base , ext def extract ( self , filename ) : prefix = 'django_%s_template_' % self . app_or_project tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = '_extract' ) self . paths_to_remove . append ( tempdir ) if self . verbosity >= 2 : self . stdout . write ( "Extracting %s\n" % filename ) try : archive . extract ( filename , tempdir ) return tempdir except ( archive . ArchiveException , IOError ) , e : raise CommandError ( "couldn't extract file %s to %s: %s" % ( filename , tempdir , e ) ) def is_url ( self , template ) : if ':' not in template : return False scheme = template . split ( ':' , 1 ) [ 0 ] . lower ( ) return scheme in self . url_schemes def make_writeable ( self , filename ) : if sys . platform . startswith ( 'java' ) : return if not os . access ( filename , os . W_OK ) : st = os . stat ( filename ) new_permissions = stat . S_IMODE ( st . st_mode ) | stat . S_IWUSR os . chmod ( filename , new_permissions )

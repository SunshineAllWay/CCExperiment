""" This module contains the spatial lookup types, and the `get_geo_where_clause` routine for Oracle Spatial. Please note that WKT support is broken on the XE version, and thus this backend will not work on such platforms. Specifically, XE lacks support for an internal JVM, and Java libraries are required to use the WKT constructors. """ import re from decimal import Decimal from django . db . backends . oracle . base import DatabaseOperations from django . contrib . gis . db . backends . base import BaseSpatialOperations from django . contrib . gis . db . backends . oracle . adapter import OracleSpatialAdapter from django . contrib . gis . db . backends . util import SpatialFunction from django . contrib . gis . geometry . backend import Geometry from django . contrib . gis . measure import Distance class SDOOperation ( SpatialFunction ) : sql_template = "%(function)s(%(geo_col)s, %(geometry)s) %(operator)s '%(result)s'" def __init__ ( self , func , ** kwargs ) : kwargs . setdefault ( 'operator' , '=' ) kwargs . setdefault ( 'result' , 'TRUE' ) super ( SDOOperation , self ) . __init__ ( func , ** kwargs ) class SDODistance ( SpatialFunction ) : sql_template = ( '%(function)s(%(geo_col)s, %(geometry)s, %(tolerance)s) ' ) dist_func = 'SDO_GEOM.SDO_DISTANCE' def __init__ ( self , op , tolerance = 0.05 ) : super ( SDODistance , self ) . __init__ ( self . dist_func , tolerance = tolerance , operator = op , result = '%s' ) class SDODWithin ( SpatialFunction ) : dwithin_func = 'SDO_WITHIN_DISTANCE' sql_template = "%(function)s(%(geo_col)s, %(geometry)s, %%s) = 'TRUE'" def __init__ ( self ) : super ( SDODWithin , self ) . __init__ ( self . dwithin_func ) class SDOGeomRelate ( SpatialFunction ) : relate_func = 'SDO_GEOM.RELATE' sql_template = ( "%(function)s(%(geo_col)s, '%(mask)s', %(geometry)s, " ) def __init__ ( self , mask , tolerance = 0.05 ) : super ( SDOGeomRelate , self ) . __init__ ( self . relate_func , operator = '=' , mask = mask , tolerance = tolerance ) class SDORelate ( SpatialFunction ) : masks = 'TOUCH|OVERLAPBDYDISJOINT|OVERLAPBDYINTERSECT|EQUAL|INSIDE|COVEREDBY|CONTAINS|COVERS|ANYINTERACT|ON' mask_regex = re . compile ( r'^(%s)(\+(%s))*$' % ( masks , masks ) , re . I ) sql_template = "%(function)s(%(geo_col)s, %(geometry)s, 'mask=%(mask)s') = 'TRUE'" relate_func = 'SDO_RELATE' def __init__ ( self , mask ) : if not self . mask_regex . match ( mask ) : raise ValueError ( 'Invalid %s mask: "%s"' % ( self . relate_func , mask ) ) super ( SDORelate , self ) . __init__ ( self . relate_func , mask = mask ) dtypes = ( Decimal , Distance , float , int , long ) class OracleOperations ( DatabaseOperations , BaseSpatialOperations ) : compiler_module = "django.contrib.gis.db.backends.oracle.compiler" name = 'oracle' oracle = True valid_aggregates = dict ( [ ( a , None ) for a in ( 'Union' , 'Extent' ) ] ) Adapter = OracleSpatialAdapter Adaptor = Adapter area = 'SDO_GEOM.SDO_AREA' gml = 'SDO_UTIL.TO_GMLGEOMETRY' centroid = 'SDO_GEOM.SDO_CENTROID' difference = 'SDO_GEOM.SDO_DIFFERENCE' distance = 'SDO_GEOM.SDO_DISTANCE' extent = 'SDO_AGGR_MBR' intersection = 'SDO_GEOM.SDO_INTERSECTION' length = 'SDO_GEOM.SDO_LENGTH' num_geom = 'SDO_UTIL.GETNUMELEM' num_points = 'SDO_UTIL.GETNUMVERTICES' perimeter = length point_on_surface = 'SDO_GEOM.SDO_POINTONSURFACE' reverse = 'SDO_UTIL.REVERSE_LINESTRING' sym_difference = 'SDO_GEOM.SDO_XOR' transform = 'SDO_CS.TRANSFORM' union = 'SDO_GEOM.SDO_UNION' unionagg = 'SDO_AGGR_UNION' select = 'SDO_UTIL.TO_WKTGEOMETRY(%s)' distance_functions = { : ( SDODistance ( '>' ) , dtypes ) , : ( SDODistance ( '>=' ) , dtypes ) , : ( SDODistance ( '<' ) , dtypes ) , : ( SDODistance ( '<=' ) , dtypes ) , : ( SDODWithin ( ) , dtypes ) , } geometry_functions = { : SDOOperation ( 'SDO_CONTAINS' ) , : SDOOperation ( 'SDO_COVEREDBY' ) , : SDOOperation ( 'SDO_COVERS' ) , : SDOGeomRelate ( 'DISJOINT' ) , : SDOOperation ( 'SDO_OVERLAPBDYINTERSECT' ) , : SDOOperation ( 'SDO_EQUAL' ) , : SDOOperation ( 'SDO_EQUAL' ) , : SDOOperation ( 'SDO_OVERLAPS' ) , : SDOOperation ( 'SDO_EQUAL' ) , : ( SDORelate , basestring ) , : SDOOperation ( 'SDO_TOUCH' ) , : SDOOperation ( 'SDO_INSIDE' ) , } geometry_functions . update ( distance_functions ) gis_terms = [ 'isnull' ] gis_terms += geometry_functions . keys ( ) gis_terms = dict ( [ ( term , None ) for term in gis_terms ] ) truncate_params = { 'relate' : None } def convert_extent ( self , clob ) : if clob : ext_geom = Geometry ( clob . read ( ) ) gtype = str ( ext_geom . geom_type ) if gtype == 'Polygon' : shell = ext_geom . shell ll , ur = shell [ 0 ] [ : 2 ] , shell [ 2 ] [ : 2 ] elif gtype == 'Point' : ll = ext_geom . coords [ : 2 ] ur = ll else : raise Exception ( 'Unexpected geometry type returned for extent: %s' % gtype ) xmin , ymin = ll xmax , ymax = ur return ( xmin , ymin , xmax , ymax ) else : return None def convert_geom ( self , clob , geo_field ) : if clob : return Geometry ( clob . read ( ) , geo_field . srid ) else : return None def geo_db_type ( self , f ) : return 'MDSYS.SDO_GEOMETRY' def get_distance ( self , f , value , lookup_type ) : if not value : return [ ] value = value [ 0 ] if isinstance ( value , Distance ) : if f . geodetic ( self . connection ) : dist_param = value . m else : dist_param = getattr ( value , Distance . unit_attname ( f . units_name ( self . connection ) ) ) else : dist_param = value if lookup_type == 'dwithin' : dist_param = 'distance=%s' % dist_param return [ dist_param ] def get_geom_placeholder ( self , f , value ) : if value is None : return 'NULL' def transform_value ( val , srid ) : return val . srid != srid if hasattr ( value , 'expression' ) : if transform_value ( value , f . srid ) : placeholder = '%s(%%s, %s)' % ( self . transform , f . srid ) else : placeholder = '%s' return placeholder % '%s.%s' % tuple ( map ( self . quote_name , value . cols [ value . expression ] ) ) else : if transform_value ( value , f . srid ) : return '%s(SDO_GEOMETRY(%%s, %s), %s)' % ( self . transform , value . srid , f . srid ) else : return 'SDO_GEOMETRY(%%s, %s)' % f . srid def spatial_lookup_sql ( self , lvalue , lookup_type , value , field , qn ) : alias , col , db_type = lvalue geo_col = '%s.%s' % ( qn ( alias ) , qn ( col ) ) lookup_info = self . geometry_functions . get ( lookup_type , False ) if lookup_info : if isinstance ( lookup_info , tuple ) : sdo_op , arg_type = lookup_info geom = value [ 0 ] if not isinstance ( value , tuple ) : raise ValueError ( 'Tuple required for `%s` lookup type.' % lookup_type ) if len ( value ) != 2 : raise ValueError ( '2-element tuple required for %s lookup type.' % lookup_type ) if not isinstance ( value [ 1 ] , arg_type ) : raise ValueError ( 'Argument type should be %s, got %s instead.' % ( arg_type , type ( value [ 1 ] ) ) ) if lookup_type == 'relate' : return sdo_op ( value [ 1 ] ) . as_sql ( geo_col , self . get_geom_placeholder ( field , geom ) ) else : return sdo_op . as_sql ( geo_col , self . get_geom_placeholder ( field , geom ) ) else : return lookup_info . as_sql ( geo_col , self . get_geom_placeholder ( field , value ) ) elif lookup_type == 'isnull' : return "%s IS %sNULL" % ( geo_col , ( not value and 'NOT ' or '' ) ) raise TypeError ( "Got invalid lookup_type: %s" % repr ( lookup_type ) ) def spatial_aggregate_sql ( self , agg ) : agg_name = agg . __class__ . __name__ . lower ( ) if agg_name == 'union' : agg_name += 'agg' if agg . is_extent : sql_template = '%(function)s(%(field)s)' else : sql_template = '%(function)s(SDOAGGRTYPE(%(field)s,%(tolerance)s))' sql_function = getattr ( self , agg_name ) return self . select % sql_template , sql_function def geometry_columns ( self ) : from django . contrib . gis . db . backends . oracle . models import GeometryColumns return GeometryColumns def spatial_ref_sys ( self ) : from django . contrib . gis . db . backends . oracle . models import SpatialRefSys return SpatialRefSys

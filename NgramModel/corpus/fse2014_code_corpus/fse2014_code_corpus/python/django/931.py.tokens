import weakref import threading from django . dispatch import saferef WEAKREF_TYPES = ( weakref . ReferenceType , saferef . BoundMethodWeakref ) def _make_id ( target ) : if hasattr ( target , 'im_func' ) : return ( id ( target . im_self ) , id ( target . im_func ) ) return id ( target ) class Signal ( object ) : def __init__ ( self , providing_args = None ) : self . receivers = [ ] if providing_args is None : providing_args = [ ] self . providing_args = set ( providing_args ) self . lock = threading . Lock ( ) def connect ( self , receiver , sender = None , weak = True , dispatch_uid = None ) : from django . conf import settings if settings . DEBUG : import inspect assert callable ( receiver ) , "Signal receivers must be callable." try : argspec = inspect . getargspec ( receiver ) except TypeError : try : argspec = inspect . getargspec ( receiver . __call__ ) except ( TypeError , AttributeError ) : argspec = None if argspec : assert argspec [ 2 ] is not None , "Signal receivers must accept keyword arguments (**kwargs)." if dispatch_uid : lookup_key = ( dispatch_uid , _make_id ( sender ) ) else : lookup_key = ( _make_id ( receiver ) , _make_id ( sender ) ) if weak : receiver = saferef . safeRef ( receiver , onDelete = self . _remove_receiver ) self . lock . acquire ( ) try : for r_key , _ in self . receivers : if r_key == lookup_key : break else : self . receivers . append ( ( lookup_key , receiver ) ) finally : self . lock . release ( ) def disconnect ( self , receiver = None , sender = None , weak = True , dispatch_uid = None ) : if dispatch_uid : lookup_key = ( dispatch_uid , _make_id ( sender ) ) else : lookup_key = ( _make_id ( receiver ) , _make_id ( sender ) ) self . lock . acquire ( ) try : for index in xrange ( len ( self . receivers ) ) : ( r_key , _ ) = self . receivers [ index ] if r_key == lookup_key : del self . receivers [ index ] break finally : self . lock . release ( ) def send ( self , sender , ** named ) : responses = [ ] if not self . receivers : return responses for receiver in self . _live_receivers ( _make_id ( sender ) ) : response = receiver ( signal = self , sender = sender , ** named ) responses . append ( ( receiver , response ) ) return responses def send_robust ( self , sender , ** named ) : responses = [ ] if not self . receivers : return responses for receiver in self . _live_receivers ( _make_id ( sender ) ) : try : response = receiver ( signal = self , sender = sender , ** named ) except Exception , err : responses . append ( ( receiver , err ) ) else : responses . append ( ( receiver , response ) ) return responses def _live_receivers ( self , senderkey ) : none_senderkey = _make_id ( None ) receivers = [ ] for ( receiverkey , r_senderkey ) , receiver in self . receivers : if r_senderkey == none_senderkey or r_senderkey == senderkey : if isinstance ( receiver , WEAKREF_TYPES ) : receiver = receiver ( ) if receiver is not None : receivers . append ( receiver ) else : receivers . append ( receiver ) return receivers def _remove_receiver ( self , receiver ) : self . lock . acquire ( ) try : to_remove = [ ] for key , connected_receiver in self . receivers : if connected_receiver == receiver : to_remove . append ( key ) for key in to_remove : last_idx = len ( self . receivers ) - 1 for idx , ( r_key , _ ) in enumerate ( reversed ( self . receivers ) ) : if r_key == key : del self . receivers [ last_idx - idx ] finally : self . lock . release ( ) def receiver ( signal , ** kwargs ) : def _decorator ( func ) : signal . connect ( func , ** kwargs ) return func return _decorator

""" Convenience routines for creating non-trivial Field subclasses, as well as backwards compatibility utilities. Add SubfieldBase as the __metaclass__ for your Field subclass, implement to_python() and the other necessary methods and everything will work seamlessly. """ class SubfieldBase ( type ) : def __new__ ( cls , name , bases , attrs ) : new_class = super ( SubfieldBase , cls ) . __new__ ( cls , name , bases , attrs ) new_class . contribute_to_class = make_contrib ( new_class , attrs . get ( 'contribute_to_class' ) ) return new_class class Creator ( object ) : def __init__ ( self , field ) : self . field = field def __get__ ( self , obj , type = None ) : if obj is None : raise AttributeError ( 'Can only be accessed via an instance.' ) return obj . __dict__ [ self . field . name ] def __set__ ( self , obj , value ) : obj . __dict__ [ self . field . name ] = self . field . to_python ( value ) def make_contrib ( superclass , func = None ) : def contribute_to_class ( self , cls , name ) : if func : func ( self , cls , name ) else : super ( superclass , self ) . contribute_to_class ( cls , name ) setattr ( cls , self . name , Creator ( self ) ) return contribute_to_class

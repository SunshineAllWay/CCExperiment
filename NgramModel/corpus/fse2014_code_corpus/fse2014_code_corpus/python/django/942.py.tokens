"""Default variable filters.""" import re import random as random_module import unicodedata from decimal import Decimal , InvalidOperation , Context , ROUND_HALF_UP from functools import wraps from pprint import pformat from django . template . base import Variable , Library , VariableDoesNotExist from django . conf import settings from django . utils import formats from django . utils . dateformat import format , time_format from django . utils . encoding import force_unicode , iri_to_uri from django . utils . html import ( conditional_escape , escapejs , fix_ampersands , escape , urlize as urlize_impl , linebreaks , strip_tags ) from django . utils . http import urlquote from django . utils . text import Truncator , wrap , phone2numeric from django . utils . safestring import mark_safe , SafeData , mark_for_escaping from django . utils . timesince import timesince , timeuntil from django . utils . translation import ugettext , ungettext from django . utils . text import normalize_newlines register = Library ( ) def stringfilter ( func ) : def _dec ( * args , ** kwargs ) : if args : args = list ( args ) args [ 0 ] = force_unicode ( args [ 0 ] ) if ( isinstance ( args [ 0 ] , SafeData ) and getattr ( _dec . _decorated_function , 'is_safe' , False ) ) : return mark_safe ( func ( * args , ** kwargs ) ) return func ( * args , ** kwargs ) _dec . _decorated_function = getattr ( func , '_decorated_function' , func ) for attr in ( 'is_safe' , 'needs_autoescape' ) : if hasattr ( func , attr ) : import warnings warnings . warn ( "Setting the %s attribute of a template filter " % ( attr , attr , getattr ( func , attr ) ) , PendingDeprecationWarning ) setattr ( _dec , attr , getattr ( func , attr ) ) return wraps ( func ) ( _dec ) @ register . filter ( is_safe = True ) @ stringfilter def addslashes ( value ) : return value . replace ( '\\' , '\\\\' ) . replace ( '"' , '\\"' ) . replace ( "'" , "\\'" ) @ register . filter ( is_safe = True ) @ stringfilter def capfirst ( value ) : return value and value [ 0 ] . upper ( ) + value [ 1 : ] @ register . filter ( "escapejs" ) @ stringfilter def escapejs_filter ( value ) : return escapejs ( value ) @ register . filter ( "fix_ampersands" , is_safe = True ) @ stringfilter def fix_ampersands_filter ( value ) : return fix_ampersands ( value ) pos_inf = 1e200 * 1e200 neg_inf = - 1e200 * 1e200 nan = ( 1e200 * 1e200 ) // ( 1e200 * 1e200 ) special_floats = [ str ( pos_inf ) , str ( neg_inf ) , str ( nan ) ] @ register . filter ( is_safe = True ) def floatformat ( text , arg = - 1 ) : try : input_val = force_unicode ( text ) d = Decimal ( input_val ) except UnicodeEncodeError : return u'' except InvalidOperation : if input_val in special_floats : return input_val try : d = Decimal ( force_unicode ( float ( text ) ) ) except ( ValueError , InvalidOperation , TypeError , UnicodeEncodeError ) : return u'' try : p = int ( arg ) except ValueError : return input_val try : m = int ( d ) - d except ( ValueError , OverflowError , InvalidOperation ) : return input_val if not m and p < 0 : return mark_safe ( formats . number_format ( u'%d' % ( int ( d ) ) , 0 ) ) if p == 0 : exp = Decimal ( 1 ) else : exp = Decimal ( u'1.0' ) / ( Decimal ( 10 ) ** abs ( p ) ) try : tupl = d . as_tuple ( ) units = len ( tupl [ 1 ] ) - tupl [ 2 ] prec = abs ( p ) + units + 1 sign , digits , exponent = d . quantize ( exp , ROUND_HALF_UP , Context ( prec = prec ) ) . as_tuple ( ) digits = [ unicode ( digit ) for digit in reversed ( digits ) ] while len ( digits ) <= abs ( exponent ) : digits . append ( u'0' ) digits . insert ( - exponent , u'.' ) if sign : digits . append ( u'-' ) number = u'' . join ( reversed ( digits ) ) return mark_safe ( formats . number_format ( number , abs ( p ) ) ) except InvalidOperation : return input_val @ register . filter ( is_safe = True ) @ stringfilter def iriencode ( value ) : return force_unicode ( iri_to_uri ( value ) ) @ register . filter ( is_safe = True , needs_autoescape = True ) @ stringfilter def linenumbers ( value , autoescape = None ) : lines = value . split ( u'\n' ) width = unicode ( len ( unicode ( len ( lines ) ) ) ) if not autoescape or isinstance ( value , SafeData ) : for i , line in enumerate ( lines ) : lines [ i ] = ( u"%0" + width + u"d. %s" ) % ( i + 1 , line ) else : for i , line in enumerate ( lines ) : lines [ i ] = ( u"%0" + width + u"d. %s" ) % ( i + 1 , escape ( line ) ) return mark_safe ( u'\n' . join ( lines ) ) @ register . filter ( is_safe = True ) @ stringfilter def lower ( value ) : return value . lower ( ) @ register . filter ( is_safe = False ) @ stringfilter def make_list ( value ) : return list ( value ) @ register . filter ( is_safe = True ) @ stringfilter def slugify ( value ) : value = unicodedata . normalize ( 'NFKD' , value ) . encode ( 'ascii' , 'ignore' ) value = unicode ( re . sub ( '[^\w\s-]' , '' , value ) . strip ( ) . lower ( ) ) return mark_safe ( re . sub ( '[-\s]+' , '-' , value ) ) @ register . filter ( is_safe = True ) def stringformat ( value , arg ) : try : return ( u"%" + unicode ( arg ) ) % value except ( ValueError , TypeError ) : return u"" @ register . filter ( is_safe = True ) @ stringfilter def title ( value ) : t = re . sub ( "([a-z])'([A-Z])" , lambda m : m . group ( 0 ) . lower ( ) , value . title ( ) ) return re . sub ( "\d([A-Z])" , lambda m : m . group ( 0 ) . lower ( ) , t ) @ register . filter ( is_safe = True ) @ stringfilter def truncatechars ( value , arg ) : try : length = int ( arg ) except ValueError : return value return Truncator ( value ) . chars ( length ) @ register . filter ( is_safe = True ) @ stringfilter def truncatewords ( value , arg ) : try : length = int ( arg ) except ValueError : return value return Truncator ( value ) . words ( length , truncate = ' ...' ) @ register . filter ( is_safe = True ) @ stringfilter def truncatewords_html ( value , arg ) : try : length = int ( arg ) except ValueError : return value return Truncator ( value ) . words ( length , html = True , truncate = ' ...' ) @ register . filter ( is_safe = False ) @ stringfilter def upper ( value ) : return value . upper ( ) @ register . filter ( is_safe = False ) @ stringfilter def urlencode ( value , safe = None ) : kwargs = { } if safe is not None : kwargs [ 'safe' ] = safe return urlquote ( value , ** kwargs ) @ register . filter ( is_safe = True , needs_autoescape = True ) @ stringfilter def urlize ( value , autoescape = None ) : return mark_safe ( urlize_impl ( value , nofollow = True , autoescape = autoescape ) ) @ register . filter ( is_safe = True , needs_autoescape = True ) @ stringfilter def urlizetrunc ( value , limit , autoescape = None ) : return mark_safe ( urlize_impl ( value , trim_url_limit = int ( limit ) , nofollow = True , autoescape = autoescape ) ) @ register . filter ( is_safe = False ) @ stringfilter def wordcount ( value ) : return len ( value . split ( ) ) @ register . filter ( is_safe = True ) @ stringfilter def wordwrap ( value , arg ) : return wrap ( value , int ( arg ) ) @ register . filter ( is_safe = True ) @ stringfilter def ljust ( value , arg ) : return value . ljust ( int ( arg ) ) @ register . filter ( is_safe = True ) @ stringfilter def rjust ( value , arg ) : return value . rjust ( int ( arg ) ) @ register . filter ( is_safe = True ) @ stringfilter def center ( value , arg ) : return value . center ( int ( arg ) ) @ register . filter @ stringfilter def cut ( value , arg ) : safe = isinstance ( value , SafeData ) value = value . replace ( arg , u'' ) if safe and arg != ';' : return mark_safe ( value ) return value @ register . filter ( "escape" , is_safe = True ) @ stringfilter def escape_filter ( value ) : return mark_for_escaping ( value ) @ register . filter ( is_safe = True ) @ stringfilter def force_escape ( value ) : return mark_safe ( escape ( value ) ) @ register . filter ( "linebreaks" , is_safe = True , needs_autoescape = True ) @ stringfilter def linebreaks_filter ( value , autoescape = None ) : autoescape = autoescape and not isinstance ( value , SafeData ) return mark_safe ( linebreaks ( value , autoescape ) ) @ register . filter ( is_safe = True , needs_autoescape = True ) @ stringfilter def linebreaksbr ( value , autoescape = None ) : autoescape = autoescape and not isinstance ( value , SafeData ) value = normalize_newlines ( value ) if autoescape : value = escape ( value ) return mark_safe ( value . replace ( '\n' , '<br />' ) ) @ register . filter ( is_safe = True ) @ stringfilter def safe ( value ) : return mark_safe ( value ) @ register . filter ( is_safe = True ) def safeseq ( value ) : return [ mark_safe ( force_unicode ( obj ) ) for obj in value ] @ register . filter ( is_safe = True ) @ stringfilter def removetags ( value , tags ) : tags = [ re . escape ( tag ) for tag in tags . split ( ) ] tags_re = u'(%s)' % u'|' . join ( tags ) starttag_re = re . compile ( ur'<%s(/?>|(\s+[^>]*>))' % tags_re , re . U ) endtag_re = re . compile ( u'</%s>' % tags_re ) value = starttag_re . sub ( u'' , value ) value = endtag_re . sub ( u'' , value ) return value @ register . filter ( is_safe = True ) @ stringfilter def striptags ( value ) : return strip_tags ( value ) @ register . filter ( is_safe = False ) def dictsort ( value , arg ) : try : return sorted ( value , key = Variable ( arg ) . resolve ) except ( TypeError , VariableDoesNotExist ) : return u'' @ register . filter ( is_safe = False ) def dictsortreversed ( value , arg ) : try : return sorted ( value , key = Variable ( arg ) . resolve , reverse = True ) except ( TypeError , VariableDoesNotExist ) : return u'' @ register . filter ( is_safe = False ) def first ( value ) : try : return value [ 0 ] except IndexError : return u'' @ register . filter ( is_safe = True , needs_autoescape = True ) def join ( value , arg , autoescape = None ) : value = map ( force_unicode , value ) if autoescape : value = [ conditional_escape ( v ) for v in value ] try : data = conditional_escape ( arg ) . join ( value ) except AttributeError : return value return mark_safe ( data ) @ register . filter ( is_safe = True ) def last ( value ) : try : return value [ - 1 ] except IndexError : return u'' @ register . filter ( is_safe = True ) def length ( value ) : try : return len ( value ) except ( ValueError , TypeError ) : return '' @ register . filter ( is_safe = False ) def length_is ( value , arg ) : try : return len ( value ) == int ( arg ) except ( ValueError , TypeError ) : return '' @ register . filter ( is_safe = True ) def random ( value ) : return random_module . choice ( value ) @ register . filter ( "slice" , is_safe = True ) def slice_filter ( value , arg ) : try : bits = [ ] for x in arg . split ( u':' ) : if len ( x ) == 0 : bits . append ( None ) else : bits . append ( int ( x ) ) return value [ slice ( * bits ) ] except ( ValueError , TypeError ) : return value @ register . filter ( is_safe = True , needs_autoescape = True ) def unordered_list ( value , autoescape = None ) : if autoescape : escaper = conditional_escape else : escaper = lambda x : x def convert_old_style_list ( list_ ) : if not isinstance ( list_ , ( tuple , list ) ) or len ( list_ ) != 2 : return list_ , False first_item , second_item = list_ if second_item == [ ] : return [ first_item ] , True try : iter ( second_item ) except TypeError : return list_ , False old_style_list = True new_second_item = [ ] for sublist in second_item : item , old_style_list = convert_old_style_list ( sublist ) if not old_style_list : break new_second_item . extend ( item ) if old_style_list : second_item = new_second_item return [ first_item , second_item ] , old_style_list def _helper ( list_ , tabs = 1 ) : indent = u'\t' * tabs output = [ ] list_length = len ( list_ ) i = 0 while i < list_length : title = list_ [ i ] sublist = '' sublist_item = None if isinstance ( title , ( list , tuple ) ) : sublist_item = title title = '' elif i < list_length - 1 : next_item = list_ [ i + 1 ] if next_item and isinstance ( next_item , ( list , tuple ) ) : sublist_item = next_item i += 1 if sublist_item : sublist = _helper ( sublist_item , tabs + 1 ) sublist = '\n%s<ul>\n%s\n%s</ul>\n%s' % ( indent , sublist , indent , indent ) output . append ( '%s<li>%s%s</li>' % ( indent , escaper ( force_unicode ( title ) ) , sublist ) ) i += 1 return '\n' . join ( output ) value , converted = convert_old_style_list ( value ) return mark_safe ( _helper ( value ) ) @ register . filter ( is_safe = False ) def add ( value , arg ) : try : return int ( value ) + int ( arg ) except ( ValueError , TypeError ) : try : return value + arg except Exception : return '' @ register . filter ( is_safe = False ) def get_digit ( value , arg ) : try : arg = int ( arg ) value = int ( value ) except ValueError : return value if arg < 1 : return value try : return int ( str ( value ) [ - arg ] ) except IndexError : return 0 @ register . filter ( expects_localtime = True , is_safe = False ) def date ( value , arg = None ) : if not value : return u'' if arg is None : arg = settings . DATE_FORMAT try : return formats . date_format ( value , arg ) except AttributeError : try : return format ( value , arg ) except AttributeError : return '' @ register . filter ( expects_localtime = True , is_safe = False ) def time ( value , arg = None ) : if value in ( None , u'' ) : return u'' if arg is None : arg = settings . TIME_FORMAT try : return formats . time_format ( value , arg ) except AttributeError : try : return time_format ( value , arg ) except AttributeError : return '' @ register . filter ( "timesince" , is_safe = False ) def timesince_filter ( value , arg = None ) : if not value : return u'' try : if arg : return timesince ( value , arg ) return timesince ( value ) except ( ValueError , TypeError ) : return u'' @ register . filter ( "timeuntil" , is_safe = False ) def timeuntil_filter ( value , arg = None ) : if not value : return u'' try : return timeuntil ( value , arg ) except ( ValueError , TypeError ) : return u'' @ register . filter ( is_safe = False ) def default ( value , arg ) : return value or arg @ register . filter ( is_safe = False ) def default_if_none ( value , arg ) : if value is None : return arg return value @ register . filter ( is_safe = False ) def divisibleby ( value , arg ) : return int ( value ) % int ( arg ) == 0 @ register . filter ( is_safe = False ) def yesno ( value , arg = None ) : if arg is None : arg = ugettext ( 'yes,no,maybe' ) bits = arg . split ( u',' ) if len ( bits ) < 2 : return value try : yes , no , maybe = bits except ValueError : yes , no , maybe = bits [ 0 ] , bits [ 1 ] , bits [ 1 ] if value is None : return maybe if value : return yes return no @ register . filter ( is_safe = True ) def filesizeformat ( bytes ) : try : bytes = float ( bytes ) except ( TypeError , ValueError , UnicodeDecodeError ) : return ungettext ( "%(size)d byte" , "%(size)d bytes" , 0 ) % { 'size' : 0 } filesize_number_format = lambda value : formats . number_format ( round ( value , 1 ) , 1 ) if bytes < 1024 : return ungettext ( "%(size)d byte" , "%(size)d bytes" , bytes ) % { 'size' : bytes } if bytes < 1024 * 1024 : return ugettext ( "%s KB" ) % filesize_number_format ( bytes / 1024 ) if bytes < 1024 * 1024 * 1024 : return ugettext ( "%s MB" ) % filesize_number_format ( bytes / ( 1024 * 1024 ) ) if bytes < 1024 * 1024 * 1024 * 1024 : return ugettext ( "%s GB" ) % filesize_number_format ( bytes / ( 1024 * 1024 * 1024 ) ) if bytes < 1024 * 1024 * 1024 * 1024 * 1024 : return ugettext ( "%s TB" ) % filesize_number_format ( bytes / ( 1024 * 1024 * 1024 * 1024 ) ) return ugettext ( "%s PB" ) % filesize_number_format ( bytes / ( 1024 * 1024 * 1024 * 1024 * 1024 ) ) @ register . filter ( is_safe = False ) def pluralize ( value , arg = u's' ) : if not u',' in arg : arg = u',' + arg bits = arg . split ( u',' ) if len ( bits ) > 2 : return u'' singular_suffix , plural_suffix = bits [ : 2 ] try : if int ( value ) != 1 : return plural_suffix except ValueError : pass except TypeError : try : if len ( value ) != 1 : return plural_suffix except TypeError : pass return singular_suffix @ register . filter ( "phone2numeric" , is_safe = True ) def phone2numeric_filter ( value ) : return phone2numeric ( value ) @ register . filter ( is_safe = True ) def pprint ( value ) : try : return pformat ( value ) except Exception , e : return u"Error in formatting: %s" % force_unicode ( e , errors = "replace" )

""" Oracle database backend for Django. Requires cx_Oracle: http://cx-oracle.sourceforge.net/ """ import datetime import decimal import sys def _setup_environment ( environ ) : import platform if platform . system ( ) . upper ( ) . startswith ( 'CYGWIN' ) : try : import ctypes except ImportError , e : from django . core . exceptions import ImproperlyConfigured raise ImproperlyConfigured ( "Error loading ctypes: %s; " % e ) kernel32 = ctypes . CDLL ( 'kernel32' ) for name , value in environ : kernel32 . SetEnvironmentVariableA ( name , value ) else : import os os . environ . update ( environ ) _setup_environment ( [ ( 'NLS_LANG' , '.UTF8' ) , ( 'ORA_NCHAR_LITERAL_REPLACE' , 'TRUE' ) , ] ) try : import cx_Oracle as Database except ImportError , e : from django . core . exceptions import ImproperlyConfigured raise ImproperlyConfigured ( "Error loading cx_Oracle module: %s" % e ) from django . conf import settings from django . db import utils from django . db . backends import * from django . db . backends . signals import connection_created from django . db . backends . oracle . client import DatabaseClient from django . db . backends . oracle . creation import DatabaseCreation from django . db . backends . oracle . introspection import DatabaseIntrospection from django . utils . encoding import smart_str , force_unicode from django . utils . timezone import is_aware , is_naive , utc DatabaseError = Database . DatabaseError IntegrityError = Database . IntegrityError if int ( Database . version . split ( '.' , 1 ) [ 0 ] ) >= 5 and not hasattr ( Database , 'UNICODE' ) : convert_unicode = force_unicode else : convert_unicode = smart_str class DatabaseFeatures ( BaseDatabaseFeatures ) : empty_fetchmany_value = ( ) needs_datetime_string_cast = False interprets_empty_strings_as_nulls = True uses_savepoints = True has_select_for_update = True has_select_for_update_nowait = True can_return_id_from_insert = True allow_sliced_subqueries = False supports_subqueries_in_group_by = False supports_timezones = False supports_bitwise_or = False can_defer_constraint_checks = True ignores_nulls_in_unique_constraints = False has_bulk_insert = True supports_tablespaces = True class DatabaseOperations ( BaseDatabaseOperations ) : compiler_module = "django.db.backends.oracle.compiler" def autoinc_sql ( self , table , column ) : sq_name = self . _get_sequence_name ( table ) tr_name = self . _get_trigger_name ( table ) tbl_name = self . quote_name ( table ) col_name = self . quote_name ( column ) sequence_sql = """ DECLARE i INTEGER; BEGIN SELECT COUNT(*) INTO i FROM USER_CATALOG WHERE TABLE_NAME = '%(sq_name)s' AND TABLE_TYPE = 'SEQUENCE'; IF i = 0 THEN EXECUTE IMMEDIATE 'CREATE SEQUENCE "%(sq_name)s"'; END IF; END; /""" % locals ( ) trigger_sql = """ CREATE OR REPLACE TRIGGER "%(tr_name)s" BEFORE INSERT ON %(tbl_name)s FOR EACH ROW WHEN (new.%(col_name)s IS NULL) BEGIN SELECT "%(sq_name)s".nextval INTO :new.%(col_name)s FROM dual; END; /""" % locals ( ) return sequence_sql , trigger_sql def date_extract_sql ( self , lookup_type , field_name ) : if lookup_type == 'week_day' : return "TO_CHAR(%s, 'D')" % field_name else : return "EXTRACT(%s FROM %s)" % ( lookup_type , field_name ) def date_interval_sql ( self , sql , connector , timedelta ) : minutes , seconds = divmod ( timedelta . seconds , 60 ) hours , minutes = divmod ( minutes , 60 ) days = str ( timedelta . days ) day_precision = len ( days ) fmt = "(%s %s INTERVAL '%s %02d:%02d:%02d.%06d' DAY(%d) TO SECOND(6))" return fmt % ( sql , connector , days , hours , minutes , seconds , timedelta . microseconds , day_precision ) def date_trunc_sql ( self , lookup_type , field_name ) : if lookup_type == 'day' : sql = 'TRUNC(%s)' % field_name else : sql = "TRUNC(%s, '%s')" % ( field_name , lookup_type ) return sql def convert_values ( self , value , field ) : if isinstance ( value , Database . LOB ) : value = value . read ( ) if field and field . get_internal_type ( ) == 'TextField' : value = force_unicode ( value ) if value is None and field and field . empty_strings_allowed : value = u'' elif value in ( 1 , 0 ) and field and field . get_internal_type ( ) in ( 'BooleanField' , 'NullBooleanField' ) : value = bool ( value ) elif value is not None and field and field . get_internal_type ( ) == 'FloatField' : value = float ( value ) elif value is not None and field and field . get_internal_type ( ) == 'DecimalField' : value = util . typecast_decimal ( field . format_number ( value ) ) elif isinstance ( value , Database . Timestamp ) : if field and field . get_internal_type ( ) == 'DateTimeField' : pass elif field and field . get_internal_type ( ) == 'DateField' : value = value . date ( ) elif field and field . get_internal_type ( ) == 'TimeField' or ( value . year == 1900 and value . month == value . day == 1 ) : value = value . time ( ) elif value . hour == value . minute == value . second == value . microsecond == 0 : value = value . date ( ) return value def datetime_cast_sql ( self ) : return "TO_TIMESTAMP(%s, 'YYYY-MM-DD HH24:MI:SS.FF')" def deferrable_sql ( self ) : return " DEFERRABLE INITIALLY DEFERRED" def drop_sequence_sql ( self , table ) : return "DROP SEQUENCE %s;" % self . quote_name ( self . _get_sequence_name ( table ) ) def fetch_returned_insert_id ( self , cursor ) : return long ( cursor . _insert_id_var . getvalue ( ) ) def field_cast_sql ( self , db_type ) : if db_type and db_type . endswith ( 'LOB' ) : return "DBMS_LOB.SUBSTR(%s)" else : return "%s" def last_executed_query ( self , cursor , sql , params ) : return cursor . statement def last_insert_id ( self , cursor , table_name , pk_name ) : sq_name = self . _get_sequence_name ( table_name ) cursor . execute ( 'SELECT "%s".currval FROM dual' % sq_name ) return cursor . fetchone ( ) [ 0 ] def lookup_cast ( self , lookup_type ) : if lookup_type in ( 'iexact' , 'icontains' , 'istartswith' , 'iendswith' ) : return "UPPER(%s)" return "%s" def max_in_list_size ( self ) : return 1000 def max_name_length ( self ) : return 30 def prep_for_iexact_query ( self , x ) : return x def process_clob ( self , value ) : if value is None : return u'' return force_unicode ( value . read ( ) ) def quote_name ( self , name ) : if not name . startswith ( '"' ) and not name . endswith ( '"' ) : name = '"%s"' % util . truncate_name ( name . upper ( ) , self . max_name_length ( ) ) return name . upper ( ) def random_function_sql ( self ) : return "DBMS_RANDOM.RANDOM" def regex_lookup_9 ( self , lookup_type ) : raise NotImplementedError ( "Regexes are not supported in Oracle before version 10g." ) def regex_lookup_10 ( self , lookup_type ) : if lookup_type == 'regex' : match_option = "'c'" else : match_option = "'i'" return 'REGEXP_LIKE(%%s, %%s, %s)' % match_option def regex_lookup ( self , lookup_type ) : self . connection . cursor ( ) return self . connection . ops . regex_lookup ( lookup_type ) def return_insert_id ( self ) : return "RETURNING %s INTO %%s" , ( InsertIdVar ( ) , ) def savepoint_create_sql ( self , sid ) : return convert_unicode ( "SAVEPOINT " + self . quote_name ( sid ) ) def savepoint_rollback_sql ( self , sid ) : return convert_unicode ( "ROLLBACK TO SAVEPOINT " + self . quote_name ( sid ) ) def sql_flush ( self , style , tables , sequences ) : if tables : sql = [ '%s %s %s;' % ( style . SQL_KEYWORD ( 'DELETE' ) , style . SQL_KEYWORD ( 'FROM' ) , style . SQL_FIELD ( self . quote_name ( table ) ) ) for table in tables ] for sequence_info in sequences : sequence_name = self . _get_sequence_name ( sequence_info [ 'table' ] ) table_name = self . quote_name ( sequence_info [ 'table' ] ) column_name = self . quote_name ( sequence_info [ 'column' ] or 'id' ) query = _get_sequence_reset_sql ( ) % { 'sequence' : sequence_name , : table_name , : column_name } sql . append ( query ) return sql else : return [ ] def sequence_reset_sql ( self , style , model_list ) : from django . db import models output = [ ] query = _get_sequence_reset_sql ( ) for model in model_list : for f in model . _meta . local_fields : if isinstance ( f , models . AutoField ) : table_name = self . quote_name ( model . _meta . db_table ) sequence_name = self . _get_sequence_name ( model . _meta . db_table ) column_name = self . quote_name ( f . column ) output . append ( query % { 'sequence' : sequence_name , : table_name , : column_name } ) break for f in model . _meta . many_to_many : if not f . rel . through : table_name = self . quote_name ( f . m2m_db_table ( ) ) sequence_name = self . _get_sequence_name ( f . m2m_db_table ( ) ) column_name = self . quote_name ( 'id' ) output . append ( query % { 'sequence' : sequence_name , : table_name , : column_name } ) return output def start_transaction_sql ( self ) : return '' def tablespace_sql ( self , tablespace , inline = False ) : if inline : return "USING INDEX TABLESPACE %s" % self . quote_name ( tablespace ) else : return "TABLESPACE %s" % self . quote_name ( tablespace ) def value_to_db_datetime ( self , value ) : if value is None : return None if is_aware ( value ) : if settings . USE_TZ : value = value . astimezone ( utc ) . replace ( tzinfo = None ) else : raise ValueError ( "Oracle backend does not support timezone-aware datetimes when USE_TZ is False." ) return unicode ( value ) def value_to_db_time ( self , value ) : if value is None : return None if isinstance ( value , basestring ) : return datetime . datetime . strptime ( value , '%H:%M:%S' ) if is_aware ( value ) : raise ValueError ( "Oracle backend does not support timezone-aware times." ) return datetime . datetime ( 1900 , 1 , 1 , value . hour , value . minute , value . second , value . microsecond ) def year_lookup_bounds_for_date_field ( self , value ) : first = '%s-01-01' second = '%s-12-31' return [ first % value , second % value ] def combine_expression ( self , connector , sub_expressions ) : if connector == '%%' : return 'MOD(%s)' % ',' . join ( sub_expressions ) elif connector == '&' : return 'BITAND(%s)' % ',' . join ( sub_expressions ) elif connector == '|' : raise NotImplementedError ( "Bit-wise or is not supported in Oracle." ) return super ( DatabaseOperations , self ) . combine_expression ( connector , sub_expressions ) def _get_sequence_name ( self , table ) : name_length = self . max_name_length ( ) - 3 return '%s_SQ' % util . truncate_name ( table , name_length ) . upper ( ) def _get_trigger_name ( self , table ) : name_length = self . max_name_length ( ) - 3 return '%s_TR' % util . truncate_name ( table , name_length ) . upper ( ) def bulk_insert_sql ( self , fields , num_values ) : items_sql = "SELECT %s FROM DUAL" % ", " . join ( [ "%s" ] * len ( fields ) ) return " UNION ALL " . join ( [ items_sql ] * num_values ) class _UninitializedOperatorsDescriptor ( object ) : def __get__ ( self , instance , owner ) : if instance is None : raise AttributeError ( "operators not available as class attribute" ) instance . cursor ( ) . close ( ) return instance . __dict__ [ 'operators' ] class DatabaseWrapper ( BaseDatabaseWrapper ) : vendor = 'oracle' operators = _UninitializedOperatorsDescriptor ( ) _standard_operators = { : '= %s' , : '= UPPER(%s)' , : "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)" , : "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\' USING NCHAR_CS)" , : '> %s' , : '>= %s' , : '< %s' , : '<= %s' , : "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)" , : "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)" , : "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\' USING NCHAR_CS)" , : "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\' USING NCHAR_CS)" , } _likec_operators = _standard_operators . copy ( ) _likec_operators . update ( { : "LIKEC %s ESCAPE '\\'" , : "LIKEC UPPER(%s) ESCAPE '\\'" , : "LIKEC %s ESCAPE '\\'" , : "LIKEC %s ESCAPE '\\'" , : "LIKEC UPPER(%s) ESCAPE '\\'" , : "LIKEC UPPER(%s) ESCAPE '\\'" , } ) def __init__ ( self , * args , ** kwargs ) : super ( DatabaseWrapper , self ) . __init__ ( * args , ** kwargs ) self . oracle_version = None self . features = DatabaseFeatures ( self ) use_returning_into = self . settings_dict [ "OPTIONS" ] . get ( 'use_returning_into' , True ) self . features . can_return_id_from_insert = use_returning_into self . ops = DatabaseOperations ( self ) self . client = DatabaseClient ( self ) self . creation = DatabaseCreation ( self ) self . introspection = DatabaseIntrospection ( self ) self . validation = BaseDatabaseValidation ( self ) def check_constraints ( self , table_names = None ) : self . cursor ( ) . execute ( 'SET CONSTRAINTS ALL IMMEDIATE' ) self . cursor ( ) . execute ( 'SET CONSTRAINTS ALL DEFERRED' ) def _valid_connection ( self ) : return self . connection is not None def _connect_string ( self ) : settings_dict = self . settings_dict if not settings_dict [ 'HOST' ] . strip ( ) : settings_dict [ 'HOST' ] = 'localhost' if settings_dict [ 'PORT' ] . strip ( ) : dsn = Database . makedsn ( settings_dict [ 'HOST' ] , int ( settings_dict [ 'PORT' ] ) , settings_dict [ 'NAME' ] ) else : dsn = settings_dict [ 'NAME' ] return "%s/%s@%s" % ( settings_dict [ 'USER' ] , settings_dict [ 'PASSWORD' ] , dsn ) def _cursor ( self ) : cursor = None if not self . _valid_connection ( ) : conn_string = convert_unicode ( self . _connect_string ( ) ) conn_params = self . settings_dict [ 'OPTIONS' ] . copy ( ) if 'use_returning_into' in conn_params : del conn_params [ 'use_returning_into' ] self . connection = Database . connect ( conn_string , ** conn_params ) cursor = FormatStylePlaceholderCursor ( self . connection ) cursor . execute ( "ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS'" + ( " TIME_ZONE = 'UTC'" if settings . USE_TZ else '' ) ) if 'operators' not in self . __dict__ : try : cursor . execute ( "SELECT 1 FROM DUAL WHERE DUMMY %s" % self . _standard_operators [ 'contains' ] , [ 'X' ] ) except utils . DatabaseError : self . operators = self . _likec_operators else : self . operators = self . _standard_operators try : self . oracle_version = int ( self . connection . version . split ( '.' ) [ 0 ] ) if self . oracle_version <= 9 : self . ops . regex_lookup = self . ops . regex_lookup_9 else : self . ops . regex_lookup = self . ops . regex_lookup_10 except ValueError : pass try : self . connection . stmtcachesize = 20 except : pass connection_created . send ( sender = self . __class__ , connection = self ) if not cursor : cursor = FormatStylePlaceholderCursor ( self . connection ) return cursor def _savepoint_commit ( self , sid ) : pass def _commit ( self ) : if self . connection is not None : try : return self . connection . commit ( ) except Database . IntegrityError , e : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] except Database . DatabaseError , e : x = e . args [ 0 ] if hasattr ( x , 'code' ) and hasattr ( x , 'message' ) and x . code == 2091 and 'ORA-02291' in x . message : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] raise utils . DatabaseError , utils . DatabaseError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] class OracleParam ( object ) : def __init__ ( self , param , cursor , strings_only = False ) : if hasattr ( param , 'bind_parameter' ) : self . smart_str = param . bind_parameter ( cursor ) else : self . smart_str = convert_unicode ( param , cursor . charset , strings_only ) if hasattr ( param , 'input_size' ) : self . input_size = param . input_size elif isinstance ( param , basestring ) and len ( param ) > 4000 : self . input_size = Database . CLOB else : self . input_size = None class VariableWrapper ( object ) : def __init__ ( self , var ) : self . var = var def bind_parameter ( self , cursor ) : return self . var def __getattr__ ( self , key ) : return getattr ( self . var , key ) def __setattr__ ( self , key , value ) : if key == 'var' : self . __dict__ [ key ] = value else : setattr ( self . var , key , value ) class InsertIdVar ( object ) : def bind_parameter ( self , cursor ) : param = cursor . cursor . var ( Database . NUMBER ) cursor . _insert_id_var = param return param class FormatStylePlaceholderCursor ( object ) : charset = 'utf-8' def __init__ ( self , connection ) : self . cursor = connection . cursor ( ) self . cursor . numbersAsStrings = True self . cursor . arraysize = 100 def _format_params ( self , params ) : return tuple ( [ OracleParam ( p , self , True ) for p in params ] ) def _guess_input_sizes ( self , params_list ) : sizes = [ None ] * len ( params_list [ 0 ] ) for params in params_list : for i , value in enumerate ( params ) : if value . input_size : sizes [ i ] = value . input_size self . setinputsizes ( * sizes ) def _param_generator ( self , params ) : return [ p . smart_str for p in params ] def execute ( self , query , params = None ) : if params is None : params = [ ] else : params = self . _format_params ( params ) args = [ ( ':arg%d' % i ) for i in range ( len ( params ) ) ] if query . endswith ( ';' ) or query . endswith ( '/' ) : query = query [ : - 1 ] query = convert_unicode ( query % tuple ( args ) , self . charset ) self . _guess_input_sizes ( [ params ] ) try : return self . cursor . execute ( query , self . _param_generator ( params ) ) except Database . IntegrityError , e : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] except Database . DatabaseError , e : if hasattr ( e . args [ 0 ] , 'code' ) and e . args [ 0 ] . code == 1400 and not isinstance ( e , IntegrityError ) : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] raise utils . DatabaseError , utils . DatabaseError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] def executemany ( self , query , params = None ) : if params is not None and not isinstance ( params , ( list , tuple ) ) : params = list ( params ) try : args = [ ( ':arg%d' % i ) for i in range ( len ( params [ 0 ] ) ) ] except ( IndexError , TypeError ) : return None if query . endswith ( ';' ) or query . endswith ( '/' ) : query = query [ : - 1 ] query = convert_unicode ( query % tuple ( args ) , self . charset ) formatted = [ self . _format_params ( i ) for i in params ] self . _guess_input_sizes ( formatted ) try : return self . cursor . executemany ( query , [ self . _param_generator ( p ) for p in formatted ] ) except Database . IntegrityError , e : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] except Database . DatabaseError , e : if hasattr ( e . args [ 0 ] , 'code' ) and e . args [ 0 ] . code == 1400 and not isinstance ( e , IntegrityError ) : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] raise utils . DatabaseError , utils . DatabaseError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] def fetchone ( self ) : row = self . cursor . fetchone ( ) if row is None : return row return _rowfactory ( row , self . cursor ) def fetchmany ( self , size = None ) : if size is None : size = self . arraysize return tuple ( [ _rowfactory ( r , self . cursor ) for r in self . cursor . fetchmany ( size ) ] ) def fetchall ( self ) : return tuple ( [ _rowfactory ( r , self . cursor ) for r in self . cursor . fetchall ( ) ] ) def var ( self , * args ) : return VariableWrapper ( self . cursor . var ( * args ) ) def arrayvar ( self , * args ) : return VariableWrapper ( self . cursor . arrayvar ( * args ) ) def __getattr__ ( self , attr ) : if attr in self . __dict__ : return self . __dict__ [ attr ] else : return getattr ( self . cursor , attr ) def __iter__ ( self ) : return CursorIterator ( self . cursor ) class CursorIterator ( object ) : def __init__ ( self , cursor ) : self . cursor = cursor self . iter = iter ( cursor ) def __iter__ ( self ) : return self def next ( self ) : return _rowfactory ( self . iter . next ( ) , self . cursor ) def _rowfactory ( row , cursor ) : casted = [ ] for value , desc in zip ( row , cursor . description ) : if value is not None and desc [ 1 ] is Database . NUMBER : precision , scale = desc [ 4 : 6 ] if scale == - 127 : if precision == 0 : if '.' in value : value = decimal . Decimal ( value ) else : value = int ( value ) else : value = float ( value ) elif precision > 0 : if scale == 0 : value = int ( value ) else : value = decimal . Decimal ( value ) elif '.' in value : value = decimal . Decimal ( value ) else : value = int ( value ) elif desc [ 1 ] in ( Database . TIMESTAMP , Database . DATETIME ) : if settings . USE_TZ and value is not None and is_naive ( value ) : value = value . replace ( tzinfo = utc ) elif desc [ 1 ] in ( Database . STRING , Database . FIXED_CHAR , Database . LONG_STRING ) : value = to_unicode ( value ) casted . append ( value ) return tuple ( casted ) def to_unicode ( s ) : if isinstance ( s , basestring ) : return force_unicode ( s ) return s def _get_sequence_reset_sql ( ) : return """ DECLARE table_value integer; seq_value integer; BEGIN SELECT NVL(MAX(%(column)s), 0) INTO table_value FROM %(table)s; SELECT NVL(last_number - cache_size, 0) INTO seq_value FROM user_sequences WHERE sequence_name = '%(sequence)s'; WHILE table_value > seq_value LOOP SELECT "%(sequence)s".nextval INTO seq_value FROM dual; END LOOP; END; /"""

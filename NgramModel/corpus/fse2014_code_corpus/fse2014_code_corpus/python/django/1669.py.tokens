from django . contrib . gis . geos . base import numpy from django . contrib . gis . geos . coordseq import GEOSCoordSeq from django . contrib . gis . geos . error import GEOSException from django . contrib . gis . geos . geometry import GEOSGeometry from django . contrib . gis . geos . point import Point from django . contrib . gis . geos import prototypes as capi class LineString ( GEOSGeometry ) : _init_func = capi . create_linestring _minlength = 2 def __init__ ( self , * args , ** kwargs ) : if len ( args ) == 1 : coords = args [ 0 ] else : coords = args if isinstance ( coords , ( tuple , list ) ) : ncoords = len ( coords ) if coords : ndim = len ( coords [ 0 ] ) else : raise TypeError ( 'Cannot initialize on empty sequence.' ) self . _checkdim ( ndim ) for i in xrange ( 1 , ncoords ) : if not isinstance ( coords [ i ] , ( tuple , list , Point ) ) : raise TypeError ( 'each coordinate should be a sequence (list or tuple)' ) if len ( coords [ i ] ) != ndim : raise TypeError ( 'Dimension mismatch.' ) numpy_coords = False elif numpy and isinstance ( coords , numpy . ndarray ) : shape = coords . shape if len ( shape ) != 2 : raise TypeError ( 'Too many dimensions.' ) self . _checkdim ( shape [ 1 ] ) ncoords = shape [ 0 ] ndim = shape [ 1 ] numpy_coords = True else : raise TypeError ( 'Invalid initialization input for LineStrings.' ) cs = GEOSCoordSeq ( capi . create_cs ( ncoords , ndim ) , z = bool ( ndim == 3 ) ) for i in xrange ( ncoords ) : if numpy_coords : cs [ i ] = coords [ i , : ] elif isinstance ( coords [ i ] , Point ) : cs [ i ] = coords [ i ] . tuple else : cs [ i ] = coords [ i ] srid = kwargs . get ( 'srid' , None ) super ( LineString , self ) . __init__ ( self . _init_func ( cs . ptr ) , srid = srid ) def __iter__ ( self ) : for i in xrange ( len ( self ) ) : yield self [ i ] def __len__ ( self ) : return len ( self . _cs ) def _get_single_external ( self , index ) : return self . _cs [ index ] _get_single_internal = _get_single_external def _set_list ( self , length , items ) : ndim = self . _cs . dims hasz = self . _cs . hasz cs = GEOSCoordSeq ( capi . create_cs ( length , ndim ) , z = hasz ) for i , c in enumerate ( items ) : cs [ i ] = c ptr = self . _init_func ( cs . ptr ) if ptr : capi . destroy_geom ( self . ptr ) self . ptr = ptr self . _post_init ( self . srid ) else : raise GEOSException ( 'Geometry resulting from slice deletion was invalid.' ) def _set_single ( self , index , value ) : self . _checkindex ( index ) self . _cs [ index ] = value def _checkdim ( self , dim ) : if dim not in ( 2 , 3 ) : raise TypeError ( 'Dimension mismatch.' ) @ property def tuple ( self ) : return self . _cs . tuple coords = tuple def _listarr ( self , func ) : lst = [ func ( i ) for i in xrange ( len ( self ) ) ] if numpy : return numpy . array ( lst ) else : return lst @ property def array ( self ) : return self . _listarr ( self . _cs . __getitem__ ) @ property def merged ( self ) : return self . _topology ( capi . geos_linemerge ( self . ptr ) ) @ property def x ( self ) : return self . _listarr ( self . _cs . getX ) @ property def y ( self ) : return self . _listarr ( self . _cs . getY ) @ property def z ( self ) : if not self . hasz : return None else : return self . _listarr ( self . _cs . getZ ) class LinearRing ( LineString ) : _minLength = 4 _init_func = capi . create_linearring

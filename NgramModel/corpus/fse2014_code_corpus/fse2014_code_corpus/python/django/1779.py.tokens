import os from django . conf import settings from django . core . cache import get_cache from django . core . cache . backends . db import BaseDatabaseCache from django . core . exceptions import ImproperlyConfigured from django . db . backends . sqlite3 . creation import DatabaseCreation class SpatiaLiteCreation ( DatabaseCreation ) : def create_test_db ( self , verbosity = 1 , autoclobber = False ) : from django . core . management import call_command test_database_name = self . _get_test_db_name ( ) if verbosity >= 1 : test_db_repr = '' if verbosity >= 2 : test_db_repr = " ('%s')" % test_database_name print "Creating test database for alias '%s'%s..." % ( self . connection . alias , test_db_repr ) self . _create_test_db ( verbosity , autoclobber ) self . connection . close ( ) self . connection . settings_dict [ "NAME" ] = test_database_name self . connection . features . confirm ( ) self . load_spatialite_sql ( ) call_command ( 'syncdb' , verbosity = max ( verbosity - 1 , 0 ) , interactive = False , database = self . connection . alias , load_initial_data = False ) call_command ( 'flush' , verbosity = max ( verbosity - 1 , 0 ) , interactive = False , database = self . connection . alias ) from django . core . cache import get_cache from django . core . cache . backends . db import BaseDatabaseCache for cache_alias in settings . CACHES : cache = get_cache ( cache_alias ) if isinstance ( cache , BaseDatabaseCache ) : call_command ( 'createcachetable' , cache . _table , database = self . connection . alias ) cursor = self . connection . cursor ( ) return test_database_name def sql_indexes_for_field ( self , model , f , style ) : from django . contrib . gis . db . models . fields import GeometryField output = super ( SpatiaLiteCreation , self ) . sql_indexes_for_field ( model , f , style ) if isinstance ( f , GeometryField ) : gqn = self . connection . ops . geo_quote_name qn = self . connection . ops . quote_name db_table = model . _meta . db_table output . append ( style . SQL_KEYWORD ( 'SELECT ' ) + style . SQL_TABLE ( 'AddGeometryColumn' ) + '(' + style . SQL_TABLE ( gqn ( db_table ) ) + ', ' + style . SQL_FIELD ( gqn ( f . column ) ) + ', ' + style . SQL_FIELD ( str ( f . srid ) ) + ', ' + style . SQL_COLTYPE ( gqn ( f . geom_type ) ) + ', ' + style . SQL_KEYWORD ( str ( f . dim ) ) + ', ' + style . SQL_KEYWORD ( str ( int ( not f . null ) ) ) + ) if f . spatial_index : output . append ( style . SQL_KEYWORD ( 'SELECT ' ) + style . SQL_TABLE ( 'CreateSpatialIndex' ) + '(' + style . SQL_TABLE ( gqn ( db_table ) ) + ', ' + style . SQL_FIELD ( gqn ( f . column ) ) + ');' ) return output def load_spatialite_sql ( self ) : if self . connection . ops . spatial_version [ : 2 ] >= ( 3 , 0 ) : cur = self . connection . _cursor ( ) cur . execute ( "SELECT InitSpatialMetaData()" ) else : spatialite_sql = self . spatialite_init_file ( ) if not os . path . isfile ( spatialite_sql ) : raise ImproperlyConfigured ( 'Could not find the required SpatiaLite initialization ' % spatialite_sql ) sql_fh = open ( spatialite_sql , 'r' ) try : cur = self . connection . _cursor ( ) cur . executescript ( sql_fh . read ( ) ) finally : sql_fh . close ( ) def spatialite_init_file ( self ) : return getattr ( settings , 'SPATIALITE_SQL' , % self . connection . ops . spatial_version [ : 2 ] )

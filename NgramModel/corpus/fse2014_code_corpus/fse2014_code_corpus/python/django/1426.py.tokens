""" A generic comment-moderation system which allows configuration of moderation options on a per-model basis. To use, do two things: 1. Create or import a subclass of ``CommentModerator`` defining the options you want. 2. Import ``moderator`` from this module and register one or more models, passing the models and the ``CommentModerator`` options class you want to use. Example ------- First, we define a simple model class which might represent entries in a Weblog:: from django.db import models class Entry(models.Model): title = models.CharField(maxlength=250) body = models.TextField() pub_date = models.DateField() enable_comments = models.BooleanField() Then we create a ``CommentModerator`` subclass specifying some moderation options:: from django.contrib.comments.moderation import CommentModerator, moderator class EntryModerator(CommentModerator): email_notification = True enable_field = 'enable_comments' And finally register it for moderation:: moderator.register(Entry, EntryModerator) This sample class would apply two moderation steps to each new comment submitted on an Entry: * If the entry's ``enable_comments`` field is set to ``False``, the comment will be rejected (immediately deleted). * If the comment is successfully posted, an email notification of the comment will be sent to site staff. For a full list of built-in moderation options and other configurability, see the documentation for the ``CommentModerator`` class. """ import datetime from django . conf import settings from django . core . mail import send_mail from django . contrib . comments import signals from django . db . models . base import ModelBase from django . template import Context , loader from django . contrib import comments from django . contrib . sites . models import Site from django . utils import timezone class AlreadyModerated ( Exception ) : pass class NotModerated ( Exception ) : pass class CommentModerator ( object ) : auto_close_field = None auto_moderate_field = None close_after = None email_notification = False enable_field = None moderate_after = None def __init__ ( self , model ) : self . _model = model def _get_delta ( self , now , then ) : if now . __class__ is not then . __class__ : now = datetime . date ( now . year , now . month , now . day ) then = datetime . date ( then . year , then . month , then . day ) if now < then : raise ValueError ( "Cannot determine moderation rules because date field is set to a value in the future" ) return now - then def allow ( self , comment , content_object , request ) : if self . enable_field : if not getattr ( content_object , self . enable_field ) : return False if self . auto_close_field and self . close_after is not None : close_after_date = getattr ( content_object , self . auto_close_field ) if close_after_date is not None and self . _get_delta ( timezone . now ( ) , close_after_date ) . days >= self . close_after : return False return True def moderate ( self , comment , content_object , request ) : if self . auto_moderate_field and self . moderate_after is not None : moderate_after_date = getattr ( content_object , self . auto_moderate_field ) if moderate_after_date is not None and self . _get_delta ( timezone . now ( ) , moderate_after_date ) . days >= self . moderate_after : return True return False def email ( self , comment , content_object , request ) : if not self . email_notification : return recipient_list = [ manager_tuple [ 1 ] for manager_tuple in settings . MANAGERS ] t = loader . get_template ( 'comments/comment_notification_email.txt' ) c = Context ( { 'comment' : comment , : content_object } ) subject = '[%s] New comment posted on "%s"' % ( Site . objects . get_current ( ) . name , content_object ) message = t . render ( c ) send_mail ( subject , message , settings . DEFAULT_FROM_EMAIL , recipient_list , fail_silently = True ) class Moderator ( object ) : def __init__ ( self ) : self . _registry = { } self . connect ( ) def connect ( self ) : signals . comment_will_be_posted . connect ( self . pre_save_moderation , sender = comments . get_model ( ) ) signals . comment_was_posted . connect ( self . post_save_moderation , sender = comments . get_model ( ) ) def register ( self , model_or_iterable , moderation_class ) : if isinstance ( model_or_iterable , ModelBase ) : model_or_iterable = [ model_or_iterable ] for model in model_or_iterable : if model in self . _registry : raise AlreadyModerated ( "The model '%s' is already being moderated" % model . _meta . module_name ) self . _registry [ model ] = moderation_class ( model ) def unregister ( self , model_or_iterable ) : if isinstance ( model_or_iterable , ModelBase ) : model_or_iterable = [ model_or_iterable ] for model in model_or_iterable : if model not in self . _registry : raise NotModerated ( "The model '%s' is not currently being moderated" % model . _meta . module_name ) del self . _registry [ model ] def pre_save_moderation ( self , sender , comment , request , ** kwargs ) : model = comment . content_type . model_class ( ) if model not in self . _registry : return content_object = comment . content_object moderation_class = self . _registry [ model ] if not moderation_class . allow ( comment , content_object , request ) : return False if moderation_class . moderate ( comment , content_object , request ) : comment . is_public = False def post_save_moderation ( self , sender , comment , request , ** kwargs ) : model = comment . content_type . model_class ( ) if model not in self . _registry : return self . _registry [ model ] . email ( comment , comment . content_object , request ) moderator = Moderator ( )

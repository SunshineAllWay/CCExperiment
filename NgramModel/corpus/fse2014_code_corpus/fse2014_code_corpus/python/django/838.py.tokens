from __future__ import with_statement , absolute_import import datetime import threading from django . conf import settings from django . core . management . color import no_style from django . core . exceptions import ImproperlyConfigured from django . db import ( backend , connection , connections , DEFAULT_DB_ALIAS , IntegrityError , transaction ) from django . db . backends . signals import connection_created from django . db . backends . postgresql_psycopg2 import version as pg_version from django . db . utils import ConnectionHandler , DatabaseError , load_backend from django . test import TestCase , skipUnlessDBFeature , TransactionTestCase from django . test . utils import override_settings from django . utils import unittest from . import models class OracleChecks ( unittest . TestCase ) : @ unittest . skipUnless ( connection . vendor == 'oracle' , ) def test_dbms_session ( self ) : convert_unicode = backend . convert_unicode cursor = connection . cursor ( ) cursor . callproc ( convert_unicode ( 'DBMS_SESSION.SET_IDENTIFIER' ) , [ convert_unicode ( '_django_testing!' ) , ] ) @ unittest . skipUnless ( connection . vendor == 'oracle' , ) def test_cursor_var ( self ) : cursor = connection . cursor ( ) var = cursor . var ( backend . Database . STRING ) cursor . execute ( "BEGIN %s := 'X'; END; " , [ var ] ) self . assertEqual ( var . getvalue ( ) , 'X' ) @ unittest . skipUnless ( connection . vendor == 'oracle' , ) def test_long_string ( self ) : c = connection . cursor ( ) c . execute ( 'CREATE TABLE ltext ("TEXT" NCLOB)' ) long_str = '' . join ( [ unicode ( x ) for x in xrange ( 4000 ) ] ) c . execute ( 'INSERT INTO ltext VALUES (%s)' , [ long_str ] ) c . execute ( 'SELECT text FROM ltext' ) row = c . fetchone ( ) self . assertEqual ( long_str , row [ 0 ] . read ( ) ) c . execute ( 'DROP TABLE ltext' ) @ unittest . skipUnless ( connection . vendor == 'oracle' , ) def test_client_encoding ( self ) : c = connection . cursor ( ) self . assertEqual ( connection . connection . encoding , "UTF-8" ) self . assertEqual ( connection . connection . nencoding , "UTF-8" ) class DateQuotingTest ( TestCase ) : def test_django_date_trunc ( self ) : updated = datetime . datetime ( 2010 , 2 , 20 ) models . SchoolClass . objects . create ( year = 2009 , last_updated = updated ) years = models . SchoolClass . objects . dates ( 'last_updated' , 'year' ) self . assertEqual ( list ( years ) , [ datetime . datetime ( 2010 , 1 , 1 , 0 , 0 ) ] ) def test_django_extract ( self ) : updated = datetime . datetime ( 2010 , 2 , 20 ) models . SchoolClass . objects . create ( year = 2009 , last_updated = updated ) classes = models . SchoolClass . objects . filter ( last_updated__day = 20 ) self . assertEqual ( len ( classes ) , 1 ) class LastExecutedQueryTest ( TestCase ) : def setUp ( self ) : settings . DEBUG = True def tearDown ( self ) : settings . DEBUG = False @ unittest . skipUnless ( connection . vendor in ( 'oracle' , 'postgresql' ) , ) def test_parameter_escaping ( self ) : list ( models . Tag . objects . filter ( name = "special:\\\"':" , object_id = 12 ) ) sql = connection . queries [ - 1 ] [ 'sql' ] self . assertTrue ( "= 'special:\\\"'':' " in sql ) self . assertTrue ( "= 12 " in sql ) @ unittest . skipUnless ( connection . vendor == 'mysql' , ) def test_parameter_escaping ( self ) : list ( models . Tag . objects . filter ( name = "special:\\\"':" , object_id = 12 ) ) sql = connection . queries [ - 1 ] [ 'sql' ] self . assertTrue ( "= 'special:\\\\\\\"\\':' " in sql ) self . assertTrue ( "= 12 " in sql ) class ParameterHandlingTest ( TestCase ) : def test_bad_parameter_count ( self ) : cursor = connection . cursor ( ) query = ( 'INSERT INTO %s (%s, %s) VALUES (%%s, %%s)' % ( connection . introspection . table_name_converter ( 'backends_square' ) , connection . ops . quote_name ( 'root' ) , connection . ops . quote_name ( 'square' ) ) ) self . assertRaises ( Exception , cursor . executemany , query , [ ( 1 , 2 , 3 ) , ] ) self . assertRaises ( Exception , cursor . executemany , query , [ ( 1 , ) , ] ) class LongNameTest ( TestCase ) : @ skipUnlessDBFeature ( 'supports_long_model_names' ) def test_sequence_name_length_limits_create ( self ) : models . VeryLongModelNameZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ . objects . create ( ) @ skipUnlessDBFeature ( 'supports_long_model_names' ) def test_sequence_name_length_limits_m2m ( self ) : obj = models . VeryLongModelNameZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ . objects . create ( ) rel_obj = models . Person . objects . create ( first_name = 'Django' , last_name = 'Reinhardt' ) obj . m2m_also_quite_long_zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz . add ( rel_obj ) @ skipUnlessDBFeature ( 'supports_long_model_names' ) def test_sequence_name_length_limits_flush ( self ) : VLM = models . VeryLongModelNameZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ VLM_m2m = VLM . m2m_also_quite_long_zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz . through tables = [ VLM . _meta . db_table , VLM_m2m . _meta . db_table , ] sequences = [ { : VLM . _meta . pk . column , : VLM . _meta . db_table } , ] cursor = connection . cursor ( ) for statement in connection . ops . sql_flush ( no_style ( ) , tables , sequences ) : cursor . execute ( statement ) class SequenceResetTest ( TestCase ) : def test_generic_relation ( self ) : models . Post . objects . create ( id = 10 , name = '1st post' , text = 'hello world' ) cursor = connection . cursor ( ) commands = connections [ DEFAULT_DB_ALIAS ] . ops . sequence_reset_sql ( no_style ( ) , [ models . Post ] ) for sql in commands : cursor . execute ( sql ) obj = models . Post . objects . create ( name = 'New post' , text = 'goodbye world' ) self . assertTrue ( obj . pk > 10 ) class PostgresVersionTest ( TestCase ) : def assert_parses ( self , version_string , version ) : self . assertEqual ( pg_version . _parse_version ( version_string ) , version ) def test_parsing ( self ) : self . assert_parses ( "PostgreSQL 8.3 beta4" , 80300 ) self . assert_parses ( "PostgreSQL 8.3" , 80300 ) self . assert_parses ( "EnterpriseDB 8.3" , 80300 ) self . assert_parses ( "PostgreSQL 8.3.6" , 80306 ) self . assert_parses ( "PostgreSQL 8.4beta1" , 80400 ) self . assert_parses ( "PostgreSQL 8.3.1 on i386-apple-darwin9.2.2, compiled by GCC i686-apple-darwin9-gcc-4.0.1 (GCC) 4.0.1 (Apple Inc. build 5478)" , 80301 ) def test_version_detection ( self ) : class CursorMock ( object ) : def execute ( self , arg ) : pass def fetchone ( self ) : return [ "PostgreSQL 8.3" ] class OlderConnectionMock ( object ) : def cursor ( self ) : return CursorMock ( ) conn = OlderConnectionMock ( ) self . assertEqual ( pg_version . get_version ( conn ) , 80300 ) class PostgresNewConnectionTest ( TestCase ) : @ unittest . skipUnless ( connection . vendor == 'postgresql' and connection . isolation_level > 0 , ) def test_connect_and_rollback ( self ) : new_connections = ConnectionHandler ( settings . DATABASES ) new_connection = new_connections [ DEFAULT_DB_ALIAS ] try : cursor = new_connection . cursor ( ) cursor . execute ( "RESET TIMEZONE" ) cursor . execute ( "SHOW TIMEZONE" ) db_default_tz = cursor . fetchone ( ) [ 0 ] new_tz = 'Europe/Paris' if db_default_tz == 'UTC' else 'UTC' new_connection . close ( ) new_connection . settings_dict [ 'TIME_ZONE' ] = new_tz new_connection . enter_transaction_management ( ) cursor = new_connection . cursor ( ) new_connection . rollback ( ) cursor . execute ( "SHOW TIMEZONE" ) tz = cursor . fetchone ( ) [ 0 ] self . assertEqual ( new_tz , tz ) finally : try : new_connection . close ( ) except DatabaseError : pass class ConnectionCreatedSignalTest ( TestCase ) : @ skipUnlessDBFeature ( 'test_db_allows_multiple_connections' ) def test_signal ( self ) : data = { } def receiver ( sender , connection , ** kwargs ) : data [ "connection" ] = connection connection_created . connect ( receiver ) connection . close ( ) cursor = connection . cursor ( ) self . assertTrue ( data [ "connection" ] . connection is connection . connection ) connection_created . disconnect ( receiver ) data . clear ( ) cursor = connection . cursor ( ) self . assertTrue ( data == { } ) class EscapingChecks ( TestCase ) : @ unittest . skipUnless ( connection . vendor == 'sqlite' , ) def test_parameter_escaping ( self ) : cursor = connection . cursor ( ) response = cursor . execute ( ) . fetchall ( ) [ 0 ] [ 0 ] self . assertNotEqual ( response , None ) self . assertTrue ( int ( response ) ) class BackendTestCase ( TestCase ) : def create_squares_with_executemany ( self , args ) : cursor = connection . cursor ( ) opts = models . Square . _meta tbl = connection . introspection . table_name_converter ( opts . db_table ) f1 = connection . ops . quote_name ( opts . get_field ( 'root' ) . column ) f2 = connection . ops . quote_name ( opts . get_field ( 'square' ) . column ) query = 'INSERT INTO %s (%s, %s) VALUES (%%s, %%s)' % ( tbl , f1 , f2 ) cursor . executemany ( query , args ) def test_cursor_executemany ( self ) : args = [ ( i , i ** 2 ) for i in range ( - 5 , 6 ) ] self . create_squares_with_executemany ( args ) self . assertEqual ( models . Square . objects . count ( ) , 11 ) for i in range ( - 5 , 6 ) : square = models . Square . objects . get ( root = i ) self . assertEqual ( square . square , i ** 2 ) def test_cursor_executemany_with_empty_params_list ( self ) : args = [ ] self . create_squares_with_executemany ( args ) self . assertEqual ( models . Square . objects . count ( ) , 0 ) def test_cursor_executemany_with_iterator ( self ) : args = iter ( ( i , i ** 2 ) for i in range ( - 3 , 2 ) ) self . create_squares_with_executemany ( args ) self . assertEqual ( models . Square . objects . count ( ) , 5 ) args = iter ( ( i , i ** 2 ) for i in range ( 3 , 7 ) ) with override_settings ( DEBUG = True ) : self . create_squares_with_executemany ( args ) self . assertEqual ( models . Square . objects . count ( ) , 9 ) def test_unicode_fetches ( self ) : qn = connection . ops . quote_name models . Person ( first_name = "John" , last_name = "Doe" ) . save ( ) models . Person ( first_name = "Jane" , last_name = "Doe" ) . save ( ) models . Person ( first_name = "Mary" , last_name = "Agnelline" ) . save ( ) models . Person ( first_name = "Peter" , last_name = "Parker" ) . save ( ) models . Person ( first_name = "Clark" , last_name = "Kent" ) . save ( ) opts2 = models . Person . _meta f3 , f4 = opts2 . get_field ( 'first_name' ) , opts2 . get_field ( 'last_name' ) query2 = ( 'SELECT %s, %s FROM %s ORDER BY %s' % ( qn ( f3 . column ) , qn ( f4 . column ) , connection . introspection . table_name_converter ( opts2 . db_table ) , qn ( f3 . column ) ) ) cursor = connection . cursor ( ) cursor . execute ( query2 ) self . assertEqual ( cursor . fetchone ( ) , ( u'Clark' , u'Kent' ) ) self . assertEqual ( list ( cursor . fetchmany ( 2 ) ) , [ ( u'Jane' , u'Doe' ) , ( u'John' , u'Doe' ) ] ) self . assertEqual ( list ( cursor . fetchall ( ) ) , [ ( u'Mary' , u'Agnelline' ) , ( u'Peter' , u'Parker' ) ] ) def test_database_operations_helper_class ( self ) : self . assertTrue ( hasattr ( connection , 'ops' ) ) self . assertTrue ( hasattr ( connection . ops , 'connection' ) ) self . assertEqual ( connection , connection . ops . connection ) def test_duplicate_table_error ( self ) : cursor = connection . cursor ( ) query = 'CREATE TABLE %s (id INTEGER);' % models . Article . _meta . db_table with self . assertRaises ( DatabaseError ) : cursor . execute ( query ) class FkConstraintsTests ( TransactionTestCase ) : def setUp ( self ) : self . r = models . Reporter . objects . create ( first_name = 'John' , last_name = 'Smith' ) def test_integrity_checks_on_creation ( self ) : a = models . Article ( headline = "This is a test" , pub_date = datetime . datetime ( 2005 , 7 , 27 ) , reporter_id = 30 ) try : a . save ( ) except IntegrityError : return self . skipTest ( "This backend does not support integrity checks." ) def test_integrity_checks_on_update ( self ) : models . Article . objects . create ( headline = "Test article" , pub_date = datetime . datetime ( 2010 , 9 , 4 ) , reporter = self . r ) a = models . Article . objects . get ( headline = "Test article" ) a . reporter_id = 30 try : a . save ( ) except IntegrityError : return self . skipTest ( "This backend does not support integrity checks." ) def test_disable_constraint_checks_manually ( self ) : with transaction . commit_manually ( ) : models . Article . objects . create ( headline = "Test article" , pub_date = datetime . datetime ( 2010 , 9 , 4 ) , reporter = self . r ) a = models . Article . objects . get ( headline = "Test article" ) a . reporter_id = 30 try : connection . disable_constraint_checking ( ) a . save ( ) connection . enable_constraint_checking ( ) except IntegrityError : self . fail ( "IntegrityError should not have occurred." ) finally : transaction . rollback ( ) def test_disable_constraint_checks_context_manager ( self ) : with transaction . commit_manually ( ) : models . Article . objects . create ( headline = "Test article" , pub_date = datetime . datetime ( 2010 , 9 , 4 ) , reporter = self . r ) a = models . Article . objects . get ( headline = "Test article" ) a . reporter_id = 30 try : with connection . constraint_checks_disabled ( ) : a . save ( ) except IntegrityError : self . fail ( "IntegrityError should not have occurred." ) finally : transaction . rollback ( ) def test_check_constraints ( self ) : with transaction . commit_manually ( ) : models . Article . objects . create ( headline = "Test article" , pub_date = datetime . datetime ( 2010 , 9 , 4 ) , reporter = self . r ) a = models . Article . objects . get ( headline = "Test article" ) a . reporter_id = 30 try : with connection . constraint_checks_disabled ( ) : a . save ( ) with self . assertRaises ( IntegrityError ) : connection . check_constraints ( ) finally : transaction . rollback ( ) class ThreadTests ( TestCase ) : def test_default_connection_thread_local ( self ) : connections_set = set ( ) connection . cursor ( ) connections_set . add ( connection . connection ) def runner ( ) : from django . db import connection connection . cursor ( ) connections_set . add ( connection . connection ) for x in xrange ( 2 ) : t = threading . Thread ( target = runner ) t . start ( ) t . join ( ) self . assertEquals ( len ( connections_set ) , 3 ) for conn in connections_set : if conn != connection . connection : conn . close ( ) def test_connections_thread_local ( self ) : connections_set = set ( ) for conn in connections . all ( ) : connections_set . add ( conn ) def runner ( ) : from django . db import connections for conn in connections . all ( ) : conn . allow_thread_sharing = True connections_set . add ( conn ) for x in xrange ( 2 ) : t = threading . Thread ( target = runner ) t . start ( ) t . join ( ) self . assertEquals ( len ( connections_set ) , 6 ) for conn in connections_set : if conn != connection : conn . close ( ) def test_pass_connection_between_threads ( self ) : models . Person . objects . create ( first_name = "John" , last_name = "Doe" ) def do_thread ( ) : def runner ( main_thread_connection ) : from django . db import connections connections [ 'default' ] = main_thread_connection try : models . Person . objects . get ( first_name = "John" , last_name = "Doe" ) except DatabaseError , e : exceptions . append ( e ) t = threading . Thread ( target = runner , args = [ connections [ 'default' ] ] ) t . start ( ) t . join ( ) exceptions = [ ] do_thread ( ) self . assertTrue ( isinstance ( exceptions [ 0 ] , DatabaseError ) ) connections [ 'default' ] . allow_thread_sharing = False exceptions = [ ] do_thread ( ) self . assertTrue ( isinstance ( exceptions [ 0 ] , DatabaseError ) ) connections [ 'default' ] . allow_thread_sharing = True exceptions = [ ] do_thread ( ) self . assertEqual ( len ( exceptions ) , 0 ) def test_closing_non_shared_connections ( self ) : exceptions = set ( ) def runner1 ( ) : def runner2 ( other_thread_connection ) : try : other_thread_connection . close ( ) except DatabaseError , e : exceptions . add ( e ) t2 = threading . Thread ( target = runner2 , args = [ connections [ 'default' ] ] ) t2 . start ( ) t2 . join ( ) t1 = threading . Thread ( target = runner1 ) t1 . start ( ) t1 . join ( ) self . assertEqual ( len ( exceptions ) , 1 ) exceptions = set ( ) def runner1 ( ) : def runner2 ( other_thread_connection ) : try : other_thread_connection . close ( ) except DatabaseError , e : exceptions . add ( e ) connections [ 'default' ] . allow_thread_sharing = True t2 = threading . Thread ( target = runner2 , args = [ connections [ 'default' ] ] ) t2 . start ( ) t2 . join ( ) t1 = threading . Thread ( target = runner1 ) t1 . start ( ) t1 . join ( ) self . assertEqual ( len ( exceptions ) , 0 ) class BackendLoadingTests ( TestCase ) : def test_old_style_backends_raise_useful_exception ( self ) : self . assertRaisesRegexp ( ImproperlyConfigured , , load_backend , 'sqlite3' )

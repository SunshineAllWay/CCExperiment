"Utilities for loading models and the modules that contain them." from django . conf import settings from django . core . exceptions import ImproperlyConfigured from django . utils . datastructures import SortedDict from django . utils . importlib import import_module from django . utils . module_loading import module_has_submodule import sys import os import threading __all__ = ( 'get_apps' , 'get_app' , 'get_models' , 'get_model' , 'register_models' , , 'app_cache_ready' ) class AppCache ( object ) : __shared_state = dict ( app_store = SortedDict ( ) , app_labels = { } , app_models = SortedDict ( ) , app_errors = { } , loaded = False , handled = { } , postponed = [ ] , nesting_level = 0 , write_lock = threading . RLock ( ) , _get_models_cache = { } , ) def __init__ ( self ) : self . __dict__ = self . __shared_state def _populate ( self ) : if self . loaded : return self . write_lock . acquire ( ) try : if self . loaded : return for app_name in settings . INSTALLED_APPS : if app_name in self . handled : continue self . load_app ( app_name , True ) if not self . nesting_level : for app_name in self . postponed : self . load_app ( app_name ) self . loaded = True finally : self . write_lock . release ( ) def _label_for ( self , app_mod ) : return app_mod . __name__ . split ( '.' ) [ - 2 ] def load_app ( self , app_name , can_postpone = False ) : self . handled [ app_name ] = None self . nesting_level += 1 app_module = import_module ( app_name ) try : models = import_module ( '.models' , app_name ) except ImportError : self . nesting_level -= 1 if not module_has_submodule ( app_module , 'models' ) : return None else : if can_postpone : self . postponed . append ( app_name ) return None else : raise self . nesting_level -= 1 if models not in self . app_store : self . app_store [ models ] = len ( self . app_store ) self . app_labels [ self . _label_for ( models ) ] = models return models def app_cache_ready ( self ) : return self . loaded def get_apps ( self ) : self . _populate ( ) apps = [ ( v , k ) for k , v in self . app_store . items ( ) ] apps . sort ( ) return [ elt [ 1 ] for elt in apps ] def get_app ( self , app_label , emptyOK = False ) : self . _populate ( ) self . write_lock . acquire ( ) try : for app_name in settings . INSTALLED_APPS : if app_label == app_name . split ( '.' ) [ - 1 ] : mod = self . load_app ( app_name , False ) if mod is None : if emptyOK : return None raise ImproperlyConfigured ( "App with label %s is missing a models.py module." % app_label ) else : return mod raise ImproperlyConfigured ( "App with label %s could not be found" % app_label ) finally : self . write_lock . release ( ) def get_app_errors ( self ) : self . _populate ( ) return self . app_errors def get_models ( self , app_mod = None , include_auto_created = False , include_deferred = False , only_installed = True ) : cache_key = ( app_mod , include_auto_created , include_deferred , only_installed ) try : return self . _get_models_cache [ cache_key ] except KeyError : pass self . _populate ( ) if app_mod : if app_mod in self . app_store : app_list = [ self . app_models . get ( self . _label_for ( app_mod ) , SortedDict ( ) ) ] else : app_list = [ ] else : if only_installed : app_list = [ self . app_models . get ( app_label , SortedDict ( ) ) for app_label in self . app_labels . iterkeys ( ) ] else : app_list = self . app_models . itervalues ( ) model_list = [ ] for app in app_list : model_list . extend ( model for model in app . values ( ) if ( ( not model . _deferred or include_deferred ) and ( not model . _meta . auto_created or include_auto_created ) ) ) self . _get_models_cache [ cache_key ] = model_list return model_list def get_model ( self , app_label , model_name , seed_cache = True , only_installed = True ) : if seed_cache : self . _populate ( ) if only_installed and app_label not in self . app_labels : return None return self . app_models . get ( app_label , SortedDict ( ) ) . get ( model_name . lower ( ) ) def register_models ( self , app_label , * models ) : for model in models : model_name = model . _meta . object_name . lower ( ) model_dict = self . app_models . setdefault ( app_label , SortedDict ( ) ) if model_name in model_dict : fname1 = os . path . abspath ( sys . modules [ model . __module__ ] . __file__ ) fname2 = os . path . abspath ( sys . modules [ model_dict [ model_name ] . __module__ ] . __file__ ) if os . path . splitext ( fname1 ) [ 0 ] == os . path . splitext ( fname2 ) [ 0 ] : continue model_dict [ model_name ] = model self . _get_models_cache . clear ( ) cache = AppCache ( ) get_apps = cache . get_apps get_app = cache . get_app get_app_errors = cache . get_app_errors get_models = cache . get_models get_model = cache . get_model register_models = cache . register_models load_app = cache . load_app app_cache_ready = cache . app_cache_ready

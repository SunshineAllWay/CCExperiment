import re from django . db . backends import BaseDatabaseIntrospection class FlexibleFieldLookupDict ( object ) : base_data_types_reverse = { : 'BooleanField' , : 'BooleanField' , : 'SmallIntegerField' , : 'PositiveSmallIntegerField' , : 'SmallIntegerField' , : 'IntegerField' , : 'IntegerField' , : 'BigIntegerField' , : 'PositiveIntegerField' , : 'DecimalField' , : 'FloatField' , : 'TextField' , : 'CharField' , : 'DateField' , : 'DateTimeField' , : 'TimeField' , } def __getitem__ ( self , key ) : key = key . lower ( ) try : return self . base_data_types_reverse [ key ] except KeyError : import re m = re . search ( r'^\s*(?:var)?char\s*\(\s*(\d+)\s*\)\s*$' , key ) if m : return ( 'CharField' , { 'max_length' : int ( m . group ( 1 ) ) } ) raise KeyError class DatabaseIntrospection ( BaseDatabaseIntrospection ) : data_types_reverse = FlexibleFieldLookupDict ( ) def get_table_list ( self , cursor ) : cursor . execute ( """ SELECT name FROM sqlite_master WHERE type='table' AND NOT name='sqlite_sequence' ORDER BY name""" ) return [ row [ 0 ] for row in cursor . fetchall ( ) ] def get_table_description ( self , cursor , table_name ) : return [ ( info [ 'name' ] , info [ 'type' ] , None , None , None , None , info [ 'null_ok' ] ) for info in self . _table_info ( cursor , table_name ) ] def get_relations ( self , cursor , table_name ) : relations = { } cursor . execute ( "SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s" , [ table_name , "table" ] ) results = cursor . fetchone ( ) [ 0 ] . strip ( ) results = results [ results . index ( '(' ) + 1 : results . rindex ( ')' ) ] for field_index , field_desc in enumerate ( results . split ( ',' ) ) : field_desc = field_desc . strip ( ) if field_desc . startswith ( "UNIQUE" ) : continue m = re . search ( 'references (.*) \(["|](.*)["|]\)' , field_desc , re . I ) if not m : continue table , column = [ s . strip ( '"' ) for s in m . groups ( ) ] cursor . execute ( "SELECT sql FROM sqlite_master WHERE tbl_name = %s" , [ table ] ) result = cursor . fetchall ( ) [ 0 ] other_table_results = result [ 0 ] . strip ( ) li , ri = other_table_results . index ( '(' ) , other_table_results . rindex ( ')' ) other_table_results = other_table_results [ li + 1 : ri ] for other_index , other_desc in enumerate ( other_table_results . split ( ',' ) ) : other_desc = other_desc . strip ( ) if other_desc . startswith ( 'UNIQUE' ) : continue name = other_desc . split ( ' ' , 1 ) [ 0 ] . strip ( '"' ) if name == column : relations [ field_index ] = ( other_index , table ) break return relations def get_key_columns ( self , cursor , table_name ) : key_columns = [ ] cursor . execute ( "SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s" , [ table_name , "table" ] ) results = cursor . fetchone ( ) [ 0 ] . strip ( ) results = results [ results . index ( '(' ) + 1 : results . rindex ( ')' ) ] for field_index , field_desc in enumerate ( results . split ( ',' ) ) : field_desc = field_desc . strip ( ) if field_desc . startswith ( "UNIQUE" ) : continue m = re . search ( '"(.*)".*references (.*) \(["|](.*)["|]\)' , field_desc , re . I ) if not m : continue key_columns . append ( tuple ( [ s . strip ( '"' ) for s in m . groups ( ) ] ) ) return key_columns def get_indexes ( self , cursor , table_name ) : indexes = { } for info in self . _table_info ( cursor , table_name ) : indexes [ info [ 'name' ] ] = { 'primary_key' : info [ 'pk' ] != 0 , : False } cursor . execute ( 'PRAGMA index_list(%s)' % self . connection . ops . quote_name ( table_name ) ) for index , unique in [ ( field [ 1 ] , field [ 2 ] ) for field in cursor . fetchall ( ) ] : if not unique : continue cursor . execute ( 'PRAGMA index_info(%s)' % self . connection . ops . quote_name ( index ) ) info = cursor . fetchall ( ) if len ( info ) != 1 : continue name = info [ 0 ] [ 2 ] indexes [ name ] [ 'unique' ] = True return indexes def get_primary_key_column ( self , cursor , table_name ) : cursor . execute ( "SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s" , [ table_name , "table" ] ) results = cursor . fetchone ( ) [ 0 ] . strip ( ) results = results [ results . index ( '(' ) + 1 : results . rindex ( ')' ) ] for field_desc in results . split ( ',' ) : field_desc = field_desc . strip ( ) m = re . search ( '"(.*)".*PRIMARY KEY$' , field_desc ) if m : return m . groups ( ) [ 0 ] return None def _table_info ( self , cursor , name ) : cursor . execute ( 'PRAGMA table_info(%s)' % self . connection . ops . quote_name ( name ) ) return [ { 'name' : field [ 1 ] , : field [ 2 ] , : not field [ 3 ] , : field [ 5 ] } for field in cursor . fetchall ( ) ]

from django . core . exceptions import ImproperlyConfigured from django . db import models from django . db . models . fields import FieldDoesNotExist from django . forms . models import ( BaseModelForm , BaseModelFormSet , fields_for_model , _get_foreign_key ) from django . contrib . admin import ListFilter , FieldListFilter from django . contrib . admin . util import get_fields_from_path , NotRelationField from django . contrib . admin . options import ( flatten_fieldsets , BaseModelAdmin , HORIZONTAL , VERTICAL ) __all__ = [ 'validate' ] def validate ( cls , model ) : models . get_apps ( ) opts = model . _meta validate_base ( cls , model ) if hasattr ( cls , 'list_display' ) : check_isseq ( cls , 'list_display' , cls . list_display ) for idx , field in enumerate ( cls . list_display ) : if not callable ( field ) : if not hasattr ( cls , field ) : if not hasattr ( model , field ) : try : opts . get_field ( field ) except models . FieldDoesNotExist : raise ImproperlyConfigured ( "%s.list_display[%d], %r is not a callable or an attribute of %r or found in the model %r." % ( cls . __name__ , idx , field , cls . __name__ , model . _meta . object_name ) ) else : f = fetch_attr ( cls , model , opts , "list_display[%d]" % idx , field ) if isinstance ( f , models . ManyToManyField ) : raise ImproperlyConfigured ( "'%s.list_display[%d]', '%s' is a ManyToManyField which is not supported." % ( cls . __name__ , idx , field ) ) if hasattr ( cls , 'list_display_links' ) : check_isseq ( cls , 'list_display_links' , cls . list_display_links ) for idx , field in enumerate ( cls . list_display_links ) : if field not in cls . list_display : raise ImproperlyConfigured ( "'%s.list_display_links[%d]' " % ( cls . __name__ , idx , field ) ) if hasattr ( cls , 'list_filter' ) : check_isseq ( cls , 'list_filter' , cls . list_filter ) for idx , item in enumerate ( cls . list_filter ) : if callable ( item ) and not isinstance ( item , models . Field ) : if not issubclass ( item , ListFilter ) : raise ImproperlyConfigured ( "'%s.list_filter[%d]' is '%s'" % ( cls . __name__ , idx , item . __name__ ) ) if issubclass ( item , FieldListFilter ) : raise ImproperlyConfigured ( "'%s.list_filter[%d]' is '%s'" % ( cls . __name__ , idx , item . __name__ ) ) else : if isinstance ( item , ( tuple , list ) ) : field , list_filter_class = item if not issubclass ( list_filter_class , FieldListFilter ) : raise ImproperlyConfigured ( "'%s.list_filter[%d][1]'" % ( cls . __name__ , idx , list_filter_class . __name__ ) ) else : field = item try : get_fields_from_path ( model , field ) except ( NotRelationField , FieldDoesNotExist ) : raise ImproperlyConfigured ( "'%s.list_filter[%d]' refers to '%s'" % ( cls . __name__ , idx , field ) ) if hasattr ( cls , 'list_per_page' ) and not isinstance ( cls . list_per_page , int ) : raise ImproperlyConfigured ( "'%s.list_per_page' should be a integer." % cls . __name__ ) if hasattr ( cls , 'list_max_show_all' ) and not isinstance ( cls . list_max_show_all , int ) : raise ImproperlyConfigured ( "'%s.list_max_show_all' should be an integer." % cls . __name__ ) if hasattr ( cls , 'list_editable' ) and cls . list_editable : check_isseq ( cls , 'list_editable' , cls . list_editable ) for idx , field_name in enumerate ( cls . list_editable ) : try : field = opts . get_field_by_name ( field_name ) [ 0 ] except models . FieldDoesNotExist : raise ImproperlyConfigured ( "'%s.list_editable[%d]' refers to a " % ( cls . __name__ , idx , field_name , model . _meta . app_label , model . __name__ ) ) if field_name not in cls . list_display : raise ImproperlyConfigured ( "'%s.list_editable[%d]' refers to " % ( cls . __name__ , idx , field_name ) ) if field_name in cls . list_display_links : raise ImproperlyConfigured ( "'%s' cannot be in both '%s.list_editable'" % ( field_name , cls . __name__ , cls . __name__ ) ) if not cls . list_display_links and cls . list_display [ 0 ] in cls . list_editable : raise ImproperlyConfigured ( "'%s.list_editable[%d]' refers to" % ( cls . __name__ , idx , cls . list_display [ 0 ] ) ) if not field . editable : raise ImproperlyConfigured ( "'%s.list_editable[%d]' refers to a " % ( cls . __name__ , idx , field_name ) ) if hasattr ( cls , 'search_fields' ) : check_isseq ( cls , 'search_fields' , cls . search_fields ) if cls . date_hierarchy : f = get_field ( cls , model , opts , 'date_hierarchy' , cls . date_hierarchy ) if not isinstance ( f , ( models . DateField , models . DateTimeField ) ) : raise ImproperlyConfigured ( "'%s.date_hierarchy is " % cls . __name__ ) if cls . ordering : check_isseq ( cls , 'ordering' , cls . ordering ) for idx , field in enumerate ( cls . ordering ) : if field == '?' and len ( cls . ordering ) != 1 : raise ImproperlyConfigured ( "'%s.ordering' has the random " % cls . __name__ ) if field == '?' : continue if field . startswith ( '-' ) : field = field [ 1 : ] if '__' in field : continue get_field ( cls , model , opts , 'ordering[%d]' % idx , field ) if hasattr ( cls , "readonly_fields" ) : check_readonly_fields ( cls , model , opts ) for attr in ( 'list_select_related' , 'save_as' , 'save_on_top' ) : if not isinstance ( getattr ( cls , attr ) , bool ) : raise ImproperlyConfigured ( "'%s.%s' should be a boolean." % ( cls . __name__ , attr ) ) if hasattr ( cls , 'inlines' ) : check_isseq ( cls , 'inlines' , cls . inlines ) for idx , inline in enumerate ( cls . inlines ) : if not issubclass ( inline , BaseModelAdmin ) : raise ImproperlyConfigured ( "'%s.inlines[%d]' does not inherit " % ( cls . __name__ , idx ) ) if not inline . model : raise ImproperlyConfigured ( "'model' is a required attribute " % ( cls . __name__ , idx ) ) if not issubclass ( inline . model , models . Model ) : raise ImproperlyConfigured ( "'%s.inlines[%d].model' does not " % ( cls . __name__ , idx ) ) validate_base ( inline , inline . model ) validate_inline ( inline , cls , model ) def validate_inline ( cls , parent , parent_model ) : if cls . fk_name : f = get_field ( cls , cls . model , cls . model . _meta , 'fk_name' , cls . fk_name ) if not isinstance ( f , models . ForeignKey ) : raise ImproperlyConfigured ( "'%s.fk_name is not an instance of " % cls . __name__ ) fk = _get_foreign_key ( parent_model , cls . model , fk_name = cls . fk_name , can_fail = True ) if not isinstance ( cls . extra , int ) : raise ImproperlyConfigured ( "'%s.extra' should be a integer." % cls . __name__ ) max_num = getattr ( cls , 'max_num' , None ) if max_num is not None and not isinstance ( max_num , int ) : raise ImproperlyConfigured ( "'%s.max_num' should be an integer or None (default)." % cls . __name__ ) if hasattr ( cls , 'formset' ) and not issubclass ( cls . formset , BaseModelFormSet ) : raise ImproperlyConfigured ( "'%s.formset' does not inherit from " % cls . __name__ ) if hasattr ( cls , 'exclude' ) and cls . exclude : if fk and fk . name in cls . exclude : raise ImproperlyConfigured ( "%s cannot exclude the field " % ( cls . __name__ , fk . name , parent_model . _meta . app_label , parent_model . __name__ ) ) if hasattr ( cls , "readonly_fields" ) : check_readonly_fields ( cls , cls . model , cls . model . _meta ) def validate_fields_spec ( cls , model , opts , flds , label ) : for fields in flds : if type ( fields ) != tuple : fields = ( fields , ) for field in fields : if field in cls . readonly_fields : continue check_formfield ( cls , model , opts , label , field ) try : f = opts . get_field ( field ) except models . FieldDoesNotExist : continue if isinstance ( f , models . ManyToManyField ) and not f . rel . through . _meta . auto_created : raise ImproperlyConfigured ( "'%s.%s' " % ( cls . __name__ , label , field , field ) ) def validate_base ( cls , model ) : opts = model . _meta if hasattr ( cls , 'raw_id_fields' ) : check_isseq ( cls , 'raw_id_fields' , cls . raw_id_fields ) for idx , field in enumerate ( cls . raw_id_fields ) : f = get_field ( cls , model , opts , 'raw_id_fields' , field ) if not isinstance ( f , ( models . ForeignKey , models . ManyToManyField ) ) : raise ImproperlyConfigured ( "'%s.raw_id_fields[%d]', '%s' must " % ( cls . __name__ , idx , field ) ) if cls . fields : check_isseq ( cls , 'fields' , cls . fields ) validate_fields_spec ( cls , model , opts , cls . fields , 'fields' ) if cls . fieldsets : raise ImproperlyConfigured ( 'Both fieldsets and fields are specified in %s.' % cls . __name__ ) if len ( cls . fields ) > len ( set ( cls . fields ) ) : raise ImproperlyConfigured ( 'There are duplicate field(s) in %s.fields' % cls . __name__ ) if cls . fieldsets : check_isseq ( cls , 'fieldsets' , cls . fieldsets ) for idx , fieldset in enumerate ( cls . fieldsets ) : check_isseq ( cls , 'fieldsets[%d]' % idx , fieldset ) if len ( fieldset ) != 2 : raise ImproperlyConfigured ( "'%s.fieldsets[%d]' does not " % ( cls . __name__ , idx ) ) check_isdict ( cls , 'fieldsets[%d][1]' % idx , fieldset [ 1 ] ) if 'fields' not in fieldset [ 1 ] : raise ImproperlyConfigured ( "'fields' key is required in " % ( cls . __name__ , idx ) ) validate_fields_spec ( cls , model , opts , fieldset [ 1 ] [ 'fields' ] , "fieldsets[%d][1]['fields']" % idx ) flattened_fieldsets = flatten_fieldsets ( cls . fieldsets ) if len ( flattened_fieldsets ) > len ( set ( flattened_fieldsets ) ) : raise ImproperlyConfigured ( 'There are duplicate field(s) in %s.fieldsets' % cls . __name__ ) if cls . exclude : check_isseq ( cls , 'exclude' , cls . exclude ) for field in cls . exclude : check_formfield ( cls , model , opts , 'exclude' , field ) try : f = opts . get_field ( field ) except models . FieldDoesNotExist : continue if len ( cls . exclude ) > len ( set ( cls . exclude ) ) : raise ImproperlyConfigured ( 'There are duplicate field(s) in %s.exclude' % cls . __name__ ) if hasattr ( cls , 'form' ) and not issubclass ( cls . form , BaseModelForm ) : raise ImproperlyConfigured ( "%s.form does not inherit from " % cls . __name__ ) if hasattr ( cls , 'filter_vertical' ) : check_isseq ( cls , 'filter_vertical' , cls . filter_vertical ) for idx , field in enumerate ( cls . filter_vertical ) : f = get_field ( cls , model , opts , 'filter_vertical' , field ) if not isinstance ( f , models . ManyToManyField ) : raise ImproperlyConfigured ( "'%s.filter_vertical[%d]' must be " % ( cls . __name__ , idx ) ) if hasattr ( cls , 'filter_horizontal' ) : check_isseq ( cls , 'filter_horizontal' , cls . filter_horizontal ) for idx , field in enumerate ( cls . filter_horizontal ) : f = get_field ( cls , model , opts , 'filter_horizontal' , field ) if not isinstance ( f , models . ManyToManyField ) : raise ImproperlyConfigured ( "'%s.filter_horizontal[%d]' must be " % ( cls . __name__ , idx ) ) if hasattr ( cls , 'radio_fields' ) : check_isdict ( cls , 'radio_fields' , cls . radio_fields ) for field , val in cls . radio_fields . items ( ) : f = get_field ( cls , model , opts , 'radio_fields' , field ) if not ( isinstance ( f , models . ForeignKey ) or f . choices ) : raise ImproperlyConfigured ( "'%s.radio_fields['%s']' " % ( cls . __name__ , field ) ) if not val in ( HORIZONTAL , VERTICAL ) : raise ImproperlyConfigured ( "'%s.radio_fields['%s']' " % ( cls . __name__ , field ) ) if hasattr ( cls , 'prepopulated_fields' ) : check_isdict ( cls , 'prepopulated_fields' , cls . prepopulated_fields ) for field , val in cls . prepopulated_fields . items ( ) : f = get_field ( cls , model , opts , 'prepopulated_fields' , field ) if isinstance ( f , ( models . DateTimeField , models . ForeignKey , models . ManyToManyField ) ) : raise ImproperlyConfigured ( "'%s.prepopulated_fields['%s']' " % ( cls . __name__ , field ) ) check_isseq ( cls , "prepopulated_fields['%s']" % field , val ) for idx , f in enumerate ( val ) : get_field ( cls , model , opts , "prepopulated_fields['%s'][%d]" % ( field , idx ) , f ) def check_isseq ( cls , label , obj ) : if not isinstance ( obj , ( list , tuple ) ) : raise ImproperlyConfigured ( "'%s.%s' must be a list or tuple." % ( cls . __name__ , label ) ) def check_isdict ( cls , label , obj ) : if not isinstance ( obj , dict ) : raise ImproperlyConfigured ( "'%s.%s' must be a dictionary." % ( cls . __name__ , label ) ) def get_field ( cls , model , opts , label , field ) : try : return opts . get_field ( field ) except models . FieldDoesNotExist : raise ImproperlyConfigured ( "'%s.%s' refers to field '%s' that is missing from model '%s.%s'." % ( cls . __name__ , label , field , model . _meta . app_label , model . __name__ ) ) def check_formfield ( cls , model , opts , label , field ) : if getattr ( cls . form , 'base_fields' , None ) : try : cls . form . base_fields [ field ] except KeyError : raise ImproperlyConfigured ( "'%s.%s' refers to field '%s' that " % ( cls . __name__ , label , field ) ) else : fields = fields_for_model ( model ) try : fields [ field ] except KeyError : raise ImproperlyConfigured ( "'%s.%s' refers to field '%s' that " % ( cls . __name__ , label , field ) ) def fetch_attr ( cls , model , opts , label , field ) : try : return opts . get_field ( field ) except models . FieldDoesNotExist : pass try : return getattr ( model , field ) except AttributeError : raise ImproperlyConfigured ( "'%s.%s' refers to '%s' that is neither a field, method or property of model '%s.%s'." % ( cls . __name__ , label , field , model . _meta . app_label , model . __name__ ) ) def check_readonly_fields ( cls , model , opts ) : check_isseq ( cls , "readonly_fields" , cls . readonly_fields ) for idx , field in enumerate ( cls . readonly_fields ) : if not callable ( field ) : if not hasattr ( cls , field ) : if not hasattr ( model , field ) : try : opts . get_field ( field ) except models . FieldDoesNotExist : raise ImproperlyConfigured ( "%s.readonly_fields[%d], %r is not a callable or an attribute of %r or found in the model %r." % ( cls . __name__ , idx , field , cls . __name__ , model . _meta . object_name ) )

import re import unicodedata import warnings from gzip import GzipFile from htmlentitydefs import name2codepoint try : from cStringIO import StringIO except ImportError : from StringIO import StringIO from django . utils . encoding import force_unicode from django . utils . functional import allow_lazy , SimpleLazyObject from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext capfirst = lambda x : x and force_unicode ( x ) [ 0 ] . upper ( ) + force_unicode ( x ) [ 1 : ] capfirst = allow_lazy ( capfirst , unicode ) re_words = re . compile ( r'&.*?;|<.*?>|(\w[\w-]*)' , re . U | re . S ) re_tag = re . compile ( r'<(/)?([^ ]+?)(?: (/)| .*?)?>' , re . S ) def wrap ( text , width ) : text = force_unicode ( text ) def _generator ( ) : it = iter ( text . split ( ' ' ) ) word = it . next ( ) yield word pos = len ( word ) - word . rfind ( '\n' ) - 1 for word in it : if "\n" in word : lines = word . split ( '\n' ) else : lines = ( word , ) pos += len ( lines [ 0 ] ) + 1 if pos > width : yield '\n' pos = len ( lines [ - 1 ] ) else : yield ' ' if len ( lines ) > 1 : pos = len ( lines [ - 1 ] ) yield word return u'' . join ( _generator ( ) ) wrap = allow_lazy ( wrap , unicode ) class Truncator ( SimpleLazyObject ) : def __init__ ( self , text ) : super ( Truncator , self ) . __init__ ( lambda : force_unicode ( text ) ) def add_truncation_text ( self , text , truncate = None ) : if truncate is None : truncate = pgettext ( , ) truncate = force_unicode ( truncate ) if '%(truncated_text)s' in truncate : return truncate % { 'truncated_text' : text } if text . endswith ( truncate ) : return text return '%s%s' % ( text , truncate ) def chars ( self , num , truncate = None ) : length = int ( num ) text = unicodedata . normalize ( 'NFC' , self . _wrapped ) truncate_len = length for char in self . add_truncation_text ( '' , truncate ) : if not unicodedata . combining ( char ) : truncate_len -= 1 if truncate_len == 0 : break s_len = 0 end_index = None for i , char in enumerate ( text ) : if unicodedata . combining ( char ) : continue s_len += 1 if end_index is None and s_len > truncate_len : end_index = i if s_len > length : return self . add_truncation_text ( text [ : end_index or 0 ] , truncate ) return text chars = allow_lazy ( chars ) def words ( self , num , truncate = None , html = False ) : length = int ( num ) if html : return self . _html_words ( length , truncate ) return self . _text_words ( length , truncate ) words = allow_lazy ( words ) def _text_words ( self , length , truncate ) : words = self . _wrapped . split ( ) if len ( words ) > length : words = words [ : length ] return self . add_truncation_text ( u' ' . join ( words ) , truncate ) return u' ' . join ( words ) def _html_words ( self , length , truncate ) : if length <= 0 : return u'' html4_singlets = ( , 'col' , 'link' , 'base' , 'img' , , 'area' , 'hr' , 'input' ) pos = 0 end_text_pos = 0 words = 0 open_tags = [ ] while words <= length : m = re_words . search ( self . _wrapped , pos ) if not m : break pos = m . end ( 0 ) if m . group ( 1 ) : words += 1 if words == length : end_text_pos = pos continue tag = re_tag . match ( m . group ( 0 ) ) if not tag or end_text_pos : continue closing_tag , tagname , self_closing = tag . groups ( ) tagname = tagname . lower ( ) if self_closing or tagname in html4_singlets : pass elif closing_tag : try : i = open_tags . index ( tagname ) except ValueError : pass else : open_tags = open_tags [ i + 1 : ] else : open_tags . insert ( 0 , tagname ) if words <= length : return self . _wrapped out = self . _wrapped [ : end_text_pos ] truncate_text = self . add_truncation_text ( '' , truncate ) if truncate_text : out += truncate_text for tag in open_tags : out += '</%s>' % tag return out def truncate_words ( s , num , end_text = '...' ) : warnings . warn ( 'This function has been deprecated. Use the Truncator class ' , category = PendingDeprecationWarning ) truncate = end_text and ' %s' % end_text or '' return Truncator ( s ) . words ( num , truncate = truncate ) truncate_words = allow_lazy ( truncate_words , unicode ) def truncate_html_words ( s , num , end_text = '...' ) : warnings . warn ( 'This function has been deprecated. Use the Truncator class ' , category = PendingDeprecationWarning ) truncate = end_text and ' %s' % end_text or '' return Truncator ( s ) . words ( num , truncate = truncate , html = True ) truncate_html_words = allow_lazy ( truncate_html_words , unicode ) def get_valid_filename ( s ) : s = force_unicode ( s ) . strip ( ) . replace ( ' ' , '_' ) return re . sub ( r'(?u)[^-\w.]' , '' , s ) get_valid_filename = allow_lazy ( get_valid_filename , unicode ) def get_text_list ( list_ , last_word = ugettext_lazy ( u'or' ) ) : if len ( list_ ) == 0 : return u'' if len ( list_ ) == 1 : return force_unicode ( list_ [ 0 ] ) return u'%s %s %s' % ( _ ( ', ' ) . join ( [ force_unicode ( i ) for i in list_ ] [ : - 1 ] ) , force_unicode ( last_word ) , force_unicode ( list_ [ - 1 ] ) ) get_text_list = allow_lazy ( get_text_list , unicode ) def normalize_newlines ( text ) : return force_unicode ( re . sub ( r'\r\n|\r|\n' , '\n' , text ) ) normalize_newlines = allow_lazy ( normalize_newlines , unicode ) def recapitalize ( text ) : text = force_unicode ( text ) . lower ( ) capsRE = re . compile ( r'(?:^|(?<=[\.\?\!] ))([a-z])' ) text = capsRE . sub ( lambda x : x . group ( 1 ) . upper ( ) , text ) return text recapitalize = allow_lazy ( recapitalize ) def phone2numeric ( phone ) : letters = re . compile ( r'[A-Z]' , re . I ) char2number = lambda m : { 'a' : '2' , 'b' : '2' , 'c' : '2' , 'd' : '3' , 'e' : '3' , : '3' , 'g' : '4' , 'h' : '4' , 'i' : '4' , 'j' : '5' , 'k' : '5' , 'l' : '5' , : '6' , 'n' : '6' , 'o' : '6' , 'p' : '7' , 'q' : '7' , 'r' : '7' , 's' : '7' , : '8' , 'u' : '8' , 'v' : '8' , 'w' : '9' , 'x' : '9' , 'y' : '9' , 'z' : '9' , } . get ( m . group ( 0 ) . lower ( ) ) return letters . sub ( char2number , phone ) phone2numeric = allow_lazy ( phone2numeric ) def compress_string ( s ) : zbuf = StringIO ( ) zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = zbuf ) zfile . write ( s ) zfile . close ( ) return zbuf . getvalue ( ) ustring_re = re . compile ( u"([\u0080-\uffff])" ) def javascript_quote ( s , quote_double_quotes = False ) : def fix ( match ) : return r"\u%04x" % ord ( match . group ( 1 ) ) if type ( s ) == str : s = s . decode ( 'utf-8' ) elif type ( s ) != unicode : raise TypeError ( s ) s = s . replace ( '\\' , '\\\\' ) s = s . replace ( '\r' , '\\r' ) s = s . replace ( '\n' , '\\n' ) s = s . replace ( '\t' , '\\t' ) s = s . replace ( "'" , "\\'" ) if quote_double_quotes : s = s . replace ( '"' , '&quot;' ) return str ( ustring_re . sub ( fix , s ) ) javascript_quote = allow_lazy ( javascript_quote , unicode ) smart_split_re = re . compile ( r""" ((?: [^\s'"]* (?: (?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*') [^\s'"]* )+ ) | \S+) """ , re . VERBOSE ) def smart_split ( text ) : text = force_unicode ( text ) for bit in smart_split_re . finditer ( text ) : yield bit . group ( 0 ) smart_split = allow_lazy ( smart_split , unicode ) def _replace_entity ( match ) : text = match . group ( 1 ) if text [ 0 ] == u'#' : text = text [ 1 : ] try : if text [ 0 ] in u'xX' : c = int ( text [ 1 : ] , 16 ) else : c = int ( text ) return unichr ( c ) except ValueError : return match . group ( 0 ) else : try : return unichr ( name2codepoint [ text ] ) except ( ValueError , KeyError ) : return match . group ( 0 ) _entity_re = re . compile ( r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));" ) def unescape_entities ( text ) : return _entity_re . sub ( _replace_entity , text ) unescape_entities = allow_lazy ( unescape_entities , unicode ) def unescape_string_literal ( s ) : if s [ 0 ] not in "\"'" or s [ - 1 ] != s [ 0 ] : raise ValueError ( "Not a string literal: %r" % s ) quote = s [ 0 ] return s [ 1 : - 1 ] . replace ( r'\%s' % quote , quote ) . replace ( r'\\' , '\\' ) unescape_string_literal = allow_lazy ( unescape_string_literal )

from __future__ import with_statement import hashlib import os import posixpath import re from urllib import unquote from urlparse import urlsplit , urlunsplit , urldefrag from django . conf import settings from django . core . cache import ( get_cache , InvalidCacheBackendError , cache as default_cache ) from django . core . exceptions import ImproperlyConfigured from django . core . files . base import ContentFile from django . core . files . storage import FileSystemStorage , get_storage_class from django . utils . datastructures import SortedDict from django . utils . encoding import force_unicode , smart_str from django . utils . functional import LazyObject from django . utils . importlib import import_module from django . contrib . staticfiles . utils import check_settings , matches_patterns class StaticFilesStorage ( FileSystemStorage ) : def __init__ ( self , location = None , base_url = None , * args , ** kwargs ) : if location is None : location = settings . STATIC_ROOT if base_url is None : base_url = settings . STATIC_URL check_settings ( base_url ) super ( StaticFilesStorage , self ) . __init__ ( location , base_url , * args , ** kwargs ) def path ( self , name ) : if not self . location : raise ImproperlyConfigured ( "You're using the staticfiles app " ) return super ( StaticFilesStorage , self ) . path ( name ) class CachedFilesMixin ( object ) : patterns = ( ( "*.css" , ( , , ) ) , ) def __init__ ( self , * args , ** kwargs ) : super ( CachedFilesMixin , self ) . __init__ ( * args , ** kwargs ) try : self . cache = get_cache ( 'staticfiles' ) except InvalidCacheBackendError : self . cache = default_cache self . _patterns = SortedDict ( ) for extension , patterns in self . patterns : for pattern in patterns : compiled = re . compile ( pattern ) self . _patterns . setdefault ( extension , [ ] ) . append ( compiled ) def hashed_name ( self , name , content = None ) : parsed_name = urlsplit ( unquote ( name ) ) clean_name = parsed_name . path if content is None : if not self . exists ( clean_name ) : raise ValueError ( "The file '%s' could not be found with %r." % ( clean_name , self ) ) try : content = self . open ( clean_name ) except IOError : return name path , filename = os . path . split ( clean_name ) root , ext = os . path . splitext ( filename ) md5 = hashlib . md5 ( ) for chunk in content . chunks ( ) : md5 . update ( chunk ) md5sum = md5 . hexdigest ( ) [ : 12 ] hashed_name = os . path . join ( path , u"%s.%s%s" % ( root , md5sum , ext ) ) unparsed_name = list ( parsed_name ) unparsed_name [ 2 ] = hashed_name if '?#' in name and not unparsed_name [ 3 ] : unparsed_name [ 2 ] += '?' return urlunsplit ( unparsed_name ) def cache_key ( self , name ) : return u'staticfiles:cache:%s' % name def url ( self , name , force = False ) : if settings . DEBUG and not force : hashed_name , fragment = name , '' else : clean_name , fragment = urldefrag ( name ) if urlsplit ( clean_name ) . path . endswith ( '/' ) : hashed_name = name else : cache_key = self . cache_key ( name ) hashed_name = self . cache . get ( cache_key ) if hashed_name is None : hashed_name = self . hashed_name ( clean_name ) . replace ( '\\' , '/' ) self . cache . set ( cache_key , hashed_name ) final_url = super ( CachedFilesMixin , self ) . url ( hashed_name ) query_fragment = '?#' in name if fragment or query_fragment : urlparts = list ( urlsplit ( final_url ) ) if fragment and not urlparts [ 4 ] : urlparts [ 4 ] = fragment if query_fragment and not urlparts [ 3 ] : urlparts [ 2 ] += '?' final_url = urlunsplit ( urlparts ) return unquote ( final_url ) def url_converter ( self , name ) : def converter ( matchobj ) : matched , url = matchobj . groups ( ) if url . startswith ( ( '#' , 'http:' , 'https:' , 'data:' ) ) : return matched name_parts = name . split ( os . sep ) url = posixpath . normpath ( url ) url_parts = url . split ( '/' ) parent_level , sub_level = url . count ( '..' ) , url . count ( '/' ) if url . startswith ( '/' ) : sub_level -= 1 url_parts = url_parts [ 1 : ] if parent_level or not url . startswith ( '/' ) : start , end = parent_level + 1 , parent_level else : if sub_level : if sub_level == 1 : parent_level -= 1 start , end = parent_level , sub_level - 1 else : start , end = 1 , sub_level - 1 joined_result = '/' . join ( name_parts [ : - start ] + url_parts [ end : ] ) hashed_url = self . url ( unquote ( joined_result ) , force = True ) return 'url("%s")' % unquote ( hashed_url ) return converter def post_process ( self , paths , dry_run = False , ** options ) : if dry_run : return self . cache . delete_many ( [ self . cache_key ( path ) for path in paths ] ) matches = lambda path : matches_patterns ( path , self . _patterns . keys ( ) ) adjustable_paths = [ path for path in paths if matches ( path ) ] path_level = lambda name : len ( name . split ( os . sep ) ) for name in sorted ( paths . keys ( ) , key = path_level , reverse = True ) : storage , path = paths [ name ] with storage . open ( path ) as original_file : hashed_name = self . hashed_name ( name , original_file ) if hasattr ( original_file , 'seek' ) : original_file . seek ( 0 ) hashed_file_exists = self . exists ( hashed_name ) processed = False if name in adjustable_paths : content = original_file . read ( ) converter = self . url_converter ( name ) for patterns in self . _patterns . values ( ) : for pattern in patterns : content = pattern . sub ( converter , content ) if hashed_file_exists : self . delete ( hashed_name ) content_file = ContentFile ( smart_str ( content ) ) saved_name = self . _save ( hashed_name , content_file ) hashed_name = force_unicode ( saved_name . replace ( '\\' , '/' ) ) processed = True else : if not hashed_file_exists : processed = True saved_name = self . _save ( hashed_name , original_file ) hashed_name = force_unicode ( saved_name . replace ( '\\' , '/' ) ) self . cache . set ( self . cache_key ( name ) , hashed_name ) yield name , hashed_name , processed class CachedStaticFilesStorage ( CachedFilesMixin , StaticFilesStorage ) : pass class AppStaticStorage ( FileSystemStorage ) : prefix = None source_dir = 'static' def __init__ ( self , app , * args , ** kwargs ) : mod = import_module ( app ) mod_path = os . path . dirname ( mod . __file__ ) location = os . path . join ( mod_path , self . source_dir ) super ( AppStaticStorage , self ) . __init__ ( location , * args , ** kwargs ) class ConfiguredStorage ( LazyObject ) : def _setup ( self ) : self . _wrapped = get_storage_class ( settings . STATICFILES_STORAGE ) ( ) staticfiles_storage = ConfiguredStorage ( )

from __future__ import with_statement from datetime import datetime , tzinfo try : import pytz except ImportError : pytz = None from django . template import Node from django . template import TemplateSyntaxError , Library from django . utils import timezone register = Library ( ) class datetimeobject ( datetime , object ) : pass @ register . filter def localtime ( value ) : return do_timezone ( value , timezone . get_current_timezone ( ) ) @ register . filter def utc ( value ) : return do_timezone ( value , timezone . utc ) @ register . filter ( 'timezone' ) def do_timezone ( value , arg ) : if not isinstance ( value , datetime ) : return '' try : if timezone . is_naive ( value ) : default_timezone = timezone . get_default_timezone ( ) value = timezone . make_aware ( value , default_timezone ) except Exception : return '' if isinstance ( arg , tzinfo ) : tz = arg elif isinstance ( arg , basestring ) and pytz is not None : try : tz = pytz . timezone ( arg ) except pytz . UnknownTimeZoneError : return '' else : return '' result = value . astimezone ( tz ) if hasattr ( tz , 'normalize' ) : result = tz . normalize ( result ) result = datetimeobject ( result . year , result . month , result . day , result . hour , result . minute , result . second , result . microsecond , result . tzinfo ) result . convert_to_local_time = False return result class LocalTimeNode ( Node ) : def __init__ ( self , nodelist , use_tz ) : self . nodelist = nodelist self . use_tz = use_tz def render ( self , context ) : old_setting = context . use_tz context . use_tz = self . use_tz output = self . nodelist . render ( context ) context . use_tz = old_setting return output class TimezoneNode ( Node ) : def __init__ ( self , nodelist , tz ) : self . nodelist = nodelist self . tz = tz def render ( self , context ) : with timezone . override ( self . tz . resolve ( context ) ) : output = self . nodelist . render ( context ) return output class GetCurrentTimezoneNode ( Node ) : def __init__ ( self , variable ) : self . variable = variable def render ( self , context ) : context [ self . variable ] = timezone . get_current_timezone_name ( ) return '' @ register . tag ( 'localtime' ) def localtime_tag ( parser , token ) : bits = token . split_contents ( ) if len ( bits ) == 1 : use_tz = True elif len ( bits ) > 2 or bits [ 1 ] not in ( 'on' , 'off' ) : raise TemplateSyntaxError ( "%r argument should be 'on' or 'off'" % bits [ 0 ] ) else : use_tz = bits [ 1 ] == 'on' nodelist = parser . parse ( ( 'endlocaltime' , ) ) parser . delete_first_token ( ) return LocalTimeNode ( nodelist , use_tz ) @ register . tag ( 'timezone' ) def timezone_tag ( parser , token ) : bits = token . split_contents ( ) if len ( bits ) != 2 : raise TemplateSyntaxError ( "'%s' takes one argument (timezone)" % bits [ 0 ] ) tz = parser . compile_filter ( bits [ 1 ] ) nodelist = parser . parse ( ( 'endtimezone' , ) ) parser . delete_first_token ( ) return TimezoneNode ( nodelist , tz ) @ register . tag ( "get_current_timezone" ) def get_current_timezone_tag ( parser , token ) : args = token . contents . split ( ) if len ( args ) != 3 or args [ 1 ] != 'as' : raise TemplateSyntaxError ( "'get_current_timezone' requires " % args ) return GetCurrentTimezoneNode ( args [ 2 ] )

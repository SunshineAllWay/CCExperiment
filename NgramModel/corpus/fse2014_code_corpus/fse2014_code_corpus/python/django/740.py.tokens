from __future__ import absolute_import import datetime import pickle from decimal import Decimal from operator import attrgetter from django . core . exceptions import FieldError from django . db . models import Count , Max , Avg , Sum , StdDev , Variance , F , Q from django . test import TestCase , Approximate , skipUnlessDBFeature from . models import Author , Book , Publisher , Clues , Entries , HardbackBook class AggregationTests ( TestCase ) : fixtures = [ "aggregation_regress.json" ] def assertObjectAttrs ( self , obj , ** kwargs ) : for attr , value in kwargs . iteritems ( ) : self . assertEqual ( getattr ( obj , attr ) , value ) def test_aggregates_in_where_clause ( self ) : qs = Book . objects . values ( 'contact' ) . annotate ( Max ( 'id' ) ) qs = qs . order_by ( 'contact' ) . values_list ( 'id__max' , flat = True ) books = Book . objects . order_by ( 'id' ) qs1 = books . filter ( id__in = qs ) qs2 = books . filter ( id__in = list ( qs ) ) self . assertEqual ( list ( qs1 ) , list ( qs2 ) ) def test_aggregates_in_where_clause_pre_eval ( self ) : qs = Book . objects . values ( 'contact' ) . annotate ( Max ( 'id' ) ) qs = qs . order_by ( 'contact' ) . values_list ( 'id__max' , flat = True ) list ( qs ) books = Book . objects . order_by ( 'id' ) qs1 = books . filter ( id__in = qs ) qs2 = books . filter ( id__in = list ( qs ) ) self . assertEqual ( list ( qs1 ) , list ( qs2 ) ) @ skipUnlessDBFeature ( 'supports_subqueries_in_group_by' ) def test_annotate_with_extra ( self ) : shortest_book_sql = """ SELECT name FROM aggregation_regress_book b WHERE b.publisher_id = aggregation_regress_publisher.id ORDER BY b.pages LIMIT 1 """ qs = Publisher . objects . extra ( select = { : shortest_book_sql , } ) . annotate ( total_books = Count ( 'book' ) ) list ( qs ) def test_aggregate ( self ) : self . assertEqual ( Author . objects . order_by ( "name" ) . aggregate ( Avg ( "age" ) ) , { "age__avg" : Approximate ( 37.444 , places = 1 ) } ) self . assertEqual ( Book . objects . aggregate ( Sum ( "pages" ) ) , { "pages__sum" : 3703 } , ) self . assertEqual ( Book . objects . aggregate ( Sum ( 'pages' ) , Avg ( 'pages' ) ) , { 'pages__sum' : 3703 , 'pages__avg' : Approximate ( 617.166 , places = 2 ) } ) self . assertEqual ( Book . objects . values ( ) . aggregate ( Sum ( 'pages' ) , Avg ( 'pages' ) ) , { 'pages__sum' : 3703 , 'pages__avg' : Approximate ( 617.166 , places = 2 ) } ) self . assertEqual ( Book . objects . extra ( select = { 'price_per_page' : 'price / pages' } ) . aggregate ( Sum ( 'pages' ) ) , { 'pages__sum' : 3703 } ) def test_annotation ( self ) : obj = Book . objects . annotate ( mean_auth_age = Avg ( "authors__age" ) ) . extra ( select = { "manufacture_cost" : "price * .5" } ) . get ( pk = 2 ) self . assertObjectAttrs ( obj , contact_id = 3 , id = 2 , isbn = u'067232959' , mean_auth_age = 45.0 , name = 'Sams Teach Yourself Django in 24 Hours' , pages = 528 , price = Decimal ( "23.09" ) , pubdate = datetime . date ( 2008 , 3 , 3 ) , publisher_id = 2 , rating = 3.0 ) self . assertTrue ( obj . manufacture_cost == 11.545 or obj . manufacture_cost == Decimal ( '11.545' ) ) obj = Book . objects . extra ( select = { 'manufacture_cost' : 'price * .5' } ) . annotate ( mean_auth_age = Avg ( 'authors__age' ) ) . get ( pk = 2 ) self . assertObjectAttrs ( obj , contact_id = 3 , id = 2 , isbn = u'067232959' , mean_auth_age = 45.0 , name = u'Sams Teach Yourself Django in 24 Hours' , pages = 528 , price = Decimal ( "23.09" ) , pubdate = datetime . date ( 2008 , 3 , 3 ) , publisher_id = 2 , rating = 3.0 ) self . assertTrue ( obj . manufacture_cost == 11.545 or obj . manufacture_cost == Decimal ( '11.545' ) ) obj = Book . objects . annotate ( mean_auth_age = Avg ( 'authors__age' ) ) . extra ( select = { 'manufacture_cost' : 'price * .5' } ) . values ( ) . get ( pk = 2 ) manufacture_cost = obj [ 'manufacture_cost' ] self . assertTrue ( manufacture_cost == 11.545 or manufacture_cost == Decimal ( '11.545' ) ) del obj [ 'manufacture_cost' ] self . assertEqual ( obj , { : 3 , : 2 , : u"067232959" , : 45.0 , : u"Sams Teach Yourself Django in 24 Hours" , : 528 , : Decimal ( "23.09" ) , : datetime . date ( 2008 , 3 , 3 ) , : 2 , : 3.0 , } ) obj = Book . objects . values ( ) . annotate ( mean_auth_age = Avg ( 'authors__age' ) ) . extra ( select = { 'manufacture_cost' : 'price * .5' } ) . get ( pk = 2 ) manufacture_cost = obj [ 'manufacture_cost' ] self . assertTrue ( manufacture_cost == 11.545 or manufacture_cost == Decimal ( '11.545' ) ) del obj [ 'manufacture_cost' ] self . assertEqual ( obj , { : 3 , : 2 , : u'067232959' , : 45.0 , : u'Sams Teach Yourself Django in 24 Hours' , : 528 , : Decimal ( "23.09" ) , : datetime . date ( 2008 , 3 , 3 ) , : 2 , : 3.0 } ) obj = Book . objects . annotate ( mean_auth_age = Avg ( 'authors__age' ) ) . extra ( select = { 'price_per_page' : 'price / pages' } ) . values ( 'name' ) . get ( pk = 1 ) self . assertEqual ( obj , { : u'The Definitive Guide to Django: Web Development Done Right' , } ) obj = Book . objects . annotate ( mean_auth_age = Avg ( 'authors__age' ) ) . extra ( select = { 'price_per_page' : 'price / pages' } ) . values ( 'name' , 'mean_auth_age' ) . get ( pk = 1 ) self . assertEqual ( obj , { : 34.5 , : u'The Definitive Guide to Django: Web Development Done Right' , } ) qs = Book . objects . annotate ( n_authors = Count ( 'authors' ) ) . values ( 'name' ) . filter ( n_authors__gt = 2 ) self . assertQuerysetEqual ( qs , [ { "name" : u'Python Web Development with Django' } ] , lambda b : b , ) obj = Book . objects . values ( 'name' ) . annotate ( mean_auth_age = Avg ( 'authors__age' ) ) . extra ( select = { 'price_per_page' : 'price / pages' } ) . get ( pk = 1 ) self . assertEqual ( obj , { : 34.5 , : u'The Definitive Guide to Django: Web Development Done Right' , } ) self . assertEqual ( len ( Author . objects . annotate ( Avg ( 'friends__age' ) ) . values ( ) ) , 9 ) qs = Book . objects . values ( 'price' ) . annotate ( oldest = Max ( 'authors__age' ) ) . order_by ( 'oldest' , 'price' ) . annotate ( Max ( 'publisher__num_awards' ) ) self . assertQuerysetEqual ( qs , [ { 'price' : Decimal ( "30" ) , 'oldest' : 35 , 'publisher__num_awards__max' : 3 } , { 'price' : Decimal ( "29.69" ) , 'oldest' : 37 , 'publisher__num_awards__max' : 7 } , { 'price' : Decimal ( "23.09" ) , 'oldest' : 45 , 'publisher__num_awards__max' : 1 } , { 'price' : Decimal ( "75" ) , 'oldest' : 57 , 'publisher__num_awards__max' : 9 } , { 'price' : Decimal ( "82.8" ) , 'oldest' : 57 , 'publisher__num_awards__max' : 7 } ] , lambda b : b , ) def test_aggrate_annotation ( self ) : vals = Book . objects . all ( ) . annotate ( num_authors = Count ( 'authors__id' ) ) . aggregate ( Max ( 'pages' ) , Max ( 'price' ) , Sum ( 'num_authors' ) , Avg ( 'num_authors' ) ) self . assertEqual ( vals , { : 10 , : Approximate ( 1.666 , places = 2 ) , : 1132 , : Decimal ( "82.80" ) } ) def test_field_error ( self ) : self . assertRaises ( FieldError , lambda : Book . objects . all ( ) . aggregate ( num_authors = Count ( 'foo' ) ) ) self . assertRaises ( FieldError , lambda : Book . objects . all ( ) . annotate ( num_authors = Count ( 'foo' ) ) ) self . assertRaises ( FieldError , lambda : Book . objects . all ( ) . annotate ( num_authors = Count ( 'authors__id' ) ) . aggregate ( Max ( 'foo' ) ) ) def test_more ( self ) : self . assertEqual ( Book . objects . annotate ( num_authors = Count ( 'authors' ) ) . count ( ) , 6 ) vals = Book . objects . annotate ( num_authors = Count ( 'authors' ) ) . aggregate ( Max ( 'num_authors' ) ) self . assertEqual ( vals , { 'num_authors__max' : 3 } ) vals = Publisher . objects . annotate ( avg_price = Avg ( 'book__price' ) ) . aggregate ( Max ( 'avg_price' ) ) self . assertEqual ( vals , { 'avg_price__max' : 75.0 } ) vals = Book . objects . aggregate ( number = Max ( 'pages' ) , select = Max ( 'pages' ) ) self . assertEqual ( vals , { 'number' : 1132 , 'select' : 1132 } ) obj = Book . objects . select_related ( 'publisher' ) . annotate ( num_authors = Count ( 'authors' ) ) . values ( ) [ 0 ] self . assertEqual ( obj , { : 8 , : 5 , : u'013790395' , : u'Artificial Intelligence: A Modern Approach' , : 2 , : 1132 , : Decimal ( "82.8" ) , : datetime . date ( 1995 , 1 , 15 ) , : 3 , : 4.0 , } ) self . assertEqual ( len ( Book . objects . annotate ( num_authors = Count ( 'authors' ) ) ) , 6 ) self . assertEqual ( len ( Book . objects . annotate ( num_authors = Count ( 'authors' ) ) . filter ( num_authors__gt = 2 ) ) , 1 ) self . assertEqual ( len ( Book . objects . annotate ( num_authors = Count ( 'authors' ) ) . exclude ( num_authors__gt = 2 ) ) , 5 ) self . assertEqual ( len ( Book . objects . annotate ( num_authors = Count ( 'authors' ) ) . filter ( num_authors__lt = 3 ) . exclude ( num_authors__lt = 2 ) ) , 2 ) self . assertEqual ( len ( Book . objects . annotate ( num_authors = Count ( 'authors' ) ) . exclude ( num_authors__lt = 2 ) . filter ( num_authors__lt = 3 ) ) , 2 ) def test_aggregate_fexpr ( self ) : qs = Publisher . objects . annotate ( num_books = Count ( 'book' ) ) . filter ( num_books__lt = F ( 'num_awards' ) / 2 ) . order_by ( 'name' ) . values ( 'name' , 'num_books' , 'num_awards' ) self . assertQuerysetEqual ( qs , [ { 'num_books' : 1 , 'name' : u'Morgan Kaufmann' , 'num_awards' : 9 } , { 'num_books' : 2 , 'name' : u'Prentice Hall' , 'num_awards' : 7 } ] , lambda p : p , ) qs = Publisher . objects . annotate ( num_books = Count ( 'book' ) ) . exclude ( num_books__lt = F ( 'num_awards' ) / 2 ) . order_by ( 'name' ) . values ( 'name' , 'num_books' , 'num_awards' ) self . assertQuerysetEqual ( qs , [ { 'num_books' : 2 , 'name' : u'Apress' , 'num_awards' : 3 } , { 'num_books' : 0 , 'name' : u"Jonno's House of Books" , 'num_awards' : 0 } , { 'num_books' : 1 , 'name' : u'Sams' , 'num_awards' : 1 } ] , lambda p : p , ) qs = Publisher . objects . annotate ( num_books = Count ( 'book' ) ) . filter ( num_awards__gt = 2 * F ( 'num_books' ) ) . order_by ( 'name' ) . values ( 'name' , 'num_books' , 'num_awards' ) self . assertQuerysetEqual ( qs , [ { 'num_books' : 1 , 'name' : u'Morgan Kaufmann' , 'num_awards' : 9 } , { 'num_books' : 2 , 'name' : u'Prentice Hall' , 'num_awards' : 7 } ] , lambda p : p , ) qs = Publisher . objects . annotate ( num_books = Count ( 'book' ) ) . exclude ( num_books__lt = F ( 'num_awards' ) / 2 ) . order_by ( 'name' ) . values ( 'name' , 'num_books' , 'num_awards' ) self . assertQuerysetEqual ( qs , [ { 'num_books' : 2 , 'name' : u'Apress' , 'num_awards' : 3 } , { 'num_books' : 0 , 'name' : u"Jonno's House of Books" , 'num_awards' : 0 } , { 'num_books' : 1 , 'name' : u'Sams' , 'num_awards' : 1 } ] , lambda p : p , ) def test_db_col_table ( self ) : qs = Clues . objects . values ( 'EntryID__Entry' ) . annotate ( Appearances = Count ( 'EntryID' ) , Distinct_Clues = Count ( 'Clue' , distinct = True ) ) self . assertQuerysetEqual ( qs , [ ] ) qs = Entries . objects . annotate ( clue_count = Count ( 'clues__ID' ) ) self . assertQuerysetEqual ( qs , [ ] ) def test_empty ( self ) : self . assertEqual ( Book . objects . filter ( id__in = [ ] ) . count ( ) , 0 ) vals = Book . objects . filter ( id__in = [ ] ) . aggregate ( num_authors = Count ( 'authors' ) , avg_authors = Avg ( 'authors' ) , max_authors = Max ( 'authors' ) , max_price = Max ( 'price' ) , max_rating = Max ( 'rating' ) ) self . assertEqual ( vals , { 'max_authors' : None , 'max_rating' : None , 'num_authors' : 0 , 'avg_authors' : None , 'max_price' : None } ) qs = Publisher . objects . filter ( pk = 5 ) . annotate ( num_authors = Count ( 'book__authors' ) , avg_authors = Avg ( 'book__authors' ) , max_authors = Max ( 'book__authors' ) , max_price = Max ( 'book__price' ) , max_rating = Max ( 'book__rating' ) ) . values ( ) self . assertQuerysetEqual ( qs , [ { 'max_authors' : None , 'name' : u"Jonno's House of Books" , 'num_awards' : 0 , 'max_price' : None , 'num_authors' : 0 , 'max_rating' : None , 'id' : 5 , 'avg_authors' : None } ] , lambda p : p ) def test_more_more ( self ) : self . assertQuerysetEqual ( Book . objects . annotate ( num_authors = Count ( 'authors' ) ) . order_by ( 'publisher__name' , 'name' ) , [ , , , , , , ] , lambda b : b . name ) qs = Book . objects . filter ( rating__lt = 4.5 ) . select_related ( ) . annotate ( Avg ( 'authors__age' ) ) self . assertQuerysetEqual ( qs , [ ( u'Artificial Intelligence: A Modern Approach' , 51.5 , u'Prentice Hall' , u'Peter Norvig' ) , ( u'Practical Django Projects' , 29.0 , u'Apress' , u'James Bennett' ) , ( u'Python Web Development with Django' , Approximate ( 30.333 , places = 2 ) , u'Prentice Hall' , u'Jeffrey Forcier' ) , ( u'Sams Teach Yourself Django in 24 Hours' , 45.0 , u'Sams' , u'Brad Dayley' ) ] , lambda b : ( b . name , b . authors__age__avg , b . publisher . name , b . contact . name ) ) qs = Book . objects . extra ( select = { 'pub' : 'publisher_id' } ) . values ( 'pub' ) . annotate ( Count ( 'id' ) ) . order_by ( 'pub' ) self . assertQuerysetEqual ( qs , [ { 'pub' : 1 , 'id__count' : 2 } , { 'pub' : 2 , 'id__count' : 1 } , { 'pub' : 3 , 'id__count' : 2 } , { 'pub' : 4 , 'id__count' : 1 } ] , lambda b : b ) qs = Book . objects . extra ( select = { 'pub' : 'publisher_id' , 'foo' : 'pages' } ) . values ( 'pub' ) . annotate ( Count ( 'id' ) ) . order_by ( 'pub' ) self . assertQuerysetEqual ( qs , [ { 'pub' : 1 , 'id__count' : 2 } , { 'pub' : 2 , 'id__count' : 1 } , { 'pub' : 3 , 'id__count' : 2 } , { 'pub' : 4 , 'id__count' : 1 } ] , lambda b : b ) ids = Book . objects . filter ( pages__gt = 100 ) . annotate ( n_authors = Count ( 'authors' ) ) . filter ( n_authors__gt = 2 ) . order_by ( 'n_authors' ) self . assertQuerysetEqual ( Book . objects . filter ( id__in = ids ) , [ , ] , lambda b : b . name ) qs = Book . objects . values ( 'publisher' ) . annotate ( max_pages = Max ( 'pages' ) ) . order_by ( ) grouping , gb_params = qs . query . get_compiler ( qs . db ) . get_grouping ( ) self . assertEqual ( len ( grouping ) , 1 ) def test_duplicate_alias ( self ) : self . assertRaises ( ValueError , Book . objects . all ( ) . annotate , Avg ( 'authors__age' ) , authors__age__avg = Avg ( 'authors__age' ) ) def test_field_name_conflict ( self ) : self . assertRaises ( ValueError , Author . objects . annotate , age = Avg ( 'friends__age' ) ) def test_m2m_name_conflict ( self ) : self . assertRaises ( ValueError , Author . objects . annotate , friends = Count ( 'friends' ) ) def test_values_queryset_non_conflict ( self ) : results = Author . objects . values ( 'name' ) . annotate ( age = Count ( 'book_contact_set' ) ) . order_by ( 'name' ) self . assertEqual ( len ( results ) , 9 ) self . assertEqual ( results [ 0 ] [ 'name' ] , u'Adrian Holovaty' ) self . assertEqual ( results [ 0 ] [ 'age' ] , 1 ) results = Author . objects . values ( 'name' ) . annotate ( age = Avg ( 'friends__age' ) ) . order_by ( 'name' ) self . assertEqual ( len ( results ) , 9 ) self . assertEqual ( results [ 0 ] [ 'name' ] , u'Adrian Holovaty' ) self . assertEqual ( results [ 0 ] [ 'age' ] , 32.0 ) results = Author . objects . values ( 'name' ) . annotate ( friends = Count ( 'friends' ) ) . order_by ( 'name' ) self . assertEqual ( len ( results ) , 9 ) self . assertEqual ( results [ 0 ] [ 'name' ] , u'Adrian Holovaty' ) self . assertEqual ( results [ 0 ] [ 'friends' ] , 2 ) def test_reverse_relation_name_conflict ( self ) : self . assertRaises ( ValueError , Author . objects . annotate , book_contact_set = Avg ( 'friends__age' ) ) def test_pickle ( self ) : qs = Book . objects . annotate ( num_authors = Count ( 'authors' ) ) pickle . dumps ( qs ) query = qs . query . get_compiler ( qs . db ) . as_sql ( ) [ 0 ] qs2 = pickle . loads ( pickle . dumps ( qs ) ) self . assertEqual ( qs2 . query . get_compiler ( qs2 . db ) . as_sql ( ) [ 0 ] , query , ) def test_more_more_more ( self ) : books = Book . objects . all ( ) books . aggregate ( Avg ( "authors__age" ) ) self . assertQuerysetEqual ( books . all ( ) , [ , , , , , ] , lambda b : b . name ) qs = Book . objects . annotate ( num_authors = Count ( 'authors' ) ) . filter ( num_authors = 2 ) . dates ( 'pubdate' , 'day' ) self . assertQuerysetEqual ( qs , [ datetime . datetime ( 1995 , 1 , 15 , 0 , 0 ) , datetime . datetime ( 2007 , 12 , 6 , 0 , 0 ) ] , lambda b : b ) qs = Book . objects . annotate ( mean_auth_age = Avg ( 'authors__age' ) ) . extra ( select = { 'sheets' : '(pages + %s) / %s' } , select_params = [ 1 , 2 ] ) . order_by ( 'sheets' ) . values ( 'sheets' ) self . assertQuerysetEqual ( qs , [ 150 , 175 , 224 , 264 , 473 , 566 ] , lambda b : int ( b [ "sheets" ] ) ) self . assertEqual ( Book . objects . values ( 'publisher' ) . annotate ( Count ( 'publisher' ) ) . count ( ) , 4 ) self . assertEqual ( Book . objects . annotate ( Count ( 'publisher' ) ) . values ( 'publisher' ) . count ( ) , 6 ) publishers = Publisher . objects . filter ( id__in = [ 1 , 2 ] ) self . assertEqual ( sorted ( p . name for p in publishers ) , [ , ] ) publishers = publishers . annotate ( n_books = Count ( "book" ) ) self . assertEqual ( publishers [ 0 ] . n_books , 2 ) self . assertEqual ( sorted ( p . name for p in publishers ) , [ , ] ) books = Book . objects . filter ( publisher__in = publishers ) self . assertQuerysetEqual ( books , [ , , , ] , lambda b : b . name ) self . assertEqual ( sorted ( p . name for p in publishers ) , [ , ] ) self . assertEqual ( HardbackBook . objects . aggregate ( n_pages = Sum ( 'book_ptr__pages' ) ) , { 'n_pages' : 2078 } ) self . assertEqual ( HardbackBook . objects . aggregate ( n_pages = Sum ( 'pages' ) ) , { 'n_pages' : 2078 } , ) qs = HardbackBook . objects . annotate ( n_authors = Count ( 'book_ptr__authors' ) ) . values ( 'name' , 'n_authors' ) self . assertQuerysetEqual ( qs , [ { 'n_authors' : 2 , 'name' : u'Artificial Intelligence: A Modern Approach' } , { 'n_authors' : 1 , 'name' : u'Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp' } ] , lambda h : h ) qs = HardbackBook . objects . annotate ( n_authors = Count ( 'authors' ) ) . values ( 'name' , 'n_authors' ) self . assertQuerysetEqual ( qs , [ { 'n_authors' : 2 , 'name' : u'Artificial Intelligence: A Modern Approach' } , { 'n_authors' : 1 , 'name' : u'Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp' } ] , lambda h : h , ) self . assertRaises ( FieldError , lambda : Book . objects . annotate ( mean_age = Avg ( 'authors__age' ) ) . annotate ( Avg ( 'mean_age' ) ) ) def test_empty_filter_count ( self ) : self . assertEqual ( Author . objects . filter ( id__in = [ ] ) . annotate ( Count ( "friends" ) ) . count ( ) , 0 ) def test_empty_filter_aggregate ( self ) : self . assertEqual ( Author . objects . filter ( id__in = [ ] ) . annotate ( Count ( "friends" ) ) . aggregate ( Count ( "pk" ) ) , { "pk__count" : None } ) def test_none_call_before_aggregate ( self ) : self . assertEqual ( Author . objects . none ( ) . aggregate ( Avg ( 'age' ) ) , { 'age__avg' : None } ) def test_annotate_and_join ( self ) : self . assertEqual ( Author . objects . annotate ( c = Count ( "friends__name" ) ) . exclude ( friends__name = "Joe" ) . count ( ) , Author . objects . count ( ) ) def test_f_expression_annotation ( self ) : qs = Book . objects . values ( "name" ) . annotate ( n_authors = Count ( "authors" ) ) . filter ( pages__lt = F ( "n_authors" ) * 200 ) . values_list ( "pk" ) self . assertQuerysetEqual ( Book . objects . filter ( pk__in = qs ) , [ ] , attrgetter ( "name" ) ) def test_values_annotate_values ( self ) : qs = Book . objects . values ( "name" ) . annotate ( n_authors = Count ( "authors" ) ) . values_list ( "pk" , flat = True ) self . assertEqual ( list ( qs ) , list ( Book . objects . values_list ( "pk" , flat = True ) ) ) def test_having_group_by ( self ) : qs = Book . objects . values_list ( "name" ) . annotate ( n_authors = Count ( "authors" ) ) . filter ( pages__gt = F ( "n_authors" ) ) . values_list ( "name" , flat = True ) self . assertEqual ( list ( qs ) , list ( Book . objects . values_list ( "name" , flat = True ) ) ) def test_annotation_disjunction ( self ) : qs = Book . objects . annotate ( n_authors = Count ( "authors" ) ) . filter ( Q ( n_authors = 2 ) | Q ( name = "Python Web Development with Django" ) ) self . assertQuerysetEqual ( qs , [ , , , ] , attrgetter ( "name" ) ) qs = Book . objects . annotate ( n_authors = Count ( "authors" ) ) . filter ( Q ( name = "The Definitive Guide to Django: Web Development Done Right" ) | ( Q ( name = "Artificial Intelligence: A Modern Approach" ) & Q ( n_authors = 3 ) ) ) self . assertQuerysetEqual ( qs , [ , ] , attrgetter ( "name" ) ) qs = Publisher . objects . annotate ( rating_sum = Sum ( "book__rating" ) , book_count = Count ( "book" ) ) . filter ( Q ( rating_sum__gt = 5.5 ) | Q ( rating_sum__isnull = True ) ) . order_by ( 'pk' ) self . assertQuerysetEqual ( qs , [ , , , ] , attrgetter ( "name" ) ) qs = Publisher . objects . annotate ( rating_sum = Sum ( "book__rating" ) , book_count = Count ( "book" ) ) . filter ( Q ( pk__lt = F ( "book_count" ) ) | Q ( rating_sum = None ) ) . order_by ( "pk" ) self . assertQuerysetEqual ( qs , [ , , ] , attrgetter ( "name" ) ) def test_quoting_aggregate_order_by ( self ) : qs = Book . objects . filter ( name = "Python Web Development with Django" ) . annotate ( authorCount = Count ( "authors" ) ) . order_by ( "authorCount" ) self . assertQuerysetEqual ( qs , [ ( "Python Web Development with Django" , 3 ) , ] , lambda b : ( b . name , b . authorCount ) ) @ skipUnlessDBFeature ( 'supports_stddev' ) def test_stddev ( self ) : self . assertEqual ( Book . objects . aggregate ( StdDev ( 'pages' ) ) , { 'pages__stddev' : Approximate ( 311.46 , 1 ) } ) self . assertEqual ( Book . objects . aggregate ( StdDev ( 'rating' ) ) , { 'rating__stddev' : Approximate ( 0.60 , 1 ) } ) self . assertEqual ( Book . objects . aggregate ( StdDev ( 'price' ) ) , { 'price__stddev' : Approximate ( 24.16 , 2 ) } ) self . assertEqual ( Book . objects . aggregate ( StdDev ( 'pages' , sample = True ) ) , { 'pages__stddev' : Approximate ( 341.19 , 2 ) } ) self . assertEqual ( Book . objects . aggregate ( StdDev ( 'rating' , sample = True ) ) , { 'rating__stddev' : Approximate ( 0.66 , 2 ) } ) self . assertEqual ( Book . objects . aggregate ( StdDev ( 'price' , sample = True ) ) , { 'price__stddev' : Approximate ( 26.46 , 1 ) } ) self . assertEqual ( Book . objects . aggregate ( Variance ( 'pages' ) ) , { 'pages__variance' : Approximate ( 97010.80 , 1 ) } ) self . assertEqual ( Book . objects . aggregate ( Variance ( 'rating' ) ) , { 'rating__variance' : Approximate ( 0.36 , 1 ) } ) self . assertEqual ( Book . objects . aggregate ( Variance ( 'price' ) ) , { 'price__variance' : Approximate ( 583.77 , 1 ) } ) self . assertEqual ( Book . objects . aggregate ( Variance ( 'pages' , sample = True ) ) , { 'pages__variance' : Approximate ( 116412.96 , 1 ) } ) self . assertEqual ( Book . objects . aggregate ( Variance ( 'rating' , sample = True ) ) , { 'rating__variance' : Approximate ( 0.44 , 2 ) } ) self . assertEqual ( Book . objects . aggregate ( Variance ( 'price' , sample = True ) ) , { 'price__variance' : Approximate ( 700.53 , 2 ) } ) def test_filtering_by_annotation_name ( self ) : qs = Author . objects . annotate ( book_cnt = Count ( 'book' ) ) . filter ( book_cnt = 2 ) self . assertQuerysetEqual ( qs , [ 'Peter Norvig' ] , lambda b : b . name ) qs = Author . objects . annotate ( book_count = Count ( 'book' ) ) . filter ( book_count = 2 ) self . assertQuerysetEqual ( qs , [ 'Peter Norvig' ] , lambda b : b . name ) qs = Author . objects . annotate ( Count ( 'book' ) ) . filter ( book__count = 2 ) self . assertQuerysetEqual ( qs , [ 'Peter Norvig' ] , lambda b : b . name )

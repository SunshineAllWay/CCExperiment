from ctypes import c_uint , byref from django . contrib . gis . geos . geometry import GEOSGeometry from django . contrib . gis . geos . libgeos import get_pointer_arr , GEOM_PTR from django . contrib . gis . geos . linestring import LinearRing from django . contrib . gis . geos import prototypes as capi class Polygon ( GEOSGeometry ) : _minlength = 1 def __init__ ( self , * args , ** kwargs ) : if not args : raise TypeError ( 'Must provide at least one LinearRing, or a tuple, to initialize a Polygon.' ) ext_ring = args [ 0 ] init_holes = args [ 1 : ] n_holes = len ( init_holes ) if n_holes == 1 and isinstance ( init_holes [ 0 ] , ( tuple , list ) ) : if len ( init_holes [ 0 ] ) == 0 : init_holes = ( ) n_holes = 0 elif isinstance ( init_holes [ 0 ] [ 0 ] , LinearRing ) : init_holes = init_holes [ 0 ] n_holes = len ( init_holes ) polygon = self . _create_polygon ( n_holes + 1 , ( ext_ring , ) + init_holes ) super ( Polygon , self ) . __init__ ( polygon , ** kwargs ) def __iter__ ( self ) : for i in xrange ( len ( self ) ) : yield self [ i ] def __len__ ( self ) : return self . num_interior_rings + 1 @ classmethod def from_bbox ( cls , bbox ) : x0 , y0 , x1 , y1 = bbox return GEOSGeometry ( 'POLYGON((%s %s, %s %s, %s %s, %s %s, %s %s))' % ( x0 , y0 , x0 , y1 , x1 , y1 , x1 , y0 , x0 , y0 ) ) def _create_polygon ( self , length , items ) : rings = [ ] for r in items : if isinstance ( r , GEOM_PTR ) : rings . append ( r ) else : rings . append ( self . _construct_ring ( r ) ) shell = self . _clone ( rings . pop ( 0 ) ) n_holes = length - 1 if n_holes : holes = get_pointer_arr ( n_holes ) for i , r in enumerate ( rings ) : holes [ i ] = self . _clone ( r ) holes_param = byref ( holes ) else : holes_param = None return capi . create_polygon ( shell , holes_param , c_uint ( n_holes ) ) def _clone ( self , g ) : if isinstance ( g , GEOM_PTR ) : return capi . geom_clone ( g ) else : return capi . geom_clone ( g . ptr ) def _construct_ring ( self , param , msg = 'Parameter must be a sequence of LinearRings or objects that can initialize to LinearRings' ) : if isinstance ( param , LinearRing ) : return param try : ring = LinearRing ( param ) return ring except TypeError : raise TypeError ( msg ) def _set_list ( self , length , items ) : prev_ptr = self . ptr srid = self . srid self . ptr = self . _create_polygon ( length , items ) if srid : self . srid = srid capi . destroy_geom ( prev_ptr ) def _get_single_internal ( self , index ) : if index == 0 : return capi . get_extring ( self . ptr ) else : return capi . get_intring ( self . ptr , index - 1 ) def _get_single_external ( self , index ) : return GEOSGeometry ( capi . geom_clone ( self . _get_single_internal ( index ) ) , srid = self . srid ) _set_single = GEOSGeometry . _set_single_rebuild _assign_extended_slice = GEOSGeometry . _assign_extended_slice_rebuild @ property def num_interior_rings ( self ) : return capi . get_nrings ( self . ptr ) def _get_ext_ring ( self ) : return self [ 0 ] def _set_ext_ring ( self , ring ) : self [ 0 ] = ring exterior_ring = property ( _get_ext_ring , _set_ext_ring ) shell = exterior_ring @ property def tuple ( self ) : return tuple ( [ self [ i ] . tuple for i in xrange ( len ( self ) ) ] ) coords = tuple @ property def kml ( self ) : inner_kml = '' . join ( [ "<innerBoundaryIs>%s</innerBoundaryIs>" % self [ i + 1 ] . kml for i in xrange ( self . num_interior_rings ) ] ) return "<Polygon><outerBoundaryIs>%s</outerBoundaryIs>%s</Polygon>" % ( self [ 0 ] . kml , inner_kml )

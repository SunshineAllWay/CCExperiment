import math import timeit import hashlib from django . utils import unittest from django . utils . crypto import pbkdf2 class TestUtilsCryptoPBKDF2 ( unittest . TestCase ) : rfc_vectors = [ { : { : "password" , : "salt" , : 1 , : 20 , : hashlib . sha1 , } , : "0c60c80f961f0e71f3a9b524af6012062fe037a6" , } , { : { : "password" , : "salt" , : 2 , : 20 , : hashlib . sha1 , } , : "ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957" , } , { : { : "password" , : "salt" , : 4096 , : 20 , : hashlib . sha1 , } , : "4b007901b765489abead49d926f721d065a429c1" , } , { : { : "passwordPASSWORDpassword" , : "saltSALTsaltSALTsaltSALTsaltSALTsalt" , : 4096 , : 25 , : hashlib . sha1 , } , : "3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038" , } , { : { : "pass\0word" , : "sa\0lt" , : 4096 , : 16 , : hashlib . sha1 , } , : "56fa6aa75548099dcc37d7f03425e0c3" , } , ] regression_vectors = [ { : { : "password" , : "salt" , : 1 , : 20 , : hashlib . sha256 , } , : "120fb6cffcf8b32c43e7225256c4f837a86548c9" , } , { : { : "password" , : "salt" , : 1 , : 20 , : hashlib . sha512 , } , : "867f70cf1ade02cff3752599a3a53dc4af34c7a6" , } , { : { : "password" , : "salt" , : 1000 , : 0 , : hashlib . sha512 , } , : ( "afe6c5530785b6cc6b1c6453384731bd5ee432ee" ) , } , { : { : chr ( 186 ) , : "salt" , : 1 , : 20 , : hashlib . sha1 , } , : '0053d3b91a7f1e54effebd6d68771e8a6e0b2c5b' , } , ] def test_public_vectors ( self ) : for vector in self . rfc_vectors : result = pbkdf2 ( ** vector [ 'args' ] ) self . assertEqual ( result . encode ( 'hex' ) , vector [ 'result' ] ) def test_regression_vectors ( self ) : for vector in self . regression_vectors : result = pbkdf2 ( ** vector [ 'args' ] ) self . assertEqual ( result . encode ( 'hex' ) , vector [ 'result' ] ) def test_performance_scalability ( self ) : n1 , n2 = 200000 , 800000 elapsed = lambda f : timeit . Timer ( f , ) . timeit ( number = 1 ) t1 = elapsed ( 'pbkdf2("password", "salt", iterations=%d)' % n1 ) t2 = elapsed ( 'pbkdf2("password", "salt", iterations=%d)' % n2 ) measured_scale_exponent = math . log ( t2 / t1 , n2 / n1 ) self . assertLess ( measured_scale_exponent , 1.2 )

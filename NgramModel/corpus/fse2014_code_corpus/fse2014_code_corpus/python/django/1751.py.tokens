from itertools import izip from django . db . backends . util import truncate_name , typecast_timestamp from django . db . models . sql import compiler from django . db . models . sql . constants import TABLE_NAME , MULTI from django . db . models . sql . query import get_proxied_model SQLCompiler = compiler . SQLCompiler class GeoSQLCompiler ( compiler . SQLCompiler ) : def get_columns ( self , with_aliases = False ) : qn = self . quote_name_unless_alias qn2 = self . connection . ops . quote_name result = [ '(%s) AS %s' % ( self . get_extra_select_format ( alias ) % col [ 0 ] , qn2 ( alias ) ) for alias , col in self . query . extra_select . iteritems ( ) ] aliases = set ( self . query . extra_select . keys ( ) ) if with_aliases : col_aliases = aliases . copy ( ) else : col_aliases = set ( ) if self . query . select : only_load = self . deferred_to_columns ( ) for col , field in izip ( self . query . select , self . query . select_fields ) : if isinstance ( col , ( list , tuple ) ) : alias , column = col table = self . query . alias_map [ alias ] [ TABLE_NAME ] if table in only_load and column not in only_load [ table ] : continue r = self . get_field_select ( field , alias , column ) if with_aliases : if col [ 1 ] in col_aliases : c_alias = 'Col%d' % len ( col_aliases ) result . append ( '%s AS %s' % ( r , c_alias ) ) aliases . add ( c_alias ) col_aliases . add ( c_alias ) else : result . append ( '%s AS %s' % ( r , qn2 ( col [ 1 ] ) ) ) aliases . add ( r ) col_aliases . add ( col [ 1 ] ) else : result . append ( r ) aliases . add ( r ) col_aliases . add ( col [ 1 ] ) else : result . append ( col . as_sql ( qn , self . connection ) ) if hasattr ( col , 'alias' ) : aliases . add ( col . alias ) col_aliases . add ( col . alias ) elif self . query . default_cols : cols , new_aliases = self . get_default_columns ( with_aliases , col_aliases ) result . extend ( cols ) aliases . update ( new_aliases ) max_name_length = self . connection . ops . max_name_length ( ) result . extend ( [ % ( self . get_extra_select_format ( alias ) % aggregate . as_sql ( qn , self . connection ) , alias is not None and ' AS %s' % qn ( truncate_name ( alias , max_name_length ) ) or '' ) for alias , aggregate in self . query . aggregate_select . items ( ) ] ) for ( table , col ) , field in izip ( self . query . related_select_cols , self . query . related_select_fields ) : r = self . get_field_select ( field , table , col ) if with_aliases and col in col_aliases : c_alias = 'Col%d' % len ( col_aliases ) result . append ( '%s AS %s' % ( r , c_alias ) ) aliases . add ( c_alias ) col_aliases . add ( c_alias ) else : result . append ( r ) aliases . add ( r ) col_aliases . add ( col ) self . _select_aliases = aliases return result def get_default_columns ( self , with_aliases = False , col_aliases = None , start_alias = None , opts = None , as_pairs = False , local_only = False ) : result = [ ] if opts is None : opts = self . query . model . _meta aliases = set ( ) only_load = self . deferred_to_columns ( ) proxied_model = get_proxied_model ( opts ) if start_alias : seen = { None : start_alias } for field , model in opts . get_fields_with_model ( ) : if local_only and model is not None : continue if start_alias : try : alias = seen [ model ] except KeyError : if model is proxied_model : alias = start_alias else : link_field = opts . get_ancestor_link ( model ) alias = self . query . join ( ( start_alias , model . _meta . db_table , link_field . column , model . _meta . pk . column ) ) seen [ model ] = alias else : alias = self . query . included_inherited_models [ model ] table = self . query . alias_map [ alias ] [ TABLE_NAME ] if table in only_load and field . column not in only_load [ table ] : continue if as_pairs : result . append ( ( alias , field . column ) ) aliases . add ( alias ) continue field_sel = self . get_field_select ( field , alias ) if with_aliases and field . column in col_aliases : c_alias = 'Col%d' % len ( col_aliases ) result . append ( '%s AS %s' % ( field_sel , c_alias ) ) col_aliases . add ( c_alias ) aliases . add ( c_alias ) else : r = field_sel result . append ( r ) aliases . add ( r ) if with_aliases : col_aliases . add ( field . column ) return result , aliases def resolve_columns ( self , row , fields = ( ) ) : values = [ ] aliases = self . query . extra_select . keys ( ) rn_offset = 0 if self . connection . ops . oracle : if self . query . high_mark is not None or self . query . low_mark : rn_offset = 1 index_start = rn_offset + len ( aliases ) values = [ self . query . convert_values ( v , self . query . extra_select_fields . get ( a , None ) , self . connection ) for v , a in izip ( row [ rn_offset : index_start ] , aliases ) ] if self . connection . ops . oracle or getattr ( self . query , 'geo_values' , False ) : for value , field in map ( None , row [ index_start : ] , fields ) : values . append ( self . query . convert_values ( value , field , self . connection ) ) else : values . extend ( row [ index_start : ] ) return tuple ( values ) def get_extra_select_format ( self , alias ) : sel_fmt = '%s' if hasattr ( self . query , 'custom_select' ) and alias in self . query . custom_select : sel_fmt = sel_fmt % self . query . custom_select [ alias ] return sel_fmt def get_field_select ( self , field , alias = None , column = None ) : sel_fmt = self . get_select_format ( field ) if field in self . query . custom_select : field_sel = sel_fmt % self . query . custom_select [ field ] else : field_sel = sel_fmt % self . _field_column ( field , alias , column ) return field_sel def get_select_format ( self , fld ) : if self . connection . ops . select and hasattr ( fld , 'geom_type' ) : sel_fmt = self . connection . ops . select if self . query . transformed_srid and ( self . connection . ops . oracle or self . connection . ops . spatialite ) : sel_fmt = "'SRID=%d;'||%s" % ( self . query . transformed_srid , sel_fmt ) else : sel_fmt = '%s' return sel_fmt def _field_column ( self , field , table_alias = None , column = None ) : if table_alias is None : table_alias = self . query . model . _meta . db_table return "%s.%s" % ( self . quote_name_unless_alias ( table_alias ) , self . connection . ops . quote_name ( column or field . column ) ) class SQLInsertCompiler ( compiler . SQLInsertCompiler , GeoSQLCompiler ) : pass class SQLDeleteCompiler ( compiler . SQLDeleteCompiler , GeoSQLCompiler ) : pass class SQLUpdateCompiler ( compiler . SQLUpdateCompiler , GeoSQLCompiler ) : pass class SQLAggregateCompiler ( compiler . SQLAggregateCompiler , GeoSQLCompiler ) : pass class SQLDateCompiler ( compiler . SQLDateCompiler , GeoSQLCompiler ) : def results_iter ( self ) : if self . connection . ops . oracle : from django . db . models . fields import DateTimeField fields = [ DateTimeField ( ) ] else : needs_string_cast = self . connection . features . needs_datetime_string_cast offset = len ( self . query . extra_select ) for rows in self . execute_sql ( MULTI ) : for row in rows : date = row [ offset ] if self . connection . ops . oracle : date = self . resolve_columns ( row , fields ) [ offset ] elif needs_string_cast : date = typecast_timestamp ( str ( date ) ) yield date

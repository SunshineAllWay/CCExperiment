import mimetypes import os import random import time from email import charset as Charset , encoders as Encoders from email . generator import Generator from email . mime . text import MIMEText from email . mime . multipart import MIMEMultipart from email . mime . base import MIMEBase from email . header import Header from email . utils import formatdate , getaddresses , formataddr , parseaddr from django . conf import settings from django . core . mail . utils import DNS_NAME from django . utils . encoding import smart_str , force_unicode try : from cStringIO import StringIO except ImportError : from StringIO import StringIO Charset . add_charset ( 'utf-8' , Charset . SHORTEST , None , 'utf-8' ) DEFAULT_ATTACHMENT_MIME_TYPE = 'application/octet-stream' class BadHeaderError ( ValueError ) : pass def make_msgid ( idstring = None ) : timeval = time . time ( ) utcdate = time . strftime ( '%Y%m%d%H%M%S' , time . gmtime ( timeval ) ) try : pid = os . getpid ( ) except AttributeError : pid = 1 randint = random . randrange ( 100000 ) if idstring is None : idstring = '' else : idstring = '.' + idstring idhost = DNS_NAME msgid = '<%s.%s.%s%s@%s>' % ( utcdate , pid , randint , idstring , idhost ) return msgid ADDRESS_HEADERS = set ( [ , , , , , , , , , , , ] ) def forbid_multi_line_headers ( name , val , encoding ) : encoding = encoding or settings . DEFAULT_CHARSET val = force_unicode ( val ) if '\n' in val or '\r' in val : raise BadHeaderError ( "Header values can't contain newlines (got %r for header %r)" % ( val , name ) ) try : val = val . encode ( 'ascii' ) except UnicodeEncodeError : if name . lower ( ) in ADDRESS_HEADERS : val = ', ' . join ( sanitize_address ( addr , encoding ) for addr in getaddresses ( ( val , ) ) ) else : val = str ( Header ( val , encoding ) ) else : if name . lower ( ) == 'subject' : val = Header ( val ) return name , val def sanitize_address ( addr , encoding ) : if isinstance ( addr , basestring ) : addr = parseaddr ( force_unicode ( addr ) ) nm , addr = addr nm = str ( Header ( nm , encoding ) ) try : addr = addr . encode ( 'ascii' ) except UnicodeEncodeError : if u'@' in addr : localpart , domain = addr . split ( u'@' , 1 ) localpart = str ( Header ( localpart , encoding ) ) domain = domain . encode ( 'idna' ) addr = '@' . join ( [ localpart , domain ] ) else : addr = str ( Header ( addr , encoding ) ) return formataddr ( ( nm , addr ) ) class SafeMIMEText ( MIMEText ) : def __init__ ( self , text , subtype , charset ) : self . encoding = charset MIMEText . __init__ ( self , text , subtype , charset ) def __setitem__ ( self , name , val ) : name , val = forbid_multi_line_headers ( name , val , self . encoding ) MIMEText . __setitem__ ( self , name , val ) def as_string ( self , unixfrom = False ) : fp = StringIO ( ) g = Generator ( fp , mangle_from_ = False ) g . flatten ( self , unixfrom = unixfrom ) return fp . getvalue ( ) class SafeMIMEMultipart ( MIMEMultipart ) : def __init__ ( self , _subtype = 'mixed' , boundary = None , _subparts = None , encoding = None , ** _params ) : self . encoding = encoding MIMEMultipart . __init__ ( self , _subtype , boundary , _subparts , ** _params ) def __setitem__ ( self , name , val ) : name , val = forbid_multi_line_headers ( name , val , self . encoding ) MIMEMultipart . __setitem__ ( self , name , val ) def as_string ( self , unixfrom = False ) : fp = StringIO ( ) g = Generator ( fp , mangle_from_ = False ) g . flatten ( self , unixfrom = unixfrom ) return fp . getvalue ( ) class EmailMessage ( object ) : content_subtype = 'plain' mixed_subtype = 'mixed' encoding = None def __init__ ( self , subject = '' , body = '' , from_email = None , to = None , bcc = None , connection = None , attachments = None , headers = None , cc = None ) : if to : assert not isinstance ( to , basestring ) , '"to" argument must be a list or tuple' self . to = list ( to ) else : self . to = [ ] if cc : assert not isinstance ( cc , basestring ) , '"cc" argument must be a list or tuple' self . cc = list ( cc ) else : self . cc = [ ] if bcc : assert not isinstance ( bcc , basestring ) , '"bcc" argument must be a list or tuple' self . bcc = list ( bcc ) else : self . bcc = [ ] self . from_email = from_email or settings . DEFAULT_FROM_EMAIL self . subject = subject self . body = body self . attachments = attachments or [ ] self . extra_headers = headers or { } self . connection = connection def get_connection ( self , fail_silently = False ) : from django . core . mail import get_connection if not self . connection : self . connection = get_connection ( fail_silently = fail_silently ) return self . connection def message ( self ) : encoding = self . encoding or settings . DEFAULT_CHARSET msg = SafeMIMEText ( smart_str ( self . body , encoding ) , self . content_subtype , encoding ) msg = self . _create_message ( msg ) msg [ 'Subject' ] = self . subject msg [ 'From' ] = self . extra_headers . get ( 'From' , self . from_email ) msg [ 'To' ] = self . extra_headers . get ( 'To' , ', ' . join ( self . to ) ) if self . cc : msg [ 'Cc' ] = ', ' . join ( self . cc ) header_names = [ key . lower ( ) for key in self . extra_headers ] if 'date' not in header_names : msg [ 'Date' ] = formatdate ( ) if 'message-id' not in header_names : msg [ 'Message-ID' ] = make_msgid ( ) for name , value in self . extra_headers . items ( ) : if name . lower ( ) in ( 'from' , 'to' ) : continue msg [ name ] = value return msg def recipients ( self ) : return self . to + self . cc + self . bcc def send ( self , fail_silently = False ) : if not self . recipients ( ) : return 0 return self . get_connection ( fail_silently ) . send_messages ( [ self ] ) def attach ( self , filename = None , content = None , mimetype = None ) : if isinstance ( filename , MIMEBase ) : assert content == mimetype == None self . attachments . append ( filename ) else : assert content is not None self . attachments . append ( ( filename , content , mimetype ) ) def attach_file ( self , path , mimetype = None ) : filename = os . path . basename ( path ) content = open ( path , 'rb' ) . read ( ) self . attach ( filename , content , mimetype ) def _create_message ( self , msg ) : return self . _create_attachments ( msg ) def _create_attachments ( self , msg ) : if self . attachments : encoding = self . encoding or settings . DEFAULT_CHARSET body_msg = msg msg = SafeMIMEMultipart ( _subtype = self . mixed_subtype , encoding = encoding ) if self . body : msg . attach ( body_msg ) for attachment in self . attachments : if isinstance ( attachment , MIMEBase ) : msg . attach ( attachment ) else : msg . attach ( self . _create_attachment ( * attachment ) ) return msg def _create_mime_attachment ( self , content , mimetype ) : basetype , subtype = mimetype . split ( '/' , 1 ) if basetype == 'text' : encoding = self . encoding or settings . DEFAULT_CHARSET attachment = SafeMIMEText ( smart_str ( content , encoding ) , subtype , encoding ) else : attachment = MIMEBase ( basetype , subtype ) attachment . set_payload ( content ) Encoders . encode_base64 ( attachment ) return attachment def _create_attachment ( self , filename , content , mimetype = None ) : if mimetype is None : mimetype , _ = mimetypes . guess_type ( filename ) if mimetype is None : mimetype = DEFAULT_ATTACHMENT_MIME_TYPE attachment = self . _create_mime_attachment ( content , mimetype ) if filename : try : filename = filename . encode ( 'ascii' ) except UnicodeEncodeError : filename = ( 'utf-8' , '' , filename . encode ( 'utf-8' ) ) attachment . add_header ( 'Content-Disposition' , 'attachment' , filename = filename ) return attachment class EmailMultiAlternatives ( EmailMessage ) : alternative_subtype = 'alternative' def __init__ ( self , subject = '' , body = '' , from_email = None , to = None , bcc = None , connection = None , attachments = None , headers = None , alternatives = None , cc = None ) : super ( EmailMultiAlternatives , self ) . __init__ ( subject , body , from_email , to , bcc , connection , attachments , headers , cc ) self . alternatives = alternatives or [ ] def attach_alternative ( self , content , mimetype ) : assert content is not None assert mimetype is not None self . alternatives . append ( ( content , mimetype ) ) def _create_message ( self , msg ) : return self . _create_attachments ( self . _create_alternatives ( msg ) ) def _create_alternatives ( self , msg ) : encoding = self . encoding or settings . DEFAULT_CHARSET if self . alternatives : body_msg = msg msg = SafeMIMEMultipart ( _subtype = self . alternative_subtype , encoding = encoding ) if self . body : msg . attach ( body_msg ) for alternative in self . alternatives : msg . attach ( self . _create_mime_attachment ( * alternative ) ) return msg

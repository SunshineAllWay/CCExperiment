import datetime from django . contrib . admin . util import lookup_field , display_for_field , label_for_field from django . contrib . admin . views . main import ( ALL_VAR , EMPTY_CHANGELIST_VALUE , ORDER_VAR , PAGE_VAR , SEARCH_VAR ) from django . contrib . admin . templatetags . admin_static import static from django . core . exceptions import ObjectDoesNotExist from django . db import models from django . utils import formats from django . utils . html import escape , conditional_escape from django . utils . safestring import mark_safe from django . utils . text import capfirst from django . utils . translation import ugettext as _ from django . utils . encoding import smart_unicode , force_unicode from django . template import Library from django . template . loader import get_template from django . template . context import Context register = Library ( ) DOT = '.' @ register . simple_tag def paginator_number ( cl , i ) : if i == DOT : return u'... ' elif i == cl . page_num : return mark_safe ( u'<span class="this-page">%d</span> ' % ( i + 1 ) ) else : return mark_safe ( u'<a href="%s"%s>%d</a> ' % ( escape ( cl . get_query_string ( { PAGE_VAR : i } ) ) , ( i == cl . paginator . num_pages - 1 and ' class="end"' or '' ) , i + 1 ) ) @ register . inclusion_tag ( 'admin/pagination.html' ) def pagination ( cl ) : paginator , page_num = cl . paginator , cl . page_num pagination_required = ( not cl . show_all or not cl . can_show_all ) and cl . multi_page if not pagination_required : page_range = [ ] else : ON_EACH_SIDE = 3 ON_ENDS = 2 if paginator . num_pages <= 10 : page_range = range ( paginator . num_pages ) else : page_range = [ ] if page_num > ( ON_EACH_SIDE + ON_ENDS ) : page_range . extend ( range ( 0 , ON_EACH_SIDE - 1 ) ) page_range . append ( DOT ) page_range . extend ( range ( page_num - ON_EACH_SIDE , page_num + 1 ) ) else : page_range . extend ( range ( 0 , page_num + 1 ) ) if page_num < ( paginator . num_pages - ON_EACH_SIDE - ON_ENDS - 1 ) : page_range . extend ( range ( page_num + 1 , page_num + ON_EACH_SIDE + 1 ) ) page_range . append ( DOT ) page_range . extend ( range ( paginator . num_pages - ON_ENDS , paginator . num_pages ) ) else : page_range . extend ( range ( page_num + 1 , paginator . num_pages ) ) need_show_all_link = cl . can_show_all and not cl . show_all and cl . multi_page return { : cl , : pagination_required , : need_show_all_link and cl . get_query_string ( { ALL_VAR : '' } ) , : page_range , : ALL_VAR , : 1 , } def result_headers ( cl ) : ordering_field_columns = cl . get_ordering_field_columns ( ) for i , field_name in enumerate ( cl . list_display ) : text , attr = label_for_field ( field_name , cl . model , model_admin = cl . model_admin , return_attr = True ) if attr : if field_name == 'action_checkbox' : yield { : text , : mark_safe ( ' class="action-checkbox-column"' ) , : False , } continue admin_order_field = getattr ( attr , "admin_order_field" , None ) if not admin_order_field : yield { : text , : False , } continue th_classes = [ 'sortable' ] order_type = '' new_order_type = 'asc' sort_priority = 0 sorted = False if i in ordering_field_columns : sorted = True order_type = ordering_field_columns . get ( i ) . lower ( ) sort_priority = ordering_field_columns . keys ( ) . index ( i ) + 1 th_classes . append ( 'sorted %sending' % order_type ) new_order_type = { 'asc' : 'desc' , 'desc' : 'asc' } [ order_type ] o_list_primary = [ ] o_list_remove = [ ] o_list_toggle = [ ] make_qs_param = lambda t , n : ( '-' if t == 'desc' else '' ) + str ( n ) for j , ot in ordering_field_columns . items ( ) : if j == i : param = make_qs_param ( new_order_type , j ) o_list_primary . insert ( 0 , param ) o_list_toggle . append ( param ) else : param = make_qs_param ( ot , j ) o_list_primary . append ( param ) o_list_toggle . append ( param ) o_list_remove . append ( param ) if i not in ordering_field_columns : o_list_primary . insert ( 0 , make_qs_param ( new_order_type , i ) ) yield { : text , : True , : sorted , : order_type == "asc" , : sort_priority , : cl . get_query_string ( { ORDER_VAR : '.' . join ( o_list_primary ) } ) , : cl . get_query_string ( { ORDER_VAR : '.' . join ( o_list_remove ) } ) , : cl . get_query_string ( { ORDER_VAR : '.' . join ( o_list_toggle ) } ) , : mark_safe ( th_classes and ' class="%s"' % ' ' . join ( th_classes ) or '' ) } def _boolean_icon ( field_val ) : icon_url = static ( 'admin/img/icon-%s.gif' % { True : 'yes' , False : 'no' , None : 'unknown' } [ field_val ] ) return mark_safe ( u'<img src="%s" alt="%s" />' % ( icon_url , field_val ) ) def items_for_result ( cl , result , form ) : first = True pk = cl . lookup_opts . pk . attname for field_name in cl . list_display : row_class = '' try : f , attr , value = lookup_field ( field_name , result , cl . model_admin ) except ( AttributeError , ObjectDoesNotExist ) : result_repr = EMPTY_CHANGELIST_VALUE else : if f is None : if field_name == u'action_checkbox' : row_class = ' class="action-checkbox"' allow_tags = getattr ( attr , 'allow_tags' , False ) boolean = getattr ( attr , 'boolean' , False ) if boolean : allow_tags = True result_repr = _boolean_icon ( value ) else : result_repr = smart_unicode ( value ) if not allow_tags : result_repr = escape ( result_repr ) else : result_repr = mark_safe ( result_repr ) else : if isinstance ( f . rel , models . ManyToOneRel ) : field_val = getattr ( result , f . name ) if field_val is None : result_repr = EMPTY_CHANGELIST_VALUE else : result_repr = escape ( field_val ) else : result_repr = display_for_field ( value , f ) if isinstance ( f , models . DateField ) or isinstance ( f , models . TimeField ) or isinstance ( f , models . ForeignKey ) : row_class = ' class="nowrap"' if force_unicode ( result_repr ) == '' : result_repr = mark_safe ( '&nbsp;' ) if ( first and not cl . list_display_links ) or field_name in cl . list_display_links : table_tag = { True : 'th' , False : 'td' } [ first ] first = False url = cl . url_for_result ( result ) if cl . to_field : attr = str ( cl . to_field ) else : attr = pk value = result . serializable_value ( attr ) result_id = repr ( force_unicode ( value ) ) [ 1 : ] yield mark_safe ( u'<%s%s><a href="%s"%s>%s</a></%s>' % ( table_tag , row_class , url , ( cl . is_popup and ' onclick="opener.dismissRelatedLookupPopup(window, %s); return false;"' % result_id or '' ) , conditional_escape ( result_repr ) , table_tag ) ) else : if ( form and field_name in form . fields and not ( field_name == cl . model . _meta . pk . name and form [ cl . model . _meta . pk . name ] . is_hidden ) ) : bf = form [ field_name ] result_repr = mark_safe ( force_unicode ( bf . errors ) + force_unicode ( bf ) ) else : result_repr = conditional_escape ( result_repr ) yield mark_safe ( u'<td%s>%s</td>' % ( row_class , result_repr ) ) if form and not form [ cl . model . _meta . pk . name ] . is_hidden : yield mark_safe ( u'<td>%s</td>' % force_unicode ( form [ cl . model . _meta . pk . name ] ) ) class ResultList ( list ) : def __init__ ( self , form , * items ) : self . form = form super ( ResultList , self ) . __init__ ( * items ) def results ( cl ) : if cl . formset : for res , form in zip ( cl . result_list , cl . formset . forms ) : yield ResultList ( form , items_for_result ( cl , res , form ) ) else : for res in cl . result_list : yield ResultList ( None , items_for_result ( cl , res , None ) ) def result_hidden_fields ( cl ) : if cl . formset : for res , form in zip ( cl . result_list , cl . formset . forms ) : if form [ cl . model . _meta . pk . name ] . is_hidden : yield mark_safe ( force_unicode ( form [ cl . model . _meta . pk . name ] ) ) @ register . inclusion_tag ( "admin/change_list_results.html" ) def result_list ( cl ) : headers = list ( result_headers ( cl ) ) num_sorted_fields = 0 for h in headers : if h [ 'sortable' ] and h [ 'sorted' ] : num_sorted_fields += 1 return { 'cl' : cl , : list ( result_hidden_fields ( cl ) ) , : headers , : num_sorted_fields , : list ( results ( cl ) ) } @ register . inclusion_tag ( 'admin/date_hierarchy.html' ) def date_hierarchy ( cl ) : if cl . date_hierarchy : field_name = cl . date_hierarchy year_field = '%s__year' % field_name month_field = '%s__month' % field_name day_field = '%s__day' % field_name field_generic = '%s__' % field_name year_lookup = cl . params . get ( year_field ) month_lookup = cl . params . get ( month_field ) day_lookup = cl . params . get ( day_field ) link = lambda d : cl . get_query_string ( d , [ field_generic ] ) if not ( year_lookup or month_lookup or day_lookup ) : date_range = cl . query_set . aggregate ( first = models . Min ( field_name ) , last = models . Max ( field_name ) ) if date_range [ 'first' ] and date_range [ 'last' ] : if date_range [ 'first' ] . year == date_range [ 'last' ] . year : year_lookup = date_range [ 'first' ] . year if date_range [ 'first' ] . month == date_range [ 'last' ] . month : month_lookup = date_range [ 'first' ] . month if year_lookup and month_lookup and day_lookup : day = datetime . date ( int ( year_lookup ) , int ( month_lookup ) , int ( day_lookup ) ) return { : True , : { : link ( { year_field : year_lookup , month_field : month_lookup } ) , : capfirst ( formats . date_format ( day , 'YEAR_MONTH_FORMAT' ) ) } , : [ { 'title' : capfirst ( formats . date_format ( day , 'MONTH_DAY_FORMAT' ) ) } ] } elif year_lookup and month_lookup : days = cl . query_set . filter ( ** { year_field : year_lookup , month_field : month_lookup } ) . dates ( field_name , 'day' ) return { : True , : { : link ( { year_field : year_lookup } ) , : str ( year_lookup ) } , : [ { : link ( { year_field : year_lookup , month_field : month_lookup , day_field : day . day } ) , : capfirst ( formats . date_format ( day , 'MONTH_DAY_FORMAT' ) ) } for day in days ] } elif year_lookup : months = cl . query_set . filter ( ** { year_field : year_lookup } ) . dates ( field_name , 'month' ) return { : True , : { : link ( { } ) , : _ ( 'All dates' ) } , : [ { : link ( { year_field : year_lookup , month_field : month . month } ) , : capfirst ( formats . date_format ( month , 'YEAR_MONTH_FORMAT' ) ) } for month in months ] } else : years = cl . query_set . dates ( field_name , 'year' ) return { : True , : [ { : link ( { year_field : str ( year . year ) } ) , : str ( year . year ) , } for year in years ] } @ register . inclusion_tag ( 'admin/search_form.html' ) def search_form ( cl ) : return { : cl , : cl . result_count != cl . full_result_count , : SEARCH_VAR } @ register . simple_tag def admin_list_filter ( cl , spec ) : tpl = get_template ( spec . template ) return tpl . render ( Context ( { : spec . title , : list ( spec . choices ( cl ) ) , : spec , } ) ) @ register . inclusion_tag ( 'admin/actions.html' , takes_context = True ) def admin_actions ( context ) : context [ 'action_index' ] = context . get ( 'action_index' , - 1 ) + 1 return context

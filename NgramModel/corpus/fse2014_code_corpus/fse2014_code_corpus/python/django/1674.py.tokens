""" This module houses the GEOSCoordSeq object, which is used internally by GEOSGeometry to house the actual coordinates of the Point, LineString, and LinearRing geometries. """ from ctypes import c_double , c_uint , byref from django . contrib . gis . geos . base import GEOSBase , numpy from django . contrib . gis . geos . error import GEOSException , GEOSIndexError from django . contrib . gis . geos . libgeos import CS_PTR from django . contrib . gis . geos import prototypes as capi class GEOSCoordSeq ( GEOSBase ) : ptr_type = CS_PTR def __init__ ( self , ptr , z = False ) : if not isinstance ( ptr , CS_PTR ) : raise TypeError ( 'Coordinate sequence should initialize with a CS_PTR.' ) self . _ptr = ptr self . _z = z def __iter__ ( self ) : for i in xrange ( self . size ) : yield self [ i ] def __len__ ( self ) : return int ( self . size ) def __str__ ( self ) : return str ( self . tuple ) def __getitem__ ( self , index ) : coords = [ self . getX ( index ) , self . getY ( index ) ] if self . dims == 3 and self . _z : coords . append ( self . getZ ( index ) ) return tuple ( coords ) def __setitem__ ( self , index , value ) : if isinstance ( value , ( list , tuple ) ) : pass elif numpy and isinstance ( value , numpy . ndarray ) : pass else : raise TypeError ( 'Must set coordinate with a sequence (list, tuple, or numpy array).' ) if self . dims == 3 and self . _z : n_args = 3 set_3d = True else : n_args = 2 set_3d = False if len ( value ) != n_args : raise TypeError ( 'Dimension of value does not match.' ) self . setX ( index , value [ 0 ] ) self . setY ( index , value [ 1 ] ) if set_3d : self . setZ ( index , value [ 2 ] ) def _checkindex ( self , index ) : sz = self . size if ( sz < 1 ) or ( index < 0 ) or ( index >= sz ) : raise GEOSIndexError ( 'invalid GEOS Geometry index: %s' % str ( index ) ) def _checkdim ( self , dim ) : if dim < 0 or dim > 2 : raise GEOSException ( 'invalid ordinate dimension "%d"' % dim ) def getOrdinate ( self , dimension , index ) : self . _checkindex ( index ) self . _checkdim ( dimension ) return capi . cs_getordinate ( self . ptr , index , dimension , byref ( c_double ( ) ) ) def setOrdinate ( self , dimension , index , value ) : self . _checkindex ( index ) self . _checkdim ( dimension ) capi . cs_setordinate ( self . ptr , index , dimension , value ) def getX ( self , index ) : return self . getOrdinate ( 0 , index ) def setX ( self , index , value ) : self . setOrdinate ( 0 , index , value ) def getY ( self , index ) : return self . getOrdinate ( 1 , index ) def setY ( self , index , value ) : self . setOrdinate ( 1 , index , value ) def getZ ( self , index ) : return self . getOrdinate ( 2 , index ) def setZ ( self , index , value ) : self . setOrdinate ( 2 , index , value ) @ property def size ( self ) : return capi . cs_getsize ( self . ptr , byref ( c_uint ( ) ) ) @ property def dims ( self ) : return capi . cs_getdims ( self . ptr , byref ( c_uint ( ) ) ) @ property def hasz ( self ) : return self . _z def clone ( self ) : return GEOSCoordSeq ( capi . cs_clone ( self . ptr ) , self . hasz ) @ property def kml ( self ) : if self . hasz : substr = '%s,%s,%s ' else : substr = '%s,%s,0 ' return '<coordinates>%s</coordinates>' % '' . join ( [ substr % self [ i ] for i in xrange ( len ( self ) ) ] ) . strip ( ) @ property def tuple ( self ) : n = self . size if n == 1 : return self [ 0 ] else : return tuple ( [ self [ i ] for i in xrange ( n ) ] )

import collections import os import sys from optparse import OptionParser , NO_DEFAULT import imp import warnings from django . core . management . base import BaseCommand , CommandError , handle_default_options from django . core . management . color import color_style from django . utils . importlib import import_module from django import get_version _commands = None def find_commands ( management_dir ) : command_dir = os . path . join ( management_dir , 'commands' ) try : return [ f [ : - 3 ] for f in os . listdir ( command_dir ) if not f . startswith ( '_' ) and f . endswith ( '.py' ) ] except OSError : return [ ] def find_management_module ( app_name ) : parts = app_name . split ( '.' ) parts . append ( 'management' ) parts . reverse ( ) part = parts . pop ( ) path = None try : f , path , descr = imp . find_module ( part , path ) except ImportError , e : if os . path . basename ( os . getcwd ( ) ) != part : raise e while parts : part = parts . pop ( ) f , path , descr = imp . find_module ( part , path and [ path ] or None ) return path def load_command_class ( app_name , name ) : module = import_module ( '%s.management.commands.%s' % ( app_name , name ) ) return module . Command ( ) def get_commands ( ) : global _commands if _commands is None : _commands = dict ( [ ( name , 'django.core' ) for name in find_commands ( __path__ [ 0 ] ) ] ) try : from django . conf import settings apps = settings . INSTALLED_APPS except ( AttributeError , EnvironmentError , ImportError ) : apps = [ ] for app_name in apps : try : path = find_management_module ( app_name ) _commands . update ( dict ( [ ( name , app_name ) for name in find_commands ( path ) ] ) ) except ImportError : pass return _commands def call_command ( name , * args , ** options ) : try : app_name = get_commands ( ) [ name ] if isinstance ( app_name , BaseCommand ) : klass = app_name else : klass = load_command_class ( app_name , name ) except KeyError : raise CommandError ( "Unknown command: %r" % name ) defaults = { } for opt in klass . option_list : if opt . default is NO_DEFAULT : defaults [ opt . dest ] = None else : defaults [ opt . dest ] = opt . default defaults . update ( options ) return klass . execute ( * args , ** defaults ) class LaxOptionParser ( OptionParser ) : def error ( self , msg ) : pass def print_help ( self ) : pass def print_lax_help ( self ) : OptionParser . print_help ( self ) def _process_args ( self , largs , rargs , values ) : while rargs : arg = rargs [ 0 ] try : if arg [ 0 : 2 ] == "--" and len ( arg ) > 2 : self . _process_long_opt ( rargs , values ) elif arg [ : 1 ] == "-" and len ( arg ) > 1 : self . _process_short_opts ( rargs , values ) else : del rargs [ 0 ] raise Exception except : largs . append ( arg ) class ManagementUtility ( object ) : def __init__ ( self , argv = None ) : self . argv = argv or sys . argv [ : ] self . prog_name = os . path . basename ( self . argv [ 0 ] ) def main_help_text ( self , commands_only = False ) : if commands_only : usage = sorted ( get_commands ( ) . keys ( ) ) else : usage = [ , % self . prog_name , , , ] commands_dict = collections . defaultdict ( lambda : [ ] ) for name , app in get_commands ( ) . iteritems ( ) : if app == 'django.core' : app = 'django' else : app = app . rpartition ( '.' ) [ - 1 ] commands_dict [ app ] . append ( name ) style = color_style ( ) for app in sorted ( commands_dict . keys ( ) ) : usage . append ( "" ) usage . append ( style . NOTICE ( "[%s]" % app ) ) for name in sorted ( commands_dict [ app ] ) : usage . append ( " %s" % name ) return '\n' . join ( usage ) def fetch_command ( self , subcommand ) : try : app_name = get_commands ( ) [ subcommand ] except KeyError : sys . stderr . write ( "Unknown command: %r\nType '%s help' for usage.\n" % ( subcommand , self . prog_name ) ) sys . exit ( 1 ) if isinstance ( app_name , BaseCommand ) : klass = app_name else : klass = load_command_class ( app_name , subcommand ) return klass def autocomplete ( self ) : if 'DJANGO_AUTO_COMPLETE' not in os . environ : return cwords = os . environ [ 'COMP_WORDS' ] . split ( ) [ 1 : ] cword = int ( os . environ [ 'COMP_CWORD' ] ) try : curr = cwords [ cword - 1 ] except IndexError : curr = '' subcommands = get_commands ( ) . keys ( ) + [ 'help' ] options = [ ( '--help' , None ) ] if cword == 1 : print ' ' . join ( sorted ( filter ( lambda x : x . startswith ( curr ) , subcommands ) ) ) elif cwords [ 0 ] in subcommands and cwords [ 0 ] != 'help' : subcommand_cls = self . fetch_command ( cwords [ 0 ] ) if cwords [ 0 ] == 'runfcgi' : from django . core . servers . fastcgi import FASTCGI_OPTIONS options += [ ( k , 1 ) for k in FASTCGI_OPTIONS ] elif cwords [ 0 ] in ( 'dumpdata' , 'reset' , 'sql' , 'sqlall' , , 'sqlcustom' , 'sqlindexes' , , 'sqlsequencereset' , 'test' ) : try : from django . conf import settings options += [ ( a . split ( '.' ) [ - 1 ] , 0 ) for a in settings . INSTALLED_APPS ] except ImportError : pass options += [ ( s_opt . get_opt_string ( ) , s_opt . nargs ) for s_opt in subcommand_cls . option_list ] prev_opts = [ x . split ( '=' ) [ 0 ] for x in cwords [ 1 : cword - 1 ] ] options = filter ( lambda ( x , v ) : x not in prev_opts , options ) options = sorted ( [ ( k , v ) for k , v in options if k . startswith ( curr ) ] ) for option in options : opt_label = option [ 0 ] if option [ 1 ] : opt_label += '=' print opt_label sys . exit ( 1 ) def execute ( self ) : parser = LaxOptionParser ( usage = "%prog subcommand [options] [args]" , version = get_version ( ) , option_list = BaseCommand . option_list ) self . autocomplete ( ) try : options , args = parser . parse_args ( self . argv ) handle_default_options ( options ) except : pass try : subcommand = self . argv [ 1 ] except IndexError : subcommand = 'help' if subcommand == 'help' : if len ( args ) <= 2 : parser . print_lax_help ( ) sys . stdout . write ( self . main_help_text ( ) + '\n' ) elif args [ 2 ] == '--commands' : sys . stdout . write ( self . main_help_text ( commands_only = True ) + '\n' ) else : self . fetch_command ( args [ 2 ] ) . print_help ( self . prog_name , args [ 2 ] ) elif subcommand == 'version' : sys . stdout . write ( parser . get_version ( ) + '\n' ) elif self . argv [ 1 : ] == [ '--version' ] : pass elif self . argv [ 1 : ] in ( [ '--help' ] , [ '-h' ] ) : parser . print_lax_help ( ) sys . stdout . write ( self . main_help_text ( ) + '\n' ) else : self . fetch_command ( subcommand ) . run_from_argv ( self . argv ) def setup_environ ( settings_mod , original_settings_path = None ) : warnings . warn ( , PendingDeprecationWarning ) if '__init__.py' in settings_mod . __file__ : p = os . path . dirname ( settings_mod . __file__ ) else : p = settings_mod . __file__ project_directory , settings_filename = os . path . split ( p ) if project_directory == os . curdir or not project_directory : project_directory = os . getcwd ( ) project_name = os . path . basename ( project_directory ) settings_name = os . path . splitext ( settings_filename ) [ 0 ] if settings_name . endswith ( "$py" ) : settings_name = settings_name [ : - 3 ] if original_settings_path : os . environ [ 'DJANGO_SETTINGS_MODULE' ] = original_settings_path else : os . environ [ 'DJANGO_SETTINGS_MODULE' ] = os . environ . get ( , % ( project_name , settings_name ) ) sys . path . append ( os . path . join ( project_directory , os . pardir ) ) import_module ( project_name ) sys . path . pop ( ) return project_directory def execute_from_command_line ( argv = None ) : utility = ManagementUtility ( argv ) utility . execute ( ) def execute_manager ( settings_mod , argv = None ) : warnings . warn ( , PendingDeprecationWarning ) setup_environ ( settings_mod ) utility = ManagementUtility ( argv ) utility . execute ( )

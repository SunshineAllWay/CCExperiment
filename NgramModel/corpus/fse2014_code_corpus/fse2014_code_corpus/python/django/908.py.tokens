from django . template import loader , RequestContext from django . http import Http404 , HttpResponse from django . core . xheaders import populate_xheaders from django . core . paginator import Paginator , InvalidPage from django . core . exceptions import ObjectDoesNotExist import warnings warnings . warn ( , DeprecationWarning ) def object_list ( request , queryset , paginate_by = None , page = None , allow_empty = True , template_name = None , template_loader = loader , extra_context = None , context_processors = None , template_object_name = 'object' , mimetype = None ) : if extra_context is None : extra_context = { } queryset = queryset . _clone ( ) if paginate_by : paginator = Paginator ( queryset , paginate_by , allow_empty_first_page = allow_empty ) if not page : page = request . GET . get ( 'page' , 1 ) try : page_number = int ( page ) except ValueError : if page == 'last' : page_number = paginator . num_pages else : raise Http404 try : page_obj = paginator . page ( page_number ) except InvalidPage : raise Http404 c = RequestContext ( request , { % template_object_name : page_obj . object_list , : paginator , : page_obj , : page_obj . has_other_pages ( ) , : paginator . per_page , : page_obj . has_next ( ) , : page_obj . has_previous ( ) , : page_obj . number , : page_obj . next_page_number ( ) , : page_obj . previous_page_number ( ) , : page_obj . start_index ( ) , : page_obj . end_index ( ) , : paginator . num_pages , : paginator . count , : paginator . page_range , } , context_processors ) else : c = RequestContext ( request , { % template_object_name : queryset , : None , : None , : False , } , context_processors ) if not allow_empty and len ( queryset ) == 0 : raise Http404 for key , value in extra_context . items ( ) : if callable ( value ) : c [ key ] = value ( ) else : c [ key ] = value if not template_name : model = queryset . model template_name = "%s/%s_list.html" % ( model . _meta . app_label , model . _meta . object_name . lower ( ) ) t = template_loader . get_template ( template_name ) return HttpResponse ( t . render ( c ) , mimetype = mimetype ) def object_detail ( request , queryset , object_id = None , slug = None , slug_field = 'slug' , template_name = None , template_name_field = None , template_loader = loader , extra_context = None , context_processors = None , template_object_name = 'object' , mimetype = None ) : if extra_context is None : extra_context = { } model = queryset . model if object_id : queryset = queryset . filter ( pk = object_id ) elif slug and slug_field : queryset = queryset . filter ( ** { slug_field : slug } ) else : raise AttributeError ( "Generic detail view must be called with either an object_id or a slug/slug_field." ) try : obj = queryset . get ( ) except ObjectDoesNotExist : raise Http404 ( "No %s found matching the query" % ( model . _meta . verbose_name ) ) if not template_name : template_name = "%s/%s_detail.html" % ( model . _meta . app_label , model . _meta . object_name . lower ( ) ) if template_name_field : template_name_list = [ getattr ( obj , template_name_field ) , template_name ] t = template_loader . select_template ( template_name_list ) else : t = template_loader . get_template ( template_name ) c = RequestContext ( request , { template_object_name : obj , } , context_processors ) for key , value in extra_context . items ( ) : if callable ( value ) : c [ key ] = value ( ) else : c [ key ] = value response = HttpResponse ( t . render ( c ) , mimetype = mimetype ) populate_xheaders ( request , response , model , getattr ( obj , obj . _meta . pk . name ) ) return response

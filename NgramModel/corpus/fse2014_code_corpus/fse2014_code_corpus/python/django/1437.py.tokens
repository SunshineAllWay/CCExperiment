from django import template from django . template . loader import render_to_string from django . conf import settings from django . contrib . contenttypes . models import ContentType from django . contrib import comments from django . utils . encoding import smart_unicode register = template . Library ( ) class BaseCommentNode ( template . Node ) : @ classmethod def handle_token ( cls , parser , token ) : tokens = token . contents . split ( ) if tokens [ 1 ] != 'for' : raise template . TemplateSyntaxError ( "Second argument in %r tag must be 'for'" % tokens [ 0 ] ) if len ( tokens ) == 5 : if tokens [ 3 ] != 'as' : raise template . TemplateSyntaxError ( "Third argument in %r must be 'as'" % tokens [ 0 ] ) return cls ( object_expr = parser . compile_filter ( tokens [ 2 ] ) , as_varname = tokens [ 4 ] , ) elif len ( tokens ) == 6 : if tokens [ 4 ] != 'as' : raise template . TemplateSyntaxError ( "Fourth argument in %r must be 'as'" % tokens [ 0 ] ) return cls ( ctype = BaseCommentNode . lookup_content_type ( tokens [ 2 ] , tokens [ 0 ] ) , object_pk_expr = parser . compile_filter ( tokens [ 3 ] ) , as_varname = tokens [ 5 ] ) else : raise template . TemplateSyntaxError ( "%r tag requires 4 or 5 arguments" % tokens [ 0 ] ) @ staticmethod def lookup_content_type ( token , tagname ) : try : app , model = token . split ( '.' ) return ContentType . objects . get_by_natural_key ( app , model ) except ValueError : raise template . TemplateSyntaxError ( "Third argument in %r must be in the format 'app.model'" % tagname ) except ContentType . DoesNotExist : raise template . TemplateSyntaxError ( "%r tag has non-existant content-type: '%s.%s'" % ( tagname , app , model ) ) def __init__ ( self , ctype = None , object_pk_expr = None , object_expr = None , as_varname = None , comment = None ) : if ctype is None and object_expr is None : raise template . TemplateSyntaxError ( "Comment nodes must be given either a literal object or a ctype and object pk." ) self . comment_model = comments . get_model ( ) self . as_varname = as_varname self . ctype = ctype self . object_pk_expr = object_pk_expr self . object_expr = object_expr self . comment = comment def render ( self , context ) : qs = self . get_query_set ( context ) context [ self . as_varname ] = self . get_context_value_from_queryset ( context , qs ) return '' def get_query_set ( self , context ) : ctype , object_pk = self . get_target_ctype_pk ( context ) if not object_pk : return self . comment_model . objects . none ( ) qs = self . comment_model . objects . filter ( content_type = ctype , object_pk = smart_unicode ( object_pk ) , site__pk = settings . SITE_ID , ) field_names = [ f . name for f in self . comment_model . _meta . fields ] if 'is_public' in field_names : qs = qs . filter ( is_public = True ) if getattr ( settings , 'COMMENTS_HIDE_REMOVED' , True ) and 'is_removed' in field_names : qs = qs . filter ( is_removed = False ) return qs def get_target_ctype_pk ( self , context ) : if self . object_expr : try : obj = self . object_expr . resolve ( context ) except template . VariableDoesNotExist : return None , None return ContentType . objects . get_for_model ( obj ) , obj . pk else : return self . ctype , self . object_pk_expr . resolve ( context , ignore_failures = True ) def get_context_value_from_queryset ( self , context , qs ) : raise NotImplementedError class CommentListNode ( BaseCommentNode ) : def get_context_value_from_queryset ( self , context , qs ) : return list ( qs ) class CommentCountNode ( BaseCommentNode ) : def get_context_value_from_queryset ( self , context , qs ) : return qs . count ( ) class CommentFormNode ( BaseCommentNode ) : def get_form ( self , context ) : obj = self . get_object ( context ) if obj : return comments . get_form ( ) ( obj ) else : return None def get_object ( self , context ) : if self . object_expr : try : return self . object_expr . resolve ( context ) except template . VariableDoesNotExist : return None else : object_pk = self . object_pk_expr . resolve ( context , ignore_failures = True ) return self . ctype . get_object_for_this_type ( pk = object_pk ) def render ( self , context ) : context [ self . as_varname ] = self . get_form ( context ) return '' class RenderCommentFormNode ( CommentFormNode ) : @ classmethod def handle_token ( cls , parser , token ) : tokens = token . contents . split ( ) if tokens [ 1 ] != 'for' : raise template . TemplateSyntaxError ( "Second argument in %r tag must be 'for'" % tokens [ 0 ] ) if len ( tokens ) == 3 : return cls ( object_expr = parser . compile_filter ( tokens [ 2 ] ) ) elif len ( tokens ) == 4 : return cls ( ctype = BaseCommentNode . lookup_content_type ( tokens [ 2 ] , tokens [ 0 ] ) , object_pk_expr = parser . compile_filter ( tokens [ 3 ] ) ) def render ( self , context ) : ctype , object_pk = self . get_target_ctype_pk ( context ) if object_pk : template_search_list = [ % ( ctype . app_label , ctype . model ) , % ctype . app_label , ] context . push ( ) formstr = render_to_string ( template_search_list , { "form" : self . get_form ( context ) } , context ) context . pop ( ) return formstr else : return '' class RenderCommentListNode ( CommentListNode ) : @ classmethod def handle_token ( cls , parser , token ) : tokens = token . contents . split ( ) if tokens [ 1 ] != 'for' : raise template . TemplateSyntaxError ( "Second argument in %r tag must be 'for'" % tokens [ 0 ] ) if len ( tokens ) == 3 : return cls ( object_expr = parser . compile_filter ( tokens [ 2 ] ) ) elif len ( tokens ) == 4 : return cls ( ctype = BaseCommentNode . lookup_content_type ( tokens [ 2 ] , tokens [ 0 ] ) , object_pk_expr = parser . compile_filter ( tokens [ 3 ] ) ) def render ( self , context ) : ctype , object_pk = self . get_target_ctype_pk ( context ) if object_pk : template_search_list = [ % ( ctype . app_label , ctype . model ) , % ctype . app_label , ] qs = self . get_query_set ( context ) context . push ( ) liststr = render_to_string ( template_search_list , { : self . get_context_value_from_queryset ( context , qs ) } , context ) context . pop ( ) return liststr else : return '' @ register . tag def get_comment_count ( parser , token ) : return CommentCountNode . handle_token ( parser , token ) @ register . tag def get_comment_list ( parser , token ) : return CommentListNode . handle_token ( parser , token ) @ register . tag def render_comment_list ( parser , token ) : return RenderCommentListNode . handle_token ( parser , token ) @ register . tag def get_comment_form ( parser , token ) : return CommentFormNode . handle_token ( parser , token ) @ register . tag def render_comment_form ( parser , token ) : return RenderCommentFormNode . handle_token ( parser , token ) @ register . simple_tag def comment_form_target ( ) : return comments . get_form_target ( ) @ register . simple_tag def get_comment_permalink ( comment , anchor_pattern = None ) : if anchor_pattern : return comment . get_absolute_url ( anchor_pattern ) return comment . get_absolute_url ( )

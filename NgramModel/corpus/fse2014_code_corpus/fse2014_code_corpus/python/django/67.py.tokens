from __future__ import absolute_import import sys import time from django . conf import settings from django . db import transaction , connection from django . db . utils import ConnectionHandler , DEFAULT_DB_ALIAS , DatabaseError from django . test import ( TransactionTestCase , skipIfDBFeature , skipUnlessDBFeature ) from django . utils import unittest from . models import Person try : import threading except ImportError : threading = None requires_threading = unittest . skipUnless ( threading , 'requires threading' ) class SelectForUpdateTests ( TransactionTestCase ) : def setUp ( self ) : transaction . enter_transaction_management ( True ) transaction . managed ( True ) self . person = Person . objects . create ( name = 'Reinhardt' ) transaction . commit ( ) new_connections = ConnectionHandler ( settings . DATABASES ) self . new_connection = new_connections [ DEFAULT_DB_ALIAS ] self . _old_debug = settings . DEBUG settings . DEBUG = True def tearDown ( self ) : try : transaction . managed ( False ) transaction . leave_transaction_management ( ) except transaction . TransactionManagementError : pass self . new_connection . close ( ) settings . DEBUG = self . _old_debug try : self . end_blocking_transaction ( ) except ( DatabaseError , AttributeError ) : pass def start_blocking_transaction ( self ) : self . cursor = self . new_connection . cursor ( ) sql = 'SELECT * FROM %(db_table)s %(for_update)s;' % { : Person . _meta . db_table , : self . new_connection . ops . for_update_sql ( ) , } self . cursor . execute ( sql , ( ) ) result = self . cursor . fetchone ( ) def end_blocking_transaction ( self ) : self . new_connection . _rollback ( ) def has_for_update_sql ( self , tested_connection , nowait = False ) : for_update_sql = tested_connection . ops . for_update_sql ( nowait ) sql = tested_connection . queries [ - 1 ] [ 'sql' ] return bool ( sql . find ( for_update_sql ) > - 1 ) def check_exc ( self , exc ) : self . failUnless ( isinstance ( exc , DatabaseError ) ) @ skipUnlessDBFeature ( 'has_select_for_update' ) def test_for_update_sql_generated ( self ) : list ( Person . objects . all ( ) . select_for_update ( ) ) self . assertTrue ( self . has_for_update_sql ( connection ) ) @ skipUnlessDBFeature ( 'has_select_for_update_nowait' ) def test_for_update_sql_generated_nowait ( self ) : list ( Person . objects . all ( ) . select_for_update ( nowait = True ) ) self . assertTrue ( self . has_for_update_sql ( connection , nowait = True ) ) @ requires_threading @ skipUnlessDBFeature ( 'has_select_for_update_nowait' ) @ unittest . skipIf ( sys . version_info [ : 3 ] == ( 2 , 6 , 1 ) , "Python version is 2.6.1" ) def test_nowait_raises_error_on_block ( self ) : self . start_blocking_transaction ( ) status = [ ] thread = threading . Thread ( target = self . run_select_for_update , args = ( status , ) , kwargs = { 'nowait' : True } , ) thread . start ( ) time . sleep ( 1 ) thread . join ( ) self . end_blocking_transaction ( ) self . check_exc ( status [ - 1 ] ) @ skipIfDBFeature ( 'has_select_for_update_nowait' ) @ skipUnlessDBFeature ( 'has_select_for_update' ) @ unittest . skipIf ( sys . version_info [ : 3 ] == ( 2 , 6 , 1 ) , "Python version is 2.6.1" ) def test_unsupported_nowait_raises_error ( self ) : self . assertRaises ( DatabaseError , list , Person . objects . all ( ) . select_for_update ( nowait = True ) ) def run_select_for_update ( self , status , nowait = False ) : status . append ( 'started' ) try : transaction . enter_transaction_management ( True ) transaction . managed ( True ) people = list ( Person . objects . all ( ) . select_for_update ( nowait = nowait ) ) people [ 0 ] . name = 'Fred' people [ 0 ] . save ( ) transaction . commit ( ) except DatabaseError , e : status . append ( e ) except Exception , e : raise finally : connection . close ( ) @ requires_threading @ skipUnlessDBFeature ( 'has_select_for_update' ) @ skipUnlessDBFeature ( 'supports_transactions' ) def test_block ( self ) : self . start_blocking_transaction ( ) status = [ ] thread = threading . Thread ( target = self . run_select_for_update , args = ( status , ) ) thread . start ( ) sanity_count = 0 while len ( status ) != 1 and sanity_count < 10 : sanity_count += 1 time . sleep ( 1 ) if sanity_count >= 10 : raise ValueError , 'Thread did not run and block' p = Person . objects . get ( pk = self . person . pk ) self . assertEqual ( 'Reinhardt' , p . name ) self . end_blocking_transaction ( ) thread . join ( 5.0 ) self . failIf ( thread . isAlive ( ) ) transaction . commit ( ) p = Person . objects . get ( pk = self . person . pk ) self . assertEqual ( 'Fred' , p . name ) @ requires_threading @ skipUnlessDBFeature ( 'has_select_for_update' ) def test_raw_lock_not_available ( self ) : self . start_blocking_transaction ( ) def raw ( status ) : try : list ( Person . objects . raw ( % ( Person . _meta . db_table , connection . ops . for_update_sql ( nowait = True ) ) ) ) except DatabaseError , e : status . append ( e ) finally : connection . close ( ) status = [ ] thread = threading . Thread ( target = raw , kwargs = { 'status' : status } ) thread . start ( ) time . sleep ( 1 ) thread . join ( ) self . end_blocking_transaction ( ) self . check_exc ( status [ - 1 ] ) @ skipUnlessDBFeature ( 'has_select_for_update' ) def test_transaction_dirty_managed ( self ) : people = list ( Person . objects . select_for_update ( ) ) self . assertTrue ( transaction . is_dirty ( ) ) @ skipUnlessDBFeature ( 'has_select_for_update' ) def test_transaction_not_dirty_unmanaged ( self ) : transaction . managed ( False ) transaction . leave_transaction_management ( ) people = list ( Person . objects . select_for_update ( ) ) self . assertFalse ( transaction . is_dirty ( ) )

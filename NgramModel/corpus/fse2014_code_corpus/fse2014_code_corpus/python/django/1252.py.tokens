"""Translation helper functions.""" import locale import os import re import sys import gettext as gettext_module from threading import local try : from cStringIO import StringIO except ImportError : from StringIO import StringIO from django . utils . importlib import import_module from django . utils . safestring import mark_safe , SafeData _translations = { } _active = local ( ) _default = None _accepted = { } CONTEXT_SEPARATOR = u"\x04" accept_language_re = re . compile ( r''' ([A-Za-z]{1,8}(?:-[A-Za-z]{1,8})*|\*) # "en", "en-au", "x-y-z", "*" (?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:.0{,3})?))? # Optional "q=1.00", "q=0.8" (?:\s*,\s*|$) # Multiple accepts per header. ''' , re . VERBOSE ) language_code_prefix_re = re . compile ( r'^/([\w-]+)(/|$)' ) def to_locale ( language , to_lower = False ) : p = language . find ( '-' ) if p >= 0 : if to_lower : return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . lower ( ) else : if len ( language [ p + 1 : ] ) > 2 : return language [ : p ] . lower ( ) + '_' + language [ p + 1 ] . upper ( ) + language [ p + 2 : ] . lower ( ) return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . upper ( ) else : return language . lower ( ) def to_language ( locale ) : p = locale . find ( '_' ) if p >= 0 : return locale [ : p ] . lower ( ) + '-' + locale [ p + 1 : ] . lower ( ) else : return locale . lower ( ) class DjangoTranslation ( gettext_module . GNUTranslations ) : def __init__ ( self , * args , ** kw ) : gettext_module . GNUTranslations . __init__ ( self , * args , ** kw ) self . set_output_charset ( 'utf-8' ) self . django_output_charset = 'utf-8' self . __language = '??' def merge ( self , other ) : self . _catalog . update ( other . _catalog ) def set_language ( self , language ) : self . __language = language self . __to_language = to_language ( language ) def language ( self ) : return self . __language def to_language ( self ) : return self . __to_language def __repr__ ( self ) : return "<DjangoTranslation lang:%s>" % self . __language def translation ( language ) : global _translations t = _translations . get ( language , None ) if t is not None : return t from django . conf import settings globalpath = os . path . join ( os . path . dirname ( sys . modules [ settings . __module__ ] . __file__ ) , 'locale' ) if settings . SETTINGS_MODULE is not None : parts = settings . SETTINGS_MODULE . split ( '.' ) project = import_module ( parts [ 0 ] ) projectpath = os . path . join ( os . path . dirname ( project . __file__ ) , 'locale' ) else : projectpath = None def _fetch ( lang , fallback = None ) : global _translations res = _translations . get ( lang , None ) if res is not None : return res loc = to_locale ( lang ) def _translation ( path ) : try : t = gettext_module . translation ( 'django' , path , [ loc ] , DjangoTranslation ) t . set_language ( lang ) return t except IOError : return None res = _translation ( globalpath ) base_lang = lambda x : x . split ( '-' , 1 ) [ 0 ] if base_lang ( lang ) in [ base_lang ( trans ) for trans in _translations ] : res . _info = res . _info . copy ( ) res . _catalog = res . _catalog . copy ( ) def _merge ( path ) : t = _translation ( path ) if t is not None : if res is None : return t else : res . merge ( t ) return res for appname in reversed ( settings . INSTALLED_APPS ) : app = import_module ( appname ) apppath = os . path . join ( os . path . dirname ( app . __file__ ) , 'locale' ) if os . path . isdir ( apppath ) : res = _merge ( apppath ) localepaths = [ os . path . normpath ( path ) for path in settings . LOCALE_PATHS ] if ( projectpath and os . path . isdir ( projectpath ) and os . path . normpath ( projectpath ) not in localepaths ) : res = _merge ( projectpath ) for localepath in reversed ( settings . LOCALE_PATHS ) : if os . path . isdir ( localepath ) : res = _merge ( localepath ) if res is None : if fallback is not None : res = fallback else : return gettext_module . NullTranslations ( ) _translations [ lang ] = res return res default_translation = _fetch ( settings . LANGUAGE_CODE ) current_translation = _fetch ( language , fallback = default_translation ) return current_translation def activate ( language ) : _active . value = translation ( language ) def deactivate ( ) : if hasattr ( _active , "value" ) : del _active . value def deactivate_all ( ) : _active . value = gettext_module . NullTranslations ( ) def get_language ( ) : t = getattr ( _active , "value" , None ) if t is not None : try : return t . to_language ( ) except AttributeError : pass from django . conf import settings return settings . LANGUAGE_CODE def get_language_bidi ( ) : from django . conf import settings base_lang = get_language ( ) . split ( '-' ) [ 0 ] return base_lang in settings . LANGUAGES_BIDI def catalog ( ) : global _default t = getattr ( _active , "value" , None ) if t is not None : return t if _default is None : from django . conf import settings _default = translation ( settings . LANGUAGE_CODE ) return _default def do_translate ( message , translation_function ) : global _default eol_message = message . replace ( '\r\n' , '\n' ) . replace ( '\r' , '\n' ) t = getattr ( _active , "value" , None ) if t is not None : result = getattr ( t , translation_function ) ( eol_message ) else : if _default is None : from django . conf import settings _default = translation ( settings . LANGUAGE_CODE ) result = getattr ( _default , translation_function ) ( eol_message ) if isinstance ( message , SafeData ) : return mark_safe ( result ) return result def gettext ( message ) : return do_translate ( message , 'gettext' ) def ugettext ( message ) : return do_translate ( message , 'ugettext' ) def pgettext ( context , message ) : result = do_translate ( % ( context , CONTEXT_SEPARATOR , message ) , 'ugettext' ) if CONTEXT_SEPARATOR in result : result = message return result def gettext_noop ( message ) : return message def do_ntranslate ( singular , plural , number , translation_function ) : global _default t = getattr ( _active , "value" , None ) if t is not None : return getattr ( t , translation_function ) ( singular , plural , number ) if _default is None : from django . conf import settings _default = translation ( settings . LANGUAGE_CODE ) return getattr ( _default , translation_function ) ( singular , plural , number ) def ngettext ( singular , plural , number ) : return do_ntranslate ( singular , plural , number , 'ngettext' ) def ungettext ( singular , plural , number ) : return do_ntranslate ( singular , plural , number , 'ungettext' ) def npgettext ( context , singular , plural , number ) : result = do_ntranslate ( u"%s%s%s" % ( context , CONTEXT_SEPARATOR , singular ) , % ( context , CONTEXT_SEPARATOR , plural ) , number , 'ungettext' ) if CONTEXT_SEPARATOR in result : result = do_ntranslate ( singular , plural , number , 'ungettext' ) return result def all_locale_paths ( ) : from django . conf import settings globalpath = os . path . join ( os . path . dirname ( sys . modules [ settings . __module__ ] . __file__ ) , 'locale' ) return [ globalpath ] + list ( settings . LOCALE_PATHS ) def check_for_language ( lang_code ) : for path in all_locale_paths ( ) : if gettext_module . find ( 'django' , path , [ to_locale ( lang_code ) ] ) is not None : return True return False def get_language_from_path ( path , supported = None ) : if supported is None : from django . conf import settings supported = dict ( settings . LANGUAGES ) regex_match = language_code_prefix_re . match ( path ) if regex_match : lang_code = regex_match . group ( 1 ) if lang_code in supported and check_for_language ( lang_code ) : return lang_code def get_language_from_request ( request , check_path = False ) : global _accepted from django . conf import settings supported = dict ( settings . LANGUAGES ) if check_path : lang_code = get_language_from_path ( request . path_info , supported ) if lang_code is not None : return lang_code if hasattr ( request , 'session' ) : lang_code = request . session . get ( 'django_language' , None ) if lang_code in supported and lang_code is not None and check_for_language ( lang_code ) : return lang_code lang_code = request . COOKIES . get ( settings . LANGUAGE_COOKIE_NAME ) if lang_code and lang_code not in supported : lang_code = lang_code . split ( '-' ) [ 0 ] if lang_code and lang_code in supported and check_for_language ( lang_code ) : return lang_code accept = request . META . get ( 'HTTP_ACCEPT_LANGUAGE' , '' ) for accept_lang , unused in parse_accept_lang_header ( accept ) : if accept_lang == '*' : break normalized = locale . locale_alias . get ( to_locale ( accept_lang , True ) ) if not normalized : continue normalized = normalized . split ( '.' ) [ 0 ] if normalized in _accepted : return _accepted [ normalized ] for lang , dirname in ( ( accept_lang , normalized ) , ( accept_lang . split ( '-' ) [ 0 ] , normalized . split ( '_' ) [ 0 ] ) ) : if lang . lower ( ) not in supported : continue for path in all_locale_paths ( ) : if os . path . exists ( os . path . join ( path , dirname , 'LC_MESSAGES' , 'django.mo' ) ) : _accepted [ normalized ] = lang return lang return settings . LANGUAGE_CODE dot_re = re . compile ( r'\S' ) def blankout ( src , char ) : return dot_re . sub ( char , src ) context_re = re . compile ( r"""^\s+.*context\s+((?:"[^"]*?")|(?:'[^']*?'))\s*""" ) inline_re = re . compile ( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))(\s+.*context\s+(?:"[^"]*?")|(?:'[^']*?'))?\s*""" ) block_re = re . compile ( r"""^\s*blocktrans(\s+.*context\s+(?:"[^"]*?")|(?:'[^']*?'))?(?:\s+|$)""" ) endblock_re = re . compile ( r"""^\s*endblocktrans$""" ) plural_re = re . compile ( r"""^\s*plural$""" ) constant_re = re . compile ( r"""_\(((?:".*?")|(?:'.*?'))\)""" ) one_percent_re = re . compile ( r"""(?<!%)%(?!%)""" ) def templatize ( src , origin = None ) : from django . template import ( Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK , TOKEN_COMMENT , TRANSLATOR_COMMENT_MARK ) out = StringIO ( ) message_context = None intrans = False inplural = False singular = [ ] plural = [ ] incomment = False comment = [ ] for t in Lexer ( src , origin ) . tokenize ( ) : if incomment : if t . token_type == TOKEN_BLOCK and t . contents == 'endcomment' : content = '' . join ( comment ) translators_comment_start = None for lineno , line in enumerate ( content . splitlines ( True ) ) : if line . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) : translators_comment_start = lineno for lineno , line in enumerate ( content . splitlines ( True ) ) : if translators_comment_start is not None and lineno >= translators_comment_start : out . write ( ' # %s' % line ) else : out . write ( ' #\n' ) incomment = False comment = [ ] else : comment . append ( t . contents ) elif intrans : if t . token_type == TOKEN_BLOCK : endbmatch = endblock_re . match ( t . contents ) pluralmatch = plural_re . match ( t . contents ) if endbmatch : if inplural : if message_context : out . write ( ' npgettext(%r, %r, %r,count) ' % ( message_context , '' . join ( singular ) , '' . join ( plural ) ) ) else : out . write ( ' ngettext(%r, %r, count) ' % ( '' . join ( singular ) , '' . join ( plural ) ) ) for part in singular : out . write ( blankout ( part , 'S' ) ) for part in plural : out . write ( blankout ( part , 'P' ) ) else : if message_context : out . write ( ' pgettext(%r, %r) ' % ( message_context , '' . join ( singular ) ) ) else : out . write ( ' gettext(%r) ' % '' . join ( singular ) ) for part in singular : out . write ( blankout ( part , 'S' ) ) message_context = None intrans = False inplural = False singular = [ ] plural = [ ] elif pluralmatch : inplural = True else : filemsg = '' if origin : filemsg = 'file %s, ' % origin raise SyntaxError ( "Translation blocks must not include other block tags: %s (%sline %d)" % ( t . contents , filemsg , t . lineno ) ) elif t . token_type == TOKEN_VAR : if inplural : plural . append ( '%%(%s)s' % t . contents ) else : singular . append ( '%%(%s)s' % t . contents ) elif t . token_type == TOKEN_TEXT : contents = one_percent_re . sub ( '%%' , t . contents ) if inplural : plural . append ( contents ) else : singular . append ( contents ) else : if t . token_type == TOKEN_BLOCK : imatch = inline_re . match ( t . contents ) bmatch = block_re . match ( t . contents ) cmatches = constant_re . findall ( t . contents ) if imatch : g = imatch . group ( 1 ) if g [ 0 ] == '"' : g = g . strip ( '"' ) elif g [ 0 ] == "'" : g = g . strip ( "'" ) g = one_percent_re . sub ( '%%' , g ) if imatch . group ( 2 ) : context_match = context_re . match ( imatch . group ( 2 ) ) message_context = context_match . group ( 1 ) if message_context [ 0 ] == '"' : message_context = message_context . strip ( '"' ) elif message_context [ 0 ] == "'" : message_context = message_context . strip ( "'" ) out . write ( ' pgettext(%r, %r) ' % ( message_context , g ) ) message_context = None else : out . write ( ' gettext(%r) ' % g ) elif bmatch : for fmatch in constant_re . findall ( t . contents ) : out . write ( ' _(%s) ' % fmatch ) if bmatch . group ( 1 ) : context_match = context_re . match ( bmatch . group ( 1 ) ) message_context = context_match . group ( 1 ) if message_context [ 0 ] == '"' : message_context = message_context . strip ( '"' ) elif message_context [ 0 ] == "'" : message_context = message_context . strip ( "'" ) intrans = True inplural = False singular = [ ] plural = [ ] elif cmatches : for cmatch in cmatches : out . write ( ' _(%s) ' % cmatch ) elif t . contents == 'comment' : incomment = True else : out . write ( blankout ( t . contents , 'B' ) ) elif t . token_type == TOKEN_VAR : parts = t . contents . split ( '|' ) cmatch = constant_re . match ( parts [ 0 ] ) if cmatch : out . write ( ' _(%s) ' % cmatch . group ( 1 ) ) for p in parts [ 1 : ] : if p . find ( ':_(' ) >= 0 : out . write ( ' %s ' % p . split ( ':' , 1 ) [ 1 ] ) else : out . write ( blankout ( p , 'F' ) ) elif t . token_type == TOKEN_COMMENT : out . write ( ' # %s' % t . contents ) else : out . write ( blankout ( t . contents , 'X' ) ) return out . getvalue ( ) def parse_accept_lang_header ( lang_string ) : result = [ ] pieces = accept_language_re . split ( lang_string ) if pieces [ - 1 ] : return [ ] for i in range ( 0 , len ( pieces ) - 1 , 3 ) : first , lang , priority = pieces [ i : i + 3 ] if first : return [ ] priority = priority and float ( priority ) or 1.0 result . append ( ( lang , priority ) ) result . sort ( key = lambda k : k [ 1 ] , reverse = True ) return result

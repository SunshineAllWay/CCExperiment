import sys import time from django . conf import settings from django . db . utils import load_backend TEST_DATABASE_PREFIX = 'test_' class BaseDatabaseCreation ( object ) : data_types = { } def __init__ ( self , connection ) : self . connection = connection def _digest ( self , * args ) : return '%x' % ( abs ( hash ( args ) ) % 4294967296L ) def sql_create_model ( self , model , style , known_models = set ( ) ) : opts = model . _meta if not opts . managed or opts . proxy : return [ ] , { } final_output = [ ] table_output = [ ] pending_references = { } qn = self . connection . ops . quote_name for f in opts . local_fields : col_type = f . db_type ( connection = self . connection ) tablespace = f . db_tablespace or opts . db_tablespace if col_type is None : continue field_output = [ style . SQL_FIELD ( qn ( f . column ) ) , style . SQL_COLTYPE ( col_type ) ] if not f . null : field_output . append ( style . SQL_KEYWORD ( 'NOT NULL' ) ) if f . primary_key : field_output . append ( style . SQL_KEYWORD ( 'PRIMARY KEY' ) ) elif f . unique : field_output . append ( style . SQL_KEYWORD ( 'UNIQUE' ) ) if tablespace and f . unique : tablespace_sql = self . connection . ops . tablespace_sql ( tablespace , inline = True ) if tablespace_sql : field_output . append ( tablespace_sql ) if f . rel : ref_output , pending = self . sql_for_inline_foreign_key_references ( f , known_models , style ) if pending : pending_references . setdefault ( f . rel . to , [ ] ) . append ( ( model , f ) ) else : field_output . extend ( ref_output ) table_output . append ( ' ' . join ( field_output ) ) for field_constraints in opts . unique_together : table_output . append ( style . SQL_KEYWORD ( 'UNIQUE' ) + ' (%s)' % . join ( [ style . SQL_FIELD ( qn ( opts . get_field ( f ) . column ) ) for f in field_constraints ] ) ) full_statement = [ style . SQL_KEYWORD ( 'CREATE TABLE' ) + ' ' + style . SQL_TABLE ( qn ( opts . db_table ) ) + ' (' ] for i , line in enumerate ( table_output ) : full_statement . append ( % ( line , i < len ( table_output ) - 1 and ',' or '' ) ) full_statement . append ( ')' ) if opts . db_tablespace : tablespace_sql = self . connection . ops . tablespace_sql ( opts . db_tablespace ) if tablespace_sql : full_statement . append ( tablespace_sql ) full_statement . append ( ';' ) final_output . append ( '\n' . join ( full_statement ) ) if opts . has_auto_field : auto_column = opts . auto_field . db_column or opts . auto_field . name autoinc_sql = self . connection . ops . autoinc_sql ( opts . db_table , auto_column ) if autoinc_sql : for stmt in autoinc_sql : final_output . append ( stmt ) return final_output , pending_references def sql_for_inline_foreign_key_references ( self , field , known_models , style ) : qn = self . connection . ops . quote_name if field . rel . to in known_models : output = [ style . SQL_KEYWORD ( 'REFERENCES' ) + ' ' + style . SQL_TABLE ( qn ( field . rel . to . _meta . db_table ) ) + ' (' + style . SQL_FIELD ( qn ( field . rel . to . _meta . get_field ( field . rel . field_name ) . column ) ) + ')' + self . connection . ops . deferrable_sql ( ) ] pending = False else : output = [ ] pending = True return output , pending def sql_for_pending_references ( self , model , style , pending_references ) : from django . db . backends . util import truncate_name if not model . _meta . managed or model . _meta . proxy : return [ ] qn = self . connection . ops . quote_name final_output = [ ] opts = model . _meta if model in pending_references : for rel_class , f in pending_references [ model ] : rel_opts = rel_class . _meta r_table = rel_opts . db_table r_col = f . column table = opts . db_table col = opts . get_field ( f . rel . field_name ) . column r_name = '%s_refs_%s_%s' % ( r_col , col , self . _digest ( r_table , table ) ) final_output . append ( style . SQL_KEYWORD ( 'ALTER TABLE' ) + % ( qn ( r_table ) , qn ( truncate_name ( r_name , self . connection . ops . max_name_length ( ) ) ) , qn ( r_col ) , qn ( table ) , qn ( col ) , self . connection . ops . deferrable_sql ( ) ) ) del pending_references [ model ] return final_output def sql_indexes_for_model ( self , model , style ) : if not model . _meta . managed or model . _meta . proxy : return [ ] output = [ ] for f in model . _meta . local_fields : output . extend ( self . sql_indexes_for_field ( model , f , style ) ) return output def sql_indexes_for_field ( self , model , f , style ) : from django . db . backends . util import truncate_name if f . db_index and not f . unique : qn = self . connection . ops . quote_name tablespace = f . db_tablespace or model . _meta . db_tablespace if tablespace : tablespace_sql = self . connection . ops . tablespace_sql ( tablespace ) if tablespace_sql : tablespace_sql = ' ' + tablespace_sql else : tablespace_sql = '' i_name = '%s_%s' % ( model . _meta . db_table , self . _digest ( f . column ) ) output = [ style . SQL_KEYWORD ( 'CREATE INDEX' ) + ' ' + style . SQL_TABLE ( qn ( truncate_name ( i_name , self . connection . ops . max_name_length ( ) ) ) ) + ' ' + style . SQL_KEYWORD ( 'ON' ) + ' ' + style . SQL_TABLE ( qn ( model . _meta . db_table ) ) + ' ' + % style . SQL_FIELD ( qn ( f . column ) ) + % tablespace_sql ] else : output = [ ] return output def sql_destroy_model ( self , model , references_to_delete , style ) : if not model . _meta . managed or model . _meta . proxy : return [ ] qn = self . connection . ops . quote_name output = [ '%s %s;' % ( style . SQL_KEYWORD ( 'DROP TABLE' ) , style . SQL_TABLE ( qn ( model . _meta . db_table ) ) ) ] if model in references_to_delete : output . extend ( self . sql_remove_table_constraints ( model , references_to_delete , style ) ) if model . _meta . has_auto_field : ds = self . connection . ops . drop_sequence_sql ( model . _meta . db_table ) if ds : output . append ( ds ) return output def sql_remove_table_constraints ( self , model , references_to_delete , style ) : from django . db . backends . util import truncate_name if not model . _meta . managed or model . _meta . proxy : return [ ] output = [ ] qn = self . connection . ops . quote_name for rel_class , f in references_to_delete [ model ] : table = rel_class . _meta . db_table col = f . column r_table = model . _meta . db_table r_col = model . _meta . get_field ( f . rel . field_name ) . column r_name = '%s_refs_%s_%s' % ( col , r_col , self . _digest ( table , r_table ) ) output . append ( '%s %s %s %s;' % ( style . SQL_KEYWORD ( 'ALTER TABLE' ) , style . SQL_TABLE ( qn ( table ) ) , style . SQL_KEYWORD ( self . connection . ops . drop_foreignkey_sql ( ) ) , style . SQL_FIELD ( qn ( truncate_name ( r_name , self . connection . ops . max_name_length ( ) ) ) ) ) ) del references_to_delete [ model ] return output def create_test_db ( self , verbosity = 1 , autoclobber = False ) : from django . core . management import call_command test_database_name = self . _get_test_db_name ( ) if verbosity >= 1 : test_db_repr = '' if verbosity >= 2 : test_db_repr = " ('%s')" % test_database_name print "Creating test database for alias '%s'%s..." % ( self . connection . alias , test_db_repr ) self . _create_test_db ( verbosity , autoclobber ) self . connection . close ( ) self . connection . settings_dict [ "NAME" ] = test_database_name self . connection . features . confirm ( ) call_command ( 'syncdb' , verbosity = max ( verbosity - 1 , 0 ) , interactive = False , database = self . connection . alias , load_initial_data = False ) call_command ( 'flush' , verbosity = max ( verbosity - 1 , 0 ) , interactive = False , database = self . connection . alias ) from django . core . cache import get_cache from django . core . cache . backends . db import BaseDatabaseCache for cache_alias in settings . CACHES : cache = get_cache ( cache_alias ) if isinstance ( cache , BaseDatabaseCache ) : call_command ( 'createcachetable' , cache . _table , database = self . connection . alias ) self . connection . cursor ( ) return test_database_name def _get_test_db_name ( self ) : if self . connection . settings_dict [ 'TEST_NAME' ] : return self . connection . settings_dict [ 'TEST_NAME' ] return TEST_DATABASE_PREFIX + self . connection . settings_dict [ 'NAME' ] def _create_test_db ( self , verbosity , autoclobber ) : suffix = self . sql_table_creation_suffix ( ) test_database_name = self . _get_test_db_name ( ) qn = self . connection . ops . quote_name cursor = self . connection . cursor ( ) self . _prepare_for_test_db_ddl ( ) try : cursor . execute ( % ( qn ( test_database_name ) , suffix ) ) except Exception , e : sys . stderr . write ( % e ) if not autoclobber : confirm = raw_input ( % test_database_name ) if autoclobber or confirm == 'yes' : try : if verbosity >= 1 : print ( "Destroying old test database '%s'..." % self . connection . alias ) cursor . execute ( % qn ( test_database_name ) ) cursor . execute ( % ( qn ( test_database_name ) , suffix ) ) except Exception , e : sys . stderr . write ( % e ) sys . exit ( 2 ) else : print "Tests cancelled." sys . exit ( 1 ) return test_database_name def destroy_test_db ( self , old_database_name , verbosity = 1 ) : self . connection . close ( ) test_database_name = self . connection . settings_dict [ 'NAME' ] if verbosity >= 1 : test_db_repr = '' if verbosity >= 2 : test_db_repr = " ('%s')" % test_database_name print "Destroying test database for alias '%s'%s..." % ( self . connection . alias , test_db_repr ) settings_dict = self . connection . settings_dict . copy ( ) settings_dict [ 'NAME' ] = old_database_name backend = load_backend ( settings_dict [ 'ENGINE' ] ) new_connection = backend . DatabaseWrapper ( settings_dict , alias = '__destroy_test_db__' , allow_thread_sharing = False ) new_connection . creation . _destroy_test_db ( test_database_name , verbosity ) def _destroy_test_db ( self , test_database_name , verbosity ) : cursor = self . connection . cursor ( ) self . _prepare_for_test_db_ddl ( ) time . sleep ( 1 ) cursor . execute ( "DROP DATABASE %s" % self . connection . ops . quote_name ( test_database_name ) ) self . connection . close ( ) def set_autocommit ( self ) : pass def _prepare_for_test_db_ddl ( self ) : pass def sql_table_creation_suffix ( self ) : return '' def test_db_signature ( self ) : settings_dict = self . connection . settings_dict return ( settings_dict [ 'HOST' ] , settings_dict [ 'PORT' ] , settings_dict [ 'ENGINE' ] , settings_dict [ 'NAME' ] )

import os import re from ctypes import c_char_p from django . core . validators import ipv4_re from django . contrib . gis . geoip . libgeoip import GEOIP_SETTINGS from django . contrib . gis . geoip . prototypes import ( GeoIPRecord , GeoIPTag , GeoIP_open , GeoIP_delete , GeoIP_database_info , GeoIP_lib_version , GeoIP_record_by_addr , GeoIP_record_by_name , GeoIP_country_code_by_addr , GeoIP_country_code_by_name , GeoIP_country_name_by_addr , GeoIP_country_name_by_name ) free_regex = re . compile ( r'^GEO-\d{3}FREE' ) lite_regex = re . compile ( r'^GEO-\d{3}LITE' ) class GeoIPException ( Exception ) : pass class GeoIP ( object ) : GEOIP_STANDARD = 0 GEOIP_MEMORY_CACHE = 1 GEOIP_CHECK_CACHE = 2 GEOIP_INDEX_CACHE = 4 GEOIP_MMAP_CACHE = 8 cache_options = dict ( ( opt , None ) for opt in ( 0 , 1 , 2 , 4 , 8 ) ) _city_file = '' _country_file = '' _city = None _country = None def __init__ ( self , path = None , cache = 0 , country = None , city = None ) : if cache in self . cache_options : self . _cache = cache else : raise GeoIPException ( 'Invalid GeoIP caching option: %s' % cache ) if not path : path = GEOIP_SETTINGS . get ( 'GEOIP_PATH' , None ) if not path : raise GeoIPException ( 'GeoIP path must be provided via parameter or the GEOIP_PATH setting.' ) if not isinstance ( path , basestring ) : raise TypeError ( 'Invalid path type: %s' % type ( path ) . __name__ ) if os . path . isdir ( path ) : country_db = os . path . join ( path , country or GEOIP_SETTINGS . get ( 'GEOIP_COUNTRY' , 'GeoIP.dat' ) ) if os . path . isfile ( country_db ) : self . _country = GeoIP_open ( country_db , cache ) self . _country_file = country_db city_db = os . path . join ( path , city or GEOIP_SETTINGS . get ( 'GEOIP_CITY' , 'GeoLiteCity.dat' ) ) if os . path . isfile ( city_db ) : self . _city = GeoIP_open ( city_db , cache ) self . _city_file = city_db elif os . path . isfile ( path ) : ptr = GeoIP_open ( path , cache ) info = GeoIP_database_info ( ptr ) if lite_regex . match ( info ) : self . _city = ptr self . _city_file = path elif free_regex . match ( info ) : self . _country = ptr self . _country_file = path else : raise GeoIPException ( 'Unable to recognize database edition: %s' % info ) else : raise GeoIPException ( 'GeoIP path must be a valid file or directory.' ) def __del__ ( self ) : if self . _country : GeoIP_delete ( self . _country ) if self . _city : GeoIP_delete ( self . _city ) def _check_query ( self , query , country = False , city = False , city_or_country = False ) : if not isinstance ( query , basestring ) : raise TypeError ( 'GeoIP query must be a string, not type %s' % type ( query ) . __name__ ) query = query . encode ( 'ascii' ) if city_or_country and not ( self . _country or self . _city ) : raise GeoIPException ( 'Invalid GeoIP country and city data files.' ) elif country and not self . _country : raise GeoIPException ( 'Invalid GeoIP country data file: %s' % self . _country_file ) elif city and not self . _city : raise GeoIPException ( 'Invalid GeoIP city data file: %s' % self . _city_file ) return query def city ( self , query ) : query = self . _check_query ( query , city = True ) if ipv4_re . match ( query ) : return GeoIP_record_by_addr ( self . _city , c_char_p ( query ) ) else : return GeoIP_record_by_name ( self . _city , c_char_p ( query ) ) def country_code ( self , query ) : query = self . _check_query ( query , city_or_country = True ) if self . _country : if ipv4_re . match ( query ) : return GeoIP_country_code_by_addr ( self . _country , query ) else : return GeoIP_country_code_by_name ( self . _country , query ) else : return self . city ( query ) [ 'country_code' ] def country_name ( self , query ) : query = self . _check_query ( query , city_or_country = True ) if self . _country : if ipv4_re . match ( query ) : return GeoIP_country_name_by_addr ( self . _country , query ) else : return GeoIP_country_name_by_name ( self . _country , query ) else : return self . city ( query ) [ 'country_name' ] def country ( self , query ) : return { 'country_code' : self . country_code ( query ) , : self . country_name ( query ) , } def coords ( self , query , ordering = ( 'longitude' , 'latitude' ) ) : cdict = self . city ( query ) if cdict is None : return None else : return tuple ( cdict [ o ] for o in ordering ) def lon_lat ( self , query ) : return self . coords ( query ) def lat_lon ( self , query ) : return self . coords ( query , ( 'latitude' , 'longitude' ) ) def geos ( self , query ) : ll = self . lon_lat ( query ) if ll : from django . contrib . gis . geos import Point return Point ( ll , srid = 4326 ) else : return None @ property def country_info ( self ) : if self . _country is None : ci = 'No GeoIP Country data in "%s"' % self . _country_file else : ci = GeoIP_database_info ( self . _country ) return ci @ property def city_info ( self ) : if self . _city is None : ci = 'No GeoIP City data in "%s"' % self . _city_file else : ci = GeoIP_database_info ( self . _city ) return ci @ property def info ( self ) : info = '' if GeoIP_lib_version : info += 'GeoIP Library:\n\t%s\n' % GeoIP_lib_version ( ) return info + 'Country:\n\t%s\nCity:\n\t%s' % ( self . country_info , self . city_info ) @ classmethod def open ( cls , full_path , cache ) : return GeoIP ( full_path , cache ) def _rec_by_arg ( self , arg ) : if self . _city : return self . city ( arg ) else : return self . country ( arg ) region_by_addr = city region_by_name = city record_by_addr = _rec_by_arg record_by_name = _rec_by_arg country_code_by_addr = country_code country_code_by_name = country_code country_name_by_addr = country_name country_name_by_name = country_name

""" This module collects helper functions and classes that "span" multiple levels of MVC. In other words, these functions/classes introduce controlled coupling for convenience's sake. """ from django . template import loader , RequestContext from django . http import HttpResponse , Http404 from django . http import HttpResponseRedirect , HttpResponsePermanentRedirect from django . db . models . manager import Manager from django . db . models . query import QuerySet from django . core import urlresolvers def render_to_response ( * args , ** kwargs ) : httpresponse_kwargs = { 'mimetype' : kwargs . pop ( 'mimetype' , None ) } return HttpResponse ( loader . render_to_string ( * args , ** kwargs ) , ** httpresponse_kwargs ) def render ( request , * args , ** kwargs ) : httpresponse_kwargs = { : kwargs . pop ( 'content_type' , None ) , : kwargs . pop ( 'status' , None ) , } if 'context_instance' in kwargs : context_instance = kwargs . pop ( 'context_instance' ) if kwargs . get ( 'current_app' , None ) : raise ValueError ( 'If you provide a context_instance you must ' ) else : current_app = kwargs . pop ( 'current_app' , None ) context_instance = RequestContext ( request , current_app = current_app ) kwargs [ 'context_instance' ] = context_instance return HttpResponse ( loader . render_to_string ( * args , ** kwargs ) , ** httpresponse_kwargs ) def redirect ( to , * args , ** kwargs ) : if kwargs . pop ( 'permanent' , False ) : redirect_class = HttpResponsePermanentRedirect else : redirect_class = HttpResponseRedirect if hasattr ( to , 'get_absolute_url' ) : return redirect_class ( to . get_absolute_url ( ) ) try : return redirect_class ( urlresolvers . reverse ( to , args = args , kwargs = kwargs ) ) except urlresolvers . NoReverseMatch : if callable ( to ) : raise if '/' not in to and '.' not in to : raise return redirect_class ( to ) def _get_queryset ( klass ) : if isinstance ( klass , QuerySet ) : return klass elif isinstance ( klass , Manager ) : manager = klass else : manager = klass . _default_manager return manager . all ( ) def get_object_or_404 ( klass , * args , ** kwargs ) : queryset = _get_queryset ( klass ) try : return queryset . get ( * args , ** kwargs ) except queryset . model . DoesNotExist : raise Http404 ( 'No %s matches the given query.' % queryset . model . _meta . object_name ) def get_list_or_404 ( klass , * args , ** kwargs ) : queryset = _get_queryset ( klass ) obj_list = list ( queryset . filter ( * args , ** kwargs ) ) if not obj_list : raise Http404 ( 'No %s matches the given query.' % queryset . model . _meta . object_name ) return obj_list

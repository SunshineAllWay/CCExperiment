from __future__ import absolute_import import datetime import pickle import sys from django . conf import settings from django . core . exceptions import FieldError from django . db import DatabaseError , connection , connections , DEFAULT_DB_ALIAS from django . db . models import Count from django . db . models . query import Q , ITER_CHUNK_SIZE , EmptyQuerySet from django . test import TestCase , skipUnlessDBFeature from django . utils import unittest from django . utils . datastructures import SortedDict from . models import ( Annotation , Article , Author , Celebrity , Child , Cover , Detail , DumbCategory , ExtraInfo , Fan , Item , LeafA , LoopX , LoopZ , ManagedModel , Member , NamedCategory , Note , Number , Plaything , PointerA , Ranking , Related , Report , ReservedName , Tag , TvChef , Valid , X , Food , Eaten , Node , ObjectA , ObjectB , ObjectC , CategoryItem , SimpleCategory , SpecialCategory , OneToOneCategory ) class BaseQuerysetTest ( TestCase ) : def assertValueQuerysetEqual ( self , qs , values ) : return self . assertQuerysetEqual ( qs , values , transform = lambda x : x ) class Queries1Tests ( BaseQuerysetTest ) : def setUp ( self ) : generic = NamedCategory . objects . create ( name = "Generic" ) self . t1 = Tag . objects . create ( name = 't1' , category = generic ) self . t2 = Tag . objects . create ( name = 't2' , parent = self . t1 , category = generic ) self . t3 = Tag . objects . create ( name = 't3' , parent = self . t1 ) t4 = Tag . objects . create ( name = 't4' , parent = self . t3 ) self . t5 = Tag . objects . create ( name = 't5' , parent = self . t3 ) self . n1 = Note . objects . create ( note = 'n1' , misc = 'foo' , id = 1 ) n2 = Note . objects . create ( note = 'n2' , misc = 'bar' , id = 2 ) self . n3 = Note . objects . create ( note = 'n3' , misc = 'foo' , id = 3 ) ann1 = Annotation . objects . create ( name = 'a1' , tag = self . t1 ) ann1 . notes . add ( self . n1 ) ann2 = Annotation . objects . create ( name = 'a2' , tag = t4 ) ann2 . notes . add ( n2 , self . n3 ) self . e2 = ExtraInfo . objects . create ( info = 'e2' , note = n2 ) e1 = ExtraInfo . objects . create ( info = 'e1' , note = self . n1 ) self . a1 = Author . objects . create ( name = 'a1' , num = 1001 , extra = e1 ) self . a2 = Author . objects . create ( name = 'a2' , num = 2002 , extra = e1 ) a3 = Author . objects . create ( name = 'a3' , num = 3003 , extra = self . e2 ) self . a4 = Author . objects . create ( name = 'a4' , num = 4004 , extra = self . e2 ) self . time1 = datetime . datetime ( 2007 , 12 , 19 , 22 , 25 , 0 ) self . time2 = datetime . datetime ( 2007 , 12 , 19 , 21 , 0 , 0 ) time3 = datetime . datetime ( 2007 , 12 , 20 , 22 , 25 , 0 ) time4 = datetime . datetime ( 2007 , 12 , 20 , 21 , 0 , 0 ) self . i1 = Item . objects . create ( name = 'one' , created = self . time1 , modified = self . time1 , creator = self . a1 , note = self . n3 ) self . i1 . tags = [ self . t1 , self . t2 ] self . i2 = Item . objects . create ( name = 'two' , created = self . time2 , creator = self . a2 , note = n2 ) self . i2 . tags = [ self . t1 , self . t3 ] self . i3 = Item . objects . create ( name = 'three' , created = time3 , creator = self . a2 , note = self . n3 ) i4 = Item . objects . create ( name = 'four' , created = time4 , creator = self . a4 , note = self . n3 ) i4 . tags = [ t4 ] self . r1 = Report . objects . create ( name = 'r1' , creator = self . a1 ) Report . objects . create ( name = 'r2' , creator = a3 ) Report . objects . create ( name = 'r3' ) self . rank1 = Ranking . objects . create ( rank = 2 , author = self . a2 ) Cover . objects . create ( title = "first" , item = i4 ) Cover . objects . create ( title = "second" , item = self . i2 ) def test_ticket1050 ( self ) : self . assertQuerysetEqual ( Item . objects . filter ( tags__isnull = True ) , [ '<Item: three>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( tags__id__isnull = True ) , [ '<Item: three>' ] ) def test_ticket1801 ( self ) : self . assertQuerysetEqual ( Author . objects . filter ( item = self . i2 ) , [ '<Author: a2>' ] ) self . assertQuerysetEqual ( Author . objects . filter ( item = self . i3 ) , [ '<Author: a2>' ] ) self . assertQuerysetEqual ( Author . objects . filter ( item = self . i2 ) & Author . objects . filter ( item = self . i3 ) , [ '<Author: a2>' ] ) def test_ticket2306 ( self ) : query = Item . objects . filter ( tags = self . t2 ) . query self . assertTrue ( query . LOUTER not in [ x [ 2 ] for x in query . alias_map . values ( ) ] ) self . assertQuerysetEqual ( Item . objects . filter ( Q ( tags = self . t1 ) ) . order_by ( 'name' ) , [ '<Item: one>' , '<Item: two>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( Q ( tags = self . t1 ) ) . filter ( Q ( tags = self . t2 ) ) , [ '<Item: one>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( Q ( tags = self . t1 ) ) . filter ( Q ( creator__name = 'fred' ) | Q ( tags = self . t2 ) ) , [ '<Item: one>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( Q ( tags = self . t1 ) & Q ( tags = self . t2 ) ) , [ ] ) self . assertQuerysetEqual ( Item . objects . filter ( Q ( tags = self . t1 ) , Q ( creator__name = 'fred' ) | Q ( tags = self . t2 ) ) , [ ] ) qs = Author . objects . filter ( ranking__rank = 2 , ranking__id = self . rank1 . id ) self . assertQuerysetEqual ( list ( qs ) , [ '<Author: a2>' ] ) self . assertEqual ( 2 , qs . query . count_active_tables ( ) , 2 ) qs = Author . objects . filter ( ranking__rank = 2 ) . filter ( ranking__id = self . rank1 . id ) self . assertEqual ( qs . query . count_active_tables ( ) , 3 ) def test_ticket4464 ( self ) : self . assertQuerysetEqual ( Item . objects . filter ( tags = self . t1 ) . filter ( tags = self . t2 ) , [ '<Item: one>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( tags__in = [ self . t1 , self . t2 ] ) . distinct ( ) . order_by ( 'name' ) , [ '<Item: one>' , '<Item: two>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( tags__in = [ self . t1 , self . t2 ] ) . filter ( tags = self . t3 ) , [ '<Item: two>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( tags__in = [ self . t1 , self . t2 ] ) . order_by ( 'name' ) [ : 3 ] , [ '<Item: one>' , '<Item: one>' , '<Item: two>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( tags__in = [ self . t1 , self . t2 ] ) . distinct ( ) . order_by ( 'name' ) [ : 3 ] , [ '<Item: one>' , '<Item: two>' ] ) def test_tickets_2080_3592 ( self ) : self . assertQuerysetEqual ( Author . objects . filter ( item__name = 'one' ) | Author . objects . filter ( name = 'a3' ) , [ '<Author: a1>' , '<Author: a3>' ] ) self . assertQuerysetEqual ( Author . objects . filter ( Q ( item__name = 'one' ) | Q ( name = 'a3' ) ) , [ '<Author: a1>' , '<Author: a3>' ] ) self . assertQuerysetEqual ( Author . objects . filter ( Q ( name = 'a3' ) | Q ( item__name = 'one' ) ) , [ '<Author: a1>' , '<Author: a3>' ] ) self . assertQuerysetEqual ( Author . objects . filter ( Q ( item__name = 'three' ) | Q ( report__name = 'r3' ) ) , [ '<Author: a2>' ] ) def test_ticket6074 ( self ) : self . assertQuerysetEqual ( Author . objects . filter ( Q ( id__in = [ ] ) ) , [ ] ) self . assertQuerysetEqual ( Author . objects . filter ( Q ( id__in = [ ] ) | Q ( id__in = [ ] ) ) , [ ] ) def test_tickets_1878_2939 ( self ) : self . assertEqual ( Item . objects . values ( 'creator' ) . distinct ( ) . count ( ) , 3 ) xx = Item ( name = 'four' , created = self . time1 , creator = self . a2 , note = self . n1 ) xx . save ( ) self . assertEqual ( Item . objects . exclude ( name = 'two' ) . values ( 'creator' , 'name' ) . distinct ( ) . count ( ) , 4 ) self . assertEqual ( Item . objects . exclude ( name = 'two' ) . extra ( select = { 'foo' : '%s' } , select_params = ( 1 , ) ) . values ( 'creator' , 'name' , 'foo' ) . distinct ( ) . count ( ) , 4 ) self . assertEqual ( Item . objects . exclude ( name = 'two' ) . extra ( select = { 'foo' : '%s' } , select_params = ( 1 , ) ) . values ( 'creator' , 'name' ) . distinct ( ) . count ( ) , 4 ) xx . delete ( ) def test_ticket7323 ( self ) : self . assertEqual ( Item . objects . values ( 'creator' , 'name' ) . count ( ) , 4 ) def test_ticket2253 ( self ) : q1 = Item . objects . order_by ( 'name' ) q2 = Item . objects . filter ( id = self . i1 . id ) self . assertQuerysetEqual ( q1 , [ '<Item: four>' , '<Item: one>' , '<Item: three>' , '<Item: two>' ] ) self . assertQuerysetEqual ( q2 , [ '<Item: one>' ] ) self . assertQuerysetEqual ( ( q1 | q2 ) . order_by ( 'name' ) , [ '<Item: four>' , '<Item: one>' , '<Item: three>' , '<Item: two>' ] ) self . assertQuerysetEqual ( ( q1 & q2 ) . order_by ( 'name' ) , [ '<Item: one>' ] ) q1 = Item . objects . filter ( tags = self . t1 ) q2 = Item . objects . filter ( note = self . n3 , tags = self . t2 ) q3 = Item . objects . filter ( creator = self . a4 ) self . assertQuerysetEqual ( ( ( q1 & q2 ) | q3 ) . order_by ( 'name' ) , [ '<Item: four>' , '<Item: one>' ] ) def test_order_by_tables ( self ) : q1 = Item . objects . order_by ( 'name' ) q2 = Item . objects . filter ( id = self . i1 . id ) list ( q2 ) self . assertEqual ( len ( ( q1 & q2 ) . order_by ( 'name' ) . query . tables ) , 1 ) def test_order_by_join_unref ( self ) : qs = Celebrity . objects . order_by ( 'greatest_fan__fan_of' ) self . assertIn ( 'OUTER JOIN' , str ( qs . query ) ) qs = qs . order_by ( 'id' ) self . assertNotIn ( 'OUTER JOIN' , str ( qs . query ) ) def test_tickets_4088_4306 ( self ) : self . assertQuerysetEqual ( Report . objects . filter ( creator = 1001 ) , [ '<Report: r1>' ] ) self . assertQuerysetEqual ( Report . objects . filter ( creator__num = 1001 ) , [ '<Report: r1>' ] ) self . assertQuerysetEqual ( Report . objects . filter ( creator__id = 1001 ) , [ ] ) self . assertQuerysetEqual ( Report . objects . filter ( creator__id = self . a1 . id ) , [ '<Report: r1>' ] ) self . assertQuerysetEqual ( Report . objects . filter ( creator__name = 'a1' ) , [ '<Report: r1>' ] ) def test_ticket4510 ( self ) : self . assertQuerysetEqual ( Author . objects . filter ( report__name = 'r1' ) , [ '<Author: a1>' ] ) def test_ticket7378 ( self ) : self . assertQuerysetEqual ( self . a1 . report_set . all ( ) , [ '<Report: r1>' ] ) def test_tickets_5324_6704 ( self ) : self . assertQuerysetEqual ( Item . objects . filter ( tags__name = 't4' ) , [ '<Item: four>' ] ) self . assertQuerysetEqual ( Item . objects . exclude ( tags__name = 't4' ) . order_by ( 'name' ) . distinct ( ) , [ '<Item: one>' , '<Item: three>' , '<Item: two>' ] ) self . assertQuerysetEqual ( Item . objects . exclude ( tags__name = 't4' ) . order_by ( 'name' ) . distinct ( ) . reverse ( ) , [ '<Item: two>' , '<Item: three>' , '<Item: one>' ] ) self . assertQuerysetEqual ( Author . objects . exclude ( item__name = 'one' ) . distinct ( ) . order_by ( 'name' ) , [ '<Author: a2>' , '<Author: a3>' , '<Author: a4>' ] ) self . assertQuerysetEqual ( Item . objects . exclude ( tags__name = 't1' ) . order_by ( 'name' ) , [ '<Item: four>' , '<Item: three>' ] ) self . assertQuerysetEqual ( Item . objects . exclude ( tags__name = 't1' ) . exclude ( tags__name = 't4' ) , [ '<Item: three>' ] ) query = Item . objects . exclude ( creator__in = [ self . a1 , self . a2 ] ) . query self . assertTrue ( query . LOUTER not in [ x [ 2 ] for x in query . alias_map . values ( ) ] ) qs = Author . objects . filter ( id = self . a1 . id ) . filter ( Q ( extra__note = self . n1 ) | Q ( item__note = self . n3 ) ) self . assertEqual ( len ( [ x [ 2 ] for x in qs . query . alias_map . values ( ) if x [ 2 ] == query . LOUTER and qs . query . alias_refcount [ x [ 1 ] ] ] ) , 1 ) self . assertQuerysetEqual ( Tag . objects . filter ( parent__isnull = True ) . order_by ( 'name' ) , [ '<Tag: t1>' ] ) self . assertQuerysetEqual ( Tag . objects . exclude ( parent__isnull = True ) . order_by ( 'name' ) , [ '<Tag: t2>' , '<Tag: t3>' , '<Tag: t4>' , '<Tag: t5>' ] ) self . assertQuerysetEqual ( Tag . objects . exclude ( Q ( parent__name = 't1' ) | Q ( parent__isnull = True ) ) . order_by ( 'name' ) , [ '<Tag: t4>' , '<Tag: t5>' ] ) self . assertQuerysetEqual ( Tag . objects . exclude ( Q ( parent__isnull = True ) | Q ( parent__name = 't1' ) ) . order_by ( 'name' ) , [ '<Tag: t4>' , '<Tag: t5>' ] ) self . assertQuerysetEqual ( Tag . objects . exclude ( Q ( parent__parent__isnull = True ) ) . order_by ( 'name' ) , [ '<Tag: t4>' , '<Tag: t5>' ] ) self . assertQuerysetEqual ( Tag . objects . filter ( ~ Q ( parent__parent__isnull = True ) ) . order_by ( 'name' ) , [ '<Tag: t4>' , '<Tag: t5>' ] ) def test_ticket2091 ( self ) : t = Tag . objects . get ( name = 't4' ) self . assertQuerysetEqual ( Item . objects . filter ( tags__in = [ t ] ) , [ '<Item: four>' ] ) def test_heterogeneous_qs_combination ( self ) : self . assertRaisesMessage ( AssertionError , , lambda : Author . objects . all ( ) & Tag . objects . all ( ) ) self . assertRaisesMessage ( AssertionError , , lambda : Author . objects . all ( ) | Tag . objects . all ( ) ) def test_ticket3141 ( self ) : self . assertEqual ( Author . objects . extra ( select = { 'foo' : '1' } ) . count ( ) , 4 ) self . assertEqual ( Author . objects . extra ( select = { 'foo' : '%s' } , select_params = ( 1 , ) ) . count ( ) , 4 ) def test_ticket2400 ( self ) : self . assertQuerysetEqual ( Author . objects . filter ( item__isnull = True ) , [ '<Author: a3>' ] ) self . assertQuerysetEqual ( Tag . objects . filter ( item__isnull = True ) , [ '<Tag: t5>' ] ) def test_ticket2496 ( self ) : self . assertQuerysetEqual ( Item . objects . extra ( tables = [ 'queries_author' ] ) . select_related ( ) . order_by ( 'name' ) [ : 1 ] , [ '<Item: four>' ] ) def test_tickets_2076_7256 ( self ) : self . assertQuerysetEqual ( Item . objects . order_by ( 'note__note' , 'name' ) , [ '<Item: two>' , '<Item: four>' , '<Item: one>' , '<Item: three>' ] ) self . assertQuerysetEqual ( Author . objects . order_by ( 'extra' , '-name' ) , [ '<Author: a2>' , '<Author: a1>' , '<Author: a4>' , '<Author: a3>' ] ) self . assertQuerysetEqual ( Cover . objects . all ( ) , [ '<Cover: first>' , '<Cover: second>' ] ) self . assertQuerysetEqual ( Item . objects . order_by ( 'creator' , 'name' ) , [ '<Item: one>' , '<Item: three>' , '<Item: two>' , '<Item: four>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( tags__isnull = False ) . order_by ( 'tags' , 'id' ) , [ '<Item: one>' , '<Item: two>' , '<Item: one>' , '<Item: two>' , '<Item: four>' ] ) qs = Item . objects . order_by ( 'name' ) self . assertQuerysetEqual ( qs , [ '<Item: four>' , '<Item: one>' , '<Item: three>' , '<Item: two>' ] ) self . assertEqual ( len ( qs . query . tables ) , 1 ) def test_tickets_2874_3002 ( self ) : qs = Item . objects . select_related ( ) . order_by ( 'note__note' , 'name' ) self . assertQuerysetEqual ( qs , [ '<Item: two>' , '<Item: four>' , '<Item: one>' , '<Item: three>' ] ) self . assertTrue ( repr ( qs [ 0 ] . note ) , '<Note: n2>' ) self . assertEqual ( repr ( qs [ 0 ] . creator . extra . note ) , '<Note: n1>' ) def test_ticket3037 ( self ) : self . assertQuerysetEqual ( Item . objects . filter ( Q ( creator__name = 'a3' , name = 'two' ) | Q ( creator__name = 'a4' , name = 'four' ) ) , [ '<Item: four>' ] ) def test_tickets_5321_7070 ( self ) : self . assertValueQuerysetEqual ( Note . objects . values ( 'misc' ) . distinct ( ) . order_by ( 'note' , '-misc' ) , [ { 'misc' : u'foo' } , { 'misc' : u'bar' } , { 'misc' : u'foo' } ] ) def test_ticket4358 ( self ) : self . assertTrue ( 'note_id' in ExtraInfo . objects . values ( ) [ 0 ] ) self . assertValueQuerysetEqual ( ExtraInfo . objects . values ( 'note_id' ) , [ { 'note_id' : 1 } , { 'note_id' : 2 } ] ) self . assertValueQuerysetEqual ( ExtraInfo . objects . values ( 'note' ) , [ { 'note' : 1 } , { 'note' : 2 } ] ) def test_ticket2902 ( self ) : s = [ ( 'a' , '%s' ) , ( 'b' , '%s' ) ] params = [ 'one' , 'two' ] if { 'a' : 1 , 'b' : 2 } . keys ( ) == [ 'a' , 'b' ] : s . reverse ( ) params . reverse ( ) d = Item . objects . extra ( select = SortedDict ( s ) , select_params = params ) . values ( 'a' , 'b' ) [ 0 ] self . assertEqual ( d , { 'a' : u'one' , 'b' : u'two' } ) l = Item . objects . extra ( select = { 'count' : 'select count(*) from queries_item_tags where queries_item_tags.item_id = queries_item.id' } ) . order_by ( '-count' ) self . assertEqual ( [ o . count for o in l ] , [ 2 , 2 , 1 , 0 ] ) def test_ticket6154 ( self ) : self . assertQuerysetEqual ( Author . objects . filter ( id = self . a1 . id ) . filter ( Q ( extra__note = self . n1 ) | Q ( item__note = self . n3 ) ) , [ '<Author: a1>' ] ) self . assertQuerysetEqual ( Author . objects . filter ( Q ( extra__note = self . n1 ) | Q ( item__note = self . n3 ) ) . filter ( id = self . a1 . id ) , [ '<Author: a1>' ] ) def test_ticket6981 ( self ) : self . assertQuerysetEqual ( Tag . objects . select_related ( 'parent' ) . order_by ( 'name' ) , [ '<Tag: t1>' , '<Tag: t2>' , '<Tag: t3>' , '<Tag: t4>' , '<Tag: t5>' ] ) def test_ticket9926 ( self ) : self . assertQuerysetEqual ( Tag . objects . select_related ( "parent" , "category" ) . order_by ( 'name' ) , [ '<Tag: t1>' , '<Tag: t2>' , '<Tag: t3>' , '<Tag: t4>' , '<Tag: t5>' ] ) self . assertQuerysetEqual ( Tag . objects . select_related ( 'parent' , "parent__category" ) . order_by ( 'name' ) , [ '<Tag: t1>' , '<Tag: t2>' , '<Tag: t3>' , '<Tag: t4>' , '<Tag: t5>' ] ) def test_tickets_6180_6203 ( self ) : self . assertEqual ( Item . objects . count ( ) , 4 ) self . assertEqual ( Item . objects . dates ( 'created' , 'month' ) . count ( ) , 1 ) self . assertEqual ( Item . objects . dates ( 'created' , 'day' ) . count ( ) , 2 ) self . assertEqual ( len ( Item . objects . dates ( 'created' , 'day' ) ) , 2 ) self . assertEqual ( Item . objects . dates ( 'created' , 'day' ) [ 0 ] , datetime . datetime ( 2007 , 12 , 19 , 0 , 0 ) ) def test_tickets_7087_12242 ( self ) : self . assertQuerysetEqual ( Item . objects . dates ( 'created' , 'day' ) . extra ( select = { 'a' : 1 } ) , [ 'datetime.datetime(2007, 12, 19, 0, 0)' , 'datetime.datetime(2007, 12, 20, 0, 0)' ] ) self . assertQuerysetEqual ( Item . objects . extra ( select = { 'a' : 1 } ) . dates ( 'created' , 'day' ) , [ 'datetime.datetime(2007, 12, 19, 0, 0)' , 'datetime.datetime(2007, 12, 20, 0, 0)' ] ) name = "one" self . assertQuerysetEqual ( Item . objects . dates ( 'created' , 'day' ) . extra ( where = [ 'name=%s' ] , params = [ name ] ) , [ 'datetime.datetime(2007, 12, 19, 0, 0)' ] ) self . assertQuerysetEqual ( Item . objects . extra ( where = [ 'name=%s' ] , params = [ name ] ) . dates ( 'created' , 'day' ) , [ 'datetime.datetime(2007, 12, 19, 0, 0)' ] ) def test_ticket7155 ( self ) : self . assertQuerysetEqual ( Item . objects . dates ( 'modified' , 'day' ) , [ 'datetime.datetime(2007, 12, 19, 0, 0)' ] ) def test_ticket7098 ( self ) : self . assertValueQuerysetEqual ( Item . objects . values ( 'note__note' ) . order_by ( 'queries_note.note' , 'id' ) , [ { 'note__note' : u'n2' } , { 'note__note' : u'n3' } , { 'note__note' : u'n3' } , { 'note__note' : u'n3' } ] ) def test_ticket7096 ( self ) : self . assertQuerysetEqual ( Tag . objects . filter ( parent = self . t1 , name = 't3' ) . order_by ( 'name' ) , [ '<Tag: t3>' ] ) self . assertQuerysetEqual ( Tag . objects . exclude ( parent = self . t1 , name = 't3' ) . order_by ( 'name' ) , [ '<Tag: t1>' , '<Tag: t2>' , '<Tag: t4>' , '<Tag: t5>' ] ) self . assertQuerysetEqual ( Item . objects . exclude ( tags__name = 't1' , name = 'one' ) . order_by ( 'name' ) . distinct ( ) , [ '<Item: four>' , '<Item: three>' , '<Item: two>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( name__in = [ 'three' , 'four' ] ) . exclude ( tags__name = 't1' ) . order_by ( 'name' ) , [ '<Item: four>' , '<Item: three>' ] ) self . assertQuerysetEqual ( Item . objects . exclude ( ~ Q ( tags__name = 't1' , name = 'one' ) ) , [ '<Item: one>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( ~ Q ( tags__name = 't1' , name = 'one' ) , name = 'two' ) , [ '<Item: two>' ] ) self . assertQuerysetEqual ( Item . objects . exclude ( ~ Q ( tags__name = 't1' , name = 'one' ) , name = 'two' ) , [ '<Item: four>' , '<Item: one>' , '<Item: three>' ] ) def test_tickets_7204_7506 ( self ) : pickle . dumps ( Item . objects . all ( ) ) def test_ticket7813 ( self ) : qs = Item . objects . select_related ( ) query = qs . query . get_compiler ( qs . db ) . as_sql ( ) [ 0 ] query2 = pickle . loads ( pickle . dumps ( qs . query ) ) self . assertEqual ( query2 . get_compiler ( qs . db ) . as_sql ( ) [ 0 ] , query ) def test_deferred_load_qs_pickling ( self ) : qs = Item . objects . defer ( 'name' , 'creator' ) q2 = pickle . loads ( pickle . dumps ( qs ) ) self . assertEqual ( list ( qs ) , list ( q2 ) ) q3 = pickle . loads ( pickle . dumps ( qs , pickle . HIGHEST_PROTOCOL ) ) self . assertEqual ( list ( qs ) , list ( q3 ) ) def test_ticket7277 ( self ) : self . assertQuerysetEqual ( self . n1 . annotation_set . filter ( Q ( tag = self . t5 ) | Q ( tag__children = self . t5 ) | Q ( tag__children__children = self . t5 ) ) , [ '<Annotation: a1>' ] ) def test_tickets_7448_7707 ( self ) : self . assertQuerysetEqual ( Item . objects . filter ( created__in = [ self . time1 , self . time2 ] ) , [ '<Item: one>' , '<Item: two>' ] ) def test_ticket7235 ( self ) : q = EmptyQuerySet ( ) self . assertQuerysetEqual ( q . all ( ) , [ ] ) self . assertQuerysetEqual ( q . filter ( x = 10 ) , [ ] ) self . assertQuerysetEqual ( q . exclude ( y = 3 ) , [ ] ) self . assertQuerysetEqual ( q . complex_filter ( { 'pk' : 1 } ) , [ ] ) self . assertQuerysetEqual ( q . select_related ( 'spam' , 'eggs' ) , [ ] ) self . assertQuerysetEqual ( q . annotate ( Count ( 'eggs' ) ) , [ ] ) self . assertQuerysetEqual ( q . order_by ( '-pub_date' , 'headline' ) , [ ] ) self . assertQuerysetEqual ( q . distinct ( ) , [ ] ) self . assertQuerysetEqual ( q . extra ( select = { 'is_recent' : "pub_date > '2006-01-01'" } ) , [ ] ) q . query . low_mark = 1 self . assertRaisesMessage ( AssertionError , , q . extra , select = { 'is_recent' : "pub_date > '2006-01-01'" } ) self . assertQuerysetEqual ( q . reverse ( ) , [ ] ) self . assertQuerysetEqual ( q . defer ( 'spam' , 'eggs' ) , [ ] ) self . assertQuerysetEqual ( q . only ( 'spam' , 'eggs' ) , [ ] ) def test_ticket7791 ( self ) : self . assertEqual ( len ( Note . objects . order_by ( 'extrainfo__info' ) . distinct ( ) ) , 3 ) qs = Item . objects . dates ( 'created' , 'month' ) _ = pickle . loads ( pickle . dumps ( qs ) ) def test_ticket9997 ( self ) : self . assertQuerysetEqual ( Tag . objects . filter ( name__in = Tag . objects . filter ( parent = self . t1 ) . values ( 'name' ) ) , [ '<Tag: t2>' , '<Tag: t3>' ] ) self . assertRaisesMessage ( TypeError , , lambda : Tag . objects . filter ( name__in = Tag . objects . filter ( parent = self . t1 ) . values ( 'name' , 'id' ) ) ) self . assertRaisesMessage ( TypeError , , lambda : Tag . objects . filter ( name__in = Tag . objects . filter ( parent = self . t1 ) . values_list ( 'name' , 'id' ) ) ) def test_ticket9985 ( self ) : self . assertValueQuerysetEqual ( Note . objects . values_list ( "note" , flat = True ) . values ( "id" ) . order_by ( "id" ) , [ { 'id' : 1 } , { 'id' : 2 } , { 'id' : 3 } ] ) self . assertQuerysetEqual ( Annotation . objects . filter ( notes__in = Note . objects . filter ( note = "n1" ) . values_list ( 'note' ) . values ( 'id' ) ) , [ '<Annotation: a1>' ] ) def test_ticket10205 ( self ) : self . assertEqual ( Tag . objects . filter ( name__in = ( ) ) . update ( name = "foo" ) , 0 ) def test_ticket10432 ( self ) : def f ( ) : return iter ( [ ] ) n_obj = Note . objects . all ( ) [ 0 ] def g ( ) : for i in [ n_obj . pk ] : yield i self . assertQuerysetEqual ( Note . objects . filter ( pk__in = f ( ) ) , [ ] ) self . assertEqual ( list ( Note . objects . filter ( pk__in = g ( ) ) ) , [ n_obj ] ) def test_ticket10742 ( self ) : subq = Author . objects . filter ( num__lt = 3000 ) qs = Author . objects . filter ( pk__in = subq ) self . assertQuerysetEqual ( qs , [ '<Author: a1>' , '<Author: a2>' ] ) self . assertTrue ( subq . _result_cache is None ) subq = Author . objects . filter ( num__lt = 3000 ) qs = Author . objects . exclude ( pk__in = subq ) self . assertQuerysetEqual ( qs , [ '<Author: a3>' , '<Author: a4>' ] ) self . assertTrue ( subq . _result_cache is None ) subq = Author . objects . filter ( num__lt = 3000 ) self . assertQuerysetEqual ( Author . objects . filter ( Q ( pk__in = subq ) & Q ( name = 'a1' ) ) , [ '<Author: a1>' ] ) self . assertTrue ( subq . _result_cache is None ) def test_ticket7076 ( self ) : self . assertQuerysetEqual ( Item . objects . exclude ( modified = self . time1 ) . order_by ( 'name' ) , [ '<Item: four>' , '<Item: three>' , '<Item: two>' ] ) self . assertQuerysetEqual ( Tag . objects . exclude ( parent__name = self . t1 . name ) , [ '<Tag: t1>' , '<Tag: t4>' , '<Tag: t5>' ] ) def test_ticket7181 ( self ) : self . assertEqual ( len ( Tag . objects . order_by ( 'parent__name' ) ) , 5 ) self . assertQuerysetEqual ( Note . objects . none ( ) | Note . objects . all ( ) , [ '<Note: n1>' , '<Note: n2>' , '<Note: n3>' ] ) self . assertQuerysetEqual ( Note . objects . all ( ) | Note . objects . none ( ) , [ '<Note: n1>' , '<Note: n2>' , '<Note: n3>' ] ) self . assertQuerysetEqual ( Note . objects . none ( ) & Note . objects . all ( ) , [ ] ) self . assertQuerysetEqual ( Note . objects . all ( ) & Note . objects . none ( ) , [ ] ) def test_ticket9411 ( self ) : qs = Tag . objects . values_list ( 'id' , flat = True ) . order_by ( 'id' ) qs . query . bump_prefix ( ) first = qs [ 0 ] self . assertEqual ( list ( qs ) , range ( first , first + 5 ) ) def test_ticket8439 ( self ) : self . assertQuerysetEqual ( Author . objects . filter ( Q ( item__note__extrainfo = self . e2 ) | Q ( report = self . r1 , name = 'xyz' ) ) , [ '<Author: a2>' ] ) self . assertQuerysetEqual ( Author . objects . filter ( Q ( report = self . r1 , name = 'xyz' ) | Q ( item__note__extrainfo = self . e2 ) ) , [ '<Author: a2>' ] ) self . assertQuerysetEqual ( Annotation . objects . filter ( Q ( tag__parent = self . t1 ) | Q ( notes__note = 'n1' , name = 'a1' ) ) , [ '<Annotation: a1>' ] ) xx = ExtraInfo . objects . create ( info = 'xx' , note = self . n3 ) self . assertQuerysetEqual ( Note . objects . filter ( Q ( extrainfo__author = self . a1 ) | Q ( extrainfo = xx ) ) , [ '<Note: n1>' , '<Note: n3>' ] ) xx . delete ( ) q = Note . objects . filter ( Q ( extrainfo__author = self . a1 ) | Q ( extrainfo = xx ) ) . query self . assertEqual ( len ( [ x [ 2 ] for x in q . alias_map . values ( ) if x [ 2 ] == q . LOUTER and q . alias_refcount [ x [ 1 ] ] ] ) , 1 ) def test_ticket17429 ( self ) : original_ordering = Tag . _meta . ordering Tag . _meta . ordering = None self . assertQuerysetEqual ( Tag . objects . all ( ) , [ '<Tag: t1>' , '<Tag: t2>' , '<Tag: t3>' , '<Tag: t4>' , '<Tag: t5>' ] , ) Tag . _meta . ordering = original_ordering class Queries2Tests ( TestCase ) : def setUp ( self ) : Number . objects . create ( num = 4 ) Number . objects . create ( num = 8 ) Number . objects . create ( num = 12 ) def test_ticket4289 ( self ) : self . assertQuerysetEqual ( Number . objects . filter ( num__lt = 4 ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__gt = 8 , num__lt = 12 ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__gt = 8 , num__lt = 13 ) , [ '<Number: 12>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( Q ( num__lt = 4 ) | Q ( num__gt = 8 , num__lt = 12 ) ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( Q ( num__gt = 8 , num__lt = 12 ) | Q ( num__lt = 4 ) ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( Q ( num__gt = 8 ) & Q ( num__lt = 12 ) | Q ( num__lt = 4 ) ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( Q ( num__gt = 7 ) & Q ( num__lt = 12 ) | Q ( num__lt = 4 ) ) , [ '<Number: 8>' ] ) def test_ticket12239 ( self ) : self . assertQuerysetEqual ( Number . objects . filter ( num__gt = 11.9 ) , [ '<Number: 12>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__gt = 12 ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__gt = 12.0 ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__gt = 12.1 ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__lt = 12 ) , [ '<Number: 4>' , '<Number: 8>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__lt = 12.0 ) , [ '<Number: 4>' , '<Number: 8>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__lt = 12.1 ) , [ '<Number: 4>' , '<Number: 8>' , '<Number: 12>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__gte = 11.9 ) , [ '<Number: 12>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__gte = 12 ) , [ '<Number: 12>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__gte = 12.0 ) , [ '<Number: 12>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__gte = 12.1 ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__gte = 12.9 ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__lte = 11.9 ) , [ '<Number: 4>' , '<Number: 8>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__lte = 12 ) , [ '<Number: 4>' , '<Number: 8>' , '<Number: 12>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__lte = 12.0 ) , [ '<Number: 4>' , '<Number: 8>' , '<Number: 12>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__lte = 12.1 ) , [ '<Number: 4>' , '<Number: 8>' , '<Number: 12>' ] ) self . assertQuerysetEqual ( Number . objects . filter ( num__lte = 12.9 ) , [ '<Number: 4>' , '<Number: 8>' , '<Number: 12>' ] ) def test_ticket7411 ( self ) : for num in range ( 2 * ITER_CHUNK_SIZE + 1 ) : _ = Number . objects . create ( num = num ) for i , obj in enumerate ( Number . objects . all ( ) ) : obj . save ( ) if i > 10 : break def test_ticket7759 ( self ) : count = Number . objects . count ( ) qs = Number . objects . all ( ) def run ( ) : for obj in qs : return qs . count ( ) == count self . assertTrue ( run ( ) ) class Queries3Tests ( BaseQuerysetTest ) : def test_ticket7107 ( self ) : self . assertQuerysetEqual ( Valid . objects . all ( ) , [ ] ) def test_ticket8683 ( self ) : self . assertRaisesMessage ( AssertionError , , Item . objects . dates , 'name' , 'month' ) class Queries4Tests ( BaseQuerysetTest ) : def setUp ( self ) : generic = NamedCategory . objects . create ( name = "Generic" ) self . t1 = Tag . objects . create ( name = 't1' , category = generic ) n1 = Note . objects . create ( note = 'n1' , misc = 'foo' , id = 1 ) n2 = Note . objects . create ( note = 'n2' , misc = 'bar' , id = 2 ) e1 = ExtraInfo . objects . create ( info = 'e1' , note = n1 ) e2 = ExtraInfo . objects . create ( info = 'e2' , note = n2 ) self . a1 = Author . objects . create ( name = 'a1' , num = 1001 , extra = e1 ) self . a3 = Author . objects . create ( name = 'a3' , num = 3003 , extra = e2 ) self . r1 = Report . objects . create ( name = 'r1' , creator = self . a1 ) self . r2 = Report . objects . create ( name = 'r2' , creator = self . a3 ) self . r3 = Report . objects . create ( name = 'r3' ) Item . objects . create ( name = 'i1' , created = datetime . datetime . now ( ) , note = n1 , creator = self . a1 ) Item . objects . create ( name = 'i2' , created = datetime . datetime . now ( ) , note = n1 , creator = self . a3 ) def test_ticket14876 ( self ) : q1 = Report . objects . filter ( Q ( creator__isnull = True ) | Q ( creator__extra__info = 'e1' ) ) q2 = Report . objects . filter ( Q ( creator__isnull = True ) ) | Report . objects . filter ( Q ( creator__extra__info = 'e1' ) ) self . assertQuerysetEqual ( q1 , [ "<Report: r1>" , "<Report: r3>" ] ) self . assertEqual ( str ( q1 . query ) , str ( q2 . query ) ) q1 = Report . objects . filter ( Q ( creator__extra__info = 'e1' ) | Q ( creator__isnull = True ) ) q2 = Report . objects . filter ( Q ( creator__extra__info = 'e1' ) ) | Report . objects . filter ( Q ( creator__isnull = True ) ) self . assertQuerysetEqual ( q1 , [ "<Report: r1>" , "<Report: r3>" ] ) self . assertEqual ( str ( q1 . query ) , str ( q2 . query ) ) q1 = Item . objects . filter ( Q ( creator = self . a1 ) | Q ( creator__report__name = 'r1' ) ) . order_by ( ) q2 = Item . objects . filter ( Q ( creator = self . a1 ) ) . order_by ( ) | Item . objects . filter ( Q ( creator__report__name = 'r1' ) ) . order_by ( ) self . assertQuerysetEqual ( q1 , [ "<Item: i1>" ] ) self . assertEqual ( str ( q1 . query ) , str ( q2 . query ) ) q1 = Item . objects . filter ( Q ( creator__report__name = 'e1' ) | Q ( creator = self . a1 ) ) . order_by ( ) q2 = Item . objects . filter ( Q ( creator__report__name = 'e1' ) ) . order_by ( ) | Item . objects . filter ( Q ( creator = self . a1 ) ) . order_by ( ) self . assertQuerysetEqual ( q1 , [ "<Item: i1>" ] ) self . assertEqual ( str ( q1 . query ) , str ( q2 . query ) ) def test_ticket7095 ( self ) : ManagedModel . objects . create ( data = 'mm1' , tag = self . t1 , public = True ) self . assertEqual ( ManagedModel . objects . update ( data = 'mm' ) , 1 ) if connection . features . interprets_empty_strings_as_nulls : expected_null_charfield_repr = u'' else : expected_null_charfield_repr = None self . assertValueQuerysetEqual ( Report . objects . values_list ( "creator__extra__info" , flat = True ) . order_by ( "name" ) , [ u'e1' , u'e2' , expected_null_charfield_repr ] , ) self . assertQuerysetEqual ( Report . objects . select_related ( "creator" , "creator__extra" ) . order_by ( "name" ) , [ '<Report: r1>' , '<Report: r2>' , '<Report: r3>' ] ) d1 = Detail . objects . create ( data = "d1" ) d2 = Detail . objects . create ( data = "d2" ) m1 = Member . objects . create ( name = "m1" , details = d1 ) m2 = Member . objects . create ( name = "m2" , details = d2 ) Child . objects . create ( person = m2 , parent = m1 ) obj = m1 . children . select_related ( "person__details" ) [ 0 ] self . assertEqual ( obj . person . details . data , u'd2' ) def test_order_by_resetting ( self ) : qs = Author . objects . order_by ( ) . order_by ( 'name' ) self . assertTrue ( 'ORDER BY' in qs . query . get_compiler ( qs . db ) . as_sql ( ) [ 0 ] ) def test_ticket10181 ( self ) : self . assertQuerysetEqual ( Tag . objects . filter ( id__in = Tag . objects . filter ( id__in = [ ] ) ) , [ ] ) def test_ticket15316_filter_false ( self ) : c1 = SimpleCategory . objects . create ( name = "category1" ) c2 = SpecialCategory . objects . create ( name = "named category1" , special_name = "special1" ) c3 = SpecialCategory . objects . create ( name = "named category2" , special_name = "special2" ) ci1 = CategoryItem . objects . create ( category = c1 ) ci2 = CategoryItem . objects . create ( category = c2 ) ci3 = CategoryItem . objects . create ( category = c3 ) qs = CategoryItem . objects . filter ( category__specialcategory__isnull = False ) self . assertEqual ( qs . count ( ) , 2 ) self . assertQuerysetEqual ( qs , [ ci2 . pk , ci3 . pk ] , lambda x : x . pk , False ) def test_ticket15316_exclude_false ( self ) : c1 = SimpleCategory . objects . create ( name = "category1" ) c2 = SpecialCategory . objects . create ( name = "named category1" , special_name = "special1" ) c3 = SpecialCategory . objects . create ( name = "named category2" , special_name = "special2" ) ci1 = CategoryItem . objects . create ( category = c1 ) ci2 = CategoryItem . objects . create ( category = c2 ) ci3 = CategoryItem . objects . create ( category = c3 ) qs = CategoryItem . objects . exclude ( category__specialcategory__isnull = False ) self . assertEqual ( qs . count ( ) , 1 ) self . assertQuerysetEqual ( qs , [ ci1 . pk ] , lambda x : x . pk ) def test_ticket15316_filter_true ( self ) : c1 = SimpleCategory . objects . create ( name = "category1" ) c2 = SpecialCategory . objects . create ( name = "named category1" , special_name = "special1" ) c3 = SpecialCategory . objects . create ( name = "named category2" , special_name = "special2" ) ci1 = CategoryItem . objects . create ( category = c1 ) ci2 = CategoryItem . objects . create ( category = c2 ) ci3 = CategoryItem . objects . create ( category = c3 ) qs = CategoryItem . objects . filter ( category__specialcategory__isnull = True ) self . assertEqual ( qs . count ( ) , 1 ) self . assertQuerysetEqual ( qs , [ ci1 . pk ] , lambda x : x . pk ) def test_ticket15316_exclude_true ( self ) : c1 = SimpleCategory . objects . create ( name = "category1" ) c2 = SpecialCategory . objects . create ( name = "named category1" , special_name = "special1" ) c3 = SpecialCategory . objects . create ( name = "named category2" , special_name = "special2" ) ci1 = CategoryItem . objects . create ( category = c1 ) ci2 = CategoryItem . objects . create ( category = c2 ) ci3 = CategoryItem . objects . create ( category = c3 ) qs = CategoryItem . objects . exclude ( category__specialcategory__isnull = True ) self . assertEqual ( qs . count ( ) , 2 ) self . assertQuerysetEqual ( qs , [ ci2 . pk , ci3 . pk ] , lambda x : x . pk , False ) def test_ticket15316_one2one_filter_false ( self ) : c = SimpleCategory . objects . create ( name = "cat" ) c0 = SimpleCategory . objects . create ( name = "cat0" ) c1 = SimpleCategory . objects . create ( name = "category1" ) c2 = OneToOneCategory . objects . create ( category = c1 , new_name = "new1" ) c3 = OneToOneCategory . objects . create ( category = c0 , new_name = "new2" ) ci1 = CategoryItem . objects . create ( category = c ) ci2 = CategoryItem . objects . create ( category = c0 ) ci3 = CategoryItem . objects . create ( category = c1 ) qs = CategoryItem . objects . filter ( category__onetoonecategory__isnull = False ) self . assertEqual ( qs . count ( ) , 2 ) self . assertQuerysetEqual ( qs , [ ci2 . pk , ci3 . pk ] , lambda x : x . pk , False ) def test_ticket15316_one2one_exclude_false ( self ) : c = SimpleCategory . objects . create ( name = "cat" ) c0 = SimpleCategory . objects . create ( name = "cat0" ) c1 = SimpleCategory . objects . create ( name = "category1" ) c2 = OneToOneCategory . objects . create ( category = c1 , new_name = "new1" ) c3 = OneToOneCategory . objects . create ( category = c0 , new_name = "new2" ) ci1 = CategoryItem . objects . create ( category = c ) ci2 = CategoryItem . objects . create ( category = c0 ) ci3 = CategoryItem . objects . create ( category = c1 ) qs = CategoryItem . objects . exclude ( category__onetoonecategory__isnull = False ) self . assertEqual ( qs . count ( ) , 1 ) self . assertQuerysetEqual ( qs , [ ci1 . pk ] , lambda x : x . pk ) def test_ticket15316_one2one_filter_true ( self ) : c = SimpleCategory . objects . create ( name = "cat" ) c0 = SimpleCategory . objects . create ( name = "cat0" ) c1 = SimpleCategory . objects . create ( name = "category1" ) c2 = OneToOneCategory . objects . create ( category = c1 , new_name = "new1" ) c3 = OneToOneCategory . objects . create ( category = c0 , new_name = "new2" ) ci1 = CategoryItem . objects . create ( category = c ) ci2 = CategoryItem . objects . create ( category = c0 ) ci3 = CategoryItem . objects . create ( category = c1 ) qs = CategoryItem . objects . filter ( category__onetoonecategory__isnull = True ) self . assertEqual ( qs . count ( ) , 1 ) self . assertQuerysetEqual ( qs , [ ci1 . pk ] , lambda x : x . pk ) def test_ticket15316_one2one_exclude_true ( self ) : c = SimpleCategory . objects . create ( name = "cat" ) c0 = SimpleCategory . objects . create ( name = "cat0" ) c1 = SimpleCategory . objects . create ( name = "category1" ) c2 = OneToOneCategory . objects . create ( category = c1 , new_name = "new1" ) c3 = OneToOneCategory . objects . create ( category = c0 , new_name = "new2" ) ci1 = CategoryItem . objects . create ( category = c ) ci2 = CategoryItem . objects . create ( category = c0 ) ci3 = CategoryItem . objects . create ( category = c1 ) qs = CategoryItem . objects . exclude ( category__onetoonecategory__isnull = True ) self . assertEqual ( qs . count ( ) , 2 ) self . assertQuerysetEqual ( qs , [ ci2 . pk , ci3 . pk ] , lambda x : x . pk , False ) class Queries5Tests ( TestCase ) : def setUp ( self ) : n1 = Note . objects . create ( note = 'n1' , misc = 'foo' , id = 1 ) n2 = Note . objects . create ( note = 'n2' , misc = 'bar' , id = 2 ) e1 = ExtraInfo . objects . create ( info = 'e1' , note = n1 ) e2 = ExtraInfo . objects . create ( info = 'e2' , note = n2 ) a1 = Author . objects . create ( name = 'a1' , num = 1001 , extra = e1 ) a2 = Author . objects . create ( name = 'a2' , num = 2002 , extra = e1 ) a3 = Author . objects . create ( name = 'a3' , num = 3003 , extra = e2 ) self . rank1 = Ranking . objects . create ( rank = 2 , author = a2 ) Ranking . objects . create ( rank = 1 , author = a3 ) Ranking . objects . create ( rank = 3 , author = a1 ) def test_ordering ( self ) : self . assertQuerysetEqual ( Ranking . objects . all ( ) , [ '<Ranking: 3: a1>' , '<Ranking: 2: a2>' , '<Ranking: 1: a3>' ] ) self . assertQuerysetEqual ( Ranking . objects . all ( ) . order_by ( 'rank' ) , [ '<Ranking: 1: a3>' , '<Ranking: 2: a2>' , '<Ranking: 3: a1>' ] ) self . assertQuerysetEqual ( Ranking . objects . extra ( tables = [ 'django_site' ] , order_by = [ '-django_site.id' , 'rank' ] ) , [ '<Ranking: 1: a3>' , '<Ranking: 2: a2>' , '<Ranking: 3: a1>' ] ) qs = Ranking . objects . extra ( select = { 'good' : 'case when rank > 2 then 1 else 0 end' } ) self . assertEqual ( [ o . good for o in qs . extra ( order_by = ( '-good' , ) ) ] , [ True , False , False ] ) self . assertQuerysetEqual ( qs . extra ( order_by = ( '-good' , 'id' ) ) , [ '<Ranking: 3: a1>' , '<Ranking: 2: a2>' , '<Ranking: 1: a3>' ] ) dicts = qs . values ( 'id' , 'rank' ) . order_by ( 'id' ) self . assertEqual ( [ d . items ( ) [ 1 ] for d in dicts ] , [ ( 'rank' , 2 ) , ( 'rank' , 1 ) , ( 'rank' , 3 ) ] ) def test_ticket7256 ( self ) : qs = Ranking . objects . extra ( select = { 'good' : 'case when rank > 2 then 1 else 0 end' } ) dicts = qs . values ( ) . order_by ( 'id' ) for d in dicts : del d [ 'id' ] ; del d [ 'author_id' ] self . assertEqual ( [ sorted ( d . items ( ) ) for d in dicts ] , [ [ ( 'good' , 0 ) , ( 'rank' , 2 ) ] , [ ( 'good' , 0 ) , ( 'rank' , 1 ) ] , [ ( 'good' , 1 ) , ( 'rank' , 3 ) ] ] ) def test_ticket7045 ( self ) : qs = Ranking . objects . extra ( tables = [ 'django_site' ] ) qs . query . get_compiler ( qs . db ) . as_sql ( ) qs . query . get_compiler ( qs . db ) . as_sql ( ) def test_ticket9848 ( self ) : self . assertQuerysetEqual ( Ranking . objects . filter ( author__name = 'a1' ) , [ '<Ranking: 3: a1>' ] ) self . assertEqual ( Ranking . objects . filter ( author__name = 'a1' ) . update ( rank = '4' ) , 1 ) r = Ranking . objects . filter ( author__name = 'a1' ) [ 0 ] self . assertNotEqual ( r . id , r . author . id ) self . assertEqual ( r . rank , 4 ) r . rank = 3 r . save ( ) self . assertQuerysetEqual ( Ranking . objects . all ( ) , [ '<Ranking: 3: a1>' , '<Ranking: 2: a2>' , '<Ranking: 1: a3>' ] ) def test_ticket5261 ( self ) : self . assertQuerysetEqual ( Note . objects . exclude ( Q ( ) ) , [ '<Note: n1>' , '<Note: n2>' ] ) class SelectRelatedTests ( TestCase ) : def test_tickets_3045_3288 ( self ) : self . assertQuerysetEqual ( X . objects . all ( ) , [ ] ) self . assertQuerysetEqual ( X . objects . select_related ( ) , [ ] ) class SubclassFKTests ( TestCase ) : def test_ticket7778 ( self ) : num_celebs = Celebrity . objects . count ( ) tvc = TvChef . objects . create ( name = "Huey" ) self . assertEqual ( Celebrity . objects . count ( ) , num_celebs + 1 ) Fan . objects . create ( fan_of = tvc ) Fan . objects . create ( fan_of = tvc ) tvc . delete ( ) self . assertEqual ( Celebrity . objects . count ( ) , num_celebs ) class CustomPkTests ( TestCase ) : def test_ticket7371 ( self ) : self . assertQuerysetEqual ( Related . objects . order_by ( 'custom' ) , [ ] ) class NullableRelOrderingTests ( TestCase ) : def test_ticket10028 ( self ) : _ = Plaything . objects . create ( name = "p1" ) self . assertQuerysetEqual ( Plaything . objects . all ( ) , [ '<Plaything: p1>' ] ) class DisjunctiveFilterTests ( TestCase ) : def setUp ( self ) : self . n1 = Note . objects . create ( note = 'n1' , misc = 'foo' , id = 1 ) ExtraInfo . objects . create ( info = 'e1' , note = self . n1 ) def test_ticket7872 ( self ) : LeafA . objects . create ( data = 'first' ) self . assertQuerysetEqual ( LeafA . objects . all ( ) , [ '<LeafA: first>' ] ) self . assertQuerysetEqual ( LeafA . objects . filter ( Q ( data = 'first' ) | Q ( join__b__data = 'second' ) ) , [ '<LeafA: first>' ] ) def test_ticket8283 ( self ) : self . assertQuerysetEqual ( ( ExtraInfo . objects . filter ( note = self . n1 ) | ExtraInfo . objects . filter ( info = 'e2' ) ) . filter ( note = self . n1 ) , [ '<ExtraInfo: e1>' ] ) self . assertQuerysetEqual ( ( ExtraInfo . objects . filter ( info = 'e2' ) | ExtraInfo . objects . filter ( note = self . n1 ) ) . filter ( note = self . n1 ) , [ '<ExtraInfo: e1>' ] ) class Queries6Tests ( TestCase ) : def setUp ( self ) : generic = NamedCategory . objects . create ( name = "Generic" ) t1 = Tag . objects . create ( name = 't1' , category = generic ) t2 = Tag . objects . create ( name = 't2' , parent = t1 , category = generic ) t3 = Tag . objects . create ( name = 't3' , parent = t1 ) t4 = Tag . objects . create ( name = 't4' , parent = t3 ) t5 = Tag . objects . create ( name = 't5' , parent = t3 ) n1 = Note . objects . create ( note = 'n1' , misc = 'foo' , id = 1 ) ann1 = Annotation . objects . create ( name = 'a1' , tag = t1 ) ann1 . notes . add ( n1 ) ann2 = Annotation . objects . create ( name = 'a2' , tag = t4 ) def test_slicing_and_cache_interaction ( self ) : from django . db . models import query query . ITER_CHUNK_SIZE = 2 qs = Tag . objects . all ( ) self . assertTrue ( bool ( qs ) ) self . assertEqual ( len ( qs . _result_cache ) , 2 ) self . assertEqual ( repr ( qs [ 4 ] ) , '<Tag: t5>' ) self . assertEqual ( len ( qs . _result_cache ) , 5 ) self . assertRaises ( IndexError , lambda : qs [ 100 ] ) def test_parallel_iterators ( self ) : qs = Tag . objects . all ( ) i1 , i2 = iter ( qs ) , iter ( qs ) self . assertEqual ( repr ( i1 . next ( ) ) , '<Tag: t1>' ) self . assertEqual ( repr ( i1 . next ( ) ) , '<Tag: t2>' ) self . assertEqual ( repr ( i2 . next ( ) ) , '<Tag: t1>' ) self . assertEqual ( repr ( i2 . next ( ) ) , '<Tag: t2>' ) self . assertEqual ( repr ( i2 . next ( ) ) , '<Tag: t3>' ) self . assertEqual ( repr ( i1 . next ( ) ) , '<Tag: t3>' ) qs = X . objects . all ( ) self . assertEqual ( bool ( qs ) , False ) self . assertEqual ( bool ( qs ) , False ) def test_nested_queries_sql ( self ) : qs = Annotation . objects . filter ( notes__in = Note . objects . filter ( note = "xyzzy" ) ) self . assertEqual ( qs . query . get_compiler ( qs . db ) . as_sql ( ) [ 0 ] . count ( 'SELECT' ) , 2 ) def test_tickets_8921_9188 ( self ) : self . assertQuerysetEqual ( PointerA . objects . filter ( connection__pointerb__id = 1 ) , [ ] ) self . assertQuerysetEqual ( PointerA . objects . exclude ( connection__pointerb__id = 1 ) , [ ] ) self . assertQuerysetEqual ( Tag . objects . exclude ( children = None ) , [ '<Tag: t1>' , '<Tag: t3>' ] ) self . assertQuerysetEqual ( Tag . objects . exclude ( parent__annotation__name = "a1" ) , [ '<Tag: t1>' , '<Tag: t4>' , '<Tag: t5>' ] ) self . assertQuerysetEqual ( Annotation . objects . exclude ( tag__children__name = "t2" ) , [ '<Annotation: a2>' ] ) self . assertQuerysetEqual ( Annotation . objects . filter ( notes__in = Note . objects . filter ( note = "n1" ) ) , [ '<Annotation: a1>' ] ) def test_ticket3739 ( self ) : q1 = Tag . objects . order_by ( 'name' ) self . assertIsNot ( q1 , q1 . all ( ) ) class RawQueriesTests ( TestCase ) : def setUp ( self ) : n1 = Note . objects . create ( note = 'n1' , misc = 'foo' , id = 1 ) def test_ticket14729 ( self ) : query = "SELECT * FROM queries_note WHERE note = %s" params = [ 'n1' ] qs = Note . objects . raw ( query , params = params ) self . assertEqual ( repr ( qs ) , "<RawQuerySet: 'SELECT * FROM queries_note WHERE note = n1'>" ) query = "SELECT * FROM queries_note WHERE note = %s and misc = %s" params = [ 'n1' , 'foo' ] qs = Note . objects . raw ( query , params = params ) self . assertEqual ( repr ( qs ) , "<RawQuerySet: 'SELECT * FROM queries_note WHERE note = n1 and misc = foo'>" ) class GeneratorExpressionTests ( TestCase ) : def test_ticket10432 ( self ) : self . assertQuerysetEqual ( Note . objects . filter ( pk__in = ( x for x in ( ) ) ) , [ ] ) class ComparisonTests ( TestCase ) : def setUp ( self ) : self . n1 = Note . objects . create ( note = 'n1' , misc = 'foo' , id = 1 ) e1 = ExtraInfo . objects . create ( info = 'e1' , note = self . n1 ) self . a2 = Author . objects . create ( name = 'a2' , num = 2002 , extra = e1 ) def test_ticket8597 ( self ) : _ = Item . objects . create ( name = "a_b" , created = datetime . datetime . now ( ) , creator = self . a2 , note = self . n1 ) _ = Item . objects . create ( name = "x%y" , created = datetime . datetime . now ( ) , creator = self . a2 , note = self . n1 ) self . assertQuerysetEqual ( Item . objects . filter ( name__iexact = "A_b" ) , [ '<Item: a_b>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( name__iexact = "x%Y" ) , [ '<Item: x%y>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( name__istartswith = "A_b" ) , [ '<Item: a_b>' ] ) self . assertQuerysetEqual ( Item . objects . filter ( name__iendswith = "A_b" ) , [ '<Item: a_b>' ] ) class ExistsSql ( TestCase ) : def setUp ( self ) : settings . DEBUG = True def test_exists ( self ) : self . assertFalse ( Tag . objects . exists ( ) ) self . assertTrue ( "id" not in connection . queries [ - 1 ] [ 'sql' ] and "name" not in connection . queries [ - 1 ] [ 'sql' ] ) def tearDown ( self ) : settings . DEBUG = False class QuerysetOrderedTests ( unittest . TestCase ) : def test_no_default_or_explicit_ordering ( self ) : self . assertEqual ( Annotation . objects . all ( ) . ordered , False ) def test_cleared_default_ordering ( self ) : self . assertEqual ( Tag . objects . all ( ) . ordered , True ) self . assertEqual ( Tag . objects . all ( ) . order_by ( ) . ordered , False ) def test_explicit_ordering ( self ) : self . assertEqual ( Annotation . objects . all ( ) . order_by ( 'id' ) . ordered , True ) def test_order_by_extra ( self ) : self . assertEqual ( Annotation . objects . all ( ) . extra ( order_by = [ 'id' ] ) . ordered , True ) def test_annotated_ordering ( self ) : qs = Annotation . objects . annotate ( num_notes = Count ( 'notes' ) ) self . assertEqual ( qs . ordered , False ) self . assertEqual ( qs . order_by ( 'num_notes' ) . ordered , True ) class SubqueryTests ( TestCase ) : def setUp ( self ) : DumbCategory . objects . create ( id = 1 ) DumbCategory . objects . create ( id = 2 ) DumbCategory . objects . create ( id = 3 ) def test_ordered_subselect ( self ) : try : query = DumbCategory . objects . filter ( id__in = DumbCategory . objects . order_by ( '-id' ) [ 0 : 2 ] ) self . assertEqual ( set ( query . values_list ( 'id' , flat = True ) ) , set ( [ 2 , 3 ] ) ) query = DumbCategory . objects . filter ( id__in = DumbCategory . objects . order_by ( '-id' ) [ : 2 ] ) self . assertEqual ( set ( query . values_list ( 'id' , flat = True ) ) , set ( [ 2 , 3 ] ) ) query = DumbCategory . objects . filter ( id__in = DumbCategory . objects . order_by ( '-id' ) [ 2 : ] ) self . assertEqual ( set ( query . values_list ( 'id' , flat = True ) ) , set ( [ 1 ] ) ) except DatabaseError : self . assertFalse ( connections [ DEFAULT_DB_ALIAS ] . features . allow_sliced_subqueries ) def test_sliced_delete ( self ) : try : DumbCategory . objects . filter ( id__in = DumbCategory . objects . order_by ( '-id' ) [ 0 : 1 ] ) . delete ( ) self . assertEqual ( set ( DumbCategory . objects . values_list ( 'id' , flat = True ) ) , set ( [ 1 , 2 ] ) ) except DatabaseError : self . assertFalse ( connections [ DEFAULT_DB_ALIAS ] . features . allow_sliced_subqueries ) class CloneTests ( TestCase ) : def test_evaluated_queryset_as_argument ( self ) : n = Note ( note = 'Test1' , misc = 'misc' ) n . save ( ) e = ExtraInfo ( info = 'good' , note = n ) e . save ( ) n_list = Note . objects . all ( ) list ( n_list ) try : self . assertEqual ( ExtraInfo . objects . filter ( note__in = n_list ) [ 0 ] . info , 'good' ) except : self . fail ( 'Query should be clonable' ) class EmptyQuerySetTests ( TestCase ) : def test_emptyqueryset_values ( self ) : self . assertQuerysetEqual ( Number . objects . none ( ) . values ( 'num' ) . order_by ( 'num' ) , [ ] ) def test_values_subquery ( self ) : self . assertQuerysetEqual ( Number . objects . filter ( pk__in = Number . objects . none ( ) . values ( "pk" ) ) , [ ] ) self . assertQuerysetEqual ( Number . objects . filter ( pk__in = Number . objects . none ( ) . values_list ( "pk" ) ) , [ ] ) class ValuesQuerysetTests ( BaseQuerysetTest ) : def test_flat_values_lits ( self ) : Number . objects . create ( num = 72 ) qs = Number . objects . values_list ( "num" ) qs = qs . values_list ( "num" , flat = True ) self . assertValueQuerysetEqual ( qs , [ 72 ] ) class WeirdQuerysetSlicingTests ( BaseQuerysetTest ) : def setUp ( self ) : Number . objects . create ( num = 1 ) Number . objects . create ( num = 2 ) Article . objects . create ( name = 'one' , created = datetime . datetime . now ( ) ) Article . objects . create ( name = 'two' , created = datetime . datetime . now ( ) ) Article . objects . create ( name = 'three' , created = datetime . datetime . now ( ) ) Article . objects . create ( name = 'four' , created = datetime . datetime . now ( ) ) def test_tickets_7698_10202 ( self ) : self . assertQuerysetEqual ( Article . objects . all ( ) [ 0 : 0 ] , [ ] ) self . assertQuerysetEqual ( Article . objects . all ( ) [ 0 : 0 ] [ : 10 ] , [ ] ) self . assertEqual ( Article . objects . all ( ) [ : 0 ] . count ( ) , 0 ) self . assertRaisesMessage ( AssertionError , , Article . objects . all ( ) [ : 0 ] . latest , 'created' ) def test_empty_resultset_sql ( self ) : self . assertNumQueries ( 0 , lambda : list ( Number . objects . all ( ) [ 1 : 1 ] ) ) class EscapingTests ( TestCase ) : def test_ticket_7302 ( self ) : _ = ReservedName . objects . create ( name = 'a' , order = 42 ) ReservedName . objects . create ( name = 'b' , order = 37 ) self . assertQuerysetEqual ( ReservedName . objects . all ( ) . order_by ( 'order' ) , [ '<ReservedName: b>' , '<ReservedName: a>' ] ) self . assertQuerysetEqual ( ReservedName . objects . extra ( select = { 'stuff' : 'name' } , order_by = ( 'order' , 'stuff' ) ) , [ '<ReservedName: b>' , '<ReservedName: a>' ] ) class ToFieldTests ( TestCase ) : def test_in_query ( self ) : apple = Food . objects . create ( name = "apple" ) pear = Food . objects . create ( name = "pear" ) lunch = Eaten . objects . create ( food = apple , meal = "lunch" ) dinner = Eaten . objects . create ( food = pear , meal = "dinner" ) self . assertEqual ( set ( Eaten . objects . filter ( food__in = [ apple , pear ] ) ) , set ( [ lunch , dinner ] ) , ) def test_reverse_in ( self ) : apple = Food . objects . create ( name = "apple" ) pear = Food . objects . create ( name = "pear" ) lunch_apple = Eaten . objects . create ( food = apple , meal = "lunch" ) lunch_pear = Eaten . objects . create ( food = pear , meal = "dinner" ) self . assertEqual ( set ( Food . objects . filter ( eaten__in = [ lunch_apple , lunch_pear ] ) ) , set ( [ apple , pear ] ) ) def test_single_object ( self ) : apple = Food . objects . create ( name = "apple" ) lunch = Eaten . objects . create ( food = apple , meal = "lunch" ) dinner = Eaten . objects . create ( food = apple , meal = "dinner" ) self . assertEqual ( set ( Eaten . objects . filter ( food = apple ) ) , set ( [ lunch , dinner ] ) ) def test_single_object_reverse ( self ) : apple = Food . objects . create ( name = "apple" ) lunch = Eaten . objects . create ( food = apple , meal = "lunch" ) self . assertEqual ( set ( Food . objects . filter ( eaten = lunch ) ) , set ( [ apple ] ) ) def test_recursive_fk ( self ) : node1 = Node . objects . create ( num = 42 ) node2 = Node . objects . create ( num = 1 , parent = node1 ) self . assertEqual ( list ( Node . objects . filter ( parent = node1 ) ) , [ node2 ] ) def test_recursive_fk_reverse ( self ) : node1 = Node . objects . create ( num = 42 ) node2 = Node . objects . create ( num = 1 , parent = node1 ) self . assertEqual ( list ( Node . objects . filter ( node = node2 ) ) , [ node1 ] ) class ConditionalTests ( BaseQuerysetTest ) : def setUp ( self ) : generic = NamedCategory . objects . create ( name = "Generic" ) t1 = Tag . objects . create ( name = 't1' , category = generic ) t2 = Tag . objects . create ( name = 't2' , parent = t1 , category = generic ) t3 = Tag . objects . create ( name = 't3' , parent = t1 ) t4 = Tag . objects . create ( name = 't4' , parent = t3 ) t5 = Tag . objects . create ( name = 't5' , parent = t3 ) @ unittest . skipIf ( sys . version_info [ : 2 ] == ( 2 , 6 ) , "Python version is 2.6" ) def test_infinite_loop ( self ) : self . assertRaisesMessage ( FieldError , , lambda : list ( LoopX . objects . all ( ) ) ) self . assertRaisesMessage ( FieldError , , lambda : list ( LoopZ . objects . all ( ) ) ) self . assertEqual ( len ( Tag . objects . order_by ( 'parent' ) ) , 5 ) self . assertQuerysetEqual ( LoopX . objects . all ( ) . order_by ( 'y__x__y__x__id' ) , [ ] ) @ skipUnlessDBFeature ( 'requires_explicit_null_ordering_when_grouping' ) def test_null_ordering_added ( self ) : query = Tag . objects . values_list ( 'parent_id' , flat = True ) . order_by ( ) . query query . group_by = [ 'parent_id' ] sql = query . get_compiler ( DEFAULT_DB_ALIAS ) . as_sql ( ) [ 0 ] fragment = "ORDER BY " pos = sql . find ( fragment ) self . assertEqual ( sql . find ( fragment , pos + 1 ) , - 1 ) self . assertEqual ( sql . find ( "NULL" , pos + len ( fragment ) ) , pos + len ( fragment ) ) @ skipUnlessDBFeature ( 'supports_1000_query_parameters' ) def test_ticket14244 ( self ) : Number . objects . all ( ) . delete ( ) numbers = range ( 2500 ) for num in numbers : _ = Number . objects . create ( num = num ) self . assertEqual ( Number . objects . filter ( num__in = numbers [ : 1000 ] ) . count ( ) , 1000 ) self . assertEqual ( Number . objects . filter ( num__in = numbers [ : 1001 ] ) . count ( ) , 1001 ) self . assertEqual ( Number . objects . filter ( num__in = numbers [ : 2000 ] ) . count ( ) , 2000 ) self . assertEqual ( Number . objects . filter ( num__in = numbers ) . count ( ) , 2500 ) class UnionTests ( unittest . TestCase ) : def setUp ( self ) : objectas = [ ] objectbs = [ ] objectcs = [ ] a_info = [ 'one' , 'two' , 'three' ] for name in a_info : o = ObjectA ( name = name ) o . save ( ) objectas . append ( o ) b_info = [ ( 'un' , 1 , objectas [ 0 ] ) , ( 'deux' , 2 , objectas [ 0 ] ) , ( 'trois' , 3 , objectas [ 2 ] ) ] for name , number , objecta in b_info : o = ObjectB ( name = name , num = number , objecta = objecta ) o . save ( ) objectbs . append ( o ) c_info = [ ( 'ein' , objectas [ 2 ] , objectbs [ 2 ] ) , ( 'zwei' , objectas [ 1 ] , objectbs [ 1 ] ) ] for name , objecta , objectb in c_info : o = ObjectC ( name = name , objecta = objecta , objectb = objectb ) o . save ( ) objectcs . append ( o ) def check_union ( self , model , Q1 , Q2 ) : filter = model . objects . filter self . assertEqual ( set ( filter ( Q1 ) | filter ( Q2 ) ) , set ( filter ( Q1 | Q2 ) ) ) self . assertEqual ( set ( filter ( Q2 ) | filter ( Q1 ) ) , set ( filter ( Q1 | Q2 ) ) ) def test_A_AB ( self ) : Q1 = Q ( name = 'two' ) Q2 = Q ( objectb__name = 'deux' ) self . check_union ( ObjectA , Q1 , Q2 ) def test_A_AB2 ( self ) : Q1 = Q ( name = 'two' ) Q2 = Q ( objectb__name = 'deux' , objectb__num = 2 ) self . check_union ( ObjectA , Q1 , Q2 ) def test_AB_ACB ( self ) : Q1 = Q ( objectb__name = 'deux' ) Q2 = Q ( objectc__objectb__name = 'deux' ) self . check_union ( ObjectA , Q1 , Q2 ) def test_BAB_BAC ( self ) : Q1 = Q ( objecta__objectb__name = 'deux' ) Q2 = Q ( objecta__objectc__name = 'ein' ) self . check_union ( ObjectB , Q1 , Q2 ) def test_BAB_BACB ( self ) : Q1 = Q ( objecta__objectb__name = 'deux' ) Q2 = Q ( objecta__objectc__objectb__name = 'trois' ) self . check_union ( ObjectB , Q1 , Q2 ) def test_BA_BCA__BAB_BAC_BCA ( self ) : Q1 = Q ( objecta__name = 'one' , objectc__objecta__name = 'two' ) Q2 = Q ( objecta__objectc__name = 'ein' , objectc__objecta__name = 'three' , objecta__objectb__name = 'trois' ) self . check_union ( ObjectB , Q1 , Q2 ) class DefaultValuesInsertTest ( TestCase ) : def test_no_extra_params ( self ) : try : DumbCategory . objects . create ( ) except TypeError : self . fail ( "Creation of an instance of a model with only the PK field shouldn't error out after bulk insert refactoring (#17056)" )

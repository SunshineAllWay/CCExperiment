""" Distance and Area objects to allow for sensible and convienient calculation and conversions. Authors: Robert Coup, Justin Bronn Inspired by GeoPy (http://exogen.case.edu/projects/geopy/) and Geoff Biggs' PhD work on dimensioned units for robotics. """ __all__ = [ 'A' , 'Area' , 'D' , 'Distance' ] from decimal import Decimal class MeasureBase ( object ) : def default_units ( self , kwargs ) : val = 0.0 for unit , value in kwargs . iteritems ( ) : if not isinstance ( value , float ) : value = float ( value ) if unit in self . UNITS : val += self . UNITS [ unit ] * value default_unit = unit elif unit in self . ALIAS : u = self . ALIAS [ unit ] val += self . UNITS [ u ] * value default_unit = u else : lower = unit . lower ( ) if lower in self . UNITS : val += self . UNITS [ lower ] * value default_unit = lower elif lower in self . LALIAS : u = self . LALIAS [ lower ] val += self . UNITS [ u ] * value default_unit = u else : raise AttributeError ( 'Unknown unit type: %s' % unit ) return val , default_unit @ classmethod def unit_attname ( cls , unit_str ) : lower = unit_str . lower ( ) if unit_str in cls . UNITS : return unit_str elif lower in cls . UNITS : return lower elif lower in cls . LALIAS : return cls . LALIAS [ lower ] else : raise Exception ( 'Could not find a unit keyword associated with "%s"' % unit_str ) class Distance ( MeasureBase ) : UNITS = { : 20.1168 , : 20.116782 , : 20.1167645 , : 20.1167824944 , : 20.1167651216 , : 20.116756 , : 0.01 , : 0.304799471539 , : 0.914398414616 , : 0.3047972654 , : 0.201166195164 , : 1.8288 , : 0.3048 , : 1.0000135965 , : 0.304799710181508 , : 0.914398530744 , : 0.0254 , : 1000.0 , : 0.201168 , : 0.20116782 , : 0.20116765 , : 1.0 , : 1609.344 , : 0.001 , : 1852.0 , : 1853.184 , : 5.0292 , : 0.91439841 , : 0.304800609601 , : 0.000001 , : 0.9144 , } ALIAS = { : 'cm' , : 'ft' , : 'inch' , : 'km' , : 'km' , : 'm' , : 'm' , : 'um' , : 'um' , : 'mm' , : 'mm' , : 'mi' , : 'yd' , : 'british_chain_benoit' , : 'british_chain_sears' , : 'british_chain_sears_truncated' , : 'british_ft' , : 'british_ft' , : 'british_yd' , : 'british_yd' , : 'clarke_ft' , : 'clarke_link' , : 'chain_benoit' , : 'chain_sears' , : 'ft' , : 'german_m' , : 'gold_coast_ft' , : 'indian_yd' , : 'link_benoit' , : 'link_sears' , : 'nm' , : 'nm_uk' , : 'survey_ft' , : 'survey_ft' , : 'indian_yd' , : 'sears_yd' } LALIAS = dict ( [ ( k . lower ( ) , v ) for k , v in ALIAS . items ( ) ] ) def __init__ ( self , default_unit = None , ** kwargs ) : self . m , self . _default_unit = self . default_units ( kwargs ) if default_unit and isinstance ( default_unit , str ) : self . _default_unit = default_unit def __getattr__ ( self , name ) : if name in self . UNITS : return self . m / self . UNITS [ name ] else : raise AttributeError ( 'Unknown unit type: %s' % name ) def __repr__ ( self ) : return 'Distance(%s=%s)' % ( self . _default_unit , getattr ( self , self . _default_unit ) ) def __str__ ( self ) : return '%s %s' % ( getattr ( self , self . _default_unit ) , self . _default_unit ) def __cmp__ ( self , other ) : if isinstance ( other , Distance ) : return cmp ( self . m , other . m ) else : return NotImplemented def __add__ ( self , other ) : if isinstance ( other , Distance ) : return Distance ( default_unit = self . _default_unit , m = ( self . m + other . m ) ) else : raise TypeError ( 'Distance must be added with Distance' ) def __iadd__ ( self , other ) : if isinstance ( other , Distance ) : self . m += other . m return self else : raise TypeError ( 'Distance must be added with Distance' ) def __sub__ ( self , other ) : if isinstance ( other , Distance ) : return Distance ( default_unit = self . _default_unit , m = ( self . m - other . m ) ) else : raise TypeError ( 'Distance must be subtracted from Distance' ) def __isub__ ( self , other ) : if isinstance ( other , Distance ) : self . m -= other . m return self else : raise TypeError ( 'Distance must be subtracted from Distance' ) def __mul__ ( self , other ) : if isinstance ( other , ( int , float , long , Decimal ) ) : return Distance ( default_unit = self . _default_unit , m = ( self . m * float ( other ) ) ) elif isinstance ( other , Distance ) : return Area ( default_unit = 'sq_' + self . _default_unit , sq_m = ( self . m * other . m ) ) else : raise TypeError ( 'Distance must be multiplied with number or Distance' ) def __imul__ ( self , other ) : if isinstance ( other , ( int , float , long , Decimal ) ) : self . m *= float ( other ) return self else : raise TypeError ( 'Distance must be multiplied with number' ) def __rmul__ ( self , other ) : return self * other def __div__ ( self , other ) : if isinstance ( other , ( int , float , long , Decimal ) ) : return Distance ( default_unit = self . _default_unit , m = ( self . m / float ( other ) ) ) else : raise TypeError ( 'Distance must be divided with number' ) def __idiv__ ( self , other ) : if isinstance ( other , ( int , float , long , Decimal ) ) : self . m /= float ( other ) return self else : raise TypeError ( 'Distance must be divided with number' ) def __nonzero__ ( self ) : return bool ( self . m ) class Area ( MeasureBase ) : UNITS = dict ( [ ( 'sq_%s' % k , v ** 2 ) for k , v in Distance . UNITS . items ( ) ] ) ALIAS = dict ( [ ( k , 'sq_%s' % v ) for k , v in Distance . ALIAS . items ( ) ] ) LALIAS = dict ( [ ( k . lower ( ) , v ) for k , v in ALIAS . items ( ) ] ) def __init__ ( self , default_unit = None , ** kwargs ) : self . sq_m , self . _default_unit = self . default_units ( kwargs ) if default_unit and isinstance ( default_unit , str ) : self . _default_unit = default_unit def __getattr__ ( self , name ) : if name in self . UNITS : return self . sq_m / self . UNITS [ name ] else : raise AttributeError ( 'Unknown unit type: ' + name ) def __repr__ ( self ) : return 'Area(%s=%s)' % ( self . _default_unit , getattr ( self , self . _default_unit ) ) def __str__ ( self ) : return '%s %s' % ( getattr ( self , self . _default_unit ) , self . _default_unit ) def __cmp__ ( self , other ) : if isinstance ( other , Area ) : return cmp ( self . sq_m , other . sq_m ) else : return NotImplemented def __add__ ( self , other ) : if isinstance ( other , Area ) : return Area ( default_unit = self . _default_unit , sq_m = ( self . sq_m + other . sq_m ) ) else : raise TypeError ( 'Area must be added with Area' ) def __iadd__ ( self , other ) : if isinstance ( other , Area ) : self . sq_m += other . sq_m return self else : raise TypeError ( 'Area must be added with Area' ) def __sub__ ( self , other ) : if isinstance ( other , Area ) : return Area ( default_unit = self . _default_unit , sq_m = ( self . sq_m - other . sq_m ) ) else : raise TypeError ( 'Area must be subtracted from Area' ) def __isub__ ( self , other ) : if isinstance ( other , Area ) : self . sq_m -= other . sq_m return self else : raise TypeError ( 'Area must be subtracted from Area' ) def __mul__ ( self , other ) : if isinstance ( other , ( int , float , long , Decimal ) ) : return Area ( default_unit = self . _default_unit , sq_m = ( self . sq_m * float ( other ) ) ) else : raise TypeError ( 'Area must be multiplied with number' ) def __imul__ ( self , other ) : if isinstance ( other , ( int , float , long , Decimal ) ) : self . sq_m *= float ( other ) return self else : raise TypeError ( 'Area must be multiplied with number' ) def __rmul__ ( self , other ) : return self * other def __div__ ( self , other ) : if isinstance ( other , ( int , float , long , Decimal ) ) : return Area ( default_unit = self . _default_unit , sq_m = ( self . sq_m / float ( other ) ) ) else : raise TypeError ( 'Area must be divided with number' ) def __idiv__ ( self , other ) : if isinstance ( other , ( int , float , long , Decimal ) ) : self . sq_m /= float ( other ) return self else : raise TypeError ( 'Area must be divided with number' ) def __nonzero__ ( self ) : return bool ( self . sq_m ) D = Distance A = Area

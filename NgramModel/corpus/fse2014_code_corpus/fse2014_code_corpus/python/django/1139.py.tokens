"""SMTP email backend class.""" import smtplib import socket import threading from django . conf import settings from django . core . mail . backends . base import BaseEmailBackend from django . core . mail . utils import DNS_NAME from django . core . mail . message import sanitize_address class EmailBackend ( BaseEmailBackend ) : def __init__ ( self , host = None , port = None , username = None , password = None , use_tls = None , fail_silently = False , ** kwargs ) : super ( EmailBackend , self ) . __init__ ( fail_silently = fail_silently ) self . host = host or settings . EMAIL_HOST self . port = port or settings . EMAIL_PORT if username is None : self . username = settings . EMAIL_HOST_USER else : self . username = username if password is None : self . password = settings . EMAIL_HOST_PASSWORD else : self . password = password if use_tls is None : self . use_tls = settings . EMAIL_USE_TLS else : self . use_tls = use_tls self . connection = None self . _lock = threading . RLock ( ) def open ( self ) : if self . connection : return False try : self . connection = smtplib . SMTP ( self . host , self . port , local_hostname = DNS_NAME . get_fqdn ( ) ) if self . use_tls : self . connection . ehlo ( ) self . connection . starttls ( ) self . connection . ehlo ( ) if self . username and self . password : self . connection . login ( self . username , self . password ) return True except : if not self . fail_silently : raise def close ( self ) : try : try : self . connection . quit ( ) except socket . sslerror : self . connection . close ( ) except : if self . fail_silently : return raise finally : self . connection = None def send_messages ( self , email_messages ) : if not email_messages : return self . _lock . acquire ( ) try : new_conn_created = self . open ( ) if not self . connection : return num_sent = 0 for message in email_messages : sent = self . _send ( message ) if sent : num_sent += 1 if new_conn_created : self . close ( ) finally : self . _lock . release ( ) return num_sent def _send ( self , email_message ) : if not email_message . recipients ( ) : return False from_email = sanitize_address ( email_message . from_email , email_message . encoding ) recipients = [ sanitize_address ( addr , email_message . encoding ) for addr in email_message . recipients ( ) ] try : self . connection . sendmail ( from_email , recipients , email_message . message ( ) . as_string ( ) ) except : if not self . fail_silently : raise return False return True

from __future__ import absolute_import from datetime import date from django . contrib . gis . geos import GEOSGeometry , Point , MultiPoint from django . contrib . gis . db . models import Collect , Count , Extent , F , Union from django . contrib . gis . geometry . backend import Geometry from django . contrib . gis . tests . utils import mysql , oracle , no_mysql , no_oracle , no_spatialite from django . test import TestCase from . models import City , Location , DirectoryEntry , Parcel , Book , Author , Article class RelatedGeoModelTest ( TestCase ) : def test02_select_related ( self ) : qs1 = City . objects . all ( ) qs2 = City . objects . select_related ( ) qs3 = City . objects . select_related ( 'location' ) cities = ( ( 'Aurora' , 'TX' , - 97.516111 , 33.058333 ) , ( 'Roswell' , 'NM' , - 104.528056 , 33.387222 ) , ( 'Kecksburg' , 'PA' , - 79.460734 , 40.18476 ) , ) for qs in ( qs1 , qs2 , qs3 ) : for ref , c in zip ( cities , qs ) : nm , st , lon , lat = ref self . assertEqual ( nm , c . name ) self . assertEqual ( st , c . state ) self . assertEqual ( Point ( lon , lat ) , c . location . point ) @ no_mysql def test03_transform_related ( self ) : tol = 0 def check_pnt ( ref , pnt ) : self . assertAlmostEqual ( ref . x , pnt . x , tol ) self . assertAlmostEqual ( ref . y , pnt . y , tol ) self . assertEqual ( ref . srid , pnt . srid ) transformed = ( ( 'Kecksburg' , 2272 , 'POINT(1490553.98959621 314792.131023984)' ) , ( 'Roswell' , 2257 , 'POINT(481902.189077221 868477.766629735)' ) , ( 'Aurora' , 2276 , 'POINT(2269923.2484839 7069381.28722222)' ) , ) for name , srid , wkt in transformed : qs = list ( City . objects . filter ( name = name ) . transform ( srid , field_name = 'location__point' ) ) check_pnt ( GEOSGeometry ( wkt , srid ) , qs [ 0 ] . location . point ) @ no_mysql @ no_spatialite def test04a_related_extent_aggregate ( self ) : aggs = City . objects . aggregate ( Extent ( 'location__point' ) ) all_extent = ( - 104.528056 , 29.763374 , - 79.460734 , 40.18476 ) txpa_extent = ( - 97.516111 , 29.763374 , - 79.460734 , 40.18476 ) e1 = City . objects . extent ( field_name = 'location__point' ) e2 = City . objects . exclude ( state = 'NM' ) . extent ( field_name = 'location__point' ) e3 = aggs [ 'location__point__extent' ] tol = 4 for ref , e in [ ( all_extent , e1 ) , ( txpa_extent , e2 ) , ( all_extent , e3 ) ] : for ref_val , e_val in zip ( ref , e ) : self . assertAlmostEqual ( ref_val , e_val , tol ) @ no_mysql def test04b_related_union_aggregate ( self ) : aggs = City . objects . aggregate ( Union ( 'location__point' ) ) p1 = Point ( - 104.528056 , 33.387222 ) p2 = Point ( - 97.516111 , 33.058333 ) p3 = Point ( - 79.460734 , 40.18476 ) p4 = Point ( - 96.801611 , 32.782057 ) p5 = Point ( - 95.363151 , 29.763374 ) if oracle : ref_u1 = MultiPoint ( p4 , p5 , p3 , p1 , p2 , srid = 4326 ) ref_u2 = MultiPoint ( p3 , p2 , srid = 4326 ) else : ref_u1 = MultiPoint ( p1 , p2 , p4 , p5 , p3 , srid = 4326 ) ref_u2 = MultiPoint ( p2 , p3 , srid = 4326 ) u1 = City . objects . unionagg ( field_name = 'location__point' ) u2 = City . objects . exclude ( name__in = ( 'Roswell' , 'Houston' , 'Dallas' , 'Fort Worth' ) ) . unionagg ( field_name = 'location__point' ) u3 = aggs [ 'location__point__union' ] self . assertEqual ( ref_u1 , u1 ) self . assertEqual ( ref_u2 , u2 ) self . assertEqual ( ref_u1 , u3 ) def test05_select_related_fk_to_subclass ( self ) : l = list ( DirectoryEntry . objects . all ( ) . select_related ( ) ) def test06_f_expressions ( self ) : b1 = GEOSGeometry ( 'POLYGON((-97.501205 33.052520,-97.501205 33.052576,-97.501150 33.052576,-97.501150 33.052520,-97.501205 33.052520))' , srid = 4326 ) pcity = City . objects . get ( name = 'Aurora' ) c1 = pcity . location . point c2 = c1 . transform ( 2276 , clone = True ) b2 = c2 . buffer ( 100 ) p1 = Parcel . objects . create ( name = 'P1' , city = pcity , center1 = c1 , center2 = c2 , border1 = b1 , border2 = b2 ) c1 = b1 . centroid c2 = c1 . transform ( 2276 , clone = True ) p2 = Parcel . objects . create ( name = 'P2' , city = pcity , center1 = c1 , center2 = c2 , border1 = b1 , border2 = b1 ) qs = Parcel . objects . filter ( center1__within = F ( 'border1' ) ) self . assertEqual ( 1 , len ( qs ) ) self . assertEqual ( 'P2' , qs [ 0 ] . name ) if not mysql : qs = Parcel . objects . filter ( center2__within = F ( 'border1' ) ) self . assertEqual ( 1 , len ( qs ) ) self . assertEqual ( 'P2' , qs [ 0 ] . name ) qs = Parcel . objects . filter ( center1 = F ( 'city__location__point' ) ) self . assertEqual ( 1 , len ( qs ) ) self . assertEqual ( 'P1' , qs [ 0 ] . name ) if not mysql : qs = Parcel . objects . filter ( border2__contains = F ( 'city__location__point' ) ) self . assertEqual ( 1 , len ( qs ) ) self . assertEqual ( 'P1' , qs [ 0 ] . name ) def test07_values ( self ) : gqs = Location . objects . all ( ) gvqs = Location . objects . values ( ) gvlqs = Location . objects . values_list ( ) for m , d , t in zip ( gqs , gvqs , gvlqs ) : self . assertTrue ( isinstance ( d [ 'point' ] , Geometry ) ) self . assertTrue ( isinstance ( t [ 1 ] , Geometry ) ) self . assertEqual ( m . point , d [ 'point' ] ) self . assertEqual ( m . point , t [ 1 ] ) def test08_defer_only ( self ) : qs = Location . objects . all ( ) def_qs = Location . objects . defer ( 'point' ) for loc , def_loc in zip ( qs , def_qs ) : self . assertEqual ( loc . point , def_loc . point ) def test09_pk_relations ( self ) : city_ids = ( 1 , 2 , 3 , 4 , 5 ) loc_ids = ( 1 , 2 , 3 , 5 , 4 ) ids_qs = City . objects . order_by ( 'id' ) . values ( 'id' , 'location__id' ) for val_dict , c_id , l_id in zip ( ids_qs , city_ids , loc_ids ) : self . assertEqual ( val_dict [ 'id' ] , c_id ) self . assertEqual ( val_dict [ 'location__id' ] , l_id ) def test10_combine ( self ) : buf1 = City . objects . get ( name = 'Aurora' ) . location . point . buffer ( 0.1 ) buf2 = City . objects . get ( name = 'Kecksburg' ) . location . point . buffer ( 0.1 ) qs1 = City . objects . filter ( location__point__within = buf1 ) qs2 = City . objects . filter ( location__point__within = buf2 ) combined = qs1 | qs2 names = [ c . name for c in combined ] self . assertEqual ( 2 , len ( names ) ) self . assertTrue ( 'Aurora' in names ) self . assertTrue ( 'Kecksburg' in names ) def test11_geoquery_pickle ( self ) : import pickle from django . contrib . gis . db . models . sql import GeoQuery qs = City . objects . all ( ) q_str = pickle . dumps ( qs . query ) q = pickle . loads ( q_str ) self . assertEqual ( GeoQuery , q . __class__ ) @ no_oracle def test12a_count ( self ) : dallas = City . objects . get ( name = 'Dallas' ) loc = Location . objects . annotate ( num_cities = Count ( 'city' ) ) . get ( id = dallas . location . id ) self . assertEqual ( 2 , loc . num_cities ) def test12b_count ( self ) : qs = Author . objects . annotate ( num_books = Count ( 'books' ) ) . filter ( num_books__gt = 1 ) vqs = Author . objects . values ( 'name' ) . annotate ( num_books = Count ( 'books' ) ) . filter ( num_books__gt = 1 ) self . assertEqual ( 1 , len ( qs ) ) self . assertEqual ( 3 , qs [ 0 ] . num_books ) self . assertEqual ( 1 , len ( vqs ) ) self . assertEqual ( 3 , vqs [ 0 ] [ 'num_books' ] ) def test13c_count ( self ) : qs = Location . objects . filter ( id = 5 ) . annotate ( num_cities = Count ( 'city' ) ) . values ( 'id' , 'point' , 'num_cities' ) self . assertEqual ( 1 , len ( qs ) ) self . assertEqual ( 2 , qs [ 0 ] [ 'num_cities' ] ) self . assertTrue ( isinstance ( qs [ 0 ] [ 'point' ] , GEOSGeometry ) ) @ no_oracle def test13_select_related_null_fk ( self ) : no_author = Book . objects . create ( title = 'Without Author' ) b = Book . objects . select_related ( 'author' ) . get ( title = 'Without Author' ) self . assertEqual ( None , b . author ) @ no_mysql @ no_oracle @ no_spatialite def test14_collect ( self ) : ref_geom = GEOSGeometry ( 'MULTIPOINT(-97.516111 33.058333,-96.801611 32.782057,-95.363151 29.763374,-96.801611 32.782057)' ) c1 = City . objects . filter ( state = 'TX' ) . collect ( field_name = 'location__point' ) c2 = City . objects . filter ( state = 'TX' ) . aggregate ( Collect ( 'location__point' ) ) [ 'location__point__collect' ] for coll in ( c1 , c2 ) : self . assertEqual ( 4 , len ( coll ) ) self . assertEqual ( ref_geom , coll ) def test15_invalid_select_related ( self ) : qs = Article . objects . select_related ( 'author__article' ) sql = str ( qs . query ) def test16_annotated_date_queryset ( self ) : birth_years = [ dt . year for dt in list ( Author . objects . annotate ( num_books = Count ( 'books' ) ) . dates ( 'dob' , 'year' ) ) ] birth_years . sort ( ) self . assertEqual ( [ 1950 , 1974 ] , birth_years )

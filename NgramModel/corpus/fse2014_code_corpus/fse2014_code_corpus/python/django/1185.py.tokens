import sys from django import http from django . core import signals from django . utils . encoding import force_unicode from django . utils . importlib import import_module from django . utils . log import getLogger logger = getLogger ( 'django.request' ) class BaseHandler ( object ) : response_fixes = [ http . fix_location_header , http . conditional_content_removal , http . fix_IE_for_attach , http . fix_IE_for_vary , ] def __init__ ( self ) : self . _request_middleware = self . _view_middleware = self . _template_response_middleware = self . _response_middleware = self . _exception_middleware = None def load_middleware ( self ) : from django . conf import settings from django . core import exceptions self . _view_middleware = [ ] self . _template_response_middleware = [ ] self . _response_middleware = [ ] self . _exception_middleware = [ ] request_middleware = [ ] for middleware_path in settings . MIDDLEWARE_CLASSES : try : mw_module , mw_classname = middleware_path . rsplit ( '.' , 1 ) except ValueError : raise exceptions . ImproperlyConfigured ( '%s isn\'t a middleware module' % middleware_path ) try : mod = import_module ( mw_module ) except ImportError , e : raise exceptions . ImproperlyConfigured ( 'Error importing middleware %s: "%s"' % ( mw_module , e ) ) try : mw_class = getattr ( mod , mw_classname ) except AttributeError : raise exceptions . ImproperlyConfigured ( 'Middleware module "%s" does not define a "%s" class' % ( mw_module , mw_classname ) ) try : mw_instance = mw_class ( ) except exceptions . MiddlewareNotUsed : continue if hasattr ( mw_instance , 'process_request' ) : request_middleware . append ( mw_instance . process_request ) if hasattr ( mw_instance , 'process_view' ) : self . _view_middleware . append ( mw_instance . process_view ) if hasattr ( mw_instance , 'process_template_response' ) : self . _template_response_middleware . insert ( 0 , mw_instance . process_template_response ) if hasattr ( mw_instance , 'process_response' ) : self . _response_middleware . insert ( 0 , mw_instance . process_response ) if hasattr ( mw_instance , 'process_exception' ) : self . _exception_middleware . insert ( 0 , mw_instance . process_exception ) self . _request_middleware = request_middleware def get_response ( self , request ) : from django . core import exceptions , urlresolvers from django . conf import settings try : urlconf = settings . ROOT_URLCONF urlresolvers . set_urlconf ( urlconf ) resolver = urlresolvers . RegexURLResolver ( r'^/' , urlconf ) try : response = None for middleware_method in self . _request_middleware : response = middleware_method ( request ) if response : break if response is None : if hasattr ( request , "urlconf" ) : urlconf = request . urlconf urlresolvers . set_urlconf ( urlconf ) resolver = urlresolvers . RegexURLResolver ( r'^/' , urlconf ) callback , callback_args , callback_kwargs = resolver . resolve ( request . path_info ) for middleware_method in self . _view_middleware : response = middleware_method ( request , callback , callback_args , callback_kwargs ) if response : break if response is None : try : response = callback ( request , * callback_args , ** callback_kwargs ) except Exception , e : for middleware_method in self . _exception_middleware : response = middleware_method ( request , e ) if response : break if response is None : raise if response is None : try : view_name = callback . func_name except AttributeError : view_name = callback . __class__ . __name__ + '.__call__' raise ValueError ( "The view %s.%s didn't return an HttpResponse object." % ( callback . __module__ , view_name ) ) if hasattr ( response , 'render' ) and callable ( response . render ) : for middleware_method in self . _template_response_middleware : response = middleware_method ( request , response ) response = response . render ( ) except http . Http404 , e : logger . warning ( 'Not Found: %s' , request . path , extra = { : 404 , : request } ) if settings . DEBUG : from django . views import debug response = debug . technical_404_response ( request , e ) else : try : callback , param_dict = resolver . resolve404 ( ) response = callback ( request , ** param_dict ) except : try : response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) ) finally : signals . got_request_exception . send ( sender = self . __class__ , request = request ) except exceptions . PermissionDenied : logger . warning ( , request . path , extra = { : 403 , : request } ) try : callback , param_dict = resolver . resolve403 ( ) response = callback ( request , ** param_dict ) except : try : response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) ) finally : signals . got_request_exception . send ( sender = self . __class__ , request = request ) except SystemExit : raise except : signals . got_request_exception . send ( sender = self . __class__ , request = request ) response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) ) finally : urlresolvers . set_urlconf ( None ) try : for middleware_method in self . _response_middleware : response = middleware_method ( request , response ) response = self . apply_response_fixes ( request , response ) except : signals . got_request_exception . send ( sender = self . __class__ , request = request ) response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) ) return response def handle_uncaught_exception ( self , request , resolver , exc_info ) : from django . conf import settings if settings . DEBUG_PROPAGATE_EXCEPTIONS : raise logger . error ( 'Internal Server Error: %s' , request . path , exc_info = exc_info , extra = { : 500 , : request } ) if settings . DEBUG : from django . views import debug return debug . technical_500_response ( request , * exc_info ) if resolver . urlconf_module is None : raise exc_info [ 1 ] , None , exc_info [ 2 ] callback , param_dict = resolver . resolve500 ( ) return callback ( request , ** param_dict ) def apply_response_fixes ( self , request , response ) : for func in self . response_fixes : response = func ( request , response ) return response def get_script_name ( environ ) : from django . conf import settings if settings . FORCE_SCRIPT_NAME is not None : return force_unicode ( settings . FORCE_SCRIPT_NAME ) script_url = environ . get ( 'SCRIPT_URL' , u'' ) if not script_url : script_url = environ . get ( 'REDIRECT_URL' , u'' ) if script_url : return force_unicode ( script_url [ : - len ( environ . get ( 'PATH_INFO' , '' ) ) ] ) return force_unicode ( environ . get ( 'SCRIPT_NAME' , u'' ) )

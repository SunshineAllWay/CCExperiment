from django . db . utils import DatabaseError try : import thread except ImportError : import dummy_thread as thread from contextlib import contextmanager from django . conf import settings from django . db import DEFAULT_DB_ALIAS from django . db . backends import util from django . db . transaction import TransactionManagementError from django . utils . importlib import import_module from django . utils . timezone import is_aware class BaseDatabaseWrapper ( object ) : ops = None vendor = 'unknown' def __init__ ( self , settings_dict , alias = DEFAULT_DB_ALIAS , allow_thread_sharing = False ) : self . connection = None self . queries = [ ] self . settings_dict = settings_dict self . alias = alias self . use_debug_cursor = None self . transaction_state = [ ] self . savepoint_state = 0 self . _dirty = None self . _thread_ident = thread . get_ident ( ) self . allow_thread_sharing = allow_thread_sharing def __eq__ ( self , other ) : return self . alias == other . alias def __ne__ ( self , other ) : return not self == other def _commit ( self ) : if self . connection is not None : return self . connection . commit ( ) def _rollback ( self ) : if self . connection is not None : return self . connection . rollback ( ) def _enter_transaction_management ( self , managed ) : pass def _leave_transaction_management ( self , managed ) : pass def _savepoint ( self , sid ) : if not self . features . uses_savepoints : return self . cursor ( ) . execute ( self . ops . savepoint_create_sql ( sid ) ) def _savepoint_rollback ( self , sid ) : if not self . features . uses_savepoints : return self . cursor ( ) . execute ( self . ops . savepoint_rollback_sql ( sid ) ) def _savepoint_commit ( self , sid ) : if not self . features . uses_savepoints : return self . cursor ( ) . execute ( self . ops . savepoint_commit_sql ( sid ) ) def enter_transaction_management ( self , managed = True ) : if self . transaction_state : self . transaction_state . append ( self . transaction_state [ - 1 ] ) else : self . transaction_state . append ( settings . TRANSACTIONS_MANAGED ) if self . _dirty is None : self . _dirty = False self . _enter_transaction_management ( managed ) def leave_transaction_management ( self ) : self . _leave_transaction_management ( self . is_managed ( ) ) if self . transaction_state : del self . transaction_state [ - 1 ] else : raise TransactionManagementError ( "This code isn't under transaction " ) if self . _dirty : self . rollback ( ) raise TransactionManagementError ( "Transaction managed block ended with " ) self . _dirty = False def validate_thread_sharing ( self ) : if ( not self . allow_thread_sharing and self . _thread_ident != thread . get_ident ( ) ) : raise DatabaseError ( "DatabaseWrapper objects created in a " % ( self . alias , self . _thread_ident , thread . get_ident ( ) ) ) def is_dirty ( self ) : return self . _dirty def set_dirty ( self ) : if self . _dirty is not None : self . _dirty = True else : raise TransactionManagementError ( "This code isn't under transaction " ) def set_clean ( self ) : if self . _dirty is not None : self . _dirty = False else : raise TransactionManagementError ( "This code isn't under transaction management" ) self . clean_savepoints ( ) def clean_savepoints ( self ) : self . savepoint_state = 0 def is_managed ( self ) : if self . transaction_state : return self . transaction_state [ - 1 ] return settings . TRANSACTIONS_MANAGED def managed ( self , flag = True ) : top = self . transaction_state if top : top [ - 1 ] = flag if not flag and self . is_dirty ( ) : self . _commit ( ) self . set_clean ( ) else : raise TransactionManagementError ( "This code isn't under transaction " ) def commit_unless_managed ( self ) : self . validate_thread_sharing ( ) if not self . is_managed ( ) : self . _commit ( ) self . clean_savepoints ( ) else : self . set_dirty ( ) def rollback_unless_managed ( self ) : self . validate_thread_sharing ( ) if not self . is_managed ( ) : self . _rollback ( ) else : self . set_dirty ( ) def commit ( self ) : self . validate_thread_sharing ( ) self . _commit ( ) self . set_clean ( ) def rollback ( self ) : self . validate_thread_sharing ( ) self . _rollback ( ) self . set_clean ( ) def savepoint ( self ) : thread_ident = thread . get_ident ( ) self . savepoint_state += 1 tid = str ( thread_ident ) . replace ( '-' , '' ) sid = "s%s_x%d" % ( tid , self . savepoint_state ) self . _savepoint ( sid ) return sid def savepoint_rollback ( self , sid ) : self . validate_thread_sharing ( ) if self . savepoint_state : self . _savepoint_rollback ( sid ) def savepoint_commit ( self , sid ) : self . validate_thread_sharing ( ) if self . savepoint_state : self . _savepoint_commit ( sid ) @ contextmanager def constraint_checks_disabled ( self ) : disabled = self . disable_constraint_checking ( ) try : yield finally : if disabled : self . enable_constraint_checking ( ) def disable_constraint_checking ( self ) : pass def enable_constraint_checking ( self ) : pass def check_constraints ( self , table_names = None ) : pass def close ( self ) : self . validate_thread_sharing ( ) if self . connection is not None : self . connection . close ( ) self . connection = None def cursor ( self ) : self . validate_thread_sharing ( ) if ( self . use_debug_cursor or ( self . use_debug_cursor is None and settings . DEBUG ) ) : cursor = self . make_debug_cursor ( self . _cursor ( ) ) else : cursor = util . CursorWrapper ( self . _cursor ( ) , self ) return cursor def make_debug_cursor ( self , cursor ) : return util . CursorDebugWrapper ( cursor , self ) class BaseDatabaseFeatures ( object ) : allows_group_by_pk = False needs_datetime_string_cast = True empty_fetchmany_value = [ ] update_can_self_select = True interprets_empty_strings_as_nulls = False ignores_nulls_in_unique_constraints = True can_use_chunked_reads = True can_return_id_from_insert = False has_bulk_insert = False uses_autocommit = False uses_savepoints = False can_combine_inserts_with_and_without_auto_increment_pk = False related_fields_match_type = False allow_sliced_subqueries = True has_select_for_update = False has_select_for_update_nowait = False supports_select_related = True test_db_allows_multiple_connections = True supports_unspecified_pk = False supports_forward_references = True requires_rollback_on_dirty_transaction = False supports_long_model_names = True has_real_datatype = False supports_subqueries_in_group_by = True supports_bitwise_or = True supports_microsecond_precision = True supports_regex_backreferencing = True supports_date_lookup_using_string = True supports_timezones = True requires_explicit_null_ordering_when_grouping = False supports_1000_query_parameters = True allows_primary_key_0 = True can_defer_constraint_checks = False supports_mixed_date_datetime_comparisons = True supports_tablespaces = False _confirmed = False supports_transactions = None supports_stddev = None can_introspect_foreign_keys = None can_distinct_on_fields = False def __init__ ( self , connection ) : self . connection = connection def confirm ( self ) : self . _confirmed = True self . supports_transactions = self . _supports_transactions ( ) self . supports_stddev = self . _supports_stddev ( ) self . can_introspect_foreign_keys = self . _can_introspect_foreign_keys ( ) def _supports_transactions ( self ) : cursor = self . connection . cursor ( ) cursor . execute ( 'CREATE TABLE ROLLBACK_TEST (X INT)' ) self . connection . _commit ( ) cursor . execute ( 'INSERT INTO ROLLBACK_TEST (X) VALUES (8)' ) self . connection . _rollback ( ) cursor . execute ( 'SELECT COUNT(X) FROM ROLLBACK_TEST' ) count , = cursor . fetchone ( ) cursor . execute ( 'DROP TABLE ROLLBACK_TEST' ) self . connection . _commit ( ) return count == 0 def _supports_stddev ( self ) : class StdDevPop ( object ) : sql_function = 'STDDEV_POP' try : self . connection . ops . check_aggregate_support ( StdDevPop ( ) ) except NotImplementedError : self . supports_stddev = False def _can_introspect_foreign_keys ( self ) : return True class BaseDatabaseOperations ( object ) : compiler_module = "django.db.models.sql.compiler" def __init__ ( self , connection ) : self . connection = connection self . _cache = None def autoinc_sql ( self , table , column ) : return None def date_extract_sql ( self , lookup_type , field_name ) : raise NotImplementedError ( ) def date_interval_sql ( self , sql , connector , timedelta ) : raise NotImplementedError ( ) def date_trunc_sql ( self , lookup_type , field_name ) : raise NotImplementedError ( ) def datetime_cast_sql ( self ) : return "%s" def deferrable_sql ( self ) : return '' def drop_foreignkey_sql ( self ) : return "DROP CONSTRAINT" def drop_sequence_sql ( self , table ) : return None def fetch_returned_insert_id ( self , cursor ) : return cursor . fetchone ( ) [ 0 ] def field_cast_sql ( self , db_type ) : return '%s' def force_no_ordering ( self ) : return [ ] def for_update_sql ( self , nowait = False ) : if nowait : return 'FOR UPDATE NOWAIT' else : return 'FOR UPDATE' def fulltext_search_sql ( self , field_name ) : raise NotImplementedError ( 'Full-text search is not implemented for this database backend' ) def distinct_sql ( self , fields ) : if fields : raise NotImplementedError ( 'DISTINCT ON fields is not supported by this database backend' ) else : return 'DISTINCT' def last_executed_query ( self , cursor , sql , params ) : from django . utils . encoding import smart_unicode , force_unicode to_unicode = lambda s : force_unicode ( s , strings_only = True , errors = 'replace' ) if isinstance ( params , ( list , tuple ) ) : u_params = tuple ( [ to_unicode ( val ) for val in params ] ) else : u_params = dict ( [ ( to_unicode ( k ) , to_unicode ( v ) ) for k , v in params . items ( ) ] ) return smart_unicode ( sql ) % u_params def last_insert_id ( self , cursor , table_name , pk_name ) : return cursor . lastrowid def lookup_cast ( self , lookup_type ) : return "%s" def max_in_list_size ( self ) : return None def max_name_length ( self ) : return None def no_limit_value ( self ) : raise NotImplementedError def pk_default_value ( self ) : return 'DEFAULT' def process_clob ( self , value ) : return value def return_insert_id ( self ) : pass def compiler ( self , compiler_name ) : if self . _cache is None : self . _cache = import_module ( self . compiler_module ) return getattr ( self . _cache , compiler_name ) def quote_name ( self , name ) : raise NotImplementedError ( ) def random_function_sql ( self ) : return 'RANDOM()' def regex_lookup ( self , lookup_type ) : raise NotImplementedError def savepoint_create_sql ( self , sid ) : raise NotImplementedError def savepoint_commit_sql ( self , sid ) : raise NotImplementedError def savepoint_rollback_sql ( self , sid ) : raise NotImplementedError def sql_flush ( self , style , tables , sequences ) : raise NotImplementedError ( ) def sequence_reset_sql ( self , style , model_list ) : return [ ] def start_transaction_sql ( self ) : return "BEGIN;" def end_transaction_sql ( self , success = True ) : if not success : return "ROLLBACK;" return "COMMIT;" def tablespace_sql ( self , tablespace , inline = False ) : return '' def prep_for_like_query ( self , x ) : from django . utils . encoding import smart_unicode return smart_unicode ( x ) . replace ( "\\" , "\\\\" ) . replace ( "%" , "\%" ) . replace ( "_" , "\_" ) prep_for_iexact_query = prep_for_like_query def value_to_db_date ( self , value ) : if value is None : return None return unicode ( value ) def value_to_db_datetime ( self , value ) : if value is None : return None return unicode ( value ) def value_to_db_time ( self , value ) : if value is None : return None if is_aware ( value ) : raise ValueError ( "Django does not support timezone-aware times." ) return unicode ( value ) def value_to_db_decimal ( self , value , max_digits , decimal_places ) : if value is None : return None return util . format_number ( value , max_digits , decimal_places ) def year_lookup_bounds ( self , value ) : first = '%s-01-01 00:00:00' second = '%s-12-31 23:59:59.999999' return [ first % value , second % value ] def year_lookup_bounds_for_date_field ( self , value ) : return self . year_lookup_bounds ( value ) def convert_values ( self , value , field ) : internal_type = field . get_internal_type ( ) if internal_type == 'DecimalField' : return value elif internal_type and internal_type . endswith ( 'IntegerField' ) or internal_type == 'AutoField' : return int ( value ) elif internal_type in ( 'DateField' , 'DateTimeField' , 'TimeField' ) : return value return float ( value ) def check_aggregate_support ( self , aggregate_func ) : pass def combine_expression ( self , connector , sub_expressions ) : conn = ' %s ' % connector return conn . join ( sub_expressions ) class BaseDatabaseIntrospection ( object ) : data_types_reverse = { } def __init__ ( self , connection ) : self . connection = connection def get_field_type ( self , data_type , description ) : return self . data_types_reverse [ data_type ] def table_name_converter ( self , name ) : return name def table_names ( self ) : cursor = self . connection . cursor ( ) return self . get_table_list ( cursor ) def django_table_names ( self , only_existing = False ) : from django . db import models , router tables = set ( ) for app in models . get_apps ( ) : for model in models . get_models ( app ) : if not model . _meta . managed : continue if not router . allow_syncdb ( self . connection . alias , model ) : continue tables . add ( model . _meta . db_table ) tables . update ( [ f . m2m_db_table ( ) for f in model . _meta . local_many_to_many ] ) tables = list ( tables ) if only_existing : existing_tables = self . table_names ( ) tables = [ t for t in tables if self . table_name_converter ( t ) in existing_tables ] return tables def installed_models ( self , tables ) : from django . db import models , router all_models = [ ] for app in models . get_apps ( ) : for model in models . get_models ( app ) : if router . allow_syncdb ( self . connection . alias , model ) : all_models . append ( model ) tables = map ( self . table_name_converter , tables ) return set ( [ m for m in all_models if self . table_name_converter ( m . _meta . db_table ) in tables ] ) def sequence_list ( self ) : from django . db import models , router apps = models . get_apps ( ) sequence_list = [ ] for app in apps : for model in models . get_models ( app ) : if not model . _meta . managed : continue if not router . allow_syncdb ( self . connection . alias , model ) : continue for f in model . _meta . local_fields : if isinstance ( f , models . AutoField ) : sequence_list . append ( { 'table' : model . _meta . db_table , 'column' : f . column } ) break for f in model . _meta . local_many_to_many : if f . rel . through is None : sequence_list . append ( { 'table' : f . m2m_db_table ( ) , 'column' : None } ) return sequence_list def get_key_columns ( self , cursor , table_name ) : raise NotImplementedError def get_primary_key_column ( self , cursor , table_name ) : raise NotImplementedError class BaseDatabaseClient ( object ) : executable_name = None def __init__ ( self , connection ) : self . connection = connection def runshell ( self ) : raise NotImplementedError ( ) class BaseDatabaseValidation ( object ) : def __init__ ( self , connection ) : self . connection = connection def validate_field ( self , errors , opts , f ) : pass

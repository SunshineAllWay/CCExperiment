import re from decimal import Decimal from django . conf import settings from django . contrib . gis . db . backends . base import BaseSpatialOperations from django . contrib . gis . db . backends . util import SpatialOperation , SpatialFunction from django . contrib . gis . db . backends . postgis . adapter import PostGISAdapter from django . contrib . gis . geometry . backend import Geometry from django . contrib . gis . measure import Distance from django . core . exceptions import ImproperlyConfigured from django . db . backends . postgresql_psycopg2 . base import DatabaseOperations from django . db . utils import DatabaseError class PostGISOperator ( SpatialOperation ) : def __init__ ( self , operator ) : super ( PostGISOperator , self ) . __init__ ( operator = operator ) class PostGISFunction ( SpatialFunction ) : def __init__ ( self , prefix , function , ** kwargs ) : super ( PostGISFunction , self ) . __init__ ( prefix + function , ** kwargs ) class PostGISFunctionParam ( PostGISFunction ) : sql_template = '%(function)s(%(geo_col)s, %(geometry)s, %%s)' class PostGISDistance ( PostGISFunction ) : dist_func = 'Distance' sql_template = '%(function)s(%(geo_col)s, %(geometry)s) %(operator)s %%s' def __init__ ( self , prefix , operator ) : super ( PostGISDistance , self ) . __init__ ( prefix , self . dist_func , operator = operator ) class PostGISSpheroidDistance ( PostGISFunction ) : dist_func = 'distance_spheroid' sql_template = '%(function)s(%(geo_col)s, %(geometry)s, %%s) %(operator)s %%s' def __init__ ( self , prefix , operator ) : super ( PostGISSpheroidDistance , self ) . __init__ ( prefix , self . dist_func , operator = operator ) class PostGISSphereDistance ( PostGISDistance ) : dist_func = 'distance_sphere' class PostGISRelate ( PostGISFunctionParam ) : pattern_regex = re . compile ( r'^[012TF\*]{9}$' ) def __init__ ( self , prefix , pattern ) : if not self . pattern_regex . match ( pattern ) : raise ValueError ( 'Invalid intersection matrix pattern "%s".' % pattern ) super ( PostGISRelate , self ) . __init__ ( prefix , 'Relate' ) class PostGISOperations ( DatabaseOperations , BaseSpatialOperations ) : compiler_module = 'django.contrib.gis.db.models.sql.compiler' name = 'postgis' postgis = True version_regex = re . compile ( r'^(?P<major>\d)\.(?P<minor1>\d)\.(?P<minor2>\d+)' ) valid_aggregates = dict ( [ ( k , None ) for k in ( 'Collect' , 'Extent' , 'Extent3D' , 'MakeLine' , 'Union' ) ] ) Adapter = PostGISAdapter Adaptor = Adapter def __init__ ( self , connection ) : super ( PostGISOperations , self ) . __init__ ( connection ) try : if hasattr ( settings , 'POSTGIS_VERSION' ) : vtup = settings . POSTGIS_VERSION if len ( vtup ) == 3 : version = vtup else : version = vtup [ 1 : 4 ] else : vtup = self . postgis_version_tuple ( ) version = vtup [ 1 : ] if version >= ( 1 , 2 , 2 ) : prefix = 'ST_' else : prefix = '' self . geom_func_prefix = prefix self . spatial_version = version except DatabaseError : raise ImproperlyConfigured ( 'Cannot determine PostGIS version for database "%s". ' % self . connection . settings_dict [ 'NAME' ] ) except Exception , e : raise self . geometry_operators = { : PostGISOperator ( '&<' ) , : PostGISOperator ( '&>' ) , : PostGISOperator ( '<<' ) , : PostGISOperator ( '>>' ) , : PostGISOperator ( '&<|' ) , : PostGISOperator ( '|&>' ) , : PostGISOperator ( '<<|' ) , : PostGISOperator ( '|>>' ) , : PostGISOperator ( '~=' ) , : PostGISOperator ( '~=' ) , : PostGISOperator ( '@' ) , : PostGISOperator ( '~' ) , : PostGISOperator ( '&&' ) , } self . geometry_functions = { : PostGISFunction ( prefix , 'Equals' ) , : PostGISFunction ( prefix , 'Disjoint' ) , : PostGISFunction ( prefix , 'Touches' ) , : PostGISFunction ( prefix , 'Crosses' ) , : PostGISFunction ( prefix , 'Within' ) , : PostGISFunction ( prefix , 'Overlaps' ) , : PostGISFunction ( prefix , 'Contains' ) , : PostGISFunction ( prefix , 'Intersects' ) , : ( PostGISRelate , basestring ) , } dtypes = ( Decimal , Distance , float , int , long ) def get_dist_ops ( operator ) : return { 'cartesian' : PostGISDistance ( prefix , operator ) , : PostGISSphereDistance ( prefix , operator ) , : PostGISSpheroidDistance ( prefix , operator ) , } self . distance_functions = { : ( get_dist_ops ( '>' ) , dtypes ) , : ( get_dist_ops ( '>=' ) , dtypes ) , : ( get_dist_ops ( '<' ) , dtypes ) , : ( get_dist_ops ( '<=' ) , dtypes ) , } if version < ( 1 , 2 , 2 ) : ASKML = False else : ASKML = 'ST_AsKML' self . geometry_functions . update ( { 'coveredby' : PostGISFunction ( prefix , 'CoveredBy' ) , : PostGISFunction ( prefix , 'Covers' ) , } ) self . distance_functions [ 'dwithin' ] = ( PostGISFunctionParam ( prefix , 'DWithin' ) , dtypes ) self . geometry_functions . update ( self . distance_functions ) if version < ( 1 , 3 , 0 ) : UNIONAGG = 'GeomUnion' UNION = 'Union' MAKELINE = False else : UNIONAGG = 'ST_Union' UNION = 'ST_Union' MAKELINE = 'ST_MakeLine' if version < ( 1 , 3 , 4 ) : GEOJSON = False else : GEOJSON = prefix + 'AsGeoJson' if version >= ( 1 , 4 , 0 ) : GEOHASH = 'ST_GeoHash' BOUNDINGCIRCLE = 'ST_MinimumBoundingCircle' self . geometry_functions [ 'contains_properly' ] = PostGISFunction ( prefix , 'ContainsProperly' ) else : GEOHASH , BOUNDINGCIRCLE = False , False if version >= ( 1 , 5 , 0 ) : self . geography = True self . geography_functions = self . distance_functions . copy ( ) self . geography_functions . update ( { : self . geometry_functions [ 'coveredby' ] , : self . geometry_functions [ 'covers' ] , : self . geometry_functions [ 'intersects' ] , } ) self . geography_operators = { : PostGISOperator ( '&&' ) , } gis_terms = [ 'isnull' ] gis_terms += self . geometry_operators . keys ( ) gis_terms += self . geometry_functions . keys ( ) self . gis_terms = dict ( [ ( term , None ) for term in gis_terms ] ) self . area = prefix + 'Area' self . bounding_circle = BOUNDINGCIRCLE self . centroid = prefix + 'Centroid' self . collect = prefix + 'Collect' self . difference = prefix + 'Difference' self . distance = prefix + 'Distance' self . distance_sphere = prefix + 'distance_sphere' self . distance_spheroid = prefix + 'distance_spheroid' self . envelope = prefix + 'Envelope' self . extent = prefix + 'Extent' self . extent3d = prefix + 'Extent3D' self . force_rhr = prefix + 'ForceRHR' self . geohash = GEOHASH self . geojson = GEOJSON self . gml = prefix + 'AsGML' self . intersection = prefix + 'Intersection' self . kml = ASKML self . length = prefix + 'Length' self . length3d = prefix + 'Length3D' self . length_spheroid = prefix + 'length_spheroid' self . makeline = MAKELINE self . mem_size = prefix + 'mem_size' self . num_geom = prefix + 'NumGeometries' self . num_points = prefix + 'npoints' self . perimeter = prefix + 'Perimeter' self . perimeter3d = prefix + 'Perimeter3D' self . point_on_surface = prefix + 'PointOnSurface' self . polygonize = prefix + 'Polygonize' self . reverse = prefix + 'Reverse' self . scale = prefix + 'Scale' self . snap_to_grid = prefix + 'SnapToGrid' self . svg = prefix + 'AsSVG' self . sym_difference = prefix + 'SymDifference' self . transform = prefix + 'Transform' self . translate = prefix + 'Translate' self . union = UNION self . unionagg = UNIONAGG def check_aggregate_support ( self , aggregate ) : agg_name = aggregate . __class__ . __name__ return agg_name in self . valid_aggregates def convert_extent ( self , box ) : ll , ur = box [ 4 : - 1 ] . split ( ',' ) xmin , ymin = map ( float , ll . split ( ) ) xmax , ymax = map ( float , ur . split ( ) ) return ( xmin , ymin , xmax , ymax ) def convert_extent3d ( self , box3d ) : ll , ur = box3d [ 6 : - 1 ] . split ( ',' ) xmin , ymin , zmin = map ( float , ll . split ( ) ) xmax , ymax , zmax = map ( float , ur . split ( ) ) return ( xmin , ymin , zmin , xmax , ymax , zmax ) def convert_geom ( self , hex , geo_field ) : if hex : return Geometry ( hex ) else : return None def geo_db_type ( self , f ) : if f . geography : if not self . geography : raise NotImplementedError ( 'PostGIS 1.5 required for geography column support.' ) if f . srid != 4326 : raise NotImplementedError ( 'PostGIS 1.5 supports geography columns ' ) return 'geography(%s,%d)' % ( f . geom_type , f . srid ) else : return None def get_distance ( self , f , dist_val , lookup_type ) : if len ( dist_val ) == 1 : value , option = dist_val [ 0 ] , None else : value , option = dist_val geodetic = f . geodetic ( self . connection ) geography = f . geography and self . geography if isinstance ( value , Distance ) : if geography : dist_param = value . m elif geodetic : if lookup_type == 'dwithin' : raise ValueError ( 'Only numeric values of degree units are ' ) dist_param = value . m else : dist_param = getattr ( value , Distance . unit_attname ( f . units_name ( self . connection ) ) ) else : dist_param = value if ( not geography and geodetic and lookup_type != 'dwithin' and option == 'spheroid' ) : return [ f . _spheroid , dist_param ] else : return [ dist_param ] def get_geom_placeholder ( self , f , value ) : if value is None or value . srid == f . srid : placeholder = '%s' else : placeholder = '%s(%%s, %s)' % ( self . transform , f . srid ) if hasattr ( value , 'expression' ) : placeholder = placeholder % '%s.%s' % tuple ( map ( self . quote_name , value . cols [ value . expression ] ) ) return placeholder def _get_postgis_func ( self , func ) : cursor = self . connection . _cursor ( ) try : try : cursor . execute ( 'SELECT %s()' % func ) row = cursor . fetchone ( ) except : raise finally : self . connection . close ( ) return row [ 0 ] def postgis_geos_version ( self ) : return self . _get_postgis_func ( 'postgis_geos_version' ) def postgis_lib_version ( self ) : return self . _get_postgis_func ( 'postgis_lib_version' ) def postgis_proj_version ( self ) : return self . _get_postgis_func ( 'postgis_proj_version' ) def postgis_version ( self ) : return self . _get_postgis_func ( 'postgis_version' ) def postgis_full_version ( self ) : return self . _get_postgis_func ( 'postgis_full_version' ) def postgis_version_tuple ( self ) : version = self . postgis_lib_version ( ) m = self . version_regex . match ( version ) if m : major = int ( m . group ( 'major' ) ) minor1 = int ( m . group ( 'minor1' ) ) minor2 = int ( m . group ( 'minor2' ) ) else : raise Exception ( 'Could not parse PostGIS version string: %s' % version ) return ( version , major , minor1 , minor2 ) def proj_version_tuple ( self ) : proj_regex = re . compile ( r'(\d+)\.(\d+)\.(\d+)' ) proj_ver_str = self . postgis_proj_version ( ) m = proj_regex . search ( proj_ver_str ) if m : return tuple ( map ( int , [ m . group ( 1 ) , m . group ( 2 ) , m . group ( 3 ) ] ) ) else : raise Exception ( 'Could not determine PROJ.4 version from PostGIS.' ) def num_params ( self , lookup_type , num_param ) : def exactly_two ( np ) : return np == 2 def two_to_three ( np ) : return np >= 2 and np <= 3 if ( lookup_type in self . distance_functions and lookup_type != 'dwithin' ) : return two_to_three ( num_param ) else : return exactly_two ( num_param ) def spatial_lookup_sql ( self , lvalue , lookup_type , value , field , qn ) : alias , col , db_type = lvalue geo_col = '%s.%s' % ( qn ( alias ) , qn ( col ) ) if lookup_type in self . geometry_operators : if field . geography and not lookup_type in self . geography_operators : raise ValueError ( 'PostGIS geography does not support the ' % lookup_type ) op = self . geometry_operators [ lookup_type ] return op . as_sql ( geo_col , self . get_geom_placeholder ( field , value ) ) elif lookup_type in self . geometry_functions : if field . geography and not lookup_type in self . geography_functions : raise ValueError ( 'PostGIS geography type does not support the ' % lookup_type ) tmp = self . geometry_functions [ lookup_type ] if isinstance ( tmp , tuple ) : op , arg_type = tmp if not isinstance ( value , ( tuple , list ) ) : raise ValueError ( 'Tuple required for `%s` lookup type.' % lookup_type ) geom = value [ 0 ] nparams = len ( value ) if not self . num_params ( lookup_type , nparams ) : raise ValueError ( 'Incorrect number of parameters given for `%s` lookup type.' % lookup_type ) if not isinstance ( value [ 1 ] , arg_type ) : raise ValueError ( 'Argument type should be %s, got %s instead.' % ( arg_type , type ( value [ 1 ] ) ) ) if lookup_type == 'relate' : op = op ( self . geom_func_prefix , value [ 1 ] ) elif lookup_type in self . distance_functions and lookup_type != 'dwithin' : if not field . geography and field . geodetic ( self . connection ) : if not self . connection . ops . geography : if field . geom_type != 'POINT' : raise ValueError ( 'PostGIS spherical operations are only valid on PointFields.' ) if str ( geom . geom_type ) != 'Point' : raise ValueError ( 'PostGIS geometry distance parameter is required to be of type Point.' ) if nparams == 3 and value [ 2 ] == 'spheroid' : op = op [ 'spheroid' ] else : op = op [ 'sphere' ] else : op = op [ 'cartesian' ] else : op = tmp geom = value return op . as_sql ( geo_col , self . get_geom_placeholder ( field , geom ) ) elif lookup_type == 'isnull' : return "%s IS %sNULL" % ( geo_col , ( not value and 'NOT ' or '' ) ) raise TypeError ( "Got invalid lookup_type: %s" % repr ( lookup_type ) ) def spatial_aggregate_sql ( self , agg ) : agg_name = agg . __class__ . __name__ if not self . check_aggregate_support ( agg ) : raise NotImplementedError ( '%s spatial aggregate is not implmented for this backend.' % agg_name ) agg_name = agg_name . lower ( ) if agg_name == 'union' : agg_name += 'agg' sql_template = '%(function)s(%(field)s)' sql_function = getattr ( self , agg_name ) return sql_template , sql_function def geometry_columns ( self ) : from django . contrib . gis . db . backends . postgis . models import GeometryColumns return GeometryColumns def spatial_ref_sys ( self ) : from django . contrib . gis . db . backends . postgis . models import SpatialRefSys return SpatialRefSys

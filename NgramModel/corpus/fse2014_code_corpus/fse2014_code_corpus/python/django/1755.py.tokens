""" Base/mixin classes for the spatial backend database operations and the `SpatialRefSys` model the backend. """ import re from django . contrib . gis import gdal class BaseSpatialOperations ( object ) : distance_functions = { } geometry_functions = { } geometry_operators = { } geography_operators = { } geography_functions = { } gis_terms = { } truncate_params = { } postgis = False spatialite = False mysql = False oracle = False spatial_version = None select = None geography = False area = False centroid = False difference = False distance = False distance_sphere = False distance_spheroid = False envelope = False force_rhr = False mem_size = False bounding_circle = False num_geom = False num_points = False perimeter = False perimeter3d = False point_on_surface = False polygonize = False reverse = False scale = False snap_to_grid = False sym_difference = False transform = False translate = False union = False collect = False extent = False extent3d = False make_line = False unionagg = False geohash = False geojson = False gml = False kml = False svg = False from_text = False from_wkb = False def convert_extent ( self , box ) : raise NotImplementedError ( 'Aggregate extent not implemented for this spatial backend.' ) def convert_extent3d ( self , box ) : raise NotImplementedError ( 'Aggregate 3D extent not implemented for this spatial backend.' ) def convert_geom ( self , geom_val , geom_field ) : raise NotImplementedError ( 'Aggregate method not implemented for this spatial backend.' ) def geo_quote_name ( self , name ) : if isinstance ( name , unicode ) : name = name . encode ( 'ascii' ) return "'%s'" % name def geo_db_type ( self , f ) : raise NotImplementedError def get_distance ( self , f , value , lookup_type ) : raise NotImplementedError ( 'Distance operations not available on this spatial backend.' ) def get_geom_placeholder ( self , f , value ) : raise NotImplementedError def spatial_aggregate_sql ( self , agg ) : raise NotImplementedError ( 'Aggregate support not implemented for this spatial backend.' ) def spatial_lookup_sql ( self , lvalue , lookup_type , value , field ) : raise NotImplementedError def geometry_columns ( self ) : raise NotImplementedError def spatial_ref_sys ( self ) : raise NotImplementedError class SpatialRefSysMixin ( object ) : spheroid_regex = re . compile ( r'.+SPHEROID\[\"(?P<name>.+)\",(?P<major>\d+(\.\d+)?),(?P<flattening>\d{3}\.\d+),' ) units_regex = re . compile ( r'.+UNIT ?\["(?P<unit_name>[\w \'\(\)]+)", ?(?P<unit>[\d\.]+)(,AUTHORITY\["(?P<unit_auth_name>[\w \'\(\)]+)","(?P<unit_auth_val>\d+)"\])?\]([\w ]+)?(,AUTHORITY\["(?P<auth_name>[\w \'\(\)]+)","(?P<auth_val>\d+)"\])?\]$' ) @ property def srs ( self ) : if gdal . HAS_GDAL : if hasattr ( self , '_srs' ) : return self . _srs . clone ( ) else : try : self . _srs = gdal . SpatialReference ( self . wkt ) return self . srs except Exception , msg : pass try : self . _srs = gdal . SpatialReference ( self . proj4text ) return self . srs except Exception , msg : pass raise Exception ( 'Could not get OSR SpatialReference from WKT: %s\nError:\n%s' % ( self . wkt , msg ) ) else : raise Exception ( 'GDAL is not installed.' ) @ property def ellipsoid ( self ) : if gdal . HAS_GDAL : return self . srs . ellipsoid else : m = self . spheroid_regex . match ( self . wkt ) if m : return ( float ( m . group ( 'major' ) ) , float ( m . group ( 'flattening' ) ) ) else : return None @ property def name ( self ) : return self . srs . name @ property def spheroid ( self ) : return self . srs [ 'spheroid' ] @ property def datum ( self ) : return self . srs [ 'datum' ] @ property def projected ( self ) : if gdal . HAS_GDAL : return self . srs . projected else : return self . wkt . startswith ( 'PROJCS' ) @ property def local ( self ) : if gdal . HAS_GDAL : return self . srs . local else : return self . wkt . startswith ( 'LOCAL_CS' ) @ property def geographic ( self ) : if gdal . HAS_GDAL : return self . srs . geographic else : return self . wkt . startswith ( 'GEOGCS' ) @ property def linear_name ( self ) : if gdal . HAS_GDAL : return self . srs . linear_name elif self . geographic : return None else : m = self . units_regex . match ( self . wkt ) return m . group ( 'unit_name' ) @ property def linear_units ( self ) : if gdal . HAS_GDAL : return self . srs . linear_units elif self . geographic : return None else : m = self . units_regex . match ( self . wkt ) return m . group ( 'unit' ) @ property def angular_name ( self ) : if gdal . HAS_GDAL : return self . srs . angular_name elif self . projected : return None else : m = self . units_regex . match ( self . wkt ) return m . group ( 'unit_name' ) @ property def angular_units ( self ) : if gdal . HAS_GDAL : return self . srs . angular_units elif self . projected : return None else : m = self . units_regex . match ( self . wkt ) return m . group ( 'unit' ) @ property def units ( self ) : if self . projected or self . local : return ( self . linear_units , self . linear_name ) elif self . geographic : return ( self . angular_units , self . angular_name ) else : return ( None , None ) @ classmethod def get_units ( cls , wkt ) : if gdal . HAS_GDAL : return gdal . SpatialReference ( wkt ) . units else : m = cls . units_regex . match ( wkt ) return m . group ( 'unit' ) , m . group ( 'unit_name' ) @ classmethod def get_spheroid ( cls , wkt , string = True ) : if gdal . HAS_GDAL : srs = gdal . SpatialReference ( wkt ) sphere_params = srs . ellipsoid sphere_name = srs [ 'spheroid' ] else : m = cls . spheroid_regex . match ( wkt ) if m : sphere_params = ( float ( m . group ( 'major' ) ) , float ( m . group ( 'flattening' ) ) ) sphere_name = m . group ( 'name' ) else : return None if not string : return sphere_name , sphere_params else : if len ( sphere_params ) == 3 : radius , flattening = sphere_params [ 0 ] , sphere_params [ 2 ] else : radius , flattening = sphere_params return 'SPHEROID["%s",%s,%s]' % ( sphere_name , radius , flattening ) def __unicode__ ( self ) : try : return unicode ( self . srs ) except : return unicode ( self . wkt )

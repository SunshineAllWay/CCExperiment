""" The OGRGeometry is a wrapper for using the OGR Geometry class (see http://www.gdal.org/ogr/classOGRGeometry.html). OGRGeometry may be instantiated when reading geometries from OGR Data Sources (e.g. SHP files), or when given OGC WKT (a string). While the 'full' API is not present yet, the API is "pythonic" unlike the traditional and "next-generation" OGR Python bindings. One major advantage OGR Geometries have over their GEOS counterparts is support for spatial reference systems and their transformation. Example: >>> from django.contrib.gis.gdal import OGRGeometry, OGRGeomType, SpatialReference >>> wkt1, wkt2 = 'POINT(-90 30)', 'POLYGON((0 0, 5 0, 5 5, 0 5)' >>> pnt = OGRGeometry(wkt1) >>> print pnt POINT (-90 30) >>> mpnt = OGRGeometry(OGRGeomType('MultiPoint'), SpatialReference('WGS84')) >>> mpnt.add(wkt1) >>> mpnt.add(wkt1) >>> print mpnt MULTIPOINT (-90 30,-90 30) >>> print mpnt.srs.name WGS 84 >>> print mpnt.srs.proj +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs >>> mpnt.transform_to(SpatialReference('NAD27')) >>> print mpnt.proj +proj=longlat +ellps=clrk66 +datum=NAD27 +no_defs >>> print mpnt MULTIPOINT (-89.999930378602485 29.999797886557641,-89.999930378602485 29.999797886557641) The OGRGeomType class is to make it easy to specify an OGR geometry type: >>> from django.contrib.gis.gdal import OGRGeomType >>> gt1 = OGRGeomType(3) # Using an integer for the type >>> gt2 = OGRGeomType('Polygon') # Using a string >>> gt3 = OGRGeomType('POLYGON') # It's case-insensitive >>> print gt1 == 3, gt1 == 'Polygon' # Equivalence works w/non-OGRGeomType objects True """ import sys from binascii import a2b_hex from ctypes import byref , string_at , c_char_p , c_double , c_ubyte , c_void_p from django . contrib . gis . gdal . base import GDALBase from django . contrib . gis . gdal . envelope import Envelope , OGREnvelope from django . contrib . gis . gdal . error import OGRException , OGRIndexError , SRSException from django . contrib . gis . gdal . geomtype import OGRGeomType from django . contrib . gis . gdal . libgdal import GEOJSON , GDAL_VERSION from django . contrib . gis . gdal . srs import SpatialReference , CoordTransform from django . contrib . gis . gdal . prototypes import geom as capi , srs as srs_api from django . contrib . gis . geometry . regex import hex_regex , wkt_regex , json_regex class OGRGeometry ( GDALBase ) : def __init__ ( self , geom_input , srs = None ) : str_instance = isinstance ( geom_input , basestring ) if str_instance and hex_regex . match ( geom_input ) : geom_input = buffer ( a2b_hex ( geom_input . upper ( ) ) ) str_instance = False if str_instance : if isinstance ( geom_input , unicode ) : geom_input = geom_input . encode ( 'ascii' ) wkt_m = wkt_regex . match ( geom_input ) json_m = json_regex . match ( geom_input ) if wkt_m : if wkt_m . group ( 'srid' ) : srs = int ( wkt_m . group ( 'srid' ) ) if wkt_m . group ( 'type' ) . upper ( ) == 'LINEARRING' : g = capi . create_geom ( OGRGeomType ( wkt_m . group ( 'type' ) ) . num ) capi . import_wkt ( g , byref ( c_char_p ( wkt_m . group ( 'wkt' ) ) ) ) else : g = capi . from_wkt ( byref ( c_char_p ( wkt_m . group ( 'wkt' ) ) ) , None , byref ( c_void_p ( ) ) ) elif json_m : if GEOJSON : g = capi . from_json ( geom_input ) else : raise NotImplementedError ( 'GeoJSON input only supported on GDAL 1.5+.' ) else : ogr_t = OGRGeomType ( geom_input ) g = capi . create_geom ( OGRGeomType ( geom_input ) . num ) elif isinstance ( geom_input , buffer ) : g = capi . from_wkb ( str ( geom_input ) , None , byref ( c_void_p ( ) ) , len ( geom_input ) ) elif isinstance ( geom_input , OGRGeomType ) : g = capi . create_geom ( geom_input . num ) elif isinstance ( geom_input , self . ptr_type ) : g = geom_input else : raise OGRException ( 'Invalid input type for OGR Geometry construction: %s' % type ( geom_input ) ) if not g : raise OGRException ( 'Cannot create OGR Geometry from input: %s' % str ( geom_input ) ) self . ptr = g if bool ( srs ) : self . srs = srs self . __class__ = GEO_CLASSES [ self . geom_type . num ] def __del__ ( self ) : if self . _ptr : capi . destroy_geom ( self . _ptr ) def __getstate__ ( self ) : srs = self . srs if srs : srs = srs . wkt else : srs = None return str ( self . wkb ) , srs def __setstate__ ( self , state ) : wkb , srs = state ptr = capi . from_wkb ( wkb , None , byref ( c_void_p ( ) ) , len ( wkb ) ) if not ptr : raise OGRException ( 'Invalid OGRGeometry loaded from pickled state.' ) self . ptr = ptr self . srs = srs @ classmethod def from_bbox ( cls , bbox ) : x0 , y0 , x1 , y1 = bbox return OGRGeometry ( 'POLYGON((%s %s, %s %s, %s %s, %s %s, %s %s))' % ( x0 , y0 , x0 , y1 , x1 , y1 , x1 , y0 , x0 , y0 ) ) def __or__ ( self , other ) : return self . union ( other ) def __and__ ( self , other ) : return self . intersection ( other ) def __sub__ ( self , other ) : return self . difference ( other ) def __xor__ ( self , other ) : return self . sym_difference ( other ) def __eq__ ( self , other ) : if isinstance ( other , OGRGeometry ) : return self . equals ( other ) else : return False def __ne__ ( self , other ) : return not ( self == other ) def __str__ ( self ) : return self . wkt @ property def dimension ( self ) : return capi . get_dims ( self . ptr ) def _get_coord_dim ( self ) : if isinstance ( self , GeometryCollection ) and GDAL_VERSION < ( 1 , 5 , 2 ) : if len ( self ) : return capi . get_coord_dim ( capi . get_geom_ref ( self . ptr , 0 ) ) return capi . get_coord_dim ( self . ptr ) def _set_coord_dim ( self , dim ) : if not dim in ( 2 , 3 ) : raise ValueError ( 'Geometry dimension must be either 2 or 3' ) capi . set_coord_dim ( self . ptr , dim ) coord_dim = property ( _get_coord_dim , _set_coord_dim ) @ property def geom_count ( self ) : return capi . get_geom_count ( self . ptr ) @ property def point_count ( self ) : return capi . get_point_count ( self . ptr ) @ property def num_points ( self ) : return self . point_count @ property def num_coords ( self ) : return self . point_count @ property def geom_type ( self ) : return OGRGeomType ( capi . get_geom_type ( self . ptr ) ) @ property def geom_name ( self ) : return capi . get_geom_name ( self . ptr ) @ property def area ( self ) : return capi . get_area ( self . ptr ) @ property def envelope ( self ) : return Envelope ( capi . get_envelope ( self . ptr , byref ( OGREnvelope ( ) ) ) ) @ property def extent ( self ) : return self . envelope . tuple def _get_srs ( self ) : try : srs_ptr = capi . get_geom_srs ( self . ptr ) return SpatialReference ( srs_api . clone_srs ( srs_ptr ) ) except SRSException : return None def _set_srs ( self , srs ) : if isinstance ( srs , SpatialReference ) : srs_ptr = srs . ptr elif isinstance ( srs , ( int , long , basestring ) ) : sr = SpatialReference ( srs ) srs_ptr = sr . ptr else : raise TypeError ( 'Cannot assign spatial reference with object of type: %s' % type ( srs ) ) capi . assign_srs ( self . ptr , srs_ptr ) srs = property ( _get_srs , _set_srs ) def _get_srid ( self ) : srs = self . srs if srs : return srs . srid return None def _set_srid ( self , srid ) : if isinstance ( srid , ( int , long ) ) : self . srs = srid else : raise TypeError ( 'SRID must be set with an integer.' ) srid = property ( _get_srid , _set_srid ) @ property def geos ( self ) : from django . contrib . gis . geos import GEOSGeometry return GEOSGeometry ( self . wkb , self . srid ) @ property def gml ( self ) : return capi . to_gml ( self . ptr ) @ property def hex ( self ) : return str ( self . wkb ) . encode ( 'hex' ) . upper ( ) @ property def json ( self ) : if GEOJSON : return capi . to_json ( self . ptr ) else : raise NotImplementedError ( 'GeoJSON output only supported on GDAL 1.5+.' ) geojson = json @ property def kml ( self ) : if GEOJSON : return capi . to_kml ( self . ptr , None ) else : raise NotImplementedError ( 'KML output only supported on GDAL 1.5+.' ) @ property def wkb_size ( self ) : return capi . get_wkbsize ( self . ptr ) @ property def wkb ( self ) : if sys . byteorder == 'little' : byteorder = 1 else : byteorder = 0 sz = self . wkb_size buf = ( c_ubyte * sz ) ( ) wkb = capi . to_wkb ( self . ptr , byteorder , byref ( buf ) ) return buffer ( string_at ( buf , sz ) ) @ property def wkt ( self ) : return capi . to_wkt ( self . ptr , byref ( c_char_p ( ) ) ) @ property def ewkt ( self ) : srs = self . srs if srs and srs . srid : return 'SRID=%s;%s' % ( srs . srid , self . wkt ) else : return self . wkt def clone ( self ) : return OGRGeometry ( capi . clone_geom ( self . ptr ) , self . srs ) def close_rings ( self ) : capi . geom_close_rings ( self . ptr ) def transform ( self , coord_trans , clone = False ) : if clone : klone = self . clone ( ) klone . transform ( coord_trans ) return klone if GDAL_VERSION < ( 1 , 7 ) : orig_dim = self . coord_dim if isinstance ( coord_trans , CoordTransform ) : capi . geom_transform ( self . ptr , coord_trans . ptr ) elif isinstance ( coord_trans , SpatialReference ) : capi . geom_transform_to ( self . ptr , coord_trans . ptr ) elif isinstance ( coord_trans , ( int , long , basestring ) ) : sr = SpatialReference ( coord_trans ) capi . geom_transform_to ( self . ptr , sr . ptr ) else : raise TypeError ( 'Transform only accepts CoordTransform, ' ) if GDAL_VERSION < ( 1 , 7 ) : if isinstance ( self , GeometryCollection ) : for i in xrange ( len ( self ) ) : internal_ptr = capi . get_geom_ref ( self . ptr , i ) if orig_dim != capi . get_coord_dim ( internal_ptr ) : capi . set_coord_dim ( internal_ptr , orig_dim ) else : if self . coord_dim != orig_dim : self . coord_dim = orig_dim def transform_to ( self , srs ) : self . transform ( srs ) def _topology ( self , func , other ) : if not isinstance ( other , OGRGeometry ) : raise TypeError ( 'Must use another OGRGeometry object for topology operations!' ) return func ( self . ptr , other . ptr ) def intersects ( self , other ) : return self . _topology ( capi . ogr_intersects , other ) def equals ( self , other ) : return self . _topology ( capi . ogr_equals , other ) def disjoint ( self , other ) : return self . _topology ( capi . ogr_disjoint , other ) def touches ( self , other ) : return self . _topology ( capi . ogr_touches , other ) def crosses ( self , other ) : return self . _topology ( capi . ogr_crosses , other ) def within ( self , other ) : return self . _topology ( capi . ogr_within , other ) def contains ( self , other ) : return self . _topology ( capi . ogr_contains , other ) def overlaps ( self , other ) : return self . _topology ( capi . ogr_overlaps , other ) def _geomgen ( self , gen_func , other = None ) : if isinstance ( other , OGRGeometry ) : return OGRGeometry ( gen_func ( self . ptr , other . ptr ) , self . srs ) else : return OGRGeometry ( gen_func ( self . ptr ) , self . srs ) @ property def boundary ( self ) : return self . _geomgen ( capi . get_boundary ) @ property def convex_hull ( self ) : return self . _geomgen ( capi . geom_convex_hull ) def difference ( self , other ) : return self . _geomgen ( capi . geom_diff , other ) def intersection ( self , other ) : return self . _geomgen ( capi . geom_intersection , other ) def sym_difference ( self , other ) : return self . _geomgen ( capi . geom_sym_diff , other ) def union ( self , other ) : return self . _geomgen ( capi . geom_union , other ) class Point ( OGRGeometry ) : @ property def x ( self ) : return capi . getx ( self . ptr , 0 ) @ property def y ( self ) : return capi . gety ( self . ptr , 0 ) @ property def z ( self ) : if self . coord_dim == 3 : return capi . getz ( self . ptr , 0 ) @ property def tuple ( self ) : if self . coord_dim == 2 : return ( self . x , self . y ) elif self . coord_dim == 3 : return ( self . x , self . y , self . z ) coords = tuple class LineString ( OGRGeometry ) : def __getitem__ ( self , index ) : if index >= 0 and index < self . point_count : x , y , z = c_double ( ) , c_double ( ) , c_double ( ) capi . get_point ( self . ptr , index , byref ( x ) , byref ( y ) , byref ( z ) ) dim = self . coord_dim if dim == 1 : return ( x . value , ) elif dim == 2 : return ( x . value , y . value ) elif dim == 3 : return ( x . value , y . value , z . value ) else : raise OGRIndexError ( 'index out of range: %s' % str ( index ) ) def __iter__ ( self ) : for i in xrange ( self . point_count ) : yield self [ i ] def __len__ ( self ) : return self . point_count @ property def tuple ( self ) : return tuple ( [ self [ i ] for i in xrange ( len ( self ) ) ] ) coords = tuple def _listarr ( self , func ) : return [ func ( self . ptr , i ) for i in xrange ( len ( self ) ) ] @ property def x ( self ) : return self . _listarr ( capi . getx ) @ property def y ( self ) : return self . _listarr ( capi . gety ) @ property def z ( self ) : if self . coord_dim == 3 : return self . _listarr ( capi . getz ) class LinearRing ( LineString ) : pass class Polygon ( OGRGeometry ) : def __len__ ( self ) : return self . geom_count def __iter__ ( self ) : for i in xrange ( self . geom_count ) : yield self [ i ] def __getitem__ ( self , index ) : if index < 0 or index >= self . geom_count : raise OGRIndexError ( 'index out of range: %s' % index ) else : return OGRGeometry ( capi . clone_geom ( capi . get_geom_ref ( self . ptr , index ) ) , self . srs ) @ property def shell ( self ) : return self [ 0 ] exterior_ring = shell @ property def tuple ( self ) : return tuple ( [ self [ i ] . tuple for i in xrange ( self . geom_count ) ] ) coords = tuple @ property def point_count ( self ) : return sum ( [ self [ i ] . point_count for i in xrange ( self . geom_count ) ] ) @ property def centroid ( self ) : p = OGRGeometry ( OGRGeomType ( 'Point' ) ) capi . get_centroid ( self . ptr , p . ptr ) return p class GeometryCollection ( OGRGeometry ) : def __getitem__ ( self , index ) : if index < 0 or index >= self . geom_count : raise OGRIndexError ( 'index out of range: %s' % index ) else : return OGRGeometry ( capi . clone_geom ( capi . get_geom_ref ( self . ptr , index ) ) , self . srs ) def __iter__ ( self ) : for i in xrange ( self . geom_count ) : yield self [ i ] def __len__ ( self ) : return self . geom_count def add ( self , geom ) : if isinstance ( geom , OGRGeometry ) : if isinstance ( geom , self . __class__ ) : for g in geom : capi . add_geom ( self . ptr , g . ptr ) else : capi . add_geom ( self . ptr , geom . ptr ) elif isinstance ( geom , basestring ) : tmp = OGRGeometry ( geom ) capi . add_geom ( self . ptr , tmp . ptr ) else : raise OGRException ( 'Must add an OGRGeometry.' ) @ property def point_count ( self ) : return sum ( [ self [ i ] . point_count for i in xrange ( self . geom_count ) ] ) @ property def tuple ( self ) : return tuple ( [ self [ i ] . tuple for i in xrange ( self . geom_count ) ] ) coords = tuple class MultiPoint ( GeometryCollection ) : pass class MultiLineString ( GeometryCollection ) : pass class MultiPolygon ( GeometryCollection ) : pass GEO_CLASSES = { 1 : Point , 2 : LineString , 3 : Polygon , 4 : MultiPoint , 5 : MultiLineString , 6 : MultiPolygon , 7 : GeometryCollection , 101 : LinearRing , 1 + OGRGeomType . wkb25bit : Point , 2 + OGRGeomType . wkb25bit : LineString , 3 + OGRGeomType . wkb25bit : Polygon , 4 + OGRGeomType . wkb25bit : MultiPoint , 5 + OGRGeomType . wkb25bit : MultiLineString , 6 + OGRGeomType . wkb25bit : MultiPolygon , 7 + OGRGeomType . wkb25bit : GeometryCollection , }

import urllib from django . core . exceptions import ImproperlyConfigured from django . core . mail import send_mail from django . db import models from django . db . models . manager import EmptyManager from django . utils . crypto import get_random_string from django . utils . encoding import smart_str from django . utils . translation import ugettext_lazy as _ from django . utils import timezone from django . contrib import auth from django . contrib . auth . hashers import ( check_password , make_password , is_password_usable , UNUSABLE_PASSWORD ) from django . contrib . auth . signals import user_logged_in from django . contrib . contenttypes . models import ContentType def update_last_login ( sender , user , ** kwargs ) : user . last_login = timezone . now ( ) user . save ( ) user_logged_in . connect ( update_last_login ) class SiteProfileNotAvailable ( Exception ) : pass class PermissionManager ( models . Manager ) : def get_by_natural_key ( self , codename , app_label , model ) : return self . get ( codename = codename , content_type = ContentType . objects . get_by_natural_key ( app_label , model ) , ) class Permission ( models . Model ) : name = models . CharField ( _ ( 'name' ) , max_length = 50 ) content_type = models . ForeignKey ( ContentType ) codename = models . CharField ( _ ( 'codename' ) , max_length = 100 ) objects = PermissionManager ( ) class Meta : verbose_name = _ ( 'permission' ) verbose_name_plural = _ ( 'permissions' ) unique_together = ( ( 'content_type' , 'codename' ) , ) ordering = ( 'content_type__app_label' , 'content_type__model' , ) def __unicode__ ( self ) : return u"%s | %s | %s" % ( unicode ( self . content_type . app_label ) , unicode ( self . content_type ) , unicode ( self . name ) ) def natural_key ( self ) : return ( self . codename , ) + self . content_type . natural_key ( ) natural_key . dependencies = [ 'contenttypes.contenttype' ] class GroupManager ( models . Manager ) : def get_by_natural_key ( self , name ) : return self . get ( name = name ) class Group ( models . Model ) : name = models . CharField ( _ ( 'name' ) , max_length = 80 , unique = True ) permissions = models . ManyToManyField ( Permission , verbose_name = _ ( 'permissions' ) , blank = True ) objects = GroupManager ( ) class Meta : verbose_name = _ ( 'group' ) verbose_name_plural = _ ( 'groups' ) def __unicode__ ( self ) : return self . name def natural_key ( self ) : return ( self . name , ) class UserManager ( models . Manager ) : @ classmethod def normalize_email ( cls , email ) : email = email or '' try : email_name , domain_part = email . strip ( ) . rsplit ( '@' , 1 ) except ValueError : pass else : email = '@' . join ( [ email_name , domain_part . lower ( ) ] ) return email def create_user ( self , username , email = None , password = None ) : now = timezone . now ( ) email = UserManager . normalize_email ( email ) user = self . model ( username = username , email = email , is_staff = False , is_active = True , is_superuser = False , last_login = now , date_joined = now ) user . set_password ( password ) user . save ( using = self . _db ) return user def create_superuser ( self , username , email , password ) : u = self . create_user ( username , email , password ) u . is_staff = True u . is_active = True u . is_superuser = True u . save ( using = self . _db ) return u def make_random_password ( self , length = 10 , allowed_chars = 'abcdefghjkmnpqrstuvwxyz' ) : return get_random_string ( length , allowed_chars ) def get_by_natural_key ( self , username ) : return self . get ( username = username ) def _user_get_all_permissions ( user , obj ) : permissions = set ( ) for backend in auth . get_backends ( ) : if hasattr ( backend , "get_all_permissions" ) : if obj is not None : permissions . update ( backend . get_all_permissions ( user , obj ) ) else : permissions . update ( backend . get_all_permissions ( user ) ) return permissions def _user_has_perm ( user , perm , obj ) : anon = user . is_anonymous ( ) active = user . is_active for backend in auth . get_backends ( ) : if anon or active or backend . supports_inactive_user : if hasattr ( backend , "has_perm" ) : if obj is not None : if backend . has_perm ( user , perm , obj ) : return True else : if backend . has_perm ( user , perm ) : return True return False def _user_has_module_perms ( user , app_label ) : anon = user . is_anonymous ( ) active = user . is_active for backend in auth . get_backends ( ) : if anon or active or backend . supports_inactive_user : if hasattr ( backend , "has_module_perms" ) : if backend . has_module_perms ( user , app_label ) : return True return False class User ( models . Model ) : username = models . CharField ( _ ( 'username' ) , max_length = 30 , unique = True , help_text = _ ( 'Required. 30 characters or fewer. Letters, numbers and ' ) ) first_name = models . CharField ( _ ( 'first name' ) , max_length = 30 , blank = True ) last_name = models . CharField ( _ ( 'last name' ) , max_length = 30 , blank = True ) email = models . EmailField ( _ ( 'e-mail address' ) , blank = True ) password = models . CharField ( _ ( 'password' ) , max_length = 128 ) is_staff = models . BooleanField ( _ ( 'staff status' ) , default = False , help_text = _ ( 'Designates whether the user can log into this admin ' ) ) is_active = models . BooleanField ( _ ( 'active' ) , default = True , help_text = _ ( 'Designates whether this user should be treated as ' ) ) is_superuser = models . BooleanField ( _ ( 'superuser status' ) , default = False , help_text = _ ( 'Designates that this user has all permissions without ' ) ) last_login = models . DateTimeField ( _ ( 'last login' ) , default = timezone . now ) date_joined = models . DateTimeField ( _ ( 'date joined' ) , default = timezone . now ) groups = models . ManyToManyField ( Group , verbose_name = _ ( 'groups' ) , blank = True , help_text = _ ( 'The groups this user belongs to. A user will ' ) ) user_permissions = models . ManyToManyField ( Permission , verbose_name = _ ( 'user permissions' ) , blank = True , help_text = 'Specific permissions for this user.' ) objects = UserManager ( ) class Meta : verbose_name = _ ( 'user' ) verbose_name_plural = _ ( 'users' ) def __unicode__ ( self ) : return self . username def natural_key ( self ) : return ( self . username , ) def get_absolute_url ( self ) : return "/users/%s/" % urllib . quote ( smart_str ( self . username ) ) def is_anonymous ( self ) : return False def is_authenticated ( self ) : return True def get_full_name ( self ) : full_name = u'%s %s' % ( self . first_name , self . last_name ) return full_name . strip ( ) def set_password ( self , raw_password ) : self . password = make_password ( raw_password ) def check_password ( self , raw_password ) : def setter ( raw_password ) : self . set_password ( raw_password ) self . save ( ) return check_password ( raw_password , self . password , setter ) def set_unusable_password ( self ) : self . password = make_password ( None ) def has_usable_password ( self ) : return is_password_usable ( self . password ) def get_group_permissions ( self , obj = None ) : permissions = set ( ) for backend in auth . get_backends ( ) : if hasattr ( backend , "get_group_permissions" ) : if obj is not None : permissions . update ( backend . get_group_permissions ( self , obj ) ) else : permissions . update ( backend . get_group_permissions ( self ) ) return permissions def get_all_permissions ( self , obj = None ) : return _user_get_all_permissions ( self , obj ) def has_perm ( self , perm , obj = None ) : if self . is_active and self . is_superuser : return True return _user_has_perm ( self , perm , obj ) def has_perms ( self , perm_list , obj = None ) : for perm in perm_list : if not self . has_perm ( perm , obj ) : return False return True def has_module_perms ( self , app_label ) : if self . is_active and self . is_superuser : return True return _user_has_module_perms ( self , app_label ) def email_user ( self , subject , message , from_email = None ) : send_mail ( subject , message , from_email , [ self . email ] ) def get_profile ( self ) : if not hasattr ( self , '_profile_cache' ) : from django . conf import settings if not getattr ( settings , 'AUTH_PROFILE_MODULE' , False ) : raise SiteProfileNotAvailable ( ) try : app_label , model_name = settings . AUTH_PROFILE_MODULE . split ( '.' ) except ValueError : raise SiteProfileNotAvailable ( ) try : model = models . get_model ( app_label , model_name ) if model is None : raise SiteProfileNotAvailable ( ) self . _profile_cache = model . _default_manager . using ( self . _state . db ) . get ( user__id__exact = self . id ) self . _profile_cache . user = self except ( ImportError , ImproperlyConfigured ) : raise SiteProfileNotAvailable return self . _profile_cache class AnonymousUser ( object ) : id = None username = '' is_staff = False is_active = False is_superuser = False _groups = EmptyManager ( ) _user_permissions = EmptyManager ( ) def __init__ ( self ) : pass def __unicode__ ( self ) : return 'AnonymousUser' def __str__ ( self ) : return unicode ( self ) . encode ( 'utf-8' ) def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __hash__ ( self ) : return 1 def save ( self ) : raise NotImplementedError def delete ( self ) : raise NotImplementedError def set_password ( self , raw_password ) : raise NotImplementedError def check_password ( self , raw_password ) : raise NotImplementedError def _get_groups ( self ) : return self . _groups groups = property ( _get_groups ) def _get_user_permissions ( self ) : return self . _user_permissions user_permissions = property ( _get_user_permissions ) def get_group_permissions ( self , obj = None ) : return set ( ) def get_all_permissions ( self , obj = None ) : return _user_get_all_permissions ( self , obj = obj ) def has_perm ( self , perm , obj = None ) : return _user_has_perm ( self , perm , obj = obj ) def has_perms ( self , perm_list , obj = None ) : for perm in perm_list : if not self . has_perm ( perm , obj ) : return False return True def has_module_perms ( self , module ) : return _user_has_module_perms ( self , module ) def is_anonymous ( self ) : return True def is_authenticated ( self ) : return False

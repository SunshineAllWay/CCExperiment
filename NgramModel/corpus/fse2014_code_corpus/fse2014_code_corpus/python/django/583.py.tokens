from __future__ import absolute_import import datetime import pickle from StringIO import StringIO from django . conf import settings from django . contrib . auth . models import User from django . contrib . contenttypes . models import ContentType from django . core import management from django . db import connections , router , DEFAULT_DB_ALIAS from django . db . models import signals from django . test import TestCase from . models import Book , Person , Pet , Review , UserProfile def copy_content_types_from_default_to_other ( ) : for ct in ContentType . objects . using ( 'default' ) . all ( ) : ct . save ( using = 'other' ) class QueryTestCase ( TestCase ) : multi_db = True def test_db_selection ( self ) : self . assertEqual ( Book . objects . db , DEFAULT_DB_ALIAS ) self . assertEqual ( Book . objects . all ( ) . db , DEFAULT_DB_ALIAS ) self . assertEqual ( Book . objects . using ( 'other' ) . db , 'other' ) self . assertEqual ( Book . objects . db_manager ( 'other' ) . db , 'other' ) self . assertEqual ( Book . objects . db_manager ( 'other' ) . all ( ) . db , 'other' ) def test_default_creation ( self ) : Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) dive = Book ( ) dive . title = "Dive into Python" dive . published = datetime . date ( 2009 , 5 , 4 ) dive . save ( ) try : Book . objects . get ( title = "Pro Django" ) Book . objects . using ( 'default' ) . get ( title = "Pro Django" ) except Book . DoesNotExist : self . fail ( '"Dive Into Python" should exist on default database' ) self . assertRaises ( Book . DoesNotExist , Book . objects . using ( 'other' ) . get , title = "Pro Django" ) try : Book . objects . get ( title = "Dive into Python" ) Book . objects . using ( 'default' ) . get ( title = "Dive into Python" ) except Book . DoesNotExist : self . fail ( '"Dive into Python" should exist on default database' ) self . assertRaises ( Book . DoesNotExist , Book . objects . using ( 'other' ) . get , title = "Dive into Python" ) def test_other_creation ( self ) : Book . objects . using ( 'other' ) . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) dive = Book ( ) dive . title = "Dive into Python" dive . published = datetime . date ( 2009 , 5 , 4 ) dive . save ( using = 'other' ) try : Book . objects . using ( 'other' ) . get ( title = "Pro Django" ) except Book . DoesNotExist : self . fail ( '"Dive Into Python" should exist on other database' ) self . assertRaises ( Book . DoesNotExist , Book . objects . get , title = "Pro Django" ) self . assertRaises ( Book . DoesNotExist , Book . objects . using ( 'default' ) . get , title = "Pro Django" ) try : Book . objects . using ( 'other' ) . get ( title = "Dive into Python" ) except Book . DoesNotExist : self . fail ( '"Dive into Python" should exist on other database' ) self . assertRaises ( Book . DoesNotExist , Book . objects . get , title = "Dive into Python" ) self . assertRaises ( Book . DoesNotExist , Book . objects . using ( 'default' ) . get , title = "Dive into Python" ) def test_basic_queries ( self ) : dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) dive = Book . objects . using ( 'other' ) . get ( published = datetime . date ( 2009 , 5 , 4 ) ) self . assertEqual ( dive . title , "Dive into Python" ) self . assertRaises ( Book . DoesNotExist , Book . objects . using ( 'default' ) . get , published = datetime . date ( 2009 , 5 , 4 ) ) dive = Book . objects . using ( 'other' ) . get ( title__icontains = "dive" ) self . assertEqual ( dive . title , "Dive into Python" ) self . assertRaises ( Book . DoesNotExist , Book . objects . using ( 'default' ) . get , title__icontains = "dive" ) dive = Book . objects . using ( 'other' ) . get ( title__iexact = "dive INTO python" ) self . assertEqual ( dive . title , "Dive into Python" ) self . assertRaises ( Book . DoesNotExist , Book . objects . using ( 'default' ) . get , title__iexact = "dive INTO python" ) dive = Book . objects . using ( 'other' ) . get ( published__year = 2009 ) self . assertEqual ( dive . title , "Dive into Python" ) self . assertEqual ( dive . published , datetime . date ( 2009 , 5 , 4 ) ) self . assertRaises ( Book . DoesNotExist , Book . objects . using ( 'default' ) . get , published__year = 2009 ) years = Book . objects . using ( 'other' ) . dates ( 'published' , 'year' ) self . assertEqual ( [ o . year for o in years ] , [ 2009 ] ) years = Book . objects . using ( 'default' ) . dates ( 'published' , 'year' ) self . assertEqual ( [ o . year for o in years ] , [ ] ) months = Book . objects . using ( 'other' ) . dates ( 'published' , 'month' ) self . assertEqual ( [ o . month for o in months ] , [ 5 ] ) months = Book . objects . using ( 'default' ) . dates ( 'published' , 'month' ) self . assertEqual ( [ o . month for o in months ] , [ ] ) def test_m2m_separation ( self ) : pro = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) marty = Person . objects . create ( name = "Marty Alchin" ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) pro . authors = [ marty ] dive . authors = [ mark ] self . assertEqual ( Book . authors . through . objects . using ( 'default' ) . count ( ) , 1 ) self . assertEqual ( Book . authors . through . objects . using ( 'other' ) . count ( ) , 1 ) self . assertEqual ( list ( Book . objects . using ( 'default' ) . filter ( authors__name = 'Marty Alchin' ) . values_list ( 'title' , flat = True ) ) , [ u'Pro Django' ] ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'Marty Alchin' ) . values_list ( 'title' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Book . objects . using ( 'default' ) . filter ( authors__name = 'Mark Pilgrim' ) . values_list ( 'title' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'Mark Pilgrim' ) . values_list ( 'title' , flat = True ) ) , [ u'Dive into Python' ] ) dive = Book . objects . using ( 'other' ) . get ( title = "Dive into Python" ) mark = Person . objects . using ( 'other' ) . get ( name = "Mark Pilgrim" ) self . assertEqual ( list ( dive . authors . all ( ) . values_list ( 'name' , flat = True ) ) , [ u'Mark Pilgrim' ] ) self . assertEqual ( list ( mark . book_set . all ( ) . values_list ( 'title' , flat = True ) ) , [ u'Dive into Python' ] ) def test_m2m_forward_operations ( self ) : dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) dive . authors = [ mark ] john = Person . objects . using ( 'other' ) . create ( name = "John Smith" ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'John Smith' ) . values_list ( 'title' , flat = True ) ) , [ ] ) dive . authors . add ( john ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'Mark Pilgrim' ) . values_list ( 'title' , flat = True ) ) , [ u'Dive into Python' ] ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'John Smith' ) . values_list ( 'title' , flat = True ) ) , [ u'Dive into Python' ] ) dive . authors . remove ( john ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'Mark Pilgrim' ) . values_list ( 'title' , flat = True ) ) , [ u'Dive into Python' ] ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'John Smith' ) . values_list ( 'title' , flat = True ) ) , [ ] ) dive . authors . clear ( ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'Mark Pilgrim' ) . values_list ( 'title' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'John Smith' ) . values_list ( 'title' , flat = True ) ) , [ ] ) dive . authors . create ( name = 'Jane Brown' ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'Mark Pilgrim' ) . values_list ( 'title' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . filter ( authors__name = 'Jane Brown' ) . values_list ( 'title' , flat = True ) ) , [ u'Dive into Python' ] ) def test_m2m_reverse_operations ( self ) : dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) dive . authors = [ mark ] grease = Book . objects . using ( 'other' ) . create ( title = "Greasemonkey Hacks" , published = datetime . date ( 2005 , 11 , 1 ) ) mark . book_set . add ( grease ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( book__title = 'Dive into Python' ) . values_list ( 'name' , flat = True ) ) , [ u'Mark Pilgrim' ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( book__title = 'Greasemonkey Hacks' ) . values_list ( 'name' , flat = True ) ) , [ u'Mark Pilgrim' ] ) mark . book_set . remove ( grease ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( book__title = 'Dive into Python' ) . values_list ( 'name' , flat = True ) ) , [ u'Mark Pilgrim' ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( book__title = 'Greasemonkey Hacks' ) . values_list ( 'name' , flat = True ) ) , [ ] ) mark . book_set . clear ( ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( book__title = 'Dive into Python' ) . values_list ( 'name' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( book__title = 'Greasemonkey Hacks' ) . values_list ( 'name' , flat = True ) ) , [ ] ) mark . book_set . create ( title = "Dive into HTML5" , published = datetime . date ( 2020 , 1 , 1 ) ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( book__title = 'Dive into Python' ) . values_list ( 'name' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( book__title = 'Dive into HTML5' ) . values_list ( 'name' , flat = True ) ) , [ u'Mark Pilgrim' ] ) def test_m2m_cross_database_protection ( self ) : pro = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) marty = Person . objects . create ( name = "Marty Alchin" ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) try : marty . book_set = [ pro , dive ] self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass try : marty . book_set . add ( dive ) self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass try : marty . book_set = [ pro , dive ] self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass try : dive . authors . add ( marty ) self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass try : dive . authors = [ mark , marty ] self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass def test_m2m_deletion ( self ) : dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) dive . authors = [ mark ] self . assertEqual ( Person . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . authors . through . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Person . objects . using ( 'other' ) . count ( ) , 1 ) self . assertEqual ( Book . objects . using ( 'other' ) . count ( ) , 1 ) self . assertEqual ( Book . authors . through . objects . using ( 'other' ) . count ( ) , 1 ) dive . delete ( using = 'other' ) self . assertEqual ( Person . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . authors . through . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Person . objects . using ( 'other' ) . count ( ) , 1 ) self . assertEqual ( Book . objects . using ( 'other' ) . count ( ) , 0 ) self . assertEqual ( Book . authors . through . objects . using ( 'other' ) . count ( ) , 0 ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) dive . authors = [ mark ] self . assertEqual ( Person . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . authors . through . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Person . objects . using ( 'other' ) . count ( ) , 1 ) self . assertEqual ( Book . objects . using ( 'other' ) . count ( ) , 1 ) self . assertEqual ( Book . authors . through . objects . using ( 'other' ) . count ( ) , 1 ) mark . delete ( using = 'other' ) self . assertEqual ( Person . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . authors . through . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Person . objects . using ( 'other' ) . count ( ) , 0 ) self . assertEqual ( Book . objects . using ( 'other' ) . count ( ) , 1 ) self . assertEqual ( Book . authors . through . objects . using ( 'other' ) . count ( ) , 0 ) def test_foreign_key_separation ( self ) : pro = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) marty = Person . objects . create ( name = "Marty Alchin" ) george = Person . objects . create ( name = "George Vilches" ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) chris = Person . objects . using ( 'other' ) . create ( name = "Chris Mills" ) pro . editor = george pro . save ( ) dive . editor = chris dive . save ( ) pro = Book . objects . using ( 'default' ) . get ( title = "Pro Django" ) self . assertEqual ( pro . editor . name , "George Vilches" ) dive = Book . objects . using ( 'other' ) . get ( title = "Dive into Python" ) self . assertEqual ( dive . editor . name , "Chris Mills" ) self . assertEqual ( list ( Person . objects . using ( 'default' ) . filter ( edited__title = 'Pro Django' ) . values_list ( 'name' , flat = True ) ) , [ u'George Vilches' ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Pro Django' ) . values_list ( 'name' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Person . objects . using ( 'default' ) . filter ( edited__title = 'Dive into Python' ) . values_list ( 'name' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into Python' ) . values_list ( 'name' , flat = True ) ) , [ u'Chris Mills' ] ) chris = Person . objects . using ( 'other' ) . get ( name = "Chris Mills" ) dive = Book . objects . using ( 'other' ) . get ( title = "Dive into Python" ) self . assertEqual ( list ( chris . edited . values_list ( 'title' , flat = True ) ) , [ u'Dive into Python' ] ) def test_foreign_key_reverse_operations ( self ) : dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) chris = Person . objects . using ( 'other' ) . create ( name = "Chris Mills" ) dive . editor = chris dive . save ( ) html5 = Book . objects . using ( 'other' ) . create ( title = "Dive into HTML5" , published = datetime . date ( 2010 , 3 , 15 ) ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into HTML5' ) . values_list ( 'name' , flat = True ) ) , [ ] ) chris . edited . add ( html5 ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into HTML5' ) . values_list ( 'name' , flat = True ) ) , [ u'Chris Mills' ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into Python' ) . values_list ( 'name' , flat = True ) ) , [ u'Chris Mills' ] ) chris . edited . remove ( html5 ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into HTML5' ) . values_list ( 'name' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into Python' ) . values_list ( 'name' , flat = True ) ) , [ u'Chris Mills' ] ) chris . edited . clear ( ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into HTML5' ) . values_list ( 'name' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into Python' ) . values_list ( 'name' , flat = True ) ) , [ ] ) chris . edited . create ( title = 'Dive into Water' , published = datetime . date ( 2010 , 3 , 15 ) ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into HTML5' ) . values_list ( 'name' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into Water' ) . values_list ( 'name' , flat = True ) ) , [ u'Chris Mills' ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . filter ( edited__title = 'Dive into Python' ) . values_list ( 'name' , flat = True ) ) , [ ] ) def test_foreign_key_cross_database_protection ( self ) : pro = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) marty = Person . objects . create ( name = "Marty Alchin" ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) try : dive . editor = marty self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass try : marty . edited = [ pro , dive ] self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass try : marty . edited . add ( dive ) self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass chris = Person ( name = "Chris Mills" ) html5 = Book ( title = "Dive into HTML5" , published = datetime . date ( 2010 , 3 , 15 ) ) self . assertEqual ( chris . _state . db , None ) self . assertEqual ( html5 . _state . db , None ) dive . editor = chris html5 . editor = mark self . assertEqual ( chris . _state . db , 'other' ) self . assertEqual ( html5 . _state . db , 'other' ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . values_list ( 'name' , flat = True ) ) , [ u'Mark Pilgrim' ] ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . values_list ( 'title' , flat = True ) ) , [ u'Dive into Python' ] ) chris . save ( ) html5 . save ( ) self . assertEqual ( list ( Person . objects . using ( 'default' ) . values_list ( 'name' , flat = True ) ) , [ u'Marty Alchin' ] ) self . assertEqual ( list ( Person . objects . using ( 'other' ) . values_list ( 'name' , flat = True ) ) , [ u'Chris Mills' , u'Mark Pilgrim' ] ) self . assertEqual ( list ( Book . objects . using ( 'default' ) . values_list ( 'title' , flat = True ) ) , [ u'Pro Django' ] ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . values_list ( 'title' , flat = True ) ) , [ u'Dive into HTML5' , u'Dive into Python' ] ) water = Book ( title = "Dive into Water" , published = datetime . date ( 2001 , 1 , 1 ) , editor = mark ) self . assertEqual ( water . _state . db , 'other' ) self . assertEqual ( list ( Book . objects . using ( 'default' ) . values_list ( 'title' , flat = True ) ) , [ u'Pro Django' ] ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . values_list ( 'title' , flat = True ) ) , [ u'Dive into HTML5' , u'Dive into Python' ] ) water . save ( ) self . assertEqual ( list ( Book . objects . using ( 'default' ) . values_list ( 'title' , flat = True ) ) , [ u'Pro Django' ] ) self . assertEqual ( list ( Book . objects . using ( 'other' ) . values_list ( 'title' , flat = True ) ) , [ u'Dive into HTML5' , u'Dive into Python' , u'Dive into Water' ] ) def test_foreign_key_deletion ( self ) : mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) fido = Pet . objects . using ( 'other' ) . create ( name = "Fido" , owner = mark ) self . assertEqual ( Person . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Pet . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Person . objects . using ( 'other' ) . count ( ) , 1 ) self . assertEqual ( Pet . objects . using ( 'other' ) . count ( ) , 1 ) mark . delete ( using = 'other' ) self . assertEqual ( Person . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Pet . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Person . objects . using ( 'other' ) . count ( ) , 0 ) self . assertEqual ( Pet . objects . using ( 'other' ) . count ( ) , 0 ) def test_foreign_key_validation ( self ) : mickey = Person . objects . using ( 'other' ) . create ( name = "Mickey" ) pluto = Pet . objects . using ( 'other' ) . create ( name = "Pluto" , owner = mickey ) self . assertEqual ( None , pluto . full_clean ( ) ) def test_o2o_separation ( self ) : alice = User . objects . db_manager ( 'default' ) . create_user ( 'alice' , 'alice@example.com' ) alice_profile = UserProfile . objects . using ( 'default' ) . create ( user = alice , flavor = 'chocolate' ) bob = User . objects . db_manager ( 'other' ) . create_user ( 'bob' , 'bob@example.com' ) bob_profile = UserProfile . objects . using ( 'other' ) . create ( user = bob , flavor = 'crunchy frog' ) alice = User . objects . using ( 'default' ) . get ( username = "alice" ) self . assertEqual ( alice . userprofile . flavor , "chocolate" ) bob = User . objects . using ( 'other' ) . get ( username = "bob" ) self . assertEqual ( bob . userprofile . flavor , "crunchy frog" ) self . assertEqual ( list ( User . objects . using ( 'default' ) . filter ( userprofile__flavor = 'chocolate' ) . values_list ( 'username' , flat = True ) ) , [ u'alice' ] ) self . assertEqual ( list ( User . objects . using ( 'other' ) . filter ( userprofile__flavor = 'chocolate' ) . values_list ( 'username' , flat = True ) ) , [ ] ) self . assertEqual ( list ( User . objects . using ( 'default' ) . filter ( userprofile__flavor = 'crunchy frog' ) . values_list ( 'username' , flat = True ) ) , [ ] ) self . assertEqual ( list ( User . objects . using ( 'other' ) . filter ( userprofile__flavor = 'crunchy frog' ) . values_list ( 'username' , flat = True ) ) , [ u'bob' ] ) alice_profile = UserProfile . objects . using ( 'default' ) . get ( flavor = 'chocolate' ) bob_profile = UserProfile . objects . using ( 'other' ) . get ( flavor = 'crunchy frog' ) self . assertEqual ( alice_profile . user . username , 'alice' ) self . assertEqual ( bob_profile . user . username , 'bob' ) def test_o2o_cross_database_protection ( self ) : alice = User . objects . db_manager ( 'default' ) . create_user ( 'alice' , 'alice@example.com' ) bob = User . objects . db_manager ( 'other' ) . create_user ( 'bob' , 'bob@example.com' ) alice_profile = UserProfile . objects . using ( 'default' ) . create ( user = alice , flavor = 'chocolate' ) try : bob . userprofile = alice_profile self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass bob_profile = UserProfile . objects . using ( 'other' ) . create ( user = bob , flavor = 'crunchy frog' ) new_bob_profile = UserProfile ( flavor = "spring surprise" ) charlie = User ( username = 'charlie' , email = 'charlie@example.com' ) charlie . set_unusable_password ( ) self . assertEqual ( new_bob_profile . _state . db , None ) self . assertEqual ( charlie . _state . db , None ) new_bob_profile . user = bob charlie . userprofile = bob_profile self . assertEqual ( new_bob_profile . _state . db , 'other' ) self . assertEqual ( charlie . _state . db , 'other' ) self . assertEqual ( list ( User . objects . using ( 'other' ) . values_list ( 'username' , flat = True ) ) , [ u'bob' ] ) self . assertEqual ( list ( UserProfile . objects . using ( 'other' ) . values_list ( 'flavor' , flat = True ) ) , [ u'crunchy frog' ] ) charlie . save ( ) bob_profile . save ( ) new_bob_profile . save ( ) self . assertEqual ( list ( User . objects . using ( 'default' ) . values_list ( 'username' , flat = True ) ) , [ u'alice' ] ) self . assertEqual ( list ( User . objects . using ( 'other' ) . values_list ( 'username' , flat = True ) ) , [ u'bob' , u'charlie' ] ) self . assertEqual ( list ( UserProfile . objects . using ( 'default' ) . values_list ( 'flavor' , flat = True ) ) , [ u'chocolate' ] ) self . assertEqual ( list ( UserProfile . objects . using ( 'other' ) . values_list ( 'flavor' , flat = True ) ) , [ u'crunchy frog' , u'spring surprise' ] ) denise = User . objects . db_manager ( 'other' ) . create_user ( 'denise' , 'denise@example.com' ) denise_profile = UserProfile ( flavor = "tofu" , user = denise ) self . assertEqual ( denise_profile . _state . db , 'other' ) self . assertEqual ( list ( UserProfile . objects . using ( 'default' ) . values_list ( 'flavor' , flat = True ) ) , [ u'chocolate' ] ) self . assertEqual ( list ( UserProfile . objects . using ( 'other' ) . values_list ( 'flavor' , flat = True ) ) , [ u'crunchy frog' , u'spring surprise' ] ) denise_profile . save ( ) self . assertEqual ( list ( UserProfile . objects . using ( 'default' ) . values_list ( 'flavor' , flat = True ) ) , [ u'chocolate' ] ) self . assertEqual ( list ( UserProfile . objects . using ( 'other' ) . values_list ( 'flavor' , flat = True ) ) , [ u'crunchy frog' , u'spring surprise' , u'tofu' ] ) def test_generic_key_separation ( self ) : copy_content_types_from_default_to_other ( ) pro = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) review1 = Review . objects . create ( source = "Python Monthly" , content_object = pro ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) review2 = Review . objects . using ( 'other' ) . create ( source = "Python Weekly" , content_object = dive ) review1 = Review . objects . using ( 'default' ) . get ( source = "Python Monthly" ) self . assertEqual ( review1 . content_object . title , "Pro Django" ) review2 = Review . objects . using ( 'other' ) . get ( source = "Python Weekly" ) self . assertEqual ( review2 . content_object . title , "Dive into Python" ) dive = Book . objects . using ( 'other' ) . get ( title = "Dive into Python" ) self . assertEqual ( list ( dive . reviews . all ( ) . values_list ( 'source' , flat = True ) ) , [ u'Python Weekly' ] ) def test_generic_key_reverse_operations ( self ) : copy_content_types_from_default_to_other ( ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) temp = Book . objects . using ( 'other' ) . create ( title = "Temp" , published = datetime . date ( 2009 , 5 , 4 ) ) review1 = Review . objects . using ( 'other' ) . create ( source = "Python Weekly" , content_object = dive ) review2 = Review . objects . using ( 'other' ) . create ( source = "Python Monthly" , content_object = temp ) self . assertEqual ( list ( Review . objects . using ( 'default' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Review . objects . using ( 'other' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ u'Python Weekly' ] ) dive . reviews . add ( review2 ) self . assertEqual ( list ( Review . objects . using ( 'default' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Review . objects . using ( 'other' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ u'Python Monthly' , u'Python Weekly' ] ) dive . reviews . remove ( review1 ) self . assertEqual ( list ( Review . objects . using ( 'default' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Review . objects . using ( 'other' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ u'Python Monthly' ] ) dive . reviews . clear ( ) self . assertEqual ( list ( Review . objects . using ( 'default' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Review . objects . using ( 'other' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ ] ) dive . reviews . create ( source = 'Python Daily' ) self . assertEqual ( list ( Review . objects . using ( 'default' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ ] ) self . assertEqual ( list ( Review . objects . using ( 'other' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ u'Python Daily' ] ) def test_generic_key_cross_database_protection ( self ) : copy_content_types_from_default_to_other ( ) pro = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) review1 = Review . objects . create ( source = "Python Monthly" , content_object = pro ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) review2 = Review . objects . using ( 'other' ) . create ( source = "Python Weekly" , content_object = dive ) try : review1 . content_object = dive self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass try : dive . reviews . add ( review1 ) self . fail ( "Shouldn't be able to assign across databases" ) except ValueError : pass review3 = Review ( source = "Python Daily" ) self . assertEqual ( review3 . _state . db , None ) review3 . content_object = dive self . assertEqual ( review3 . _state . db , 'other' ) self . assertEqual ( list ( Review . objects . using ( 'default' ) . filter ( object_id = pro . pk ) . values_list ( 'source' , flat = True ) ) , [ u'Python Monthly' ] ) self . assertEqual ( list ( Review . objects . using ( 'other' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ u'Python Weekly' ] ) review3 . save ( ) self . assertEqual ( list ( Review . objects . using ( 'default' ) . filter ( object_id = pro . pk ) . values_list ( 'source' , flat = True ) ) , [ u'Python Monthly' ] ) self . assertEqual ( list ( Review . objects . using ( 'other' ) . filter ( object_id = dive . pk ) . values_list ( 'source' , flat = True ) ) , [ u'Python Daily' , u'Python Weekly' ] ) def test_generic_key_deletion ( self ) : copy_content_types_from_default_to_other ( ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) review = Review . objects . using ( 'other' ) . create ( source = "Python Weekly" , content_object = dive ) self . assertEqual ( Book . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Review . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . objects . using ( 'other' ) . count ( ) , 1 ) self . assertEqual ( Review . objects . using ( 'other' ) . count ( ) , 1 ) dive . delete ( using = 'other' ) self . assertEqual ( Book . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Review . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . objects . using ( 'other' ) . count ( ) , 0 ) self . assertEqual ( Review . objects . using ( 'other' ) . count ( ) , 0 ) def test_ordering ( self ) : pro = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) learn = Book . objects . using ( 'other' ) . create ( title = "Learning Python" , published = datetime . date ( 2008 , 7 , 16 ) ) self . assertEqual ( learn . get_next_by_published ( ) . title , "Dive into Python" ) self . assertEqual ( dive . get_previous_by_published ( ) . title , "Learning Python" ) def test_raw ( self ) : dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) val = Book . objects . db_manager ( "other" ) . raw ( 'SELECT id FROM multiple_database_book' ) self . assertEqual ( map ( lambda o : o . pk , val ) , [ dive . pk ] ) val = Book . objects . raw ( 'SELECT id FROM multiple_database_book' ) . using ( 'other' ) self . assertEqual ( map ( lambda o : o . pk , val ) , [ dive . pk ] ) def test_select_related ( self ) : mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) , editor = mark ) book = Book . objects . using ( 'other' ) . select_related ( 'editor' ) . get ( title = "Dive into Python" ) self . assertEqual ( book . editor . _state . db , 'other' ) def test_subquery ( self ) : sub = Person . objects . using ( 'other' ) . filter ( name = 'fff' ) qs = Book . objects . filter ( editor__in = sub ) self . assertRaises ( ValueError , str , qs . query ) try : for obj in qs : pass self . fail ( 'Iterating over query should raise ValueError' ) except ValueError : pass def test_related_manager ( self ) : mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) mark . book_set . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) , extra_arg = True ) mark . book_set . get_or_create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) , extra_arg = True ) mark . edited . create ( title = "Dive into Water" , published = datetime . date ( 2009 , 5 , 4 ) , extra_arg = True ) mark . edited . get_or_create ( title = "Dive into Water" , published = datetime . date ( 2009 , 5 , 4 ) , extra_arg = True ) class TestRouter ( object ) : def db_for_read ( self , model , instance = None , ** hints ) : if instance : return instance . _state . db or 'other' return 'other' def db_for_write ( self , model , ** hints ) : return DEFAULT_DB_ALIAS def allow_relation ( self , obj1 , obj2 , ** hints ) : return obj1 . _state . db in ( 'default' , 'other' ) and obj2 . _state . db in ( 'default' , 'other' ) def allow_syncdb ( self , db , model ) : return True class AuthRouter ( object ) : def db_for_read ( self , model , ** hints ) : if model . _meta . app_label == 'auth' : return 'default' return None def db_for_write ( self , model , ** hints ) : if model . _meta . app_label == 'auth' : return 'other' return None def allow_relation ( self , obj1 , obj2 , ** hints ) : if obj1 . _meta . app_label == 'auth' or obj2 . _meta . app_label == 'auth' : return True return None def allow_syncdb ( self , db , model ) : if db == 'other' : return model . _meta . app_label == 'auth' elif model . _meta . app_label == 'auth' : return False return None class WriteRouter ( object ) : def db_for_write ( self , model , ** hints ) : return 'writer' class RouterTestCase ( TestCase ) : multi_db = True def setUp ( self ) : self . old_routers = router . routers router . routers = [ TestRouter ( ) ] def tearDown ( self ) : router . routers = self . old_routers def test_db_selection ( self ) : self . assertEqual ( Book . objects . db , 'other' ) self . assertEqual ( Book . objects . all ( ) . db , 'other' ) self . assertEqual ( Book . objects . using ( 'default' ) . db , 'default' ) self . assertEqual ( Book . objects . db_manager ( 'default' ) . db , 'default' ) self . assertEqual ( Book . objects . db_manager ( 'default' ) . all ( ) . db , 'default' ) def test_syncdb_selection ( self ) : self . assertTrue ( router . allow_syncdb ( 'default' , User ) ) self . assertTrue ( router . allow_syncdb ( 'default' , Book ) ) self . assertTrue ( router . allow_syncdb ( 'other' , User ) ) self . assertTrue ( router . allow_syncdb ( 'other' , Book ) ) router . routers = [ TestRouter ( ) , AuthRouter ( ) ] self . assertTrue ( router . allow_syncdb ( 'default' , User ) ) self . assertTrue ( router . allow_syncdb ( 'default' , Book ) ) self . assertTrue ( router . allow_syncdb ( 'other' , User ) ) self . assertTrue ( router . allow_syncdb ( 'other' , Book ) ) router . routers = [ AuthRouter ( ) , TestRouter ( ) ] self . assertFalse ( router . allow_syncdb ( 'default' , User ) ) self . assertTrue ( router . allow_syncdb ( 'default' , Book ) ) self . assertTrue ( router . allow_syncdb ( 'other' , User ) ) self . assertFalse ( router . allow_syncdb ( 'other' , Book ) ) def test_partial_router ( self ) : dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) self . assertEqual ( router . db_for_read ( User ) , 'other' ) self . assertEqual ( router . db_for_read ( Book ) , 'other' ) self . assertEqual ( router . db_for_write ( User ) , 'default' ) self . assertEqual ( router . db_for_write ( Book ) , 'default' ) self . assertTrue ( router . allow_relation ( dive , dive ) ) self . assertTrue ( router . allow_syncdb ( 'default' , User ) ) self . assertTrue ( router . allow_syncdb ( 'default' , Book ) ) router . routers = [ WriteRouter ( ) , AuthRouter ( ) , TestRouter ( ) ] self . assertEqual ( router . db_for_read ( User ) , 'default' ) self . assertEqual ( router . db_for_read ( Book ) , 'other' ) self . assertEqual ( router . db_for_write ( User ) , 'writer' ) self . assertEqual ( router . db_for_write ( Book ) , 'writer' ) self . assertTrue ( router . allow_relation ( dive , dive ) ) self . assertFalse ( router . allow_syncdb ( 'default' , User ) ) self . assertTrue ( router . allow_syncdb ( 'default' , Book ) ) def test_database_routing ( self ) : marty = Person . objects . using ( 'default' ) . create ( name = "Marty Alchin" ) pro = Book . objects . using ( 'default' ) . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) , editor = marty ) pro . authors = [ marty ] dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) Book . objects . filter ( title = 'Pro Django' ) . update ( pages = 200 ) try : Book . objects . get ( title = 'Pro Django' ) self . fail ( "Shouldn't be able to find the book" ) except Book . DoesNotExist : pass pro = Book . objects . using ( 'default' ) . get ( title = 'Pro Django' ) self . assertEqual ( pro . pages , 200 ) Book . objects . using ( 'other' ) . filter ( title = 'Dive into Python' ) . update ( pages = 300 ) self . assertEqual ( Book . objects . get ( title = 'Dive into Python' ) . pages , 300 ) self . assertEqual ( list ( pro . authors . values_list ( 'name' , flat = True ) ) , [ u'Marty Alchin' ] ) self . assertEqual ( pro . editor . name , u'Marty Alchin' ) book , created = Book . objects . get_or_create ( title = "Pro Django" ) self . assertFalse ( created ) book , created = Book . objects . get_or_create ( title = "Dive Into Python" , defaults = { 'published' : datetime . date ( 2009 , 5 , 4 ) } ) self . assertTrue ( created ) self . assertEqual ( Book . objects . using ( 'default' ) . count ( ) , 2 ) self . assertEqual ( Book . objects . using ( 'other' ) . count ( ) , 1 ) self . assertEqual ( Book . objects . count ( ) , 1 ) Book . objects . filter ( pages__gt = 150 ) . delete ( ) self . assertEqual ( Book . objects . using ( 'default' ) . count ( ) , 1 ) self . assertEqual ( Book . objects . using ( 'other' ) . count ( ) , 1 ) def test_foreign_key_cross_database_protection ( self ) : pro = Book . objects . using ( 'default' ) . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) marty = Person . objects . using ( 'default' ) . create ( name = "Marty Alchin" ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) try : dive . editor = marty except ValueError : self . fail ( "Assignment across master/slave databases with a common source should be ok" ) self . assertEqual ( marty . _state . db , 'default' ) self . assertEqual ( pro . _state . db , 'default' ) self . assertEqual ( dive . _state . db , 'other' ) self . assertEqual ( mark . _state . db , 'other' ) dive . save ( ) self . assertEqual ( dive . _state . db , 'default' ) try : Book . objects . using ( 'default' ) . get ( title = 'Dive into Python' ) . delete ( ) except Book . DoesNotExist : self . fail ( 'Source database should have a copy of saved object' ) dive = Book . objects . using ( 'other' ) . get ( title = 'Dive into Python' ) self . assertEqual ( dive . _state . db , 'other' ) try : marty . edited = [ pro , dive ] except ValueError : self . fail ( "Assignment across master/slave databases with a common source should be ok" ) self . assertEqual ( marty . _state . db , 'default' ) self . assertEqual ( pro . _state . db , 'default' ) self . assertEqual ( dive . _state . db , 'default' ) self . assertEqual ( mark . _state . db , 'other' ) try : Book . objects . using ( 'default' ) . get ( title = 'Dive into Python' ) . delete ( ) except Book . DoesNotExist : self . fail ( 'Source database should have a copy of saved object' ) dive = Book . objects . using ( 'other' ) . get ( title = 'Dive into Python' ) self . assertEqual ( dive . _state . db , 'other' ) try : marty . edited . add ( dive ) except ValueError : self . fail ( "Assignment across master/slave databases with a common source should be ok" ) self . assertEqual ( marty . _state . db , 'default' ) self . assertEqual ( pro . _state . db , 'default' ) self . assertEqual ( dive . _state . db , 'default' ) self . assertEqual ( mark . _state . db , 'other' ) try : Book . objects . using ( 'default' ) . get ( title = 'Dive into Python' ) . delete ( ) except Book . DoesNotExist : self . fail ( 'Source database should have a copy of saved object' ) dive = Book . objects . using ( 'other' ) . get ( title = 'Dive into Python' ) chris = Person ( name = "Chris Mills" ) html5 = Book ( title = "Dive into HTML5" , published = datetime . date ( 2010 , 3 , 15 ) ) self . assertEqual ( chris . _state . db , None ) self . assertEqual ( html5 . _state . db , None ) self . assertEqual ( dive . _state . db , 'other' ) dive . editor = chris html5 . editor = mark self . assertEqual ( dive . _state . db , 'other' ) self . assertEqual ( mark . _state . db , 'other' ) self . assertEqual ( chris . _state . db , 'default' ) self . assertEqual ( html5 . _state . db , 'default' ) water = Book ( title = "Dive into Water" , published = datetime . date ( 2001 , 1 , 1 ) , editor = mark ) self . assertEqual ( water . _state . db , 'default' ) mark . save ( using = 'default' ) mark . save ( using = 'other' ) self . assertEqual ( mark . _state . db , 'other' ) cheesecake = mark . edited . create ( title = 'Dive into Cheesecake' , published = datetime . date ( 2010 , 3 , 15 ) ) self . assertEqual ( cheesecake . _state . db , 'default' ) cheesecake , created = mark . edited . get_or_create ( title = 'Dive into Cheesecake' , published = datetime . date ( 2010 , 3 , 15 ) ) self . assertEqual ( cheesecake . _state . db , 'default' ) puddles , created = mark . edited . get_or_create ( title = 'Dive into Puddles' , published = datetime . date ( 2010 , 3 , 15 ) ) self . assertEqual ( puddles . _state . db , 'default' ) def test_m2m_cross_database_protection ( self ) : pro = Book . objects . using ( 'other' ) . create ( pk = 1 , title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) marty = Person . objects . using ( 'other' ) . create ( pk = 1 , name = "Marty Alchin" ) dive = Book . objects . using ( 'default' ) . create ( pk = 2 , title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) mark = Person . objects . using ( 'default' ) . create ( pk = 2 , name = "Mark Pilgrim" ) pro . save ( using = 'default' ) marty . save ( using = 'default' ) dive . save ( using = 'other' ) mark . save ( using = 'other' ) self . assertEqual ( Book . objects . using ( 'default' ) . count ( ) , 2 ) self . assertEqual ( Book . objects . using ( 'other' ) . count ( ) , 2 ) self . assertEqual ( Person . objects . using ( 'default' ) . count ( ) , 2 ) self . assertEqual ( Person . objects . using ( 'other' ) . count ( ) , 2 ) try : marty . book_set = [ pro , dive ] except ValueError : self . fail ( "Assignment across master/slave databases with a common source should be ok" ) self . assertEqual ( marty . _state . db , 'default' ) self . assertEqual ( pro . _state . db , 'default' ) self . assertEqual ( dive . _state . db , 'other' ) self . assertEqual ( mark . _state . db , 'other' ) self . assertEqual ( Book . authors . through . objects . using ( 'default' ) . count ( ) , 2 ) self . assertEqual ( Book . authors . through . objects . using ( 'other' ) . count ( ) , 0 ) Book . authors . through . objects . using ( 'default' ) . delete ( ) try : marty . book_set . add ( dive ) except ValueError : self . fail ( "Assignment across master/slave databases with a common source should be ok" ) self . assertEqual ( marty . _state . db , 'default' ) self . assertEqual ( pro . _state . db , 'default' ) self . assertEqual ( dive . _state . db , 'other' ) self . assertEqual ( mark . _state . db , 'other' ) self . assertEqual ( Book . authors . through . objects . using ( 'default' ) . count ( ) , 1 ) self . assertEqual ( Book . authors . through . objects . using ( 'other' ) . count ( ) , 0 ) Book . authors . through . objects . using ( 'default' ) . delete ( ) try : dive . authors = [ mark , marty ] except ValueError : self . fail ( "Assignment across master/slave databases with a common source should be ok" ) self . assertEqual ( marty . _state . db , 'default' ) self . assertEqual ( pro . _state . db , 'default' ) self . assertEqual ( dive . _state . db , 'other' ) self . assertEqual ( mark . _state . db , 'other' ) self . assertEqual ( Book . authors . through . objects . using ( 'default' ) . count ( ) , 2 ) self . assertEqual ( Book . authors . through . objects . using ( 'other' ) . count ( ) , 0 ) Book . authors . through . objects . using ( 'default' ) . delete ( ) self . assertEqual ( Book . authors . through . objects . using ( 'default' ) . count ( ) , 0 ) self . assertEqual ( Book . authors . through . objects . using ( 'other' ) . count ( ) , 0 ) try : dive . authors . add ( marty ) except ValueError : self . fail ( "Assignment across master/slave databases with a common source should be ok" ) self . assertEqual ( marty . _state . db , 'default' ) self . assertEqual ( pro . _state . db , 'default' ) self . assertEqual ( dive . _state . db , 'other' ) self . assertEqual ( mark . _state . db , 'other' ) self . assertEqual ( Book . authors . through . objects . using ( 'default' ) . count ( ) , 1 ) self . assertEqual ( Book . authors . through . objects . using ( 'other' ) . count ( ) , 0 ) alice = dive . authors . create ( name = 'Alice' ) self . assertEqual ( alice . _state . db , 'default' ) alice , created = dive . authors . get_or_create ( name = 'Alice' ) self . assertEqual ( alice . _state . db , 'default' ) bob , created = dive . authors . get_or_create ( name = 'Bob' ) self . assertEqual ( bob . _state . db , 'default' ) def test_o2o_cross_database_protection ( self ) : alice = User . objects . db_manager ( 'default' ) . create_user ( 'alice' , 'alice@example.com' ) bob = User . objects . db_manager ( 'other' ) . create_user ( 'bob' , 'bob@example.com' ) alice_profile = UserProfile . objects . create ( user = alice , flavor = 'chocolate' ) try : bob . userprofile = alice_profile except ValueError : self . fail ( "Assignment across master/slave databases with a common source should be ok" ) self . assertEqual ( alice . _state . db , 'default' ) self . assertEqual ( alice_profile . _state . db , 'default' ) self . assertEqual ( bob . _state . db , 'other' ) bob . save ( ) self . assertEqual ( bob . _state . db , 'default' ) def test_generic_key_cross_database_protection ( self ) : copy_content_types_from_default_to_other ( ) pro = Book . objects . using ( 'default' ) . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) review1 = Review . objects . using ( 'default' ) . create ( source = "Python Monthly" , content_object = pro ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) ) review2 = Review . objects . using ( 'other' ) . create ( source = "Python Weekly" , content_object = dive ) try : review1 . content_object = dive except ValueError : self . fail ( "Assignment across master/slave databases with a common source should be ok" ) self . assertEqual ( pro . _state . db , 'default' ) self . assertEqual ( review1 . _state . db , 'default' ) self . assertEqual ( dive . _state . db , 'other' ) self . assertEqual ( review2 . _state . db , 'other' ) dive . save ( ) self . assertEqual ( review1 . _state . db , 'default' ) self . assertEqual ( dive . _state . db , 'default' ) try : Book . objects . using ( 'default' ) . get ( title = 'Dive into Python' ) . delete ( ) except Book . DoesNotExist : self . fail ( 'Source database should have a copy of saved object' ) dive = Book . objects . using ( 'other' ) . get ( title = 'Dive into Python' ) self . assertEqual ( dive . _state . db , 'other' ) try : dive . reviews . add ( review1 ) except ValueError : self . fail ( "Assignment across master/slave databases with a common source should be ok" ) self . assertEqual ( pro . _state . db , 'default' ) self . assertEqual ( review1 . _state . db , 'default' ) self . assertEqual ( dive . _state . db , 'other' ) self . assertEqual ( review2 . _state . db , 'other' ) dive . save ( ) self . assertEqual ( dive . _state . db , 'default' ) try : Book . objects . using ( 'default' ) . get ( title = 'Dive into Python' ) . delete ( ) except Book . DoesNotExist : self . fail ( 'Source database should have a copy of saved object' ) review3 = Review ( source = "Python Daily" ) self . assertEqual ( review3 . _state . db , None ) review3 . content_object = dive self . assertEqual ( review3 . _state . db , 'default' ) dive = Book . objects . using ( 'other' ) . get ( title = 'Dive into Python' ) nyt = dive . reviews . create ( source = "New York Times" , content_object = dive ) self . assertEqual ( nyt . _state . db , 'default' ) def test_m2m_managers ( self ) : pro = Book . objects . using ( 'other' ) . create ( pk = 1 , title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) marty = Person . objects . using ( 'other' ) . create ( pk = 1 , name = "Marty Alchin" ) pro_authors = pro . authors . using ( 'other' ) authors = [ marty ] self . assertEqual ( pro . authors . db , 'other' ) self . assertEqual ( pro . authors . db_manager ( 'default' ) . db , 'default' ) self . assertEqual ( pro . authors . db_manager ( 'default' ) . all ( ) . db , 'default' ) self . assertEqual ( marty . book_set . db , 'other' ) self . assertEqual ( marty . book_set . db_manager ( 'default' ) . db , 'default' ) self . assertEqual ( marty . book_set . db_manager ( 'default' ) . all ( ) . db , 'default' ) def test_foreign_key_managers ( self ) : marty = Person . objects . using ( 'other' ) . create ( pk = 1 , name = "Marty Alchin" ) pro = Book . objects . using ( 'other' ) . create ( pk = 1 , title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) , editor = marty ) self . assertEqual ( marty . edited . db , 'other' ) self . assertEqual ( marty . edited . db_manager ( 'default' ) . db , 'default' ) self . assertEqual ( marty . edited . db_manager ( 'default' ) . all ( ) . db , 'default' ) def test_generic_key_managers ( self ) : copy_content_types_from_default_to_other ( ) pro = Book . objects . using ( 'other' ) . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) review1 = Review . objects . using ( 'other' ) . create ( source = "Python Monthly" , content_object = pro ) self . assertEqual ( pro . reviews . db , 'other' ) self . assertEqual ( pro . reviews . db_manager ( 'default' ) . db , 'default' ) self . assertEqual ( pro . reviews . db_manager ( 'default' ) . all ( ) . db , 'default' ) def test_subquery ( self ) : mark = Person . objects . using ( 'other' ) . create ( name = "Mark Pilgrim" ) dive = Book . objects . using ( 'other' ) . create ( title = "Dive into Python" , published = datetime . date ( 2009 , 5 , 4 ) , editor = mark ) sub = Person . objects . filter ( name = 'Mark Pilgrim' ) qs = Book . objects . filter ( editor__in = sub ) str ( qs . query ) self . assertEqual ( list ( qs . values_list ( 'title' , flat = True ) ) , [ u'Dive into Python' ] ) class AuthTestCase ( TestCase ) : multi_db = True def setUp ( self ) : self . old_routers = router . routers router . routers = [ AuthRouter ( ) ] def tearDown ( self ) : router . routers = self . old_routers def test_auth_manager ( self ) : User . objects . create_user ( 'alice' , 'alice@example.com' ) User . objects . db_manager ( 'default' ) . create_user ( 'bob' , 'bob@example.com' ) alice = User . objects . using ( 'other' ) . get ( username = 'alice' ) self . assertEqual ( alice . username , 'alice' ) self . assertEqual ( alice . _state . db , 'other' ) self . assertRaises ( User . DoesNotExist , User . objects . using ( 'default' ) . get , username = 'alice' ) bob = User . objects . using ( 'default' ) . get ( username = 'bob' ) self . assertEqual ( bob . username , 'bob' ) self . assertEqual ( bob . _state . db , 'default' ) self . assertRaises ( User . DoesNotExist , User . objects . using ( 'other' ) . get , username = 'bob' ) self . assertEqual ( User . objects . using ( 'default' ) . count ( ) , 1 ) self . assertEqual ( User . objects . using ( 'other' ) . count ( ) , 1 ) def test_dumpdata ( self ) : User . objects . create_user ( 'alice' , 'alice@example.com' ) User . objects . db_manager ( 'default' ) . create_user ( 'bob' , 'bob@example.com' ) new_io = StringIO ( ) management . call_command ( 'dumpdata' , 'auth' , format = 'json' , database = 'default' , stdout = new_io ) command_output = new_io . getvalue ( ) . strip ( ) self . assertEqual ( command_output , '[]' ) new_io = StringIO ( ) management . call_command ( 'dumpdata' , 'auth' , format = 'json' , database = 'other' , stdout = new_io ) command_output = new_io . getvalue ( ) . strip ( ) self . assertTrue ( '"email": "alice@example.com",' in command_output ) _missing = object ( ) class UserProfileTestCase ( TestCase ) : def setUp ( self ) : self . old_auth_profile_module = getattr ( settings , 'AUTH_PROFILE_MODULE' , _missing ) settings . AUTH_PROFILE_MODULE = 'multiple_database.UserProfile' def tearDown ( self ) : if self . old_auth_profile_module is _missing : del settings . AUTH_PROFILE_MODULE else : settings . AUTH_PROFILE_MODULE = self . old_auth_profile_module def test_user_profiles ( self ) : alice = User . objects . create_user ( 'alice' , 'alice@example.com' ) bob = User . objects . db_manager ( 'other' ) . create_user ( 'bob' , 'bob@example.com' ) alice_profile = UserProfile ( user = alice , flavor = 'chocolate' ) alice_profile . save ( ) bob_profile = UserProfile ( user = bob , flavor = 'crunchy frog' ) bob_profile . save ( ) self . assertEqual ( alice . get_profile ( ) . flavor , 'chocolate' ) self . assertEqual ( bob . get_profile ( ) . flavor , 'crunchy frog' ) class AntiPetRouter ( object ) : def allow_syncdb ( self , db , model ) : if db == 'other' : return model . _meta . object_name == 'Pet' else : return model . _meta . object_name != 'Pet' class FixtureTestCase ( TestCase ) : multi_db = True fixtures = [ 'multidb-common' , 'multidb' ] def setUp ( self ) : self . old_routers = router . routers router . routers = [ AntiPetRouter ( ) ] def tearDown ( self ) : router . routers = self . old_routers def test_fixture_loading ( self ) : try : Book . objects . get ( title = "Pro Django" ) Book . objects . using ( 'default' ) . get ( title = "Pro Django" ) except Book . DoesNotExist : self . fail ( '"Pro Django" should exist on default database' ) self . assertRaises ( Book . DoesNotExist , Book . objects . using ( 'other' ) . get , title = "Pro Django" ) try : Book . objects . using ( 'other' ) . get ( title = "Dive into Python" ) except Book . DoesNotExist : self . fail ( '"Dive into Python" should exist on other database' ) self . assertRaises ( Book . DoesNotExist , Book . objects . get , title = "Dive into Python" ) self . assertRaises ( Book . DoesNotExist , Book . objects . using ( 'default' ) . get , title = "Dive into Python" ) try : Book . objects . get ( title = "The Definitive Guide to Django" ) Book . objects . using ( 'default' ) . get ( title = "The Definitive Guide to Django" ) Book . objects . using ( 'other' ) . get ( title = "The Definitive Guide to Django" ) except Book . DoesNotExist : self . fail ( '"The Definitive Guide to Django" should exist on both databases' ) def test_pseudo_empty_fixtures ( self ) : new_io = StringIO ( ) management . call_command ( 'loaddata' , 'pets' , stdout = new_io , stderr = new_io ) command_output = new_io . getvalue ( ) . strip ( ) self . assertEqual ( command_output , "Installed 0 object(s) (of 2) from 1 fixture(s)" ) class PickleQuerySetTestCase ( TestCase ) : multi_db = True def test_pickling ( self ) : for db in connections : Book . objects . using ( db ) . create ( title = 'Dive into Python' , published = datetime . date ( 2009 , 5 , 4 ) ) qs = Book . objects . all ( ) self . assertEqual ( qs . db , pickle . loads ( pickle . dumps ( qs ) ) . db ) class DatabaseReceiver ( object ) : def __call__ ( self , signal , sender , ** kwargs ) : self . _database = kwargs [ 'using' ] class WriteToOtherRouter ( object ) : def db_for_write ( self , model , ** hints ) : return "other" class SignalTests ( TestCase ) : multi_db = True def setUp ( self ) : self . old_routers = router . routers def tearDown ( self ) : router . routers = self . old_routers def _write_to_other ( self ) : router . routers = [ WriteToOtherRouter ( ) ] def _write_to_default ( self ) : router . routers = self . old_routers def test_database_arg_save_and_delete ( self ) : pre_save_receiver = DatabaseReceiver ( ) post_save_receiver = DatabaseReceiver ( ) pre_delete_receiver = DatabaseReceiver ( ) post_delete_receiver = DatabaseReceiver ( ) signals . pre_save . connect ( sender = Person , receiver = pre_save_receiver ) signals . post_save . connect ( sender = Person , receiver = post_save_receiver ) signals . pre_delete . connect ( sender = Person , receiver = pre_delete_receiver ) signals . post_delete . connect ( sender = Person , receiver = post_delete_receiver ) p = Person . objects . create ( name = 'Darth Vader' ) p . save ( ) self . assertEqual ( pre_save_receiver . _database , DEFAULT_DB_ALIAS ) self . assertEqual ( post_save_receiver . _database , DEFAULT_DB_ALIAS ) p . delete ( ) self . assertEqual ( pre_delete_receiver . _database , DEFAULT_DB_ALIAS ) self . assertEqual ( post_delete_receiver . _database , DEFAULT_DB_ALIAS ) p . save ( using = "other" ) self . assertEqual ( pre_save_receiver . _database , "other" ) self . assertEqual ( post_save_receiver . _database , "other" ) p . delete ( using = "other" ) self . assertEqual ( pre_delete_receiver . _database , "other" ) self . assertEqual ( post_delete_receiver . _database , "other" ) def test_database_arg_m2m ( self ) : receiver = DatabaseReceiver ( ) signals . m2m_changed . connect ( receiver = receiver ) b = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) p = Person . objects . create ( name = "Marty Alchin" ) Book . objects . using ( 'other' ) . create ( pk = b . pk , title = b . title , published = b . published ) Person . objects . using ( 'other' ) . create ( pk = p . pk , name = p . name ) b . authors . add ( p ) self . assertEqual ( receiver . _database , DEFAULT_DB_ALIAS ) self . _write_to_other ( ) b . authors . add ( p ) self . _write_to_default ( ) self . assertEqual ( receiver . _database , "other" ) b . authors . remove ( p ) self . assertEqual ( receiver . _database , DEFAULT_DB_ALIAS ) self . _write_to_other ( ) b . authors . remove ( p ) self . _write_to_default ( ) self . assertEqual ( receiver . _database , "other" ) p . book_set . add ( b ) self . assertEqual ( receiver . _database , DEFAULT_DB_ALIAS ) self . _write_to_other ( ) p . book_set . add ( b ) self . _write_to_default ( ) self . assertEqual ( receiver . _database , "other" ) b . authors . clear ( ) self . assertEqual ( receiver . _database , DEFAULT_DB_ALIAS ) self . _write_to_other ( ) b . authors . clear ( ) self . _write_to_default ( ) self . assertEqual ( receiver . _database , "other" ) class AttributeErrorRouter ( object ) : def db_for_read ( self , model , ** hints ) : raise AttributeError def db_for_write ( self , model , ** hints ) : raise AttributeError class RouterAttributeErrorTestCase ( TestCase ) : multi_db = True def setUp ( self ) : self . old_routers = router . routers router . routers = [ AttributeErrorRouter ( ) ] def tearDown ( self ) : router . routers = self . old_routers def test_attribute_error_read ( self ) : router . routers = [ ] b = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) router . routers = [ AttributeErrorRouter ( ) ] self . assertRaises ( AttributeError , Book . objects . get , pk = b . pk ) def test_attribute_error_save ( self ) : dive = Book ( ) dive . title = "Dive into Python" dive . published = datetime . date ( 2009 , 5 , 4 ) self . assertRaises ( AttributeError , dive . save ) def test_attribute_error_delete ( self ) : router . routers = [ ] b = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) p = Person . objects . create ( name = "Marty Alchin" ) b . authors = [ p ] b . editor = p router . routers = [ AttributeErrorRouter ( ) ] self . assertRaises ( AttributeError , b . delete ) def test_attribute_error_m2m ( self ) : router . routers = [ ] b = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) p = Person . objects . create ( name = "Marty Alchin" ) router . routers = [ AttributeErrorRouter ( ) ] self . assertRaises ( AttributeError , setattr , b , 'authors' , [ p ] ) class ModelMetaRouter ( object ) : def db_for_write ( self , model , ** hints ) : if not hasattr ( model , '_meta' ) : raise ValueError class RouterModelArgumentTestCase ( TestCase ) : multi_db = True def setUp ( self ) : self . old_routers = router . routers router . routers = [ ModelMetaRouter ( ) ] def tearDown ( self ) : router . routers = self . old_routers def test_m2m_collection ( self ) : b = Book . objects . create ( title = "Pro Django" , published = datetime . date ( 2008 , 12 , 16 ) ) p = Person . objects . create ( name = "Marty Alchin" ) b . authors . add ( p ) b . authors . remove ( p ) b . authors . clear ( ) b . authors = [ p ] b . delete ( ) def test_foreignkey_collection ( self ) : person = Person . objects . create ( name = 'Bob' ) pet = Pet . objects . create ( owner = person , name = 'Wart' ) person . delete ( )

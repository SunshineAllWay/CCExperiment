""" Cross Site Request Forgery Middleware. This module provides a middleware that implements protection against request forgeries from other sites. """ import hashlib import re import random from django . conf import settings from django . core . urlresolvers import get_callable from django . utils . cache import patch_vary_headers from django . utils . http import same_origin from django . utils . log import getLogger from django . utils . crypto import constant_time_compare , get_random_string logger = getLogger ( 'django.request' ) REASON_NO_REFERER = "Referer checking failed - no Referer." REASON_BAD_REFERER = "Referer checking failed - %s does not match %s." REASON_NO_CSRF_COOKIE = "CSRF cookie not set." REASON_BAD_TOKEN = "CSRF token missing or incorrect." CSRF_KEY_LENGTH = 32 def _get_failure_view ( ) : return get_callable ( settings . CSRF_FAILURE_VIEW ) def _get_new_csrf_key ( ) : return get_random_string ( CSRF_KEY_LENGTH ) def get_token ( request ) : request . META [ "CSRF_COOKIE_USED" ] = True return request . META . get ( "CSRF_COOKIE" , None ) def _sanitize_token ( token ) : if len ( token ) > CSRF_KEY_LENGTH : return _get_new_csrf_key ( ) token = re . sub ( '[^a-zA-Z0-9]+' , '' , str ( token . decode ( 'ascii' , 'ignore' ) ) ) if token == "" : return _get_new_csrf_key ( ) return token class CsrfViewMiddleware ( object ) : def _accept ( self , request ) : request . csrf_processing_done = True return None def _reject ( self , request , reason ) : return _get_failure_view ( ) ( request , reason = reason ) def process_view ( self , request , callback , callback_args , callback_kwargs ) : if getattr ( request , 'csrf_processing_done' , False ) : return None try : csrf_token = _sanitize_token ( request . COOKIES [ settings . CSRF_COOKIE_NAME ] ) request . META [ 'CSRF_COOKIE' ] = csrf_token except KeyError : csrf_token = None request . META [ "CSRF_COOKIE" ] = _get_new_csrf_key ( ) if getattr ( callback , 'csrf_exempt' , False ) : return None if request . method not in ( 'GET' , 'HEAD' , 'OPTIONS' , 'TRACE' ) : if getattr ( request , '_dont_enforce_csrf_checks' , False ) : return self . _accept ( request ) if request . is_secure ( ) : referer = request . META . get ( 'HTTP_REFERER' ) if referer is None : logger . warning ( 'Forbidden (%s): %s' , REASON_NO_REFERER , request . path , extra = { : 403 , : request , } ) return self . _reject ( request , REASON_NO_REFERER ) good_referer = 'https://%s/' % request . get_host ( ) if not same_origin ( referer , good_referer ) : reason = REASON_BAD_REFERER % ( referer , good_referer ) logger . warning ( 'Forbidden (%s): %s' , reason , request . path , extra = { : 403 , : request , } ) return self . _reject ( request , reason ) if csrf_token is None : logger . warning ( 'Forbidden (%s): %s' , REASON_NO_CSRF_COOKIE , request . path , extra = { : 403 , : request , } ) return self . _reject ( request , REASON_NO_CSRF_COOKIE ) request_csrf_token = "" if request . method == "POST" : request_csrf_token = request . POST . get ( 'csrfmiddlewaretoken' , '' ) if request_csrf_token == "" : request_csrf_token = request . META . get ( 'HTTP_X_CSRFTOKEN' , '' ) if not constant_time_compare ( request_csrf_token , csrf_token ) : logger . warning ( 'Forbidden (%s): %s' , REASON_BAD_TOKEN , request . path , extra = { : 403 , : request , } ) return self . _reject ( request , REASON_BAD_TOKEN ) return self . _accept ( request ) def process_response ( self , request , response ) : if getattr ( response , 'csrf_processing_done' , False ) : return response if request . META . get ( "CSRF_COOKIE" ) is None : return response if not request . META . get ( "CSRF_COOKIE_USED" , False ) : return response response . set_cookie ( settings . CSRF_COOKIE_NAME , request . META [ "CSRF_COOKIE" ] , max_age = 60 * 60 * 24 * 7 * 52 , domain = settings . CSRF_COOKIE_DOMAIN , path = settings . CSRF_COOKIE_PATH , secure = settings . CSRF_COOKIE_SECURE ) patch_vary_headers ( response , ( 'Cookie' , ) ) response . csrf_processing_done = True return response

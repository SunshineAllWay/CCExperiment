""" Field classes. """ from __future__ import absolute_import import copy import datetime import os import re import urlparse from decimal import Decimal , DecimalException try : from cStringIO import StringIO except ImportError : from StringIO import StringIO from django . core import validators from django . core . exceptions import ValidationError from django . forms . util import ErrorList , from_current_timezone , to_current_timezone from django . forms . widgets import ( TextInput , PasswordInput , HiddenInput , MultipleHiddenInput , ClearableFileInput , CheckboxInput , Select , NullBooleanSelect , SelectMultiple , DateInput , DateTimeInput , TimeInput , SplitDateTimeWidget , SplitHiddenDateTimeWidget , FILE_INPUT_CONTRADICTION ) from django . utils import formats from django . utils . encoding import smart_unicode , smart_str , force_unicode from django . utils . ipv6 import clean_ipv6_address from django . utils . translation import ugettext_lazy as _ from django . core . validators import EMPTY_VALUES __all__ = ( , 'CharField' , 'IntegerField' , , 'TimeField' , 'DateTimeField' , 'TimeField' , , 'EmailField' , 'FileField' , 'ImageField' , 'URLField' , , 'NullBooleanField' , 'ChoiceField' , 'MultipleChoiceField' , , 'MultiValueField' , 'FloatField' , 'DecimalField' , , 'IPAddressField' , 'GenericIPAddressField' , 'FilePathField' , , 'TypedChoiceField' , 'TypedMultipleChoiceField' ) class Field ( object ) : widget = TextInput hidden_widget = HiddenInput default_validators = [ ] default_error_messages = { : _ ( u'This field is required.' ) , : _ ( u'Enter a valid value.' ) , } creation_counter = 0 def __init__ ( self , required = True , widget = None , label = None , initial = None , help_text = None , error_messages = None , show_hidden_initial = False , validators = [ ] , localize = False ) : if label is not None : label = smart_unicode ( label ) self . required , self . label , self . initial = required , label , initial self . show_hidden_initial = show_hidden_initial if help_text is None : self . help_text = u'' else : self . help_text = smart_unicode ( help_text ) widget = widget or self . widget if isinstance ( widget , type ) : widget = widget ( ) self . localize = localize if self . localize : widget . is_localized = True widget . is_required = self . required extra_attrs = self . widget_attrs ( widget ) if extra_attrs : widget . attrs . update ( extra_attrs ) self . widget = widget self . creation_counter = Field . creation_counter Field . creation_counter += 1 messages = { } for c in reversed ( self . __class__ . __mro__ ) : messages . update ( getattr ( c , 'default_error_messages' , { } ) ) messages . update ( error_messages or { } ) self . error_messages = messages self . validators = self . default_validators + validators def prepare_value ( self , value ) : return value def to_python ( self , value ) : return value def validate ( self , value ) : if value in validators . EMPTY_VALUES and self . required : raise ValidationError ( self . error_messages [ 'required' ] ) def run_validators ( self , value ) : if value in validators . EMPTY_VALUES : return errors = [ ] for v in self . validators : try : v ( value ) except ValidationError , e : if hasattr ( e , 'code' ) and e . code in self . error_messages : message = self . error_messages [ e . code ] if e . params : message = message % e . params errors . append ( message ) else : errors . extend ( e . messages ) if errors : raise ValidationError ( errors ) def clean ( self , value ) : value = self . to_python ( value ) self . validate ( value ) self . run_validators ( value ) return value def bound_data ( self , data , initial ) : return data def widget_attrs ( self , widget ) : return { } def __deepcopy__ ( self , memo ) : result = copy . copy ( self ) memo [ id ( self ) ] = result result . widget = copy . deepcopy ( self . widget , memo ) result . validators = self . validators [ : ] return result class CharField ( Field ) : def __init__ ( self , max_length = None , min_length = None , * args , ** kwargs ) : self . max_length , self . min_length = max_length , min_length super ( CharField , self ) . __init__ ( * args , ** kwargs ) if min_length is not None : self . validators . append ( validators . MinLengthValidator ( min_length ) ) if max_length is not None : self . validators . append ( validators . MaxLengthValidator ( max_length ) ) def to_python ( self , value ) : if value in validators . EMPTY_VALUES : return u'' return smart_unicode ( value ) def widget_attrs ( self , widget ) : attrs = super ( CharField , self ) . widget_attrs ( widget ) if self . max_length is not None and isinstance ( widget , ( TextInput , PasswordInput ) ) : attrs . update ( { 'maxlength' : str ( self . max_length ) } ) return attrs class IntegerField ( Field ) : default_error_messages = { : _ ( u'Enter a whole number.' ) , : _ ( u'Ensure this value is less than or equal to %(limit_value)s.' ) , : _ ( u'Ensure this value is greater than or equal to %(limit_value)s.' ) , } def __init__ ( self , max_value = None , min_value = None , * args , ** kwargs ) : self . max_value , self . min_value = max_value , min_value super ( IntegerField , self ) . __init__ ( * args , ** kwargs ) if max_value is not None : self . validators . append ( validators . MaxValueValidator ( max_value ) ) if min_value is not None : self . validators . append ( validators . MinValueValidator ( min_value ) ) def to_python ( self , value ) : value = super ( IntegerField , self ) . to_python ( value ) if value in validators . EMPTY_VALUES : return None if self . localize : value = formats . sanitize_separators ( value ) try : value = int ( str ( value ) ) except ( ValueError , TypeError ) : raise ValidationError ( self . error_messages [ 'invalid' ] ) return value class FloatField ( IntegerField ) : default_error_messages = { : _ ( u'Enter a number.' ) , } def to_python ( self , value ) : value = super ( IntegerField , self ) . to_python ( value ) if value in validators . EMPTY_VALUES : return None if self . localize : value = formats . sanitize_separators ( value ) try : value = float ( value ) except ( ValueError , TypeError ) : raise ValidationError ( self . error_messages [ 'invalid' ] ) return value class DecimalField ( Field ) : default_error_messages = { : _ ( u'Enter a number.' ) , : _ ( u'Ensure this value is less than or equal to %(limit_value)s.' ) , : _ ( u'Ensure this value is greater than or equal to %(limit_value)s.' ) , : _ ( 'Ensure that there are no more than %s digits in total.' ) , : _ ( 'Ensure that there are no more than %s decimal places.' ) , : _ ( 'Ensure that there are no more than %s digits before the decimal point.' ) } def __init__ ( self , max_value = None , min_value = None , max_digits = None , decimal_places = None , * args , ** kwargs ) : self . max_value , self . min_value = max_value , min_value self . max_digits , self . decimal_places = max_digits , decimal_places Field . __init__ ( self , * args , ** kwargs ) if max_value is not None : self . validators . append ( validators . MaxValueValidator ( max_value ) ) if min_value is not None : self . validators . append ( validators . MinValueValidator ( min_value ) ) def to_python ( self , value ) : if value in validators . EMPTY_VALUES : return None if self . localize : value = formats . sanitize_separators ( value ) value = smart_str ( value ) . strip ( ) try : value = Decimal ( value ) except DecimalException : raise ValidationError ( self . error_messages [ 'invalid' ] ) return value def validate ( self , value ) : super ( DecimalField , self ) . validate ( value ) if value in validators . EMPTY_VALUES : return if value != value or value == Decimal ( "Inf" ) or value == Decimal ( "-Inf" ) : raise ValidationError ( self . error_messages [ 'invalid' ] ) sign , digittuple , exponent = value . as_tuple ( ) decimals = abs ( exponent ) digits = len ( digittuple ) if decimals > digits : digits = decimals whole_digits = digits - decimals if self . max_digits is not None and digits > self . max_digits : raise ValidationError ( self . error_messages [ 'max_digits' ] % self . max_digits ) if self . decimal_places is not None and decimals > self . decimal_places : raise ValidationError ( self . error_messages [ 'max_decimal_places' ] % self . decimal_places ) if self . max_digits is not None and self . decimal_places is not None and whole_digits > ( self . max_digits - self . decimal_places ) : raise ValidationError ( self . error_messages [ 'max_whole_digits' ] % ( self . max_digits - self . decimal_places ) ) return value class BaseTemporalField ( Field ) : def __init__ ( self , input_formats = None , * args , ** kwargs ) : super ( BaseTemporalField , self ) . __init__ ( * args , ** kwargs ) if input_formats is not None : self . input_formats = input_formats def to_python ( self , value ) : unicode_value = force_unicode ( value , strings_only = True ) if isinstance ( unicode_value , unicode ) : value = unicode_value . strip ( ) if isinstance ( value , unicode ) : for format in self . input_formats : try : return self . strptime ( value , format ) except ValueError : if format . endswith ( '.%f' ) : if value . count ( '.' ) != format . count ( '.' ) : continue try : datetime_str , usecs_str = value . rsplit ( '.' , 1 ) usecs = int ( usecs_str [ : 6 ] . ljust ( 6 , '0' ) ) dt = datetime . datetime . strptime ( datetime_str , format [ : - 3 ] ) return dt . replace ( microsecond = usecs ) except ValueError : continue raise ValidationError ( self . error_messages [ 'invalid' ] ) def strptime ( self , value , format ) : raise NotImplementedError ( 'Subclasses must define this method.' ) class DateField ( BaseTemporalField ) : widget = DateInput input_formats = formats . get_format_lazy ( 'DATE_INPUT_FORMATS' ) default_error_messages = { : _ ( u'Enter a valid date.' ) , } def to_python ( self , value ) : if value in validators . EMPTY_VALUES : return None if isinstance ( value , datetime . datetime ) : return value . date ( ) if isinstance ( value , datetime . date ) : return value return super ( DateField , self ) . to_python ( value ) def strptime ( self , value , format ) : return datetime . datetime . strptime ( value , format ) . date ( ) class TimeField ( BaseTemporalField ) : widget = TimeInput input_formats = formats . get_format_lazy ( 'TIME_INPUT_FORMATS' ) default_error_messages = { : _ ( u'Enter a valid time.' ) } def to_python ( self , value ) : if value in validators . EMPTY_VALUES : return None if isinstance ( value , datetime . time ) : return value return super ( TimeField , self ) . to_python ( value ) def strptime ( self , value , format ) : return datetime . datetime . strptime ( value , format ) . time ( ) class DateTimeField ( BaseTemporalField ) : widget = DateTimeInput input_formats = formats . get_format_lazy ( 'DATETIME_INPUT_FORMATS' ) default_error_messages = { : _ ( u'Enter a valid date/time.' ) , } def prepare_value ( self , value ) : if isinstance ( value , datetime . datetime ) : value = to_current_timezone ( value ) return value def to_python ( self , value ) : if value in validators . EMPTY_VALUES : return None if isinstance ( value , datetime . datetime ) : return from_current_timezone ( value ) if isinstance ( value , datetime . date ) : result = datetime . datetime ( value . year , value . month , value . day ) return from_current_timezone ( result ) if isinstance ( value , list ) : if len ( value ) != 2 : raise ValidationError ( self . error_messages [ 'invalid' ] ) if value [ 0 ] in validators . EMPTY_VALUES and value [ 1 ] in validators . EMPTY_VALUES : return None value = '%s %s' % tuple ( value ) result = super ( DateTimeField , self ) . to_python ( value ) return from_current_timezone ( result ) def strptime ( self , value , format ) : return datetime . datetime . strptime ( value , format ) class RegexField ( CharField ) : def __init__ ( self , regex , max_length = None , min_length = None , error_message = None , * args , ** kwargs ) : if error_message : error_messages = kwargs . get ( 'error_messages' ) or { } error_messages [ 'invalid' ] = error_message kwargs [ 'error_messages' ] = error_messages super ( RegexField , self ) . __init__ ( max_length , min_length , * args , ** kwargs ) self . _set_regex ( regex ) def _get_regex ( self ) : return self . _regex def _set_regex ( self , regex ) : if isinstance ( regex , basestring ) : regex = re . compile ( regex ) self . _regex = regex if hasattr ( self , '_regex_validator' ) and self . _regex_validator in self . validators : self . validators . remove ( self . _regex_validator ) self . _regex_validator = validators . RegexValidator ( regex = regex ) self . validators . append ( self . _regex_validator ) regex = property ( _get_regex , _set_regex ) class EmailField ( CharField ) : default_error_messages = { : _ ( u'Enter a valid e-mail address.' ) , } default_validators = [ validators . validate_email ] def clean ( self , value ) : value = self . to_python ( value ) . strip ( ) return super ( EmailField , self ) . clean ( value ) class FileField ( Field ) : widget = ClearableFileInput default_error_messages = { : _ ( u"No file was submitted. Check the encoding type on the form." ) , : _ ( u"No file was submitted." ) , : _ ( u"The submitted file is empty." ) , : _ ( u'Ensure this filename has at most %(max)d characters (it has %(length)d).' ) , : _ ( u'Please either submit a file or check the clear checkbox, not both.' ) } def __init__ ( self , * args , ** kwargs ) : self . max_length = kwargs . pop ( 'max_length' , None ) self . allow_empty_file = kwargs . pop ( 'allow_empty_file' , False ) super ( FileField , self ) . __init__ ( * args , ** kwargs ) def to_python ( self , data ) : if data in validators . EMPTY_VALUES : return None try : file_name = data . name file_size = data . size except AttributeError : raise ValidationError ( self . error_messages [ 'invalid' ] ) if self . max_length is not None and len ( file_name ) > self . max_length : error_values = { 'max' : self . max_length , 'length' : len ( file_name ) } raise ValidationError ( self . error_messages [ 'max_length' ] % error_values ) if not file_name : raise ValidationError ( self . error_messages [ 'invalid' ] ) if not self . allow_empty_file and not file_size : raise ValidationError ( self . error_messages [ 'empty' ] ) return data def clean ( self , data , initial = None ) : if data is FILE_INPUT_CONTRADICTION : raise ValidationError ( self . error_messages [ 'contradiction' ] ) if data is False : if not self . required : return False data = None if not data and initial : return initial return super ( FileField , self ) . clean ( data ) def bound_data ( self , data , initial ) : if data in ( None , FILE_INPUT_CONTRADICTION ) : return initial return data class ImageField ( FileField ) : default_error_messages = { : _ ( u"Upload a valid image. The file you uploaded was either not an image or a corrupted image." ) , } def to_python ( self , data ) : f = super ( ImageField , self ) . to_python ( data ) if f is None : return None try : from PIL import Image except ImportError : import Image if hasattr ( data , 'temporary_file_path' ) : file = data . temporary_file_path ( ) else : if hasattr ( data , 'read' ) : file = StringIO ( data . read ( ) ) else : file = StringIO ( data [ 'content' ] ) try : trial_image = Image . open ( file ) trial_image . load ( ) if hasattr ( file , 'reset' ) : file . reset ( ) trial_image = Image . open ( file ) trial_image . verify ( ) except ImportError : raise except Exception : raise ValidationError ( self . error_messages [ 'invalid_image' ] ) if hasattr ( f , 'seek' ) and callable ( f . seek ) : f . seek ( 0 ) return f class URLField ( CharField ) : default_error_messages = { : _ ( u'Enter a valid URL.' ) , : _ ( u'This URL appears to be a broken link.' ) , } def __init__ ( self , max_length = None , min_length = None , verify_exists = False , validator_user_agent = validators . URL_VALIDATOR_USER_AGENT , * args , ** kwargs ) : super ( URLField , self ) . __init__ ( max_length , min_length , * args , ** kwargs ) self . validators . append ( validators . URLValidator ( verify_exists = verify_exists , validator_user_agent = validator_user_agent ) ) def to_python ( self , value ) : def split_url ( url ) : try : return list ( urlparse . urlsplit ( url ) ) except ValueError : raise ValidationError ( self . error_messages [ 'invalid' ] ) value = super ( URLField , self ) . to_python ( value ) if value : url_fields = split_url ( value ) if not url_fields [ 0 ] : url_fields [ 0 ] = 'http' if not url_fields [ 1 ] : url_fields [ 1 ] = url_fields [ 2 ] url_fields [ 2 ] = '' url_fields = split_url ( urlparse . urlunsplit ( url_fields ) ) if not url_fields [ 2 ] : url_fields [ 2 ] = '/' value = urlparse . urlunsplit ( url_fields ) return value class BooleanField ( Field ) : widget = CheckboxInput def to_python ( self , value ) : if isinstance ( value , basestring ) and value . lower ( ) in ( 'false' , '0' ) : value = False else : value = bool ( value ) value = super ( BooleanField , self ) . to_python ( value ) if not value and self . required : raise ValidationError ( self . error_messages [ 'required' ] ) return value class NullBooleanField ( BooleanField ) : widget = NullBooleanSelect def to_python ( self , value ) : if value in ( True , 'True' , '1' ) : return True elif value in ( False , 'False' , '0' ) : return False else : return None def validate ( self , value ) : pass class ChoiceField ( Field ) : widget = Select default_error_messages = { : _ ( u'Select a valid choice. %(value)s is not one of the available choices.' ) , } def __init__ ( self , choices = ( ) , required = True , widget = None , label = None , initial = None , help_text = None , * args , ** kwargs ) : super ( ChoiceField , self ) . __init__ ( required = required , widget = widget , label = label , initial = initial , help_text = help_text , * args , ** kwargs ) self . choices = choices def __deepcopy__ ( self , memo ) : result = super ( ChoiceField , self ) . __deepcopy__ ( memo ) result . _choices = copy . deepcopy ( self . _choices , memo ) return result def _get_choices ( self ) : return self . _choices def _set_choices ( self , value ) : self . _choices = self . widget . choices = list ( value ) choices = property ( _get_choices , _set_choices ) def to_python ( self , value ) : if value in validators . EMPTY_VALUES : return u'' return smart_unicode ( value ) def validate ( self , value ) : super ( ChoiceField , self ) . validate ( value ) if value and not self . valid_value ( value ) : raise ValidationError ( self . error_messages [ 'invalid_choice' ] % { 'value' : value } ) def valid_value ( self , value ) : for k , v in self . choices : if isinstance ( v , ( list , tuple ) ) : for k2 , v2 in v : if value == smart_unicode ( k2 ) : return True else : if value == smart_unicode ( k ) : return True return False class TypedChoiceField ( ChoiceField ) : def __init__ ( self , * args , ** kwargs ) : self . coerce = kwargs . pop ( 'coerce' , lambda val : val ) self . empty_value = kwargs . pop ( 'empty_value' , '' ) super ( TypedChoiceField , self ) . __init__ ( * args , ** kwargs ) def to_python ( self , value ) : value = super ( TypedChoiceField , self ) . to_python ( value ) super ( TypedChoiceField , self ) . validate ( value ) if value == self . empty_value or value in validators . EMPTY_VALUES : return self . empty_value try : value = self . coerce ( value ) except ( ValueError , TypeError , ValidationError ) : raise ValidationError ( self . error_messages [ 'invalid_choice' ] % { 'value' : value } ) return value def validate ( self , value ) : pass class MultipleChoiceField ( ChoiceField ) : hidden_widget = MultipleHiddenInput widget = SelectMultiple default_error_messages = { : _ ( u'Select a valid choice. %(value)s is not one of the available choices.' ) , : _ ( u'Enter a list of values.' ) , } def to_python ( self , value ) : if not value : return [ ] elif not isinstance ( value , ( list , tuple ) ) : raise ValidationError ( self . error_messages [ 'invalid_list' ] ) return [ smart_unicode ( val ) for val in value ] def validate ( self , value ) : if self . required and not value : raise ValidationError ( self . error_messages [ 'required' ] ) for val in value : if not self . valid_value ( val ) : raise ValidationError ( self . error_messages [ 'invalid_choice' ] % { 'value' : val } ) class TypedMultipleChoiceField ( MultipleChoiceField ) : def __init__ ( self , * args , ** kwargs ) : self . coerce = kwargs . pop ( 'coerce' , lambda val : val ) self . empty_value = kwargs . pop ( 'empty_value' , [ ] ) super ( TypedMultipleChoiceField , self ) . __init__ ( * args , ** kwargs ) def to_python ( self , value ) : value = super ( TypedMultipleChoiceField , self ) . to_python ( value ) super ( TypedMultipleChoiceField , self ) . validate ( value ) if value == self . empty_value or value in validators . EMPTY_VALUES : return self . empty_value new_value = [ ] for choice in value : try : new_value . append ( self . coerce ( choice ) ) except ( ValueError , TypeError , ValidationError ) : raise ValidationError ( self . error_messages [ 'invalid_choice' ] % { 'value' : choice } ) return new_value def validate ( self , value ) : pass class ComboField ( Field ) : def __init__ ( self , fields = ( ) , * args , ** kwargs ) : super ( ComboField , self ) . __init__ ( * args , ** kwargs ) for f in fields : f . required = False self . fields = fields def clean ( self , value ) : super ( ComboField , self ) . clean ( value ) for field in self . fields : value = field . clean ( value ) return value class MultiValueField ( Field ) : default_error_messages = { : _ ( u'Enter a list of values.' ) , } def __init__ ( self , fields = ( ) , * args , ** kwargs ) : super ( MultiValueField , self ) . __init__ ( * args , ** kwargs ) for f in fields : f . required = False self . fields = fields def validate ( self , value ) : pass def clean ( self , value ) : clean_data = [ ] errors = ErrorList ( ) if not value or isinstance ( value , ( list , tuple ) ) : if not value or not [ v for v in value if v not in validators . EMPTY_VALUES ] : if self . required : raise ValidationError ( self . error_messages [ 'required' ] ) else : return self . compress ( [ ] ) else : raise ValidationError ( self . error_messages [ 'invalid' ] ) for i , field in enumerate ( self . fields ) : try : field_value = value [ i ] except IndexError : field_value = None if self . required and field_value in validators . EMPTY_VALUES : raise ValidationError ( self . error_messages [ 'required' ] ) try : clean_data . append ( field . clean ( field_value ) ) except ValidationError , e : errors . extend ( e . messages ) if errors : raise ValidationError ( errors ) out = self . compress ( clean_data ) self . validate ( out ) self . run_validators ( out ) return out def compress ( self , data_list ) : raise NotImplementedError ( 'Subclasses must implement this method.' ) class FilePathField ( ChoiceField ) : def __init__ ( self , path , match = None , recursive = False , required = True , widget = None , label = None , initial = None , help_text = None , * args , ** kwargs ) : self . path , self . match , self . recursive = path , match , recursive super ( FilePathField , self ) . __init__ ( choices = ( ) , required = required , widget = widget , label = label , initial = initial , help_text = help_text , * args , ** kwargs ) if self . required : self . choices = [ ] else : self . choices = [ ( "" , "---------" ) ] if self . match is not None : self . match_re = re . compile ( self . match ) if recursive : for root , dirs , files in sorted ( os . walk ( self . path ) ) : for f in files : if self . match is None or self . match_re . search ( f ) : f = os . path . join ( root , f ) self . choices . append ( ( f , f . replace ( path , "" , 1 ) ) ) else : try : for f in sorted ( os . listdir ( self . path ) ) : full_file = os . path . join ( self . path , f ) if os . path . isfile ( full_file ) and ( self . match is None or self . match_re . search ( f ) ) : self . choices . append ( ( full_file , f ) ) except OSError : pass self . widget . choices = self . choices class SplitDateTimeField ( MultiValueField ) : widget = SplitDateTimeWidget hidden_widget = SplitHiddenDateTimeWidget default_error_messages = { : _ ( u'Enter a valid date.' ) , : _ ( u'Enter a valid time.' ) , } def __init__ ( self , input_date_formats = None , input_time_formats = None , * args , ** kwargs ) : errors = self . default_error_messages . copy ( ) if 'error_messages' in kwargs : errors . update ( kwargs [ 'error_messages' ] ) localize = kwargs . get ( 'localize' , False ) fields = ( DateField ( input_formats = input_date_formats , error_messages = { 'invalid' : errors [ 'invalid_date' ] } , localize = localize ) , TimeField ( input_formats = input_time_formats , error_messages = { 'invalid' : errors [ 'invalid_time' ] } , localize = localize ) , ) super ( SplitDateTimeField , self ) . __init__ ( fields , * args , ** kwargs ) def compress ( self , data_list ) : if data_list : if data_list [ 0 ] in validators . EMPTY_VALUES : raise ValidationError ( self . error_messages [ 'invalid_date' ] ) if data_list [ 1 ] in validators . EMPTY_VALUES : raise ValidationError ( self . error_messages [ 'invalid_time' ] ) result = datetime . datetime . combine ( * data_list ) return from_current_timezone ( result ) return None class IPAddressField ( CharField ) : default_error_messages = { : _ ( u'Enter a valid IPv4 address.' ) , } default_validators = [ validators . validate_ipv4_address ] class GenericIPAddressField ( CharField ) : default_error_messages = { } def __init__ ( self , protocol = 'both' , unpack_ipv4 = False , * args , ** kwargs ) : self . unpack_ipv4 = unpack_ipv4 self . default_validators , invalid_error_message = validators . ip_address_validators ( protocol , unpack_ipv4 ) self . default_error_messages [ 'invalid' ] = invalid_error_message super ( GenericIPAddressField , self ) . __init__ ( * args , ** kwargs ) def to_python ( self , value ) : if value in validators . EMPTY_VALUES : return u'' if value and ':' in value : return clean_ipv6_address ( value , self . unpack_ipv4 , self . error_messages [ 'invalid' ] ) return value class SlugField ( CharField ) : default_error_messages = { : _ ( u"Enter a valid 'slug' consisting of letters, numbers," ) , } default_validators = [ validators . validate_slug ]

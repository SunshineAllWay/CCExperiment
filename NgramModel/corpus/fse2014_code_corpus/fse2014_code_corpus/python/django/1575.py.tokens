from django . conf import settings from django . utils . encoding import force_unicode , StrAndUnicode from django . contrib . messages import constants , utils LEVEL_TAGS = utils . get_level_tags ( ) class Message ( StrAndUnicode ) : def __init__ ( self , level , message , extra_tags = None ) : self . level = int ( level ) self . message = message self . extra_tags = extra_tags def _prepare ( self ) : self . message = force_unicode ( self . message , strings_only = True ) self . extra_tags = force_unicode ( self . extra_tags , strings_only = True ) def __eq__ ( self , other ) : return isinstance ( other , Message ) and self . level == other . level and self . message == other . message def __unicode__ ( self ) : return force_unicode ( self . message ) def _get_tags ( self ) : label_tag = force_unicode ( LEVEL_TAGS . get ( self . level , '' ) , strings_only = True ) extra_tags = force_unicode ( self . extra_tags , strings_only = True ) if extra_tags and label_tag : return u' ' . join ( [ extra_tags , label_tag ] ) elif extra_tags : return extra_tags elif label_tag : return label_tag return '' tags = property ( _get_tags ) class BaseStorage ( object ) : def __init__ ( self , request , * args , ** kwargs ) : self . request = request self . _queued_messages = [ ] self . used = False self . added_new = False super ( BaseStorage , self ) . __init__ ( * args , ** kwargs ) def __len__ ( self ) : return len ( self . _loaded_messages ) + len ( self . _queued_messages ) def __iter__ ( self ) : self . used = True if self . _queued_messages : self . _loaded_messages . extend ( self . _queued_messages ) self . _queued_messages = [ ] return iter ( self . _loaded_messages ) def __contains__ ( self , item ) : return item in self . _loaded_messages or item in self . _queued_messages @ property def _loaded_messages ( self ) : if not hasattr ( self , '_loaded_data' ) : messages , all_retrieved = self . _get ( ) self . _loaded_data = messages or [ ] return self . _loaded_data def _get ( self , * args , ** kwargs ) : raise NotImplementedError ( ) def _store ( self , messages , response , * args , ** kwargs ) : raise NotImplementedError ( ) def _prepare_messages ( self , messages ) : for message in messages : message . _prepare ( ) def update ( self , response ) : self . _prepare_messages ( self . _queued_messages ) if self . used : return self . _store ( self . _queued_messages , response ) elif self . added_new : messages = self . _loaded_messages + self . _queued_messages return self . _store ( messages , response ) def add ( self , level , message , extra_tags = '' ) : if not message : return level = int ( level ) if level < self . level : return self . added_new = True message = Message ( level , message , extra_tags = extra_tags ) self . _queued_messages . append ( message ) def _get_level ( self ) : if not hasattr ( self , '_level' ) : self . _level = getattr ( settings , 'MESSAGE_LEVEL' , constants . INFO ) return self . _level def _set_level ( self , value = None ) : if value is None and hasattr ( self , '_level' ) : del self . _level else : self . _level = int ( value ) level = property ( _get_level , _set_level , _set_level )

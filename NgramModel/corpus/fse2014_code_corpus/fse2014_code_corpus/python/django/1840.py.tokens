""" MySQL database backend for Django. Requires MySQLdb: http://sourceforge.net/projects/mysql-python """ import re import sys try : import MySQLdb as Database except ImportError , e : from django . core . exceptions import ImproperlyConfigured raise ImproperlyConfigured ( "Error loading MySQLdb module: %s" % e ) version = Database . version_info if ( version < ( 1 , 2 , 1 ) or ( version [ : 3 ] == ( 1 , 2 , 1 ) and ( len ( version ) < 5 or version [ 3 ] != 'final' or version [ 4 ] < 2 ) ) ) : from django . core . exceptions import ImproperlyConfigured raise ImproperlyConfigured ( "MySQLdb-1.2.1p2 or newer is required; you have %s" % Database . __version__ ) from MySQLdb . converters import conversions from MySQLdb . constants import FIELD_TYPE , CLIENT from django . db import utils from django . db . backends import * from django . db . backends . signals import connection_created from django . db . backends . mysql . client import DatabaseClient from django . db . backends . mysql . creation import DatabaseCreation from django . db . backends . mysql . introspection import DatabaseIntrospection from django . db . backends . mysql . validation import DatabaseValidation from django . utils . safestring import SafeString , SafeUnicode from django . utils . timezone import is_aware , is_naive , utc from django . conf import settings if settings . DEBUG : from warnings import filterwarnings filterwarnings ( "error" , category = Database . Warning ) DatabaseError = Database . DatabaseError IntegrityError = Database . IntegrityError datetime_or_None = conversions [ FIELD_TYPE . DATETIME ] def datetime_or_None_with_timezone_support ( value ) : dt = datetime_or_None ( value ) if dt is not None and settings . USE_TZ and is_naive ( dt ) : dt = dt . replace ( tzinfo = utc ) return dt django_conversions = conversions . copy ( ) django_conversions . update ( { FIELD_TYPE . TIME : util . typecast_time , FIELD_TYPE . DECIMAL : util . typecast_decimal , FIELD_TYPE . NEWDECIMAL : util . typecast_decimal , FIELD_TYPE . DATETIME : datetime_or_None_with_timezone_support , } ) server_version_re = re . compile ( r'(\d{1,2})\.(\d{1,2})\.(\d{1,2})' ) class CursorWrapper ( object ) : codes_for_integrityerror = ( 1048 , ) def __init__ ( self , cursor ) : self . cursor = cursor def execute ( self , query , args = None ) : try : return self . cursor . execute ( query , args ) except Database . IntegrityError , e : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] except Database . OperationalError , e : if e [ 0 ] in self . codes_for_integrityerror : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] raise utils . DatabaseError , utils . DatabaseError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] except Database . DatabaseError , e : raise utils . DatabaseError , utils . DatabaseError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] def executemany ( self , query , args ) : try : return self . cursor . executemany ( query , args ) except Database . IntegrityError , e : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] except Database . OperationalError , e : if e [ 0 ] in self . codes_for_integrityerror : raise utils . IntegrityError , utils . IntegrityError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] raise utils . DatabaseError , utils . DatabaseError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] except Database . DatabaseError , e : raise utils . DatabaseError , utils . DatabaseError ( * tuple ( e ) ) , sys . exc_info ( ) [ 2 ] def __getattr__ ( self , attr ) : if attr in self . __dict__ : return self . __dict__ [ attr ] else : return getattr ( self . cursor , attr ) def __iter__ ( self ) : return iter ( self . cursor ) class DatabaseFeatures ( BaseDatabaseFeatures ) : empty_fetchmany_value = ( ) update_can_self_select = False allows_group_by_pk = True related_fields_match_type = True allow_sliced_subqueries = False has_bulk_insert = True has_select_for_update = True has_select_for_update_nowait = False supports_forward_references = False supports_long_model_names = False supports_microsecond_precision = False supports_regex_backreferencing = False supports_date_lookup_using_string = False supports_timezones = False requires_explicit_null_ordering_when_grouping = True allows_primary_key_0 = False def __init__ ( self , connection ) : super ( DatabaseFeatures , self ) . __init__ ( connection ) self . _storage_engine = None def _mysql_storage_engine ( self ) : if self . _storage_engine is None : cursor = self . connection . cursor ( ) cursor . execute ( 'CREATE TABLE INTROSPECT_TEST (X INT)' ) cursor . execute ( "SHOW TABLE STATUS WHERE Name='INTROSPECT_TEST'" ) result = cursor . fetchone ( ) cursor . execute ( 'DROP TABLE INTROSPECT_TEST' ) self . _storage_engine = result [ 1 ] return self . _storage_engine def _can_introspect_foreign_keys ( self ) : return self . _mysql_storage_engine ( ) != 'MyISAM' class DatabaseOperations ( BaseDatabaseOperations ) : compiler_module = "django.db.backends.mysql.compiler" def date_extract_sql ( self , lookup_type , field_name ) : if lookup_type == 'week_day' : return "DAYOFWEEK(%s)" % field_name else : return "EXTRACT(%s FROM %s)" % ( lookup_type . upper ( ) , field_name ) def date_trunc_sql ( self , lookup_type , field_name ) : fields = [ 'year' , 'month' , 'day' , 'hour' , 'minute' , 'second' ] format = ( '%%Y-' , '%%m' , '-%%d' , ' %%H:' , '%%i' , ':%%s' ) format_def = ( '0000-' , '01' , '-01' , ' 00:' , '00' , ':00' ) try : i = fields . index ( lookup_type ) + 1 except ValueError : sql = field_name else : format_str = '' . join ( [ f for f in format [ : i ] ] + [ f for f in format_def [ i : ] ] ) sql = "CAST(DATE_FORMAT(%s, '%s') AS DATETIME)" % ( field_name , format_str ) return sql def date_interval_sql ( self , sql , connector , timedelta ) : return "(%s %s INTERVAL '%d 0:0:%d:%d' DAY_MICROSECOND)" % ( sql , connector , timedelta . days , timedelta . seconds , timedelta . microseconds ) def drop_foreignkey_sql ( self ) : return "DROP FOREIGN KEY" def force_no_ordering ( self ) : return [ "NULL" ] def fulltext_search_sql ( self , field_name ) : return 'MATCH (%s) AGAINST (%%s IN BOOLEAN MODE)' % field_name def last_executed_query ( self , cursor , sql , params ) : return cursor . _last_executed def no_limit_value ( self ) : return 18446744073709551615L def quote_name ( self , name ) : if name . startswith ( "`" ) and name . endswith ( "`" ) : return name return "`%s`" % name def random_function_sql ( self ) : return 'RAND()' def sql_flush ( self , style , tables , sequences ) : if tables : sql = [ 'SET FOREIGN_KEY_CHECKS = 0;' ] for table in tables : sql . append ( '%s %s;' % ( style . SQL_KEYWORD ( 'TRUNCATE' ) , style . SQL_FIELD ( self . quote_name ( table ) ) ) ) sql . append ( 'SET FOREIGN_KEY_CHECKS = 1;' ) sql . extend ( [ "%s %s %s %s %s;" % ( style . SQL_KEYWORD ( 'ALTER' ) , style . SQL_KEYWORD ( 'TABLE' ) , style . SQL_TABLE ( self . quote_name ( sequence [ 'table' ] ) ) , style . SQL_KEYWORD ( 'AUTO_INCREMENT' ) , style . SQL_FIELD ( '= 1' ) , ) for sequence in sequences ] ) return sql else : return [ ] def value_to_db_datetime ( self , value ) : if value is None : return None if is_aware ( value ) : if settings . USE_TZ : value = value . astimezone ( utc ) . replace ( tzinfo = None ) else : raise ValueError ( "MySQL backend does not support timezone-aware datetimes when USE_TZ is False." ) return unicode ( value . replace ( microsecond = 0 ) ) def value_to_db_time ( self , value ) : if value is None : return None if is_aware ( value ) : raise ValueError ( "MySQL backend does not support timezone-aware times." ) return unicode ( value . replace ( microsecond = 0 ) ) def year_lookup_bounds ( self , value ) : first = '%s-01-01 00:00:00' second = '%s-12-31 23:59:59.99' return [ first % value , second % value ] def max_name_length ( self ) : return 64 def bulk_insert_sql ( self , fields , num_values ) : items_sql = "(%s)" % ", " . join ( [ "%s" ] * len ( fields ) ) return "VALUES " + ", " . join ( [ items_sql ] * num_values ) def savepoint_create_sql ( self , sid ) : return "SAVEPOINT %s" % sid def savepoint_commit_sql ( self , sid ) : return "RELEASE SAVEPOINT %s" % sid def savepoint_rollback_sql ( self , sid ) : return "ROLLBACK TO SAVEPOINT %s" % sid class DatabaseWrapper ( BaseDatabaseWrapper ) : vendor = 'mysql' operators = { : '= %s' , : 'LIKE %s' , : 'LIKE BINARY %s' , : 'LIKE %s' , : 'REGEXP BINARY %s' , : 'REGEXP %s' , : '> %s' , : '>= %s' , : '< %s' , : '<= %s' , : 'LIKE BINARY %s' , : 'LIKE BINARY %s' , : 'LIKE %s' , : 'LIKE %s' , } def __init__ ( self , * args , ** kwargs ) : super ( DatabaseWrapper , self ) . __init__ ( * args , ** kwargs ) self . server_version = None self . features = DatabaseFeatures ( self ) self . ops = DatabaseOperations ( self ) self . client = DatabaseClient ( self ) self . creation = DatabaseCreation ( self ) self . introspection = DatabaseIntrospection ( self ) self . validation = DatabaseValidation ( self ) def _valid_connection ( self ) : if self . connection is not None : try : self . connection . ping ( ) return True except DatabaseError : self . connection . close ( ) self . connection = None return False def _cursor ( self ) : new_connection = False if not self . _valid_connection ( ) : new_connection = True kwargs = { : django_conversions , : 'utf8' , : True , } settings_dict = self . settings_dict if settings_dict [ 'USER' ] : kwargs [ 'user' ] = settings_dict [ 'USER' ] if settings_dict [ 'NAME' ] : kwargs [ 'db' ] = settings_dict [ 'NAME' ] if settings_dict [ 'PASSWORD' ] : kwargs [ 'passwd' ] = settings_dict [ 'PASSWORD' ] if settings_dict [ 'HOST' ] . startswith ( '/' ) : kwargs [ 'unix_socket' ] = settings_dict [ 'HOST' ] elif settings_dict [ 'HOST' ] : kwargs [ 'host' ] = settings_dict [ 'HOST' ] if settings_dict [ 'PORT' ] : kwargs [ 'port' ] = int ( settings_dict [ 'PORT' ] ) kwargs [ 'client_flag' ] = CLIENT . FOUND_ROWS kwargs . update ( settings_dict [ 'OPTIONS' ] ) self . connection = Database . connect ( ** kwargs ) self . connection . encoders [ SafeUnicode ] = self . connection . encoders [ unicode ] self . connection . encoders [ SafeString ] = self . connection . encoders [ str ] self . features . uses_savepoints = self . get_server_version ( ) >= ( 5 , 0 , 3 ) connection_created . send ( sender = self . __class__ , connection = self ) cursor = self . connection . cursor ( ) if new_connection : cursor . execute ( 'SET SQL_AUTO_IS_NULL = 0' ) return CursorWrapper ( cursor ) def _rollback ( self ) : try : BaseDatabaseWrapper . _rollback ( self ) except Database . NotSupportedError : pass def get_server_version ( self ) : if not self . server_version : if not self . _valid_connection ( ) : self . cursor ( ) m = server_version_re . match ( self . connection . get_server_info ( ) ) if not m : raise Exception ( 'Unable to determine MySQL version from version string %r' % self . connection . get_server_info ( ) ) self . server_version = tuple ( [ int ( x ) for x in m . groups ( ) ] ) return self . server_version def disable_constraint_checking ( self ) : self . cursor ( ) . execute ( 'SET foreign_key_checks=0' ) return True def enable_constraint_checking ( self ) : self . cursor ( ) . execute ( 'SET foreign_key_checks=1' ) def check_constraints ( self , table_names = None ) : cursor = self . cursor ( ) if table_names is None : table_names = self . introspection . get_table_list ( cursor ) for table_name in table_names : primary_key_column_name = self . introspection . get_primary_key_column ( cursor , table_name ) if not primary_key_column_name : continue key_columns = self . introspection . get_key_columns ( cursor , table_name ) for column_name , referenced_table_name , referenced_column_name in key_columns : cursor . execute ( """ SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING LEFT JOIN `%s` as REFERRED ON (REFERRING.`%s` = REFERRED.`%s`) WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL""" % ( primary_key_column_name , column_name , table_name , referenced_table_name , column_name , referenced_column_name , column_name , referenced_column_name ) ) for bad_row in cursor . fetchall ( ) : raise utils . IntegrityError ( "The row in table '%s' with primary key '%s' has an invalid " % ( table_name , bad_row [ 0 ] , table_name , column_name , bad_row [ 1 ] , referenced_table_name , referenced_column_name ) )

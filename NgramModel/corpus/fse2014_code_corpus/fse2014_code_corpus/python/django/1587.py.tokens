from functools import update_wrapper , partial from django import forms from django . conf import settings from django . forms . formsets import all_valid from django . forms . models import ( modelform_factory , modelformset_factory , inlineformset_factory , BaseInlineFormSet ) from django . contrib . contenttypes . models import ContentType from django . contrib . admin import widgets , helpers from django . contrib . admin . util import unquote , flatten_fieldsets , get_deleted_objects , model_format_dict from django . contrib . admin . templatetags . admin_static import static from django . contrib import messages from django . views . decorators . csrf import csrf_protect from django . core . exceptions import PermissionDenied , ValidationError from django . core . paginator import Paginator from django . core . urlresolvers import reverse from django . db import models , transaction , router from django . db . models . related import RelatedObject from django . db . models . fields import BLANK_CHOICE_DASH , FieldDoesNotExist from django . db . models . sql . constants import LOOKUP_SEP , QUERY_TERMS from django . http import Http404 , HttpResponse , HttpResponseRedirect from django . shortcuts import get_object_or_404 from django . template . response import SimpleTemplateResponse , TemplateResponse from django . utils . decorators import method_decorator from django . utils . datastructures import SortedDict from django . utils . html import escape , escapejs from django . utils . safestring import mark_safe from django . utils . text import capfirst , get_text_list from django . utils . translation import ugettext as _ from django . utils . translation import ungettext from django . utils . encoding import force_unicode HORIZONTAL , VERTICAL = 1 , 2 get_ul_class = lambda x : 'radiolist%s' % ( ( x == HORIZONTAL ) and ' inline' or '' ) class IncorrectLookupParameters ( Exception ) : pass FORMFIELD_FOR_DBFIELD_DEFAULTS = { models . DateTimeField : { : forms . SplitDateTimeField , : widgets . AdminSplitDateTime } , models . DateField : { 'widget' : widgets . AdminDateWidget } , models . TimeField : { 'widget' : widgets . AdminTimeWidget } , models . TextField : { 'widget' : widgets . AdminTextareaWidget } , models . URLField : { 'widget' : widgets . AdminURLFieldWidget } , models . IntegerField : { 'widget' : widgets . AdminIntegerFieldWidget } , models . BigIntegerField : { 'widget' : widgets . AdminIntegerFieldWidget } , models . CharField : { 'widget' : widgets . AdminTextInputWidget } , models . ImageField : { 'widget' : widgets . AdminFileWidget } , models . FileField : { 'widget' : widgets . AdminFileWidget } , } csrf_protect_m = method_decorator ( csrf_protect ) class BaseModelAdmin ( object ) : __metaclass__ = forms . MediaDefiningClass raw_id_fields = ( ) fields = None exclude = None fieldsets = None form = forms . ModelForm filter_vertical = ( ) filter_horizontal = ( ) radio_fields = { } prepopulated_fields = { } formfield_overrides = { } readonly_fields = ( ) ordering = None def __init__ ( self ) : overrides = FORMFIELD_FOR_DBFIELD_DEFAULTS . copy ( ) overrides . update ( self . formfield_overrides ) self . formfield_overrides = overrides def formfield_for_dbfield ( self , db_field , ** kwargs ) : request = kwargs . pop ( "request" , None ) if db_field . choices : return self . formfield_for_choice_field ( db_field , request , ** kwargs ) if isinstance ( db_field , ( models . ForeignKey , models . ManyToManyField ) ) : if db_field . __class__ in self . formfield_overrides : kwargs = dict ( self . formfield_overrides [ db_field . __class__ ] , ** kwargs ) if isinstance ( db_field , models . ForeignKey ) : formfield = self . formfield_for_foreignkey ( db_field , request , ** kwargs ) elif isinstance ( db_field , models . ManyToManyField ) : formfield = self . formfield_for_manytomany ( db_field , request , ** kwargs ) if formfield and db_field . name not in self . raw_id_fields : related_modeladmin = self . admin_site . _registry . get ( db_field . rel . to ) can_add_related = bool ( related_modeladmin and related_modeladmin . has_add_permission ( request ) ) formfield . widget = widgets . RelatedFieldWidgetWrapper ( formfield . widget , db_field . rel , self . admin_site , can_add_related = can_add_related ) return formfield for klass in db_field . __class__ . mro ( ) : if klass in self . formfield_overrides : kwargs = dict ( self . formfield_overrides [ klass ] , ** kwargs ) return db_field . formfield ( ** kwargs ) return db_field . formfield ( ** kwargs ) def formfield_for_choice_field ( self , db_field , request = None , ** kwargs ) : if db_field . name in self . radio_fields : if 'widget' not in kwargs : kwargs [ 'widget' ] = widgets . AdminRadioSelect ( attrs = { : get_ul_class ( self . radio_fields [ db_field . name ] ) , } ) if 'choices' not in kwargs : kwargs [ 'choices' ] = db_field . get_choices ( include_blank = db_field . blank , blank_choice = [ ( '' , _ ( 'None' ) ) ] ) return db_field . formfield ( ** kwargs ) def formfield_for_foreignkey ( self , db_field , request = None , ** kwargs ) : db = kwargs . get ( 'using' ) if db_field . name in self . raw_id_fields : kwargs [ 'widget' ] = widgets . ForeignKeyRawIdWidget ( db_field . rel , self . admin_site , using = db ) elif db_field . name in self . radio_fields : kwargs [ 'widget' ] = widgets . AdminRadioSelect ( attrs = { : get_ul_class ( self . radio_fields [ db_field . name ] ) , } ) kwargs [ 'empty_label' ] = db_field . blank and _ ( 'None' ) or None return db_field . formfield ( ** kwargs ) def formfield_for_manytomany ( self , db_field , request = None , ** kwargs ) : if not db_field . rel . through . _meta . auto_created : return None db = kwargs . get ( 'using' ) if db_field . name in self . raw_id_fields : kwargs [ 'widget' ] = widgets . ManyToManyRawIdWidget ( db_field . rel , self . admin_site , using = db ) kwargs [ 'help_text' ] = '' elif db_field . name in ( list ( self . filter_vertical ) + list ( self . filter_horizontal ) ) : kwargs [ 'widget' ] = widgets . FilteredSelectMultiple ( db_field . verbose_name , ( db_field . name in self . filter_vertical ) ) return db_field . formfield ( ** kwargs ) def _declared_fieldsets ( self ) : if self . fieldsets : return self . fieldsets elif self . fields : return [ ( None , { 'fields' : self . fields } ) ] return None declared_fieldsets = property ( _declared_fieldsets ) def get_ordering ( self , request ) : return self . ordering or ( ) def get_readonly_fields ( self , request , obj = None ) : return self . readonly_fields def get_prepopulated_fields ( self , request , obj = None ) : return self . prepopulated_fields def queryset ( self , request ) : qs = self . model . _default_manager . get_query_set ( ) ordering = self . get_ordering ( request ) if ordering : qs = qs . order_by ( * ordering ) return qs def lookup_allowed ( self , lookup , value ) : model = self . model for l in model . _meta . related_fkey_lookups : for k , v in widgets . url_params_from_lookup_dict ( l ) . items ( ) : if k == lookup and v == value : return True parts = lookup . split ( LOOKUP_SEP ) if len ( parts ) > 1 and parts [ - 1 ] in QUERY_TERMS : parts . pop ( ) pk_attr_name = None for part in parts [ : - 1 ] : field , _ , _ , _ = model . _meta . get_field_by_name ( part ) if hasattr ( field , 'rel' ) : model = field . rel . to pk_attr_name = model . _meta . pk . name elif isinstance ( field , RelatedObject ) : model = field . model pk_attr_name = model . _meta . pk . name else : pk_attr_name = None if pk_attr_name and len ( parts ) > 1 and parts [ - 1 ] == pk_attr_name : parts . pop ( ) try : self . model . _meta . get_field_by_name ( parts [ 0 ] ) except FieldDoesNotExist : return True else : if len ( parts ) == 1 : return True clean_lookup = LOOKUP_SEP . join ( parts ) return clean_lookup in self . list_filter or clean_lookup == self . date_hierarchy def has_add_permission ( self , request ) : opts = self . opts return request . user . has_perm ( opts . app_label + '.' + opts . get_add_permission ( ) ) def has_change_permission ( self , request , obj = None ) : opts = self . opts return request . user . has_perm ( opts . app_label + '.' + opts . get_change_permission ( ) ) def has_delete_permission ( self , request , obj = None ) : opts = self . opts return request . user . has_perm ( opts . app_label + '.' + opts . get_delete_permission ( ) ) class ModelAdmin ( BaseModelAdmin ) : list_display = ( '__str__' , ) list_display_links = ( ) list_filter = ( ) list_select_related = False list_per_page = 100 list_max_show_all = 200 list_editable = ( ) search_fields = ( ) date_hierarchy = None save_as = False save_on_top = False paginator = Paginator inlines = [ ] add_form_template = None change_form_template = None change_list_template = None delete_confirmation_template = None delete_selected_confirmation_template = None object_history_template = None actions = [ ] action_form = helpers . ActionForm actions_on_top = True actions_on_bottom = False actions_selection_counter = True def __init__ ( self , model , admin_site ) : self . model = model self . opts = model . _meta self . admin_site = admin_site super ( ModelAdmin , self ) . __init__ ( ) def get_inline_instances ( self , request ) : inline_instances = [ ] for inline_class in self . inlines : inline = inline_class ( self . model , self . admin_site ) if request : if not ( inline . has_add_permission ( request ) or inline . has_change_permission ( request ) or inline . has_delete_permission ( request ) ) : continue if not inline . has_add_permission ( request ) : inline . max_num = 0 inline_instances . append ( inline ) return inline_instances def get_urls ( self ) : from django . conf . urls import patterns , url def wrap ( view ) : def wrapper ( * args , ** kwargs ) : return self . admin_site . admin_view ( view ) ( * args , ** kwargs ) return update_wrapper ( wrapper , view ) info = self . model . _meta . app_label , self . model . _meta . module_name urlpatterns = patterns ( '' , url ( r'^$' , wrap ( self . changelist_view ) , name = '%s_%s_changelist' % info ) , url ( r'^add/$' , wrap ( self . add_view ) , name = '%s_%s_add' % info ) , url ( r'^(.+)/history/$' , wrap ( self . history_view ) , name = '%s_%s_history' % info ) , url ( r'^(.+)/delete/$' , wrap ( self . delete_view ) , name = '%s_%s_delete' % info ) , url ( r'^(.+)/$' , wrap ( self . change_view ) , name = '%s_%s_change' % info ) , ) return urlpatterns def urls ( self ) : return self . get_urls ( ) urls = property ( urls ) @ property def media ( self ) : extra = '' if settings . DEBUG else '.min' js = [ , , % extra , ] if self . actions is not None : js . append ( 'actions%s.js' % extra ) if self . prepopulated_fields : js . extend ( [ 'urlify.js' , 'prepopulate%s.js' % extra ] ) if self . opts . get_ordered_objects ( ) : js . extend ( [ 'getElementsBySelector.js' , 'dom-drag.js' , 'admin/ordering.js' ] ) return forms . Media ( js = [ static ( 'admin/js/%s' % url ) for url in js ] ) def get_model_perms ( self , request ) : return { : self . has_add_permission ( request ) , : self . has_change_permission ( request ) , : self . has_delete_permission ( request ) , } def get_fieldsets ( self , request , obj = None ) : if self . declared_fieldsets : return self . declared_fieldsets form = self . get_form ( request , obj ) fields = form . base_fields . keys ( ) + list ( self . get_readonly_fields ( request , obj ) ) return [ ( None , { 'fields' : fields } ) ] def get_form ( self , request , obj = None , ** kwargs ) : if self . declared_fieldsets : fields = flatten_fieldsets ( self . declared_fieldsets ) else : fields = None if self . exclude is None : exclude = [ ] else : exclude = list ( self . exclude ) exclude . extend ( self . get_readonly_fields ( request , obj ) ) if self . exclude is None and hasattr ( self . form , '_meta' ) and self . form . _meta . exclude : exclude . extend ( self . form . _meta . exclude ) exclude = exclude or None defaults = { : self . form , : fields , : exclude , : partial ( self . formfield_for_dbfield , request = request ) , } defaults . update ( kwargs ) return modelform_factory ( self . model , ** defaults ) def get_changelist ( self , request , ** kwargs ) : from django . contrib . admin . views . main import ChangeList return ChangeList def get_object ( self , request , object_id ) : queryset = self . queryset ( request ) model = queryset . model try : object_id = model . _meta . pk . to_python ( object_id ) return queryset . get ( pk = object_id ) except ( model . DoesNotExist , ValidationError ) : return None def get_changelist_form ( self , request , ** kwargs ) : defaults = { : partial ( self . formfield_for_dbfield , request = request ) , } defaults . update ( kwargs ) return modelform_factory ( self . model , ** defaults ) def get_changelist_formset ( self , request , ** kwargs ) : defaults = { : partial ( self . formfield_for_dbfield , request = request ) , } defaults . update ( kwargs ) return modelformset_factory ( self . model , self . get_changelist_form ( request ) , extra = 0 , fields = self . list_editable , ** defaults ) def get_formsets ( self , request , obj = None ) : for inline in self . get_inline_instances ( request ) : yield inline . get_formset ( request , obj ) def get_paginator ( self , request , queryset , per_page , orphans = 0 , allow_empty_first_page = True ) : return self . paginator ( queryset , per_page , orphans , allow_empty_first_page ) def log_addition ( self , request , object ) : from django . contrib . admin . models import LogEntry , ADDITION LogEntry . objects . log_action ( user_id = request . user . pk , content_type_id = ContentType . objects . get_for_model ( object ) . pk , object_id = object . pk , object_repr = force_unicode ( object ) , action_flag = ADDITION ) def log_change ( self , request , object , message ) : from django . contrib . admin . models import LogEntry , CHANGE LogEntry . objects . log_action ( user_id = request . user . pk , content_type_id = ContentType . objects . get_for_model ( object ) . pk , object_id = object . pk , object_repr = force_unicode ( object ) , action_flag = CHANGE , change_message = message ) def log_deletion ( self , request , object , object_repr ) : from django . contrib . admin . models import LogEntry , DELETION LogEntry . objects . log_action ( user_id = request . user . id , content_type_id = ContentType . objects . get_for_model ( self . model ) . pk , object_id = object . pk , object_repr = object_repr , action_flag = DELETION ) def action_checkbox ( self , obj ) : return helpers . checkbox . render ( helpers . ACTION_CHECKBOX_NAME , force_unicode ( obj . pk ) ) action_checkbox . short_description = mark_safe ( '<input type="checkbox" id="action-toggle" />' ) action_checkbox . allow_tags = True def get_actions ( self , request ) : from django . contrib . admin . views . main import IS_POPUP_VAR if self . actions is None or IS_POPUP_VAR in request . GET : return SortedDict ( ) actions = [ ] for ( name , func ) in self . admin_site . actions : description = getattr ( func , 'short_description' , name . replace ( '_' , ' ' ) ) actions . append ( ( func , name , description ) ) for klass in self . __class__ . mro ( ) [ : : - 1 ] : class_actions = getattr ( klass , 'actions' , [ ] ) if not class_actions : continue actions . extend ( [ self . get_action ( action ) for action in class_actions ] ) actions = filter ( None , actions ) actions = SortedDict ( [ ( name , ( func , name , desc ) ) for func , name , desc in actions ] ) return actions def get_action_choices ( self , request , default_choices = BLANK_CHOICE_DASH ) : choices = [ ] + default_choices for func , name , description in self . get_actions ( request ) . itervalues ( ) : choice = ( name , description % model_format_dict ( self . opts ) ) choices . append ( choice ) return choices def get_action ( self , action ) : if callable ( action ) : func = action action = action . __name__ elif hasattr ( self . __class__ , action ) : func = getattr ( self . __class__ , action ) else : try : func = self . admin_site . get_action ( action ) except KeyError : return None if hasattr ( func , 'short_description' ) : description = func . short_description else : description = capfirst ( action . replace ( '_' , ' ' ) ) return func , action , description def get_list_display ( self , request ) : return self . list_display def get_list_display_links ( self , request , list_display ) : if self . list_display_links or not list_display : return self . list_display_links else : return list ( list_display ) [ : 1 ] def construct_change_message ( self , request , form , formsets ) : change_message = [ ] if form . changed_data : change_message . append ( _ ( 'Changed %s.' ) % get_text_list ( form . changed_data , _ ( 'and' ) ) ) if formsets : for formset in formsets : for added_object in formset . new_objects : change_message . append ( _ ( 'Added %(name)s "%(object)s".' ) % { 'name' : force_unicode ( added_object . _meta . verbose_name ) , : force_unicode ( added_object ) } ) for changed_object , changed_fields in formset . changed_objects : change_message . append ( _ ( 'Changed %(list)s for %(name)s "%(object)s".' ) % { 'list' : get_text_list ( changed_fields , _ ( 'and' ) ) , : force_unicode ( changed_object . _meta . verbose_name ) , : force_unicode ( changed_object ) } ) for deleted_object in formset . deleted_objects : change_message . append ( _ ( 'Deleted %(name)s "%(object)s".' ) % { 'name' : force_unicode ( deleted_object . _meta . verbose_name ) , : force_unicode ( deleted_object ) } ) change_message = ' ' . join ( change_message ) return change_message or _ ( 'No fields changed.' ) def message_user ( self , request , message ) : messages . info ( request , message ) def save_form ( self , request , form , change ) : return form . save ( commit = False ) def save_model ( self , request , obj , form , change ) : obj . save ( ) def delete_model ( self , request , obj ) : obj . delete ( ) def save_formset ( self , request , form , formset , change ) : formset . save ( ) def save_related ( self , request , form , formsets , change ) : form . save_m2m ( ) for formset in formsets : self . save_formset ( request , form , formset , change = change ) def render_change_form ( self , request , context , add = False , change = False , form_url = '' , obj = None ) : opts = self . model . _meta app_label = opts . app_label ordered_objects = opts . get_ordered_objects ( ) context . update ( { : add , : change , : self . has_add_permission ( request ) , : self . has_change_permission ( request , obj ) , : self . has_delete_permission ( request , obj ) , : True , : hasattr ( self . model , 'get_absolute_url' ) , : ordered_objects , : mark_safe ( form_url ) , : opts , : ContentType . objects . get_for_model ( self . model ) . id , : self . save_as , : self . save_on_top , } ) if add and self . add_form_template is not None : form_template = self . add_form_template else : form_template = self . change_form_template return TemplateResponse ( request , form_template or [ % ( app_label , opts . object_name . lower ( ) ) , % app_label , ] , context , current_app = self . admin_site . name ) def response_add ( self , request , obj , post_url_continue = '../%s/' ) : opts = obj . _meta pk_value = obj . _get_pk_val ( ) msg = _ ( 'The %(name)s "%(obj)s" was added successfully.' ) % { 'name' : force_unicode ( opts . verbose_name ) , 'obj' : force_unicode ( obj ) } if "_continue" in request . POST : self . message_user ( request , msg + ' ' + _ ( "You may edit it again below." ) ) if "_popup" in request . POST : post_url_continue += "?_popup=1" return HttpResponseRedirect ( post_url_continue % pk_value ) if "_popup" in request . POST : return HttpResponse ( % ( escape ( pk_value ) , escapejs ( obj ) ) ) elif "_addanother" in request . POST : self . message_user ( request , msg + ' ' + ( _ ( "You may add another %s below." ) % force_unicode ( opts . verbose_name ) ) ) return HttpResponseRedirect ( request . path ) else : self . message_user ( request , msg ) if self . has_change_permission ( request , None ) : post_url = reverse ( 'admin:%s_%s_changelist' % ( opts . app_label , opts . module_name ) , current_app = self . admin_site . name ) else : post_url = reverse ( 'admin:index' , current_app = self . admin_site . name ) return HttpResponseRedirect ( post_url ) def response_change ( self , request , obj ) : opts = obj . _meta verbose_name = opts . verbose_name module_name = opts . module_name if obj . _deferred : opts_ = opts . proxy_for_model . _meta verbose_name = opts_ . verbose_name module_name = opts_ . module_name pk_value = obj . _get_pk_val ( ) msg = _ ( 'The %(name)s "%(obj)s" was changed successfully.' ) % { 'name' : force_unicode ( verbose_name ) , 'obj' : force_unicode ( obj ) } if "_continue" in request . POST : self . message_user ( request , msg + ' ' + _ ( "You may edit it again below." ) ) if "_popup" in request . REQUEST : return HttpResponseRedirect ( request . path + "?_popup=1" ) else : return HttpResponseRedirect ( request . path ) elif "_saveasnew" in request . POST : msg = _ ( 'The %(name)s "%(obj)s" was added successfully. You may edit it again below.' ) % { 'name' : force_unicode ( verbose_name ) , 'obj' : obj } self . message_user ( request , msg ) return HttpResponseRedirect ( reverse ( 'admin:%s_%s_change' % ( opts . app_label , module_name ) , args = ( pk_value , ) , current_app = self . admin_site . name ) ) elif "_addanother" in request . POST : self . message_user ( request , msg + ' ' + ( _ ( "You may add another %s below." ) % force_unicode ( verbose_name ) ) ) return HttpResponseRedirect ( reverse ( 'admin:%s_%s_add' % ( opts . app_label , module_name ) , current_app = self . admin_site . name ) ) else : self . message_user ( request , msg ) if self . has_change_permission ( request , None ) : post_url = reverse ( 'admin:%s_%s_changelist' % ( opts . app_label , module_name ) , current_app = self . admin_site . name ) else : post_url = reverse ( 'admin:index' , current_app = self . admin_site . name ) return HttpResponseRedirect ( post_url ) def response_action ( self , request , queryset ) : try : action_index = int ( request . POST . get ( 'index' , 0 ) ) except ValueError : action_index = 0 data = request . POST . copy ( ) data . pop ( helpers . ACTION_CHECKBOX_NAME , None ) data . pop ( "index" , None ) try : data . update ( { 'action' : data . getlist ( 'action' ) [ action_index ] } ) except IndexError : pass action_form = self . action_form ( data , auto_id = None ) action_form . fields [ 'action' ] . choices = self . get_action_choices ( request ) if action_form . is_valid ( ) : action = action_form . cleaned_data [ 'action' ] select_across = action_form . cleaned_data [ 'select_across' ] func , name , description = self . get_actions ( request ) [ action ] selected = request . POST . getlist ( helpers . ACTION_CHECKBOX_NAME ) if not selected and not select_across : msg = _ ( "Items must be selected in order to perform " ) self . message_user ( request , msg ) return None if not select_across : queryset = queryset . filter ( pk__in = selected ) response = func ( self , request , queryset ) if isinstance ( response , HttpResponse ) : return response else : return HttpResponseRedirect ( request . get_full_path ( ) ) else : msg = _ ( "No action selected." ) self . message_user ( request , msg ) return None @ csrf_protect_m @ transaction . commit_on_success def add_view ( self , request , form_url = '' , extra_context = None ) : model = self . model opts = model . _meta if not self . has_add_permission ( request ) : raise PermissionDenied ModelForm = self . get_form ( request ) formsets = [ ] inline_instances = self . get_inline_instances ( request ) if request . method == 'POST' : form = ModelForm ( request . POST , request . FILES ) if form . is_valid ( ) : new_object = self . save_form ( request , form , change = False ) form_validated = True else : form_validated = False new_object = self . model ( ) prefixes = { } for FormSet , inline in zip ( self . get_formsets ( request ) , inline_instances ) : prefix = FormSet . get_default_prefix ( ) prefixes [ prefix ] = prefixes . get ( prefix , 0 ) + 1 if prefixes [ prefix ] != 1 or not prefix : prefix = "%s-%s" % ( prefix , prefixes [ prefix ] ) formset = FormSet ( data = request . POST , files = request . FILES , instance = new_object , save_as_new = "_saveasnew" in request . POST , prefix = prefix , queryset = inline . queryset ( request ) ) formsets . append ( formset ) if all_valid ( formsets ) and form_validated : self . save_model ( request , new_object , form , False ) self . save_related ( request , form , formsets , False ) self . log_addition ( request , new_object ) return self . response_add ( request , new_object ) else : initial = dict ( request . GET . items ( ) ) for k in initial : try : f = opts . get_field ( k ) except models . FieldDoesNotExist : continue if isinstance ( f , models . ManyToManyField ) : initial [ k ] = initial [ k ] . split ( "," ) form = ModelForm ( initial = initial ) prefixes = { } for FormSet , inline in zip ( self . get_formsets ( request ) , inline_instances ) : prefix = FormSet . get_default_prefix ( ) prefixes [ prefix ] = prefixes . get ( prefix , 0 ) + 1 if prefixes [ prefix ] != 1 or not prefix : prefix = "%s-%s" % ( prefix , prefixes [ prefix ] ) formset = FormSet ( instance = self . model ( ) , prefix = prefix , queryset = inline . queryset ( request ) ) formsets . append ( formset ) adminForm = helpers . AdminForm ( form , list ( self . get_fieldsets ( request ) ) , self . get_prepopulated_fields ( request ) , self . get_readonly_fields ( request ) , model_admin = self ) media = self . media + adminForm . media inline_admin_formsets = [ ] for inline , formset in zip ( inline_instances , formsets ) : fieldsets = list ( inline . get_fieldsets ( request ) ) readonly = list ( inline . get_readonly_fields ( request ) ) prepopulated = dict ( inline . get_prepopulated_fields ( request ) ) inline_admin_formset = helpers . InlineAdminFormSet ( inline , formset , fieldsets , prepopulated , readonly , model_admin = self ) inline_admin_formsets . append ( inline_admin_formset ) media = media + inline_admin_formset . media context = { : _ ( 'Add %s' ) % force_unicode ( opts . verbose_name ) , : adminForm , : "_popup" in request . REQUEST , : False , : media , : inline_admin_formsets , : helpers . AdminErrorList ( form , formsets ) , : opts . app_label , } context . update ( extra_context or { } ) return self . render_change_form ( request , context , form_url = form_url , add = True ) @ csrf_protect_m @ transaction . commit_on_success def change_view ( self , request , object_id , form_url = '' , extra_context = None ) : model = self . model opts = model . _meta obj = self . get_object ( request , unquote ( object_id ) ) if not self . has_change_permission ( request , obj ) : raise PermissionDenied if obj is None : raise Http404 ( _ ( '%(name)s object with primary key %(key)r does not exist.' ) % { 'name' : force_unicode ( opts . verbose_name ) , 'key' : escape ( object_id ) } ) if request . method == 'POST' and "_saveasnew" in request . POST : return self . add_view ( request , form_url = reverse ( 'admin:%s_%s_add' % ( opts . app_label , opts . module_name ) , current_app = self . admin_site . name ) ) ModelForm = self . get_form ( request , obj ) formsets = [ ] inline_instances = self . get_inline_instances ( request ) if request . method == 'POST' : form = ModelForm ( request . POST , request . FILES , instance = obj ) if form . is_valid ( ) : form_validated = True new_object = self . save_form ( request , form , change = True ) else : form_validated = False new_object = obj prefixes = { } for FormSet , inline in zip ( self . get_formsets ( request , new_object ) , inline_instances ) : prefix = FormSet . get_default_prefix ( ) prefixes [ prefix ] = prefixes . get ( prefix , 0 ) + 1 if prefixes [ prefix ] != 1 or not prefix : prefix = "%s-%s" % ( prefix , prefixes [ prefix ] ) formset = FormSet ( request . POST , request . FILES , instance = new_object , prefix = prefix , queryset = inline . queryset ( request ) ) formsets . append ( formset ) if all_valid ( formsets ) and form_validated : self . save_model ( request , new_object , form , True ) self . save_related ( request , form , formsets , True ) change_message = self . construct_change_message ( request , form , formsets ) self . log_change ( request , new_object , change_message ) return self . response_change ( request , new_object ) else : form = ModelForm ( instance = obj ) prefixes = { } for FormSet , inline in zip ( self . get_formsets ( request , obj ) , inline_instances ) : prefix = FormSet . get_default_prefix ( ) prefixes [ prefix ] = prefixes . get ( prefix , 0 ) + 1 if prefixes [ prefix ] != 1 or not prefix : prefix = "%s-%s" % ( prefix , prefixes [ prefix ] ) formset = FormSet ( instance = obj , prefix = prefix , queryset = inline . queryset ( request ) ) formsets . append ( formset ) adminForm = helpers . AdminForm ( form , self . get_fieldsets ( request , obj ) , self . get_prepopulated_fields ( request , obj ) , self . get_readonly_fields ( request , obj ) , model_admin = self ) media = self . media + adminForm . media inline_admin_formsets = [ ] for inline , formset in zip ( inline_instances , formsets ) : fieldsets = list ( inline . get_fieldsets ( request , obj ) ) readonly = list ( inline . get_readonly_fields ( request , obj ) ) prepopulated = dict ( inline . get_prepopulated_fields ( request , obj ) ) inline_admin_formset = helpers . InlineAdminFormSet ( inline , formset , fieldsets , prepopulated , readonly , model_admin = self ) inline_admin_formsets . append ( inline_admin_formset ) media = media + inline_admin_formset . media context = { : _ ( 'Change %s' ) % force_unicode ( opts . verbose_name ) , : adminForm , : object_id , : obj , : "_popup" in request . REQUEST , : media , : inline_admin_formsets , : helpers . AdminErrorList ( form , formsets ) , : opts . app_label , } context . update ( extra_context or { } ) return self . render_change_form ( request , context , change = True , obj = obj , form_url = form_url ) @ csrf_protect_m def changelist_view ( self , request , extra_context = None ) : from django . contrib . admin . views . main import ERROR_FLAG opts = self . model . _meta app_label = opts . app_label if not self . has_change_permission ( request , None ) : raise PermissionDenied list_display = self . get_list_display ( request ) list_display_links = self . get_list_display_links ( request , list_display ) actions = self . get_actions ( request ) if actions : list_display = [ 'action_checkbox' ] + list ( list_display ) ChangeList = self . get_changelist ( request ) try : cl = ChangeList ( request , self . model , list_display , list_display_links , self . list_filter , self . date_hierarchy , self . search_fields , self . list_select_related , self . list_per_page , self . list_max_show_all , self . list_editable , self ) except IncorrectLookupParameters : if ERROR_FLAG in request . GET . keys ( ) : return SimpleTemplateResponse ( 'admin/invalid_setup.html' , { : _ ( 'Database error' ) , } ) return HttpResponseRedirect ( request . path + '?' + ERROR_FLAG + '=1' ) action_failed = False selected = request . POST . getlist ( helpers . ACTION_CHECKBOX_NAME ) if ( actions and request . method == 'POST' and in request . POST and '_save' not in request . POST ) : if selected : response = self . response_action ( request , queryset = cl . get_query_set ( request ) ) if response : return response else : action_failed = True else : msg = _ ( "Items must be selected in order to perform " ) self . message_user ( request , msg ) action_failed = True if ( actions and request . method == 'POST' and helpers . ACTION_CHECKBOX_NAME in request . POST and not in request . POST and '_save' not in request . POST ) : if selected : response = self . response_action ( request , queryset = cl . get_query_set ( request ) ) if response : return response else : action_failed = True formset = cl . formset = None if ( request . method == "POST" and cl . list_editable and in request . POST and not action_failed ) : FormSet = self . get_changelist_formset ( request ) formset = cl . formset = FormSet ( request . POST , request . FILES , queryset = cl . result_list ) if formset . is_valid ( ) : changecount = 0 for form in formset . forms : if form . has_changed ( ) : obj = self . save_form ( request , form , change = True ) self . save_model ( request , obj , form , change = True ) self . save_related ( request , form , formsets = [ ] , change = True ) change_msg = self . construct_change_message ( request , form , None ) self . log_change ( request , obj , change_msg ) changecount += 1 if changecount : if changecount == 1 : name = force_unicode ( opts . verbose_name ) else : name = force_unicode ( opts . verbose_name_plural ) msg = ungettext ( "%(count)s %(name)s was changed successfully." , , changecount ) % { 'count' : changecount , : name , : force_unicode ( obj ) } self . message_user ( request , msg ) return HttpResponseRedirect ( request . get_full_path ( ) ) elif cl . list_editable : FormSet = self . get_changelist_formset ( request ) formset = cl . formset = FormSet ( queryset = cl . result_list ) if formset : media = self . media + formset . media else : media = self . media if actions : action_form = self . action_form ( auto_id = None ) action_form . fields [ 'action' ] . choices = self . get_action_choices ( request ) else : action_form = None selection_note_all = ungettext ( '%(total_count)s selected' , , cl . result_count ) context = { : force_unicode ( opts . verbose_name_plural ) , : _ ( '0 of %(cnt)s selected' ) % { 'cnt' : len ( cl . result_list ) } , : selection_note_all % { 'total_count' : cl . result_count } , : cl . title , : cl . is_popup , : cl , : media , : self . has_add_permission ( request ) , : app_label , : action_form , : self . actions_on_top , : self . actions_on_bottom , : self . actions_selection_counter , } context . update ( extra_context or { } ) return TemplateResponse ( request , self . change_list_template or [ % ( app_label , opts . object_name . lower ( ) ) , % app_label , ] , context , current_app = self . admin_site . name ) @ csrf_protect_m @ transaction . commit_on_success def delete_view ( self , request , object_id , extra_context = None ) : opts = self . model . _meta app_label = opts . app_label obj = self . get_object ( request , unquote ( object_id ) ) if not self . has_delete_permission ( request , obj ) : raise PermissionDenied if obj is None : raise Http404 ( _ ( '%(name)s object with primary key %(key)r does not exist.' ) % { 'name' : force_unicode ( opts . verbose_name ) , 'key' : escape ( object_id ) } ) using = router . db_for_write ( self . model ) ( deleted_objects , perms_needed , protected ) = get_deleted_objects ( [ obj ] , opts , request . user , self . admin_site , using ) if request . POST : if perms_needed : raise PermissionDenied obj_display = force_unicode ( obj ) self . log_deletion ( request , obj , obj_display ) self . delete_model ( request , obj ) self . message_user ( request , _ ( 'The %(name)s "%(obj)s" was deleted successfully.' ) % { 'name' : force_unicode ( opts . verbose_name ) , 'obj' : force_unicode ( obj_display ) } ) if not self . has_change_permission ( request , None ) : return HttpResponseRedirect ( reverse ( 'admin:index' , current_app = self . admin_site . name ) ) return HttpResponseRedirect ( reverse ( 'admin:%s_%s_changelist' % ( opts . app_label , opts . module_name ) , current_app = self . admin_site . name ) ) object_name = force_unicode ( opts . verbose_name ) if perms_needed or protected : title = _ ( "Cannot delete %(name)s" ) % { "name" : object_name } else : title = _ ( "Are you sure?" ) context = { : title , : object_name , : obj , : deleted_objects , : perms_needed , : protected , : opts , : app_label , } context . update ( extra_context or { } ) return TemplateResponse ( request , self . delete_confirmation_template or [ % ( app_label , opts . object_name . lower ( ) ) , % app_label , ] , context , current_app = self . admin_site . name ) def history_view ( self , request , object_id , extra_context = None ) : from django . contrib . admin . models import LogEntry model = self . model opts = model . _meta app_label = opts . app_label action_list = LogEntry . objects . filter ( object_id = object_id , content_type__id__exact = ContentType . objects . get_for_model ( model ) . id ) . select_related ( ) . order_by ( 'action_time' ) obj = get_object_or_404 ( model , pk = unquote ( object_id ) ) context = { : _ ( 'Change history: %s' ) % force_unicode ( obj ) , : action_list , : capfirst ( force_unicode ( opts . verbose_name_plural ) ) , : obj , : app_label , : opts , } context . update ( extra_context or { } ) return TemplateResponse ( request , self . object_history_template or [ % ( app_label , opts . object_name . lower ( ) ) , % app_label , ] , context , current_app = self . admin_site . name ) class InlineModelAdmin ( BaseModelAdmin ) : model = None fk_name = None formset = BaseInlineFormSet extra = 3 max_num = None template = None verbose_name = None verbose_name_plural = None can_delete = True def __init__ ( self , parent_model , admin_site ) : self . admin_site = admin_site self . parent_model = parent_model self . opts = self . model . _meta super ( InlineModelAdmin , self ) . __init__ ( ) if self . verbose_name is None : self . verbose_name = self . model . _meta . verbose_name if self . verbose_name_plural is None : self . verbose_name_plural = self . model . _meta . verbose_name_plural @ property def media ( self ) : extra = '' if settings . DEBUG else '.min' js = [ 'jquery%s.js' % extra , 'jquery.init.js' , 'inlines%s.js' % extra ] if self . prepopulated_fields : js . extend ( [ 'urlify.js' , 'prepopulate%s.js' % extra ] ) if self . filter_vertical or self . filter_horizontal : js . extend ( [ 'SelectBox.js' , 'SelectFilter2.js' ] ) return forms . Media ( js = [ static ( 'admin/js/%s' % url ) for url in js ] ) def get_formset ( self , request , obj = None , ** kwargs ) : if self . declared_fieldsets : fields = flatten_fieldsets ( self . declared_fieldsets ) else : fields = None if self . exclude is None : exclude = [ ] else : exclude = list ( self . exclude ) exclude . extend ( self . get_readonly_fields ( request , obj ) ) if self . exclude is None and hasattr ( self . form , '_meta' ) and self . form . _meta . exclude : exclude . extend ( self . form . _meta . exclude ) exclude = exclude or None can_delete = self . can_delete and self . has_delete_permission ( request , obj ) defaults = { : self . form , : self . formset , : self . fk_name , : fields , : exclude , : partial ( self . formfield_for_dbfield , request = request ) , : self . extra , : self . max_num , : can_delete , } defaults . update ( kwargs ) return inlineformset_factory ( self . parent_model , self . model , ** defaults ) def get_fieldsets ( self , request , obj = None ) : if self . declared_fieldsets : return self . declared_fieldsets form = self . get_formset ( request , obj ) . form fields = form . base_fields . keys ( ) + list ( self . get_readonly_fields ( request , obj ) ) return [ ( None , { 'fields' : fields } ) ] def queryset ( self , request ) : queryset = super ( InlineModelAdmin , self ) . queryset ( request ) if not self . has_change_permission ( request ) : queryset = queryset . none ( ) return queryset def has_add_permission ( self , request ) : if self . opts . auto_created : return self . has_change_permission ( request ) return request . user . has_perm ( self . opts . app_label + '.' + self . opts . get_add_permission ( ) ) def has_change_permission ( self , request , obj = None ) : opts = self . opts if opts . auto_created : for field in opts . fields : if field . rel and field . rel . to != self . parent_model : opts = field . rel . to . _meta break return request . user . has_perm ( opts . app_label + '.' + opts . get_change_permission ( ) ) def has_delete_permission ( self , request , obj = None ) : if self . opts . auto_created : return self . has_change_permission ( request , obj ) return request . user . has_perm ( self . opts . app_label + '.' + self . opts . get_delete_permission ( ) ) class StackedInline ( InlineModelAdmin ) : template = 'admin/edit_inline/stacked.html' class TabularInline ( InlineModelAdmin ) : template = 'admin/edit_inline/tabular.html'

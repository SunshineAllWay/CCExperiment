from django . contrib . gis . geos import GEOSGeometry , LinearRing , Polygon , Point from django . contrib . gis . maps . google . gmap import GoogleMapException from math import pi , sin , log , exp , atan DTOR = pi / 180. RTOD = 180. / pi class GoogleZoom ( object ) : def __init__ ( self , num_zoom = 19 , tilesize = 256 ) : self . _tilesize = tilesize self . _nzoom = num_zoom self . _degpp = [ ] self . _radpp = [ ] self . _npix = [ ] z = tilesize for i in xrange ( num_zoom ) : self . _degpp . append ( z / 360. ) self . _radpp . append ( z / ( 2 * pi ) ) self . _npix . append ( z / 2 ) z *= 2 def __len__ ( self ) : return self . _nzoom def get_lon_lat ( self , lonlat ) : if isinstance ( lonlat , Point ) : lon , lat = lonlat . coords else : lon , lat = lonlat return lon , lat def lonlat_to_pixel ( self , lonlat , zoom ) : lon , lat = self . get_lon_lat ( lonlat ) npix = self . _npix [ zoom ] px_x = round ( npix + ( lon * self . _degpp [ zoom ] ) ) fac = min ( max ( sin ( DTOR * lat ) , - 0.9999 ) , 0.9999 ) px_y = round ( npix + ( 0.5 * log ( ( 1 + fac ) / ( 1 - fac ) ) * ( - 1.0 * self . _radpp [ zoom ] ) ) ) return ( px_x , px_y ) def pixel_to_lonlat ( self , px , zoom ) : if len ( px ) != 2 : raise TypeError ( 'Pixel should be a sequence of two elements.' ) npix = self . _npix [ zoom ] lon = ( px [ 0 ] - npix ) / self . _degpp [ zoom ] lat = RTOD * ( 2 * atan ( exp ( ( px [ 1 ] - npix ) / ( - 1.0 * self . _radpp [ zoom ] ) ) ) - 0.5 * pi ) return ( lon , lat ) def tile ( self , lonlat , zoom ) : delta = self . _tilesize / 2 px = self . lonlat_to_pixel ( lonlat , zoom ) ll = self . pixel_to_lonlat ( ( px [ 0 ] - delta , px [ 1 ] - delta ) , zoom ) ur = self . pixel_to_lonlat ( ( px [ 0 ] + delta , px [ 1 ] + delta ) , zoom ) return Polygon ( LinearRing ( ll , ( ll [ 0 ] , ur [ 1 ] ) , ur , ( ur [ 0 ] , ll [ 1 ] ) , ll ) , srid = 4326 ) def get_zoom ( self , geom ) : if not isinstance ( geom , GEOSGeometry ) or geom . srid != 4326 : raise TypeError ( 'get_zoom() expects a GEOS Geometry with an SRID of 4326.' ) env = geom . envelope env_w , env_h = self . get_width_height ( env . extent ) center = env . centroid for z in xrange ( self . _nzoom ) : tile_w , tile_h = self . get_width_height ( self . tile ( center , z ) . extent ) if ( env_w > tile_w ) or ( env_h > tile_h ) : if z == 0 : raise GoogleMapException ( 'Geometry width and height should not exceed that of the Earth.' ) return z - 1 return self . _nzoom - 1 def get_width_height ( self , extent ) : ll = Point ( extent [ : 2 ] ) ul = Point ( extent [ 0 ] , extent [ 3 ] ) ur = Point ( extent [ 2 : ] ) height = ll . distance ( ul ) width = ul . distance ( ur ) return width , height

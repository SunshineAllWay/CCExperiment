from django . db . models . fields import Field from django . db . models . sql . expressions import SQLEvaluator from django . utils . translation import ugettext_lazy as _ from django . contrib . gis import forms from django . contrib . gis . db . models . proxy import GeometryProxy from django . contrib . gis . geometry . backend import Geometry , GeometryException _srid_cache = { } def get_srid_info ( srid , connection ) : global _srid_cache try : SpatialRefSys = connection . ops . spatial_ref_sys ( ) except NotImplementedError : return None , None , None if not connection . alias in _srid_cache : _srid_cache [ connection . alias ] = { } if not srid in _srid_cache [ connection . alias ] : sr = SpatialRefSys . objects . using ( connection . alias ) . get ( srid = srid ) units , units_name = sr . units spheroid = SpatialRefSys . get_spheroid ( sr . wkt ) _srid_cache [ connection . alias ] [ srid ] = ( units , units_name , spheroid ) return _srid_cache [ connection . alias ] [ srid ] class GeometryField ( Field ) : geom_type = 'GEOMETRY' geodetic_units = ( 'Decimal Degree' , 'degree' ) description = _ ( "The base GIS field -- maps to the OpenGIS Specification Geometry type." ) def __init__ ( self , verbose_name = None , srid = 4326 , spatial_index = True , dim = 2 , geography = False , ** kwargs ) : self . spatial_index = spatial_index self . srid = srid self . dim = dim kwargs [ 'verbose_name' ] = verbose_name self . geography = geography self . _extent = kwargs . pop ( 'extent' , ( - 180.0 , - 90.0 , 180.0 , 90.0 ) ) self . _tolerance = kwargs . pop ( 'tolerance' , 0.05 ) super ( GeometryField , self ) . __init__ ( ** kwargs ) def _get_srid_info ( self , connection ) : self . _units , self . _units_name , self . _spheroid = get_srid_info ( self . srid , connection ) def spheroid ( self , connection ) : if not hasattr ( self , '_spheroid' ) : self . _get_srid_info ( connection ) return self . _spheroid def units ( self , connection ) : if not hasattr ( self , '_units' ) : self . _get_srid_info ( connection ) return self . _units def units_name ( self , connection ) : if not hasattr ( self , '_units_name' ) : self . _get_srid_info ( connection ) return self . _units_name def geodetic ( self , connection ) : return self . units_name ( connection ) in self . geodetic_units def get_distance ( self , value , lookup_type , connection ) : return connection . ops . get_distance ( self , value , lookup_type ) def get_prep_value ( self , value ) : if isinstance ( value , SQLEvaluator ) : return value elif isinstance ( value , ( tuple , list ) ) : geom = value [ 0 ] seq_value = True else : geom = value seq_value = False if isinstance ( geom , Geometry ) : pass elif isinstance ( geom , basestring ) or hasattr ( geom , '__geo_interface__' ) : try : geom = Geometry ( geom ) except GeometryException : raise ValueError ( 'Could not create geometry from lookup value.' ) else : raise ValueError ( 'Cannot use object with type %s for a geometry lookup parameter.' % type ( geom ) . __name__ ) geom . srid = self . get_srid ( geom ) if seq_value : lookup_val = [ geom ] lookup_val . extend ( value [ 1 : ] ) return tuple ( lookup_val ) else : return geom def get_srid ( self , geom ) : gsrid = geom . srid if gsrid is None or self . srid == - 1 or ( gsrid == - 1 and self . srid != - 1 ) : return self . srid else : return gsrid def contribute_to_class ( self , cls , name ) : super ( GeometryField , self ) . contribute_to_class ( cls , name ) setattr ( cls , self . attname , GeometryProxy ( Geometry , self ) ) def db_type ( self , connection ) : return connection . ops . geo_db_type ( self ) def formfield ( self , ** kwargs ) : defaults = { 'form_class' : forms . GeometryField , : self . null , : self . geom_type , : self . srid , } defaults . update ( kwargs ) return super ( GeometryField , self ) . formfield ( ** defaults ) def get_db_prep_lookup ( self , lookup_type , value , connection , prepared = False ) : if lookup_type in connection . ops . gis_terms : if lookup_type == 'isnull' : return [ ] if isinstance ( value , ( tuple , list ) ) : params = [ connection . ops . Adapter ( value [ 0 ] ) ] if lookup_type in connection . ops . distance_functions : params += self . get_distance ( value [ 1 : ] , lookup_type , connection ) elif lookup_type in connection . ops . truncate_params : pass else : params += value [ 1 : ] elif isinstance ( value , SQLEvaluator ) : params = [ ] else : params = [ connection . ops . Adapter ( value ) ] return params else : raise ValueError ( '%s is not a valid spatial lookup for %s.' % ( lookup_type , self . __class__ . __name__ ) ) def get_prep_lookup ( self , lookup_type , value ) : if lookup_type == 'isnull' : return bool ( value ) else : return self . get_prep_value ( value ) def get_db_prep_save ( self , value , connection ) : if value is None : return None else : return connection . ops . Adapter ( self . get_prep_value ( value ) ) def get_placeholder ( self , value , connection ) : return connection . ops . get_geom_placeholder ( self , value ) class PointField ( GeometryField ) : geom_type = 'POINT' description = _ ( "Point" ) class LineStringField ( GeometryField ) : geom_type = 'LINESTRING' description = _ ( "Line string" ) class PolygonField ( GeometryField ) : geom_type = 'POLYGON' description = _ ( "Polygon" ) class MultiPointField ( GeometryField ) : geom_type = 'MULTIPOINT' description = _ ( "Multi-point" ) class MultiLineStringField ( GeometryField ) : geom_type = 'MULTILINESTRING' description = _ ( "Multi-line string" ) class MultiPolygonField ( GeometryField ) : geom_type = 'MULTIPOLYGON' description = _ ( "Multi polygon" ) class GeometryCollectionField ( GeometryField ) : geom_type = 'GEOMETRYCOLLECTION' description = _ ( "Geometry collection" )

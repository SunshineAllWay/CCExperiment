from django . db import connections from django . db . models . query import QuerySet , ValuesQuerySet , ValuesListQuerySet from django . contrib . gis . db . models import aggregates from django . contrib . gis . db . models . fields import get_srid_info , PointField , LineStringField from django . contrib . gis . db . models . sql import AreaField , DistanceField , GeomField , GeoQuery from django . contrib . gis . geometry . backend import Geometry from django . contrib . gis . measure import Area , Distance class GeoQuerySet ( QuerySet ) : def __init__ ( self , model = None , query = None , using = None ) : super ( GeoQuerySet , self ) . __init__ ( model = model , query = query , using = using ) self . query = query or GeoQuery ( self . model ) def values ( self , * fields ) : return self . _clone ( klass = GeoValuesQuerySet , setup = True , _fields = fields ) def values_list ( self , * fields , ** kwargs ) : flat = kwargs . pop ( 'flat' , False ) if kwargs : raise TypeError ( 'Unexpected keyword arguments to values_list: %s' % ( kwargs . keys ( ) , ) ) if flat and len ( fields ) > 1 : raise TypeError ( "'flat' is not valid when values_list is called with more than one field." ) return self . _clone ( klass = GeoValuesListQuerySet , setup = True , flat = flat , _fields = fields ) def area ( self , tolerance = 0.05 , ** kwargs ) : procedure_args , geo_field = self . _spatial_setup ( 'area' , field_name = kwargs . get ( 'field_name' , None ) ) s = { 'procedure_args' : procedure_args , : geo_field , : False , } connection = connections [ self . db ] backend = connection . ops if backend . oracle : s [ 'procedure_fmt' ] = '%(geo_col)s,%(tolerance)s' s [ 'procedure_args' ] [ 'tolerance' ] = tolerance s [ 'select_field' ] = AreaField ( 'sq_m' ) elif backend . postgis or backend . spatialite : if backend . geography : s [ 'select_field' ] = AreaField ( 'sq_m' ) elif not geo_field . geodetic ( connection ) : s [ 'select_field' ] = AreaField ( Area . unit_attname ( geo_field . units_name ( connection ) ) ) else : raise Exception ( 'Area on geodetic coordinate systems not supported.' ) return self . _spatial_attribute ( 'area' , s , ** kwargs ) def centroid ( self , ** kwargs ) : return self . _geom_attribute ( 'centroid' , ** kwargs ) def collect ( self , ** kwargs ) : return self . _spatial_aggregate ( aggregates . Collect , ** kwargs ) def difference ( self , geom , ** kwargs ) : return self . _geomset_attribute ( 'difference' , geom , ** kwargs ) def distance ( self , geom , ** kwargs ) : return self . _distance_attribute ( 'distance' , geom , ** kwargs ) def envelope ( self , ** kwargs ) : return self . _geom_attribute ( 'envelope' , ** kwargs ) def extent ( self , ** kwargs ) : return self . _spatial_aggregate ( aggregates . Extent , ** kwargs ) def extent3d ( self , ** kwargs ) : return self . _spatial_aggregate ( aggregates . Extent3D , ** kwargs ) def force_rhr ( self , ** kwargs ) : return self . _geom_attribute ( 'force_rhr' , ** kwargs ) def geojson ( self , precision = 8 , crs = False , bbox = False , ** kwargs ) : backend = connections [ self . db ] . ops if not backend . geojson : raise NotImplementedError ( 'Only PostGIS 1.3.4+ supports GeoJSON serialization.' ) if not isinstance ( precision , ( int , long ) ) : raise TypeError ( 'Precision keyword must be set with an integer.' ) if backend . spatial_version >= ( 1 , 4 , 0 ) : options = 0 if crs and bbox : options = 3 elif bbox : options = 1 elif crs : options = 2 else : options = 0 if crs and bbox : options = 3 elif crs : options = 1 elif bbox : options = 2 s = { 'desc' : 'GeoJSON' , : { 'precision' : precision , 'options' : options } , : '%(geo_col)s,%(precision)s,%(options)s' , } return self . _spatial_attribute ( 'geojson' , s , ** kwargs ) def geohash ( self , precision = 20 , ** kwargs ) : s = { 'desc' : 'GeoHash' , : { 'precision' : precision } , : '%(geo_col)s,%(precision)s' , } return self . _spatial_attribute ( 'geohash' , s , ** kwargs ) def gml ( self , precision = 8 , version = 2 , ** kwargs ) : backend = connections [ self . db ] . ops s = { 'desc' : 'GML' , 'procedure_args' : { 'precision' : precision } } if backend . postgis : if backend . spatial_version > ( 1 , 3 , 1 ) : procedure_fmt = '%(version)s,%(geo_col)s,%(precision)s' else : procedure_fmt = '%(geo_col)s,%(precision)s,%(version)s' s [ 'procedure_args' ] = { 'precision' : precision , 'version' : version } return self . _spatial_attribute ( 'gml' , s , ** kwargs ) def intersection ( self , geom , ** kwargs ) : return self . _geomset_attribute ( 'intersection' , geom , ** kwargs ) def kml ( self , ** kwargs ) : s = { 'desc' : 'KML' , : '%(geo_col)s,%(precision)s' , : { 'precision' : kwargs . pop ( 'precision' , 8 ) } , } return self . _spatial_attribute ( 'kml' , s , ** kwargs ) def length ( self , ** kwargs ) : return self . _distance_attribute ( 'length' , None , ** kwargs ) def make_line ( self , ** kwargs ) : return self . _spatial_aggregate ( aggregates . MakeLine , geo_field_type = PointField , ** kwargs ) def mem_size ( self , ** kwargs ) : return self . _spatial_attribute ( 'mem_size' , { } , ** kwargs ) def num_geom ( self , ** kwargs ) : return self . _spatial_attribute ( 'num_geom' , { } , ** kwargs ) def num_points ( self , ** kwargs ) : return self . _spatial_attribute ( 'num_points' , { } , ** kwargs ) def perimeter ( self , ** kwargs ) : return self . _distance_attribute ( 'perimeter' , None , ** kwargs ) def point_on_surface ( self , ** kwargs ) : return self . _geom_attribute ( 'point_on_surface' , ** kwargs ) def reverse_geom ( self , ** kwargs ) : s = { 'select_field' : GeomField ( ) , } kwargs . setdefault ( 'model_att' , 'reverse_geom' ) if connections [ self . db ] . ops . oracle : s [ 'geo_field_type' ] = LineStringField return self . _spatial_attribute ( 'reverse' , s , ** kwargs ) def scale ( self , x , y , z = 0.0 , ** kwargs ) : if connections [ self . db ] . ops . spatialite : if z != 0.0 : raise NotImplementedError ( 'SpatiaLite does not support 3D scaling.' ) s = { 'procedure_fmt' : '%(geo_col)s,%(x)s,%(y)s' , : { 'x' : x , 'y' : y } , : GeomField ( ) , } else : s = { 'procedure_fmt' : '%(geo_col)s,%(x)s,%(y)s,%(z)s' , : { 'x' : x , 'y' : y , 'z' : z } , : GeomField ( ) , } return self . _spatial_attribute ( 'scale' , s , ** kwargs ) def snap_to_grid ( self , * args , ** kwargs ) : if False in [ isinstance ( arg , ( float , int , long ) ) for arg in args ] : raise TypeError ( 'Size argument(s) for the grid must be a float or integer values.' ) nargs = len ( args ) if nargs == 1 : size = args [ 0 ] procedure_fmt = '%(geo_col)s,%(size)s' procedure_args = { 'size' : size } elif nargs == 2 : xsize , ysize = args procedure_fmt = '%(geo_col)s,%(xsize)s,%(ysize)s' procedure_args = { 'xsize' : xsize , 'ysize' : ysize } elif nargs == 4 : xsize , ysize , xorigin , yorigin = args procedure_fmt = '%(geo_col)s,%(xorigin)s,%(yorigin)s,%(xsize)s,%(ysize)s' procedure_args = { 'xsize' : xsize , 'ysize' : ysize , : xorigin , 'yorigin' : yorigin } else : raise ValueError ( 'Must provide 1, 2, or 4 arguments to `snap_to_grid`.' ) s = { 'procedure_fmt' : procedure_fmt , : procedure_args , : GeomField ( ) , } return self . _spatial_attribute ( 'snap_to_grid' , s , ** kwargs ) def svg ( self , relative = False , precision = 8 , ** kwargs ) : relative = int ( bool ( relative ) ) if not isinstance ( precision , ( int , long ) ) : raise TypeError ( 'SVG precision keyword argument must be an integer.' ) s = { 'desc' : 'SVG' , : '%(geo_col)s,%(rel)s,%(precision)s' , : { 'rel' : relative , : precision , } } return self . _spatial_attribute ( 'svg' , s , ** kwargs ) def sym_difference ( self , geom , ** kwargs ) : return self . _geomset_attribute ( 'sym_difference' , geom , ** kwargs ) def translate ( self , x , y , z = 0.0 , ** kwargs ) : if connections [ self . db ] . ops . spatialite : if z != 0.0 : raise NotImplementedError ( 'SpatiaLite does not support 3D translation.' ) s = { 'procedure_fmt' : '%(geo_col)s,%(x)s,%(y)s' , : { 'x' : x , 'y' : y } , : GeomField ( ) , } else : s = { 'procedure_fmt' : '%(geo_col)s,%(x)s,%(y)s,%(z)s' , : { 'x' : x , 'y' : y , 'z' : z } , : GeomField ( ) , } return self . _spatial_attribute ( 'translate' , s , ** kwargs ) def transform ( self , srid = 4326 , ** kwargs ) : if not isinstance ( srid , ( int , long ) ) : raise TypeError ( 'An integer SRID must be provided.' ) field_name = kwargs . get ( 'field_name' , None ) tmp , geo_field = self . _spatial_setup ( 'transform' , field_name = field_name ) field_col = self . _geocol_select ( geo_field , field_name ) geo_col = self . query . custom_select . get ( geo_field , field_col ) custom_sel = '%s(%s, %s)' % ( connections [ self . db ] . ops . transform , geo_col , srid ) self . query . transformed_srid = srid self . query . custom_select [ geo_field ] = custom_sel return self . _clone ( ) def union ( self , geom , ** kwargs ) : return self . _geomset_attribute ( 'union' , geom , ** kwargs ) def unionagg ( self , ** kwargs ) : return self . _spatial_aggregate ( aggregates . Union , ** kwargs ) def _spatial_setup ( self , att , desc = None , field_name = None , geo_field_type = None ) : connection = connections [ self . db ] func = getattr ( connection . ops , att , False ) if desc is None : desc = att if not func : raise NotImplementedError ( '%s stored procedure not available on ' % ( desc , connection . ops . name ) ) procedure_args = { 'function' : func } geo_field = self . query . _geo_field ( field_name ) if not geo_field : raise TypeError ( '%s output only available on GeometryFields.' % func ) if not geo_field_type is None and not isinstance ( geo_field , geo_field_type ) : raise TypeError ( '"%s" stored procedures may only be called on %ss.' % ( func , geo_field_type . __name__ ) ) procedure_args [ 'geo_col' ] = self . _geocol_select ( geo_field , field_name ) return procedure_args , geo_field def _spatial_aggregate ( self , aggregate , field_name = None , geo_field_type = None , tolerance = 0.05 ) : geo_field = self . query . _geo_field ( field_name ) if not geo_field : raise TypeError ( '%s aggregate only available on GeometryFields.' % aggregate . name ) if not geo_field_type is None and not isinstance ( geo_field , geo_field_type ) : raise TypeError ( '%s aggregate may only be called on %ss.' % ( aggregate . name , geo_field_type . __name__ ) ) agg_col = field_name or geo_field . name agg_kwargs = { } if connections [ self . db ] . ops . oracle : agg_kwargs [ 'tolerance' ] = tolerance return self . aggregate ( geoagg = aggregate ( agg_col , ** agg_kwargs ) ) [ 'geoagg' ] def _spatial_attribute ( self , att , settings , field_name = None , model_att = None ) : settings . setdefault ( 'desc' , None ) settings . setdefault ( 'geom_args' , ( ) ) settings . setdefault ( 'geom_field' , None ) settings . setdefault ( 'procedure_args' , { } ) settings . setdefault ( 'procedure_fmt' , '%(geo_col)s' ) settings . setdefault ( 'select_params' , [ ] ) connection = connections [ self . db ] backend = connection . ops if settings . get ( 'setup' , True ) : default_args , geo_field = self . _spatial_setup ( att , desc = settings [ 'desc' ] , field_name = field_name , geo_field_type = settings . get ( 'geo_field_type' , None ) ) for k , v in default_args . iteritems ( ) : settings [ 'procedure_args' ] . setdefault ( k , v ) else : geo_field = settings [ 'geo_field' ] if not isinstance ( model_att , basestring ) : model_att = att for name in settings [ 'geom_args' ] : geom = geo_field . get_prep_value ( settings [ 'procedure_args' ] [ name ] ) params = geo_field . get_db_prep_lookup ( 'contains' , geom , connection = connection ) geom_placeholder = geo_field . get_placeholder ( geom , connection ) old_fmt = '%%(%s)s' % name new_fmt = geom_placeholder % '%%s' settings [ 'procedure_fmt' ] = settings [ 'procedure_fmt' ] . replace ( old_fmt , new_fmt ) settings [ 'select_params' ] . extend ( params ) fmt = '%%(function)s(%s)' % settings [ 'procedure_fmt' ] if settings . get ( 'select_field' , False ) : sel_fld = settings [ 'select_field' ] if isinstance ( sel_fld , GeomField ) and backend . select : self . query . custom_select [ model_att ] = backend . select if connection . ops . oracle : sel_fld . empty_strings_allowed = False self . query . extra_select_fields [ model_att ] = sel_fld return self . extra ( select = { model_att : fmt % settings [ 'procedure_args' ] } , select_params = settings [ 'select_params' ] ) def _distance_attribute ( self , func , geom = None , tolerance = 0.05 , spheroid = False , ** kwargs ) : procedure_args , geo_field = self . _spatial_setup ( func , field_name = kwargs . get ( 'field_name' , None ) ) connection = connections [ self . db ] geodetic = geo_field . geodetic ( connection ) geography = geo_field . geography if geodetic : dist_att = 'm' else : dist_att = Distance . unit_attname ( geo_field . units_name ( connection ) ) distance = func == 'distance' length = func == 'length' perimeter = func == 'perimeter' if not ( distance or length or perimeter ) : raise ValueError ( 'Unknown distance function: %s' % func ) geom_3d = geo_field . dim == 3 lookup_params = [ geom or 'POINT (0 0)' , 0 ] backend = connection . ops if spheroid or ( backend . postgis and geodetic and ( not geography ) and length ) : lookup_params . append ( 'spheroid' ) lookup_params = geo_field . get_prep_value ( lookup_params ) params = geo_field . get_db_prep_lookup ( 'distance_lte' , lookup_params , connection = connection ) geom_args = bool ( geom ) if backend . oracle : if distance : procedure_fmt = '%(geo_col)s,%(geom)s,%(tolerance)s' elif length or perimeter : procedure_fmt = '%(geo_col)s,%(tolerance)s' procedure_args [ 'tolerance' ] = tolerance else : if self . query . transformed_srid : u , unit_name , s = get_srid_info ( self . query . transformed_srid , connection ) geodetic = unit_name in geo_field . geodetic_units if backend . spatialite and geodetic : raise ValueError ( 'SQLite does not support linear distance calculations on geodetic coordinate systems.' ) if distance : if self . query . transformed_srid : geom_args = False procedure_fmt = '%s(%%(geo_col)s, %s)' % ( backend . transform , self . query . transformed_srid ) if geom . srid is None or geom . srid == self . query . transformed_srid : if backend . spatialite : procedure_fmt += ', %s(%%%%s, %s)' % ( backend . from_text , self . query . transformed_srid ) else : procedure_fmt += ', %%s' else : if backend . spatialite : procedure_fmt += ', %s(%s(%%%%s, %s), %s)' % ( backend . transform , backend . from_text , geom . srid , self . query . transformed_srid ) else : procedure_fmt += ', %s(%%%%s, %s)' % ( backend . transform , self . query . transformed_srid ) else : procedure_fmt = '%(geo_col)s,%(geom)s' if not geography and geodetic : if not backend . geography : if not isinstance ( geo_field , PointField ) : raise ValueError ( 'Spherical distance calculation only supported on PointFields.' ) if not str ( Geometry ( buffer ( params [ 0 ] . ewkb ) ) . geom_type ) == 'Point' : raise ValueError ( 'Spherical distance calculation only supported with Point Geometry parameters' ) if spheroid : procedure_fmt += ",'%(spheroid)s'" procedure_args . update ( { 'function' : backend . distance_spheroid , 'spheroid' : params [ 1 ] } ) else : procedure_args . update ( { 'function' : backend . distance_sphere } ) elif length or perimeter : procedure_fmt = '%(geo_col)s' if not geography and geodetic and length : procedure_fmt += ",'%(spheroid)s'" procedure_args . update ( { 'function' : backend . length_spheroid , 'spheroid' : params [ 1 ] } ) elif geom_3d and backend . postgis : if perimeter : procedure_args . update ( { 'function' : backend . perimeter3d } ) elif length : procedure_args . update ( { 'function' : backend . length3d } ) s = { 'select_field' : DistanceField ( dist_att ) , : False , : geo_field , : procedure_args , : procedure_fmt , } if geom_args : s [ 'geom_args' ] = ( 'geom' , ) s [ 'procedure_args' ] [ 'geom' ] = geom elif geom : s [ 'select_params' ] = [ backend . Adapter ( geom ) ] return self . _spatial_attribute ( func , s , ** kwargs ) def _geom_attribute ( self , func , tolerance = 0.05 , ** kwargs ) : s = { 'select_field' : GeomField ( ) , } if connections [ self . db ] . ops . oracle : s [ 'procedure_fmt' ] = '%(geo_col)s,%(tolerance)s' s [ 'procedure_args' ] = { 'tolerance' : tolerance } return self . _spatial_attribute ( func , s , ** kwargs ) def _geomset_attribute ( self , func , geom , tolerance = 0.05 , ** kwargs ) : s = { 'geom_args' : ( 'geom' , ) , : GeomField ( ) , : '%(geo_col)s,%(geom)s' , : { 'geom' : geom } , } if connections [ self . db ] . ops . oracle : s [ 'procedure_fmt' ] += ',%(tolerance)s' s [ 'procedure_args' ] [ 'tolerance' ] = tolerance return self . _spatial_attribute ( func , s , ** kwargs ) def _geocol_select ( self , geo_field , field_name ) : opts = self . model . _meta if not geo_field in opts . fields : self . query . add_select_related ( [ field_name ] ) compiler = self . query . get_compiler ( self . db ) compiler . pre_sql_setup ( ) rel_table , rel_col = self . query . related_select_cols [ self . query . related_select_fields . index ( geo_field ) ] return compiler . _field_column ( geo_field , rel_table ) elif not geo_field in opts . local_fields : tmp_fld , parent_model , direct , m2m = opts . get_field_by_name ( geo_field . name ) return self . query . get_compiler ( self . db ) . _field_column ( geo_field , parent_model . _meta . db_table ) else : return self . query . get_compiler ( self . db ) . _field_column ( geo_field ) class GeoValuesQuerySet ( ValuesQuerySet ) : def __init__ ( self , * args , ** kwargs ) : super ( GeoValuesQuerySet , self ) . __init__ ( * args , ** kwargs ) self . query . geo_values = True class GeoValuesListQuerySet ( GeoValuesQuerySet , ValuesListQuerySet ) : pass

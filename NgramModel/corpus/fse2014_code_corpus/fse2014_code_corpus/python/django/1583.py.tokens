from functools import update_wrapper from django . http import Http404 , HttpResponseRedirect from django . contrib . admin import ModelAdmin , actions from django . contrib . admin . forms import AdminAuthenticationForm from django . contrib . auth import REDIRECT_FIELD_NAME from django . contrib . contenttypes import views as contenttype_views from django . views . decorators . csrf import csrf_protect from django . db . models . base import ModelBase from django . core . exceptions import ImproperlyConfigured from django . core . urlresolvers import reverse , NoReverseMatch from django . template . response import TemplateResponse from django . utils . safestring import mark_safe from django . utils . text import capfirst from django . utils . translation import ugettext as _ from django . views . decorators . cache import never_cache from django . conf import settings LOGIN_FORM_KEY = 'this_is_the_login_form' class AlreadyRegistered ( Exception ) : pass class NotRegistered ( Exception ) : pass class AdminSite ( object ) : login_form = None index_template = None app_index_template = None login_template = None logout_template = None password_change_template = None password_change_done_template = None def __init__ ( self , name = 'admin' , app_name = 'admin' ) : self . _registry = { } self . name = name self . app_name = app_name self . _actions = { 'delete_selected' : actions . delete_selected } self . _global_actions = self . _actions . copy ( ) def register ( self , model_or_iterable , admin_class = None , ** options ) : if not admin_class : admin_class = ModelAdmin if admin_class and settings . DEBUG : from django . contrib . admin . validation import validate else : validate = lambda model , adminclass : None if isinstance ( model_or_iterable , ModelBase ) : model_or_iterable = [ model_or_iterable ] for model in model_or_iterable : if model . _meta . abstract : raise ImproperlyConfigured ( 'The model %s is abstract, so it ' % model . __name__ ) if model in self . _registry : raise AlreadyRegistered ( 'The model %s is already registered' % model . __name__ ) if options : options [ '__module__' ] = __name__ admin_class = type ( "%sAdmin" % model . __name__ , ( admin_class , ) , options ) validate ( admin_class , model ) self . _registry [ model ] = admin_class ( model , self ) def unregister ( self , model_or_iterable ) : if isinstance ( model_or_iterable , ModelBase ) : model_or_iterable = [ model_or_iterable ] for model in model_or_iterable : if model not in self . _registry : raise NotRegistered ( 'The model %s is not registered' % model . __name__ ) del self . _registry [ model ] def add_action ( self , action , name = None ) : name = name or action . __name__ self . _actions [ name ] = action self . _global_actions [ name ] = action def disable_action ( self , name ) : del self . _actions [ name ] def get_action ( self , name ) : return self . _global_actions [ name ] @ property def actions ( self ) : return self . _actions . iteritems ( ) def has_permission ( self , request ) : return request . user . is_active and request . user . is_staff def check_dependencies ( self ) : from django . contrib . admin . models import LogEntry from django . contrib . contenttypes . models import ContentType if not LogEntry . _meta . installed : raise ImproperlyConfigured ( "Put 'django.contrib.admin' in your " ) if not ContentType . _meta . installed : raise ImproperlyConfigured ( "Put 'django.contrib.contenttypes' in " ) if not ( 'django.contrib.auth.context_processors.auth' in settings . TEMPLATE_CONTEXT_PROCESSORS or in settings . TEMPLATE_CONTEXT_PROCESSORS ) : raise ImproperlyConfigured ( "Put 'django.contrib.auth.context_processors.auth' " ) def admin_view ( self , view , cacheable = False ) : def inner ( request , * args , ** kwargs ) : if not self . has_permission ( request ) : if request . path == reverse ( 'admin:logout' , current_app = self . name ) : index_path = reverse ( 'admin:index' , current_app = self . name ) return HttpResponseRedirect ( index_path ) return self . login ( request ) return view ( request , * args , ** kwargs ) if not cacheable : inner = never_cache ( inner ) if not getattr ( view , 'csrf_exempt' , False ) : inner = csrf_protect ( inner ) return update_wrapper ( inner , view ) def get_urls ( self ) : from django . conf . urls import patterns , url , include if settings . DEBUG : self . check_dependencies ( ) def wrap ( view , cacheable = False ) : def wrapper ( * args , ** kwargs ) : return self . admin_view ( view , cacheable ) ( * args , ** kwargs ) return update_wrapper ( wrapper , view ) urlpatterns = patterns ( '' , url ( r'^$' , wrap ( self . index ) , name = 'index' ) , url ( r'^logout/$' , wrap ( self . logout ) , name = 'logout' ) , url ( r'^password_change/$' , wrap ( self . password_change , cacheable = True ) , name = 'password_change' ) , url ( r'^password_change/done/$' , wrap ( self . password_change_done , cacheable = True ) , name = 'password_change_done' ) , url ( r'^jsi18n/$' , wrap ( self . i18n_javascript , cacheable = True ) , name = 'jsi18n' ) , url ( r'^r/(?P<content_type_id>\d+)/(?P<object_id>.+)/$' , wrap ( contenttype_views . shortcut ) ) , url ( r'^(?P<app_label>\w+)/$' , wrap ( self . app_index ) , name = 'app_list' ) ) for model , model_admin in self . _registry . iteritems ( ) : urlpatterns += patterns ( '' , url ( r'^%s/%s/' % ( model . _meta . app_label , model . _meta . module_name ) , include ( model_admin . urls ) ) ) return urlpatterns @ property def urls ( self ) : return self . get_urls ( ) , self . app_name , self . name def password_change ( self , request ) : from django . contrib . auth . views import password_change url = reverse ( 'admin:password_change_done' , current_app = self . name ) defaults = { : self . name , : url } if self . password_change_template is not None : defaults [ 'template_name' ] = self . password_change_template return password_change ( request , ** defaults ) def password_change_done ( self , request , extra_context = None ) : from django . contrib . auth . views import password_change_done defaults = { : self . name , : extra_context or { } , } if self . password_change_done_template is not None : defaults [ 'template_name' ] = self . password_change_done_template return password_change_done ( request , ** defaults ) def i18n_javascript ( self , request ) : if settings . USE_I18N : from django . views . i18n import javascript_catalog else : from django . views . i18n import null_javascript_catalog as javascript_catalog return javascript_catalog ( request , packages = [ 'django.conf' , 'django.contrib.admin' ] ) @ never_cache def logout ( self , request , extra_context = None ) : from django . contrib . auth . views import logout defaults = { : self . name , : extra_context or { } , } if self . logout_template is not None : defaults [ 'template_name' ] = self . logout_template return logout ( request , ** defaults ) @ never_cache def login ( self , request , extra_context = None ) : from django . contrib . auth . views import login context = { : _ ( 'Log in' ) , : request . get_full_path ( ) , REDIRECT_FIELD_NAME : request . get_full_path ( ) , } context . update ( extra_context or { } ) defaults = { : context , : self . name , : self . login_form or AdminAuthenticationForm , : self . login_template or 'admin/login.html' , } return login ( request , ** defaults ) @ never_cache def index ( self , request , extra_context = None ) : app_dict = { } user = request . user for model , model_admin in self . _registry . items ( ) : app_label = model . _meta . app_label has_module_perms = user . has_module_perms ( app_label ) if has_module_perms : perms = model_admin . get_model_perms ( request ) if True in perms . values ( ) : info = ( app_label , model . _meta . module_name ) model_dict = { : capfirst ( model . _meta . verbose_name_plural ) , : perms , } if perms . get ( 'change' , False ) : try : model_dict [ 'admin_url' ] = reverse ( 'admin:%s_%s_changelist' % info , current_app = self . name ) except NoReverseMatch : pass if perms . get ( 'add' , False ) : try : model_dict [ 'add_url' ] = reverse ( 'admin:%s_%s_add' % info , current_app = self . name ) except NoReverseMatch : pass if app_label in app_dict : app_dict [ app_label ] [ 'models' ] . append ( model_dict ) else : app_dict [ app_label ] = { : app_label . title ( ) , : reverse ( 'admin:app_list' , kwargs = { 'app_label' : app_label } , current_app = self . name ) , : has_module_perms , : [ model_dict ] , } app_list = app_dict . values ( ) app_list . sort ( key = lambda x : x [ 'name' ] ) for app in app_list : app [ 'models' ] . sort ( key = lambda x : x [ 'name' ] ) context = { : _ ( 'Site administration' ) , : app_list , } context . update ( extra_context or { } ) return TemplateResponse ( request , [ self . index_template or 'admin/index.html' , ] , context , current_app = self . name ) def app_index ( self , request , app_label , extra_context = None ) : user = request . user has_module_perms = user . has_module_perms ( app_label ) app_dict = { } for model , model_admin in self . _registry . items ( ) : if app_label == model . _meta . app_label : if has_module_perms : perms = model_admin . get_model_perms ( request ) if True in perms . values ( ) : info = ( app_label , model . _meta . module_name ) model_dict = { : capfirst ( model . _meta . verbose_name_plural ) , : perms , } if perms . get ( 'change' , False ) : try : model_dict [ 'admin_url' ] = reverse ( 'admin:%s_%s_changelist' % info , current_app = self . name ) except NoReverseMatch : pass if perms . get ( 'add' , False ) : try : model_dict [ 'add_url' ] = reverse ( 'admin:%s_%s_add' % info , current_app = self . name ) except NoReverseMatch : pass if app_dict : app_dict [ 'models' ] . append ( model_dict ) , else : app_dict = { : app_label . title ( ) , : '' , : has_module_perms , : [ model_dict ] , } if not app_dict : raise Http404 ( 'The requested admin page does not exist.' ) app_dict [ 'models' ] . sort ( key = lambda x : x [ 'name' ] ) context = { : _ ( '%s administration' ) % capfirst ( app_label ) , : [ app_dict ] , } context . update ( extra_context or { } ) return TemplateResponse ( request , self . app_index_template or [ % app_label , ] , context , current_app = self . name ) site = AdminSite ( )

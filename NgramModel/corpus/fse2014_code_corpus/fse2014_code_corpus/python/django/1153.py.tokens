import os import re from django . conf import settings from django . core . management . base import CommandError from django . db import models from django . db . models import get_models def sql_create ( app , style , connection ) : if connection . settings_dict [ 'ENGINE' ] == 'django.db.backends.dummy' : raise CommandError ( "Django doesn't know which syntax to use for your SQL statements,\n" + + + ) app_models = models . get_models ( app , include_auto_created = True ) final_output = [ ] tables = connection . introspection . table_names ( ) known_models = set ( [ model for model in connection . introspection . installed_models ( tables ) if model not in app_models ] ) pending_references = { } for model in app_models : output , references = connection . creation . sql_create_model ( model , style , known_models ) final_output . extend ( output ) for refto , refs in references . items ( ) : pending_references . setdefault ( refto , [ ] ) . extend ( refs ) if refto in known_models : final_output . extend ( connection . creation . sql_for_pending_references ( refto , style , pending_references ) ) final_output . extend ( connection . creation . sql_for_pending_references ( model , style , pending_references ) ) known_models . add ( model ) not_installed_models = set ( pending_references . keys ( ) ) if not_installed_models : alter_sql = [ ] for model in not_installed_models : alter_sql . extend ( [ '-- ' + sql for sql in connection . creation . sql_for_pending_references ( model , style , pending_references ) ] ) if alter_sql : final_output . append ( '-- The following references should be added but depend on non-existent tables:' ) final_output . extend ( alter_sql ) return final_output def sql_delete ( app , style , connection ) : try : cursor = connection . cursor ( ) except : cursor = None if cursor : table_names = connection . introspection . get_table_list ( cursor ) else : table_names = [ ] output = [ ] to_delete = set ( ) references_to_delete = { } app_models = models . get_models ( app , include_auto_created = True ) for model in app_models : if cursor and connection . introspection . table_name_converter ( model . _meta . db_table ) in table_names : opts = model . _meta for f in opts . local_fields : if f . rel and f . rel . to not in to_delete : references_to_delete . setdefault ( f . rel . to , [ ] ) . append ( ( model , f ) ) to_delete . add ( model ) for model in app_models : if connection . introspection . table_name_converter ( model . _meta . db_table ) in table_names : output . extend ( connection . creation . sql_destroy_model ( model , references_to_delete , style ) ) if cursor : cursor . close ( ) connection . close ( ) return output [ : : - 1 ] def sql_reset ( app , style , connection ) : import warnings warnings . warn ( , DeprecationWarning ) return sql_delete ( app , style , connection ) + sql_all ( app , style , connection ) def sql_flush ( style , connection , only_django = False ) : if only_django : tables = connection . introspection . django_table_names ( only_existing = True ) else : tables = connection . introspection . table_names ( ) statements = connection . ops . sql_flush ( style , tables , connection . introspection . sequence_list ( ) ) return statements def sql_custom ( app , style , connection ) : output = [ ] app_models = get_models ( app ) for model in app_models : output . extend ( custom_sql_for_model ( model , style , connection ) ) return output def sql_indexes ( app , style , connection ) : output = [ ] for model in models . get_models ( app ) : output . extend ( connection . creation . sql_indexes_for_model ( model , style ) ) return output def sql_all ( app , style , connection ) : return sql_create ( app , style , connection ) + sql_custom ( app , style , connection ) + sql_indexes ( app , style , connection ) def custom_sql_for_model ( model , style , connection ) : opts = model . _meta app_dir = os . path . normpath ( os . path . join ( os . path . dirname ( models . get_app ( model . _meta . app_label ) . __file__ ) , 'sql' ) ) output = [ ] if opts . managed : post_sql_fields = [ f for f in opts . local_fields if hasattr ( f , 'post_create_sql' ) ] for f in post_sql_fields : output . extend ( f . post_create_sql ( style , model . _meta . db_table ) ) statements = re . compile ( r";[ \t]*$" , re . M ) backend_name = connection . settings_dict [ 'ENGINE' ] . split ( '.' ) [ - 1 ] sql_files = [ os . path . join ( app_dir , "%s.%s.sql" % ( opts . object_name . lower ( ) , backend_name ) ) , os . path . join ( app_dir , "%s.sql" % opts . object_name . lower ( ) ) ] for sql_file in sql_files : if os . path . exists ( sql_file ) : fp = open ( sql_file , 'U' ) for statement in statements . split ( fp . read ( ) . decode ( settings . FILE_CHARSET ) ) : statement = re . sub ( ur"--.*([\n\Z]|$)" , "" , statement ) if statement . strip ( ) : output . append ( statement + u";" ) fp . close ( ) return output def emit_post_sync_signal ( created_models , verbosity , interactive , db ) : for app in models . get_apps ( ) : app_name = app . __name__ . split ( '.' ) [ - 2 ] if verbosity >= 2 : print "Running post-sync handlers for application" , app_name models . signals . post_syncdb . send ( sender = app , app = app , created_models = created_models , verbosity = verbosity , interactive = interactive , db = db )

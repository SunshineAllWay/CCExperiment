import sickbeard from sickbeard . common import countryList from sickbeard . helpers import sanitizeSceneName from sickbeard . scene_exceptions import get_scene_exceptions from sickbeard import logger from sickbeard import db import re import datetime from name_parser . parser import NameParser , InvalidNameException resultFilters = [ "sub(pack|s|bed)" , "nlsub(bed|s)?" , "swesub(bed)?" , , "sample" , "(dvd)?extras" , ] def filterBadReleases ( name ) : try : fp = NameParser ( ) parse_result = fp . parse ( name ) except InvalidNameException : logger . log ( u"Unable to parse the filename " + name + " into a valid episode" , logger . WARNING ) return False check_string = '' if parse_result . extra_info : check_string = parse_result . extra_info if parse_result . release_group : if check_string : check_string = check_string + '-' + parse_result . release_group else : check_string = parse_result . release_group if not check_string : return True for x in resultFilters + sickbeard . IGNORE_WORDS . split ( ',' ) : if re . search ( '(^|[\W_])' + x + '($|[\W_])' , check_string , re . I ) : logger . log ( u"Invalid scene release: " + name + " contains " + x + ", ignoring it" , logger . DEBUG ) return False return True def sceneToNormalShowNames ( name ) : if not name : return [ ] name_list = [ name ] new_name = re . sub ( '(?i)([\. ])and([\. ])' , '\\1&\\2' , name , re . I ) if new_name not in name_list : name_list . append ( new_name ) results = [ ] for cur_name in name_list : results . append ( re . sub ( '(\D)(\d{4})$' , '\\1(\\2)' , cur_name ) ) country_match_str = '|' . join ( countryList . values ( ) ) results . append ( re . sub ( '(?i)([. _-])(' + country_match_str + ')$' , '\\1(\\2)' , cur_name ) ) results += name_list return list ( set ( results ) ) def makeSceneShowSearchStrings ( show ) : showNames = allPossibleShowNames ( show ) return map ( sanitizeSceneName , showNames ) def makeSceneSeasonSearchString ( show , segment , extraSearchType = None ) : myDB = db . DBConnection ( ) if show . air_by_date : numseasons = 0 seasonStrings = [ segment ] else : numseasonsSQlResult = myDB . select ( "SELECT COUNT(DISTINCT season) as numseasons FROM tv_episodes WHERE showid = ? and season != 0" , [ show . tvdbid ] ) numseasons = int ( numseasonsSQlResult [ 0 ] [ 0 ] ) seasonStrings = [ "S%02d" % segment ] if extraSearchType == "nzbmatrix" : seasonStrings . append ( "%ix" % segment ) showNames = set ( makeSceneShowSearchStrings ( show ) ) toReturn = [ ] term_list = [ ] for curShow in showNames : if not extraSearchType : if numseasons == 1 : toReturn . append ( curShow ) else : for cur_season in seasonStrings : toReturn . append ( curShow + "." + cur_season ) elif extraSearchType == "nzbmatrix" : if numseasons == 1 : toReturn . append ( '"' + curShow + '"' ) elif numseasons == 0 : toReturn . append ( '"' + curShow + ' ' + str ( segment ) . replace ( '-' , ' ' ) + '"' ) else : term_list = [ x + '*' for x in seasonStrings ] if show . air_by_date : term_list = [ '"' + x + '"' for x in term_list ] toReturn . append ( '"' + curShow + '"' ) if extraSearchType == "nzbmatrix" : toReturn = [ '+(' + ',' . join ( toReturn ) + ')' ] if term_list : toReturn . append ( '+(' + ',' . join ( term_list ) + ')' ) return toReturn def makeSceneSearchString ( episode ) : myDB = db . DBConnection ( ) numseasonsSQlResult = myDB . select ( "SELECT COUNT(DISTINCT season) as numseasons FROM tv_episodes WHERE showid = ? and season != 0" , [ episode . show . tvdbid ] ) numseasons = int ( numseasonsSQlResult [ 0 ] [ 0 ] ) if episode . show . air_by_date and episode . airdate != datetime . date . fromordinal ( 1 ) : epStrings = [ str ( episode . airdate ) ] else : epStrings = [ "S%02iE%02i" % ( int ( episode . season ) , int ( episode . episode ) ) , % ( int ( episode . season ) , int ( episode . episode ) ) ] if numseasons == 1 : epStrings = [ '' ] showNames = set ( makeSceneShowSearchStrings ( episode . show ) ) toReturn = [ ] for curShow in showNames : for curEpString in epStrings : toReturn . append ( curShow + '.' + curEpString ) return toReturn def isGoodResult ( name , show , log = True ) : all_show_names = allPossibleShowNames ( show ) showNames = map ( sanitizeSceneName , all_show_names ) + all_show_names for curName in set ( showNames ) : escaped_name = re . sub ( '\\\\[\\s.-]' , '\W+' , re . escape ( curName ) ) curRegex = '^' + escaped_name + '\W+(?:(?:S\d[\dE._ -])|(?:\d\d?x)|(?:\d{4}\W\d\d\W\d\d)|(?:(?:part|pt)[\._ -]?(\d|[ivx]))|Season\W+\d+\W+|E\d+\W+)' if log : logger . log ( u"Checking if show " + name + " matches " + curRegex , logger . DEBUG ) match = re . search ( curRegex , name , re . I ) if match : logger . log ( u"Matched " + curRegex + " to " + name , logger . DEBUG ) return True if log : logger . log ( u"Provider gave result " + name + " but that doesn't seem like a valid result for " + show . name + " so I'm ignoring it" ) return False def allPossibleShowNames ( show ) : showNames = [ show . name ] showNames += [ name for name in get_scene_exceptions ( show . tvdbid ) ] if show . tvrname != "" and show . tvrname != None : showNames . append ( show . tvrname ) newShowNames = [ ] country_list = countryList country_list . update ( dict ( zip ( countryList . values ( ) , countryList . keys ( ) ) ) ) for curName in set ( showNames ) : if not curName : continue for curCountry in country_list : if curName . endswith ( ' ' + curCountry ) : newShowNames . append ( curName . replace ( ' ' + curCountry , ' (' + country_list [ curCountry ] + ')' ) ) elif curName . endswith ( ' (' + curCountry + ')' ) : newShowNames . append ( curName . replace ( ' (' + curCountry + ')' , ' (' + country_list [ curCountry ] + ')' ) ) showNames += newShowNames return showNames

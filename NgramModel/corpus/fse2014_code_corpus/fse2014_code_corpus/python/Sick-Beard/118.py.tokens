""" httpauth modules defines functions to implement HTTP Digest Authentication (RFC 2617). This has full compliance with 'Digest' and 'Basic' authentication methods. In 'Digest' it supports both MD5 and MD5-sess algorithms. Usage: First use 'doAuth' to request the client authentication for a certain resource. You should send an httplib.UNAUTHORIZED response to the client so he knows he has to authenticate itself. Then use 'parseAuthorization' to retrieve the 'auth_map' used in 'checkResponse'. To use 'checkResponse' you must have already verified the password associated with the 'username' key in 'auth_map' dict. Then you use the 'checkResponse' function to verify if the password matches the one sent by the client. SUPPORTED_ALGORITHM - list of supported 'Digest' algorithms SUPPORTED_QOP - list of supported 'Digest' 'qop'. """ __version__ = 1 , 0 , 1 __author__ = "Tiago Cogumbreiro <cogumbreiro@users.sf.net>" __credits__ = """ Peter van Kampen for its recipe which implement most of Digest authentication: http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/302378 """ __license__ = """ Copyright (c) 2005, Tiago Cogumbreiro <cogumbreiro@users.sf.net> All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Sylvain Hellegouarch nor the names of his contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. """ __all__ = ( "digestAuth" , "basicAuth" , "doAuth" , "checkResponse" , , "SUPPORTED_ALGORITHM" , "md5SessionKey" , , "SUPPORTED_QOP" ) try : from hashlib import md5 except ImportError : from md5 import new as md5 import time import base64 from urllib2 import parse_http_list , parse_keqv_list MD5 = "MD5" MD5_SESS = "MD5-sess" AUTH = "auth" AUTH_INT = "auth-int" SUPPORTED_ALGORITHM = ( MD5 , MD5_SESS ) SUPPORTED_QOP = ( AUTH , AUTH_INT ) DIGEST_AUTH_ENCODERS = { MD5 : lambda val : md5 ( val ) . hexdigest ( ) , MD5_SESS : lambda val : md5 ( val ) . hexdigest ( ) , } def calculateNonce ( realm , algorithm = MD5 ) : global SUPPORTED_ALGORITHM , DIGEST_AUTH_ENCODERS assert algorithm in SUPPORTED_ALGORITHM try : encoder = DIGEST_AUTH_ENCODERS [ algorithm ] except KeyError : raise NotImplementedError ( "The chosen algorithm (%s) does not have " "an implementation yet" % algorithm ) return encoder ( "%d:%s" % ( time . time ( ) , realm ) ) def digestAuth ( realm , algorithm = MD5 , nonce = None , qop = AUTH ) : global SUPPORTED_ALGORITHM , DIGEST_AUTH_ENCODERS , SUPPORTED_QOP assert algorithm in SUPPORTED_ALGORITHM assert qop in SUPPORTED_QOP if nonce is None : nonce = calculateNonce ( realm , algorithm ) return 'Digest realm="%s", nonce="%s", algorithm="%s", qop="%s"' % ( realm , nonce , algorithm , qop ) def basicAuth ( realm ) : assert '"' not in realm , "Realms cannot contain the \" (quote) character." return 'Basic realm="%s"' % realm def doAuth ( realm ) : return digestAuth ( realm ) + " " + basicAuth ( realm ) def _parseDigestAuthorization ( auth_params ) : items = parse_http_list ( auth_params ) params = parse_keqv_list ( items ) required = [ "username" , "realm" , "nonce" , "uri" , "response" ] for k in required : if k not in params : return None if "qop" in params and not ( "cnonce" in params and "nc" in params ) : return None if ( "cnonce" in params or "nc" in params ) and "qop" not in params : return None return params def _parseBasicAuthorization ( auth_params ) : username , password = base64 . decodestring ( auth_params ) . split ( ":" , 1 ) return { "username" : username , "password" : password } AUTH_SCHEMES = { : _parseBasicAuthorization , : _parseDigestAuthorization , } def parseAuthorization ( credentials ) : global AUTH_SCHEMES auth_scheme , auth_params = credentials . split ( " " , 1 ) auth_scheme = auth_scheme . lower ( ) parser = AUTH_SCHEMES [ auth_scheme ] params = parser ( auth_params ) if params is None : return assert "auth_scheme" not in params params [ "auth_scheme" ] = auth_scheme return params def md5SessionKey ( params , password ) : keys = ( "username" , "realm" , "nonce" , "cnonce" ) params_copy = { } for key in keys : params_copy [ key ] = params [ key ] params_copy [ "algorithm" ] = MD5_SESS return _A1 ( params_copy , password ) def _A1 ( params , password ) : algorithm = params . get ( "algorithm" , MD5 ) H = DIGEST_AUTH_ENCODERS [ algorithm ] if algorithm == MD5 : return "%s:%s:%s" % ( params [ "username" ] , params [ "realm" ] , password ) elif algorithm == MD5_SESS : h_a1 = H ( "%s:%s:%s" % ( params [ "username" ] , params [ "realm" ] , password ) ) return "%s:%s:%s" % ( h_a1 , params [ "nonce" ] , params [ "cnonce" ] ) def _A2 ( params , method , kwargs ) : qop = params . get ( "qop" , "auth" ) if qop == "auth" : return method + ":" + params [ "uri" ] elif qop == "auth-int" : entity_body = kwargs . get ( "entity_body" , "" ) H = kwargs [ "H" ] return "%s:%s:%s" % ( method , params [ "uri" ] , H ( entity_body ) ) else : raise NotImplementedError ( "The 'qop' method is unknown: %s" % qop ) def _computeDigestResponse ( auth_map , password , method = "GET" , A1 = None , ** kwargs ) : params = auth_map algorithm = params . get ( "algorithm" , MD5 ) H = DIGEST_AUTH_ENCODERS [ algorithm ] KD = lambda secret , data : H ( secret + ":" + data ) qop = params . get ( "qop" , None ) H_A2 = H ( _A2 ( params , method , kwargs ) ) if algorithm == MD5_SESS and A1 is not None : H_A1 = H ( A1 ) else : H_A1 = H ( _A1 ( params , password ) ) if qop in ( "auth" , "auth-int" ) : request = "%s:%s:%s:%s:%s" % ( params [ "nonce" ] , params [ "nc" ] , params [ "cnonce" ] , params [ "qop" ] , H_A2 , ) elif qop is None : request = "%s:%s" % ( params [ "nonce" ] , H_A2 ) return KD ( H_A1 , request ) def _checkDigestResponse ( auth_map , password , method = "GET" , A1 = None , ** kwargs ) : if auth_map [ 'realm' ] != kwargs . get ( 'realm' , None ) : return False response = _computeDigestResponse ( auth_map , password , method , A1 , ** kwargs ) return response == auth_map [ "response" ] def _checkBasicResponse ( auth_map , password , method = 'GET' , encrypt = None , ** kwargs ) : try : return encrypt ( auth_map [ "password" ] , auth_map [ "username" ] ) == password except TypeError : return encrypt ( auth_map [ "password" ] ) == password AUTH_RESPONSES = { : _checkBasicResponse , : _checkDigestResponse , } def checkResponse ( auth_map , password , method = "GET" , encrypt = None , ** kwargs ) : global AUTH_RESPONSES checker = AUTH_RESPONSES [ auth_map [ "auth_scheme" ] ] return checker ( auth_map , password , method = method , encrypt = encrypt , ** kwargs )

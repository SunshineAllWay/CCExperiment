from lib . hachoir_core . i18n import _ , ngettext import re import stat from datetime import datetime , timedelta , MAXYEAR from warnings import warn def deprecated ( comment = None ) : def _deprecated ( func ) : def newFunc ( * args , ** kwargs ) : message = "Call to deprecated function %s" % func . __name__ if comment : message += ": " + comment warn ( message , category = DeprecationWarning , stacklevel = 2 ) return func ( * args , ** kwargs ) newFunc . __name__ = func . __name__ newFunc . __doc__ = func . __doc__ newFunc . __dict__ . update ( func . __dict__ ) return newFunc return _deprecated def paddingSize ( value , align ) : if value % align != 0 : return align - ( value % align ) else : return 0 def alignValue ( value , align ) : if value % align != 0 : return value + align - ( value % align ) else : return value def timedelta2seconds ( delta ) : return delta . microseconds / 1000000.0 + delta . seconds + delta . days * 60 * 60 * 24 def humanDurationNanosec ( nsec ) : if nsec < 1000 : return u"%u nsec" % nsec usec , nsec = divmod ( nsec , 1000 ) if usec < 1000 : return u"%.2f usec" % ( usec + float ( nsec ) / 1000 ) msec , usec = divmod ( usec , 1000 ) if msec < 1000 : return u"%.2f ms" % ( msec + float ( usec ) / 1000 ) return humanDuration ( msec ) def humanDuration ( delta ) : if not isinstance ( delta , timedelta ) : delta = timedelta ( microseconds = delta * 1000 ) text = [ ] if 1000 <= delta . microseconds : text . append ( u"%u ms" % ( delta . microseconds // 1000 ) ) minutes , seconds = divmod ( delta . seconds , 60 ) hours , minutes = divmod ( minutes , 60 ) if seconds : text . append ( u"%u sec" % seconds ) if minutes : text . append ( u"%u min" % minutes ) if hours : text . append ( ngettext ( "%u hour" , "%u hours" , hours ) % hours ) years , days = divmod ( delta . days , 365 ) if days : text . append ( ngettext ( "%u day" , "%u days" , days ) % days ) if years : text . append ( ngettext ( "%u year" , "%u years" , years ) % years ) if 3 < len ( text ) : text = text [ - 3 : ] elif not text : return u"0 ms" return u" " . join ( reversed ( text ) ) def humanFilesize ( size ) : if size < 10000 : return ngettext ( "%u byte" , "%u bytes" , size ) % size units = [ _ ( "KB" ) , _ ( "MB" ) , _ ( "GB" ) , _ ( "TB" ) ] size = float ( size ) divisor = 1024 for unit in units : size = size / divisor if size < divisor : return "%.1f %s" % ( size , unit ) return "%u %s" % ( size , unit ) def humanBitSize ( size ) : divisor = 1000 if size < divisor : return ngettext ( "%u bit" , "%u bits" , size ) % size units = [ u"Kbit" , u"Mbit" , u"Gbit" , u"Tbit" ] size = float ( size ) for unit in units : size = size / divisor if size < divisor : return "%.1f %s" % ( size , unit ) return u"%u %s" % ( size , unit ) def humanBitRate ( size ) : return "" . join ( ( humanBitSize ( size ) , "/sec" ) ) def humanFrequency ( hertz ) : divisor = 1000 if hertz < divisor : return u"%u Hz" % hertz units = [ u"kHz" , u"MHz" , u"GHz" , u"THz" ] hertz = float ( hertz ) for unit in units : hertz = hertz / divisor if hertz < divisor : return u"%.1f %s" % ( hertz , unit ) return u"%s %s" % ( hertz , unit ) regex_control_code = re . compile ( r"([\x00-\x1f\x7f])" ) controlchars = tuple ( { ord ( "\n" ) : r"\n" , ord ( "\r" ) : r"\r" , ord ( "\t" ) : r"\t" , ord ( "\a" ) : r"\a" , ord ( "\b" ) : r"\b" , } . get ( code , '\\x%02x' % code ) for code in xrange ( 128 ) ) def makePrintable ( data , charset , quote = None , to_unicode = False , smart = True ) : if data : if not isinstance ( data , unicode ) : data = unicode ( data , "ISO-8859-1" ) charset = "ASCII" data = regex_control_code . sub ( lambda regs : controlchars [ ord ( regs . group ( 1 ) ) ] , data ) if quote : if quote in "\"'" : data = data . replace ( quote , '\\' + quote ) data = '' . join ( ( quote , data , quote ) ) elif quote : data = "(empty)" data = data . encode ( charset , "backslashreplace" ) if smart : data = re . sub ( r"\\x0([0-7])(?=[^0-7]|$)" , r"\\\1" , data ) if to_unicode : data = unicode ( data , charset ) return data def makeUnicode ( text ) : if isinstance ( text , str ) : text = unicode ( text , "ISO-8859-1" ) elif not isinstance ( text , unicode ) : text = unicode ( text ) text = regex_control_code . sub ( lambda regs : controlchars [ ord ( regs . group ( 1 ) ) ] , text ) text = re . sub ( r"\\x0([0-7])(?=[^0-7]|$)" , r"\\\1" , text ) return text def binarySearch ( seq , cmp_func ) : lower = 0 upper = len ( seq ) while lower < upper : index = ( lower + upper ) >> 1 diff = cmp_func ( seq [ index ] ) if diff < 0 : upper = index elif diff > 0 : lower = index + 1 else : return index return None def lowerBound ( seq , cmp_func ) : f = 0 l = len ( seq ) while l > 0 : h = l >> 1 m = f + h if cmp_func ( seq [ m ] ) : f = m f += 1 l -= h + 1 else : l = h return f def humanUnixAttributes ( mode ) : def ftypelet ( mode ) : if stat . S_ISREG ( mode ) or not stat . S_IFMT ( mode ) : return '-' if stat . S_ISBLK ( mode ) : return 'b' if stat . S_ISCHR ( mode ) : return 'c' if stat . S_ISDIR ( mode ) : return 'd' if stat . S_ISFIFO ( mode ) : return 'p' if stat . S_ISLNK ( mode ) : return 'l' if stat . S_ISSOCK ( mode ) : return 's' return '?' chars = [ ftypelet ( mode ) , 'r' , 'w' , 'x' , 'r' , 'w' , 'x' , 'r' , 'w' , 'x' ] for i in xrange ( 1 , 10 ) : if not mode & 1 << 9 - i : chars [ i ] = '-' if mode & stat . S_ISUID : if chars [ 3 ] != 'x' : chars [ 3 ] = 'S' else : chars [ 3 ] = 's' if mode & stat . S_ISGID : if chars [ 6 ] != 'x' : chars [ 6 ] = 'S' else : chars [ 6 ] = 's' if mode & stat . S_ISVTX : if chars [ 9 ] != 'x' : chars [ 9 ] = 'T' else : chars [ 9 ] = 't' return u"%s (%o)" % ( '' . join ( chars ) , mode ) def createDict ( data , index ) : return dict ( ( key , values [ index ] ) for key , values in data . iteritems ( ) ) UNIX_TIMESTAMP_T0 = datetime ( 1970 , 1 , 1 ) def timestampUNIX ( value ) : if not isinstance ( value , ( float , int , long ) ) : raise TypeError ( "timestampUNIX(): an integer or float is required" ) if not ( 0 <= value <= 2147483647 ) : raise ValueError ( "timestampUNIX(): value have to be in 0..2147483647" ) return UNIX_TIMESTAMP_T0 + timedelta ( seconds = value ) MAC_TIMESTAMP_T0 = datetime ( 1904 , 1 , 1 ) def timestampMac32 ( value ) : if not isinstance ( value , ( float , int , long ) ) : raise TypeError ( "an integer or float is required" ) if not ( 0 <= value <= 4294967295 ) : return _ ( "invalid Mac timestamp (%s)" ) % value return MAC_TIMESTAMP_T0 + timedelta ( seconds = value ) def durationWin64 ( value ) : if not isinstance ( value , ( float , int , long ) ) : raise TypeError ( "an integer or float is required" ) if value < 0 : raise ValueError ( "value have to be a positive or nul integer" ) return timedelta ( microseconds = value / 10 ) WIN64_TIMESTAMP_T0 = datetime ( 1601 , 1 , 1 , 0 , 0 , 0 ) def timestampWin64 ( value ) : try : return WIN64_TIMESTAMP_T0 + durationWin64 ( value ) except OverflowError : raise ValueError ( _ ( "date newer than year %s (value=%s)" ) % ( MAXYEAR , value ) ) UUID60_TIMESTAMP_T0 = datetime ( 1582 , 10 , 15 , 0 , 0 , 0 ) def timestampUUID60 ( value ) : if not isinstance ( value , ( float , int , long ) ) : raise TypeError ( "an integer or float is required" ) if value < 0 : raise ValueError ( "value have to be a positive or nul integer" ) try : return UUID60_TIMESTAMP_T0 + timedelta ( microseconds = value / 10 ) except OverflowError : raise ValueError ( _ ( "timestampUUID60() overflow (value=%s)" ) % value ) def humanDatetime ( value , strip_microsecond = True ) : text = unicode ( value . isoformat ( ) ) text = text . replace ( 'T' , ' ' ) if strip_microsecond and "." in text : text = text . split ( "." ) [ 0 ] return text NEWLINES_REGEX = re . compile ( "\n+" ) def normalizeNewline ( text ) : text = text . replace ( "\r\n" , "\n" ) text = text . replace ( "\r" , "\n" ) return NEWLINES_REGEX . sub ( "\n" , text )

import datetime import os import sys import re import urllib2 import sickbeard from sickbeard import helpers , classes , logger , db from sickbeard . common import Quality , MULTI_EP_RESULT , SEASON_RESULT from sickbeard import tvcache from sickbeard import encodingKludge as ek from sickbeard . exceptions import ex from lib . hachoir_parser import createParser from sickbeard . name_parser . parser import NameParser , InvalidNameException class GenericProvider : NZB = "nzb" TORRENT = "torrent" def __init__ ( self , name ) : self . providerType = None self . name = name self . url = '' self . supportsBacklog = False self . cache = tvcache . TVCache ( self ) def getID ( self ) : return GenericProvider . makeID ( self . name ) @ staticmethod def makeID ( name ) : return re . sub ( "[^\w\d_]" , "_" , name ) . lower ( ) def imageName ( self ) : return self . getID ( ) + '.gif' def _checkAuth ( self ) : return def isActive ( self ) : if self . providerType == GenericProvider . NZB and sickbeard . USE_NZBS : return self . isEnabled ( ) elif self . providerType == GenericProvider . TORRENT and sickbeard . USE_TORRENTS : return self . isEnabled ( ) else : return False def isEnabled ( self ) : return False def getResult ( self , episodes ) : if self . providerType == GenericProvider . NZB : result = classes . NZBSearchResult ( episodes ) elif self . providerType == GenericProvider . TORRENT : result = classes . TorrentSearchResult ( episodes ) else : result = classes . SearchResult ( episodes ) result . provider = self return result def getURL ( self , url , headers = None ) : if not headers : headers = [ ] result = None try : result = helpers . getURL ( url , headers ) except ( urllib2 . HTTPError , IOError ) , e : logger . log ( u"Error loading " + self . name + " URL: " + str ( sys . exc_info ( ) ) + " - " + ex ( e ) , logger . ERROR ) return None return result def downloadResult ( self , result ) : logger . log ( u"Downloading a result from " + self . name + " at " + result . url ) data = self . getURL ( result . url ) if data == None : return False if self . providerType == GenericProvider . NZB : saveDir = sickbeard . NZB_DIR writeMode = 'w' elif self . providerType == GenericProvider . TORRENT : saveDir = sickbeard . TORRENT_DIR writeMode = 'wb' else : return False fileName = ek . ek ( os . path . join , saveDir , helpers . sanitizeFileName ( result . name ) + '.' + self . providerType ) logger . log ( u"Saving to " + fileName , logger . DEBUG ) try : fileOut = open ( fileName , writeMode ) fileOut . write ( data ) fileOut . close ( ) helpers . chmodAsParent ( fileName ) except IOError , e : logger . log ( "Unable to save the file: " + ex ( e ) , logger . ERROR ) return False return self . _verify_download ( fileName ) def _verify_download ( self , file_name = None ) : if self . providerType == GenericProvider . TORRENT : parser = createParser ( file_name ) if parser : mime_type = parser . _getMimeType ( ) try : parser . stream . _input . close ( ) except : pass if mime_type != 'application/x-bittorrent' : logger . log ( u"Result is not a valid torrent file" , logger . WARNING ) return False return True def searchRSS ( self ) : self . cache . updateCache ( ) return self . cache . findNeededEpisodes ( ) def getQuality ( self , item ) : title = item . findtext ( 'title' ) quality = Quality . nameQuality ( title ) return quality def _doSearch ( self ) : return [ ] def _get_season_search_strings ( self , show , season , episode = None ) : return [ ] def _get_episode_search_strings ( self , ep_obj ) : return [ ] def _get_title_and_url ( self , item ) : title = item . findtext ( 'title' ) url = item . findtext ( 'link' ) if url : url = url . replace ( '&amp;' , '&' ) return ( title , url ) def findEpisode ( self , episode , manualSearch = False ) : self . _checkAuth ( ) logger . log ( u"Searching " + self . name + " for " + episode . prettyName ( True ) ) self . cache . updateCache ( ) results = self . cache . searchCache ( episode , manualSearch ) logger . log ( u"Cache results: " + str ( results ) , logger . DEBUG ) if results or not manualSearch : return results itemList = [ ] for cur_search_string in self . _get_episode_search_strings ( episode ) : itemList += self . _doSearch ( cur_search_string , show = episode . show ) for item in itemList : ( title , url ) = self . _get_title_and_url ( item ) try : myParser = NameParser ( ) parse_result = myParser . parse ( title ) except InvalidNameException : logger . log ( u"Unable to parse the filename " + title + " into a valid episode" , logger . WARNING ) continue if episode . show . air_by_date : if parse_result . air_date != episode . airdate : logger . log ( "Episode " + title + " didn't air on " + str ( episode . airdate ) + ", skipping it" , logger . DEBUG ) continue elif parse_result . season_number != episode . season or episode . episode not in parse_result . episode_numbers : logger . log ( "Episode " + title + " isn't " + str ( episode . season ) + "x" + str ( episode . episode ) + ", skipping it" , logger . DEBUG ) continue quality = self . getQuality ( item ) if not episode . show . wantEpisode ( episode . season , episode . episode , quality , manualSearch ) : logger . log ( u"Ignoring result " + title + " because we don't want an episode that is " + Quality . qualityStrings [ quality ] , logger . DEBUG ) continue logger . log ( u"Found result " + title + " at " + url , logger . DEBUG ) result = self . getResult ( [ episode ] ) result . url = url result . name = title result . quality = quality results . append ( result ) return results def findSeasonResults ( self , show , season ) : itemList = [ ] results = { } for curString in self . _get_season_search_strings ( show , season ) : itemList += self . _doSearch ( curString ) for item in itemList : ( title , url ) = self . _get_title_and_url ( item ) quality = self . getQuality ( item ) try : myParser = NameParser ( False ) parse_result = myParser . parse ( title ) except InvalidNameException : logger . log ( u"Unable to parse the filename " + title + " into a valid episode" , logger . WARNING ) continue if not show . air_by_date : if ( parse_result . season_number != None and parse_result . season_number != season ) or ( parse_result . season_number == None and season != 1 ) : logger . log ( u"The result " + title + " doesn't seem to be a valid episode for season " + str ( season ) + ", ignoring" ) continue actual_season = season actual_episodes = parse_result . episode_numbers else : if not parse_result . air_by_date : logger . log ( u"This is supposed to be an air-by-date search but the result " + title + " didn't parse as one, skipping it" , logger . DEBUG ) continue myDB = db . DBConnection ( ) sql_results = myDB . select ( "SELECT season, episode FROM tv_episodes WHERE showid = ? AND airdate = ?" , [ show . tvdbid , parse_result . air_date . toordinal ( ) ] ) if len ( sql_results ) != 1 : logger . log ( u"Tried to look up the date for the episode " + title + " but the database didn't give proper results, skipping it" , logger . WARNING ) continue actual_season = int ( sql_results [ 0 ] [ "season" ] ) actual_episodes = [ int ( sql_results [ 0 ] [ "episode" ] ) ] wantEp = True for epNo in actual_episodes : if not show . wantEpisode ( actual_season , epNo , quality ) : wantEp = False break if not wantEp : logger . log ( u"Ignoring result " + title + " because we don't want an episode that is " + Quality . qualityStrings [ quality ] , logger . DEBUG ) continue logger . log ( u"Found result " + title + " at " + url , logger . DEBUG ) epObj = [ ] for curEp in actual_episodes : epObj . append ( show . getEpisode ( actual_season , curEp ) ) result = self . getResult ( epObj ) result . url = url result . name = title result . quality = quality if len ( epObj ) == 1 : epNum = epObj [ 0 ] . episode elif len ( epObj ) > 1 : epNum = MULTI_EP_RESULT logger . log ( u"Separating multi-episode result to check for later - result contains episodes: " + str ( parse_result . episode_numbers ) , logger . DEBUG ) elif len ( epObj ) == 0 : epNum = SEASON_RESULT result . extraInfo = [ show ] logger . log ( u"Separating full season result to check for later" , logger . DEBUG ) if epNum in results : results [ epNum ] . append ( result ) else : results [ epNum ] = [ result ] return results def findPropers ( self , date = None ) : results = self . cache . listPropers ( date ) return [ classes . Proper ( x [ 'name' ] , x [ 'url' ] , datetime . datetime . fromtimestamp ( x [ 'time' ] ) ) for x in results ] class NZBProvider ( GenericProvider ) : def __init__ ( self , name ) : GenericProvider . __init__ ( self , name ) self . providerType = GenericProvider . NZB class TorrentProvider ( GenericProvider ) : def __init__ ( self , name ) : GenericProvider . __init__ ( self , name ) self . providerType = GenericProvider . TORRENT

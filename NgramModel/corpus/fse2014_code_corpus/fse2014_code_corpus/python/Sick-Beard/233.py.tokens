__author__ = 'python-twitter@googlegroups.com' __version__ = '0.8-devel' import base64 import calendar import datetime import httplib import os import rfc822 import sys import tempfile import textwrap import time import urllib import urllib2 import urlparse import gzip import StringIO try : import json as simplejson except ImportError : try : import lib . simplejson as simplejson except ImportError : try : from django . utils import simplejson except ImportError : raise ImportError , "Unable to load a json library" try : from urlparse import parse_qsl , parse_qs except ImportError : from cgi import parse_qsl , parse_qs try : from hashlib import md5 except ImportError : from md5 import md5 import lib . oauth2 as oauth CHARACTER_LIMIT = 140 DEFAULT_CACHE = object ( ) REQUEST_TOKEN_URL = 'https://api.twitter.com/oauth/request_token' ACCESS_TOKEN_URL = 'https://api.twitter.com/oauth/access_token' AUTHORIZATION_URL = 'https://api.twitter.com/oauth/authorize' SIGNIN_URL = 'https://api.twitter.com/oauth/authenticate' class TwitterError ( Exception ) : @ property def message ( self ) : return self . args [ 0 ] class Status ( object ) : def __init__ ( self , created_at = None , favorited = None , id = None , text = None , location = None , user = None , in_reply_to_screen_name = None , in_reply_to_user_id = None , in_reply_to_status_id = None , truncated = None , source = None , now = None ) : self . created_at = created_at self . favorited = favorited self . id = id self . text = text self . location = location self . user = user self . now = now self . in_reply_to_screen_name = in_reply_to_screen_name self . in_reply_to_user_id = in_reply_to_user_id self . in_reply_to_status_id = in_reply_to_status_id self . truncated = truncated self . source = source def GetCreatedAt ( self ) : return self . _created_at def SetCreatedAt ( self , created_at ) : self . _created_at = created_at created_at = property ( GetCreatedAt , SetCreatedAt , doc = 'The time this status message was posted.' ) def GetCreatedAtInSeconds ( self ) : return calendar . timegm ( rfc822 . parsedate ( self . created_at ) ) created_at_in_seconds = property ( GetCreatedAtInSeconds , doc = "The time this status message was " ) def GetFavorited ( self ) : return self . _favorited def SetFavorited ( self , favorited ) : self . _favorited = favorited favorited = property ( GetFavorited , SetFavorited , doc = 'The favorited state of this status message.' ) def GetId ( self ) : return self . _id def SetId ( self , id ) : self . _id = id id = property ( GetId , SetId , doc = 'The unique id of this status message.' ) def GetInReplyToScreenName ( self ) : return self . _in_reply_to_screen_name def SetInReplyToScreenName ( self , in_reply_to_screen_name ) : self . _in_reply_to_screen_name = in_reply_to_screen_name in_reply_to_screen_name = property ( GetInReplyToScreenName , SetInReplyToScreenName , doc = '' ) def GetInReplyToUserId ( self ) : return self . _in_reply_to_user_id def SetInReplyToUserId ( self , in_reply_to_user_id ) : self . _in_reply_to_user_id = in_reply_to_user_id in_reply_to_user_id = property ( GetInReplyToUserId , SetInReplyToUserId , doc = '' ) def GetInReplyToStatusId ( self ) : return self . _in_reply_to_status_id def SetInReplyToStatusId ( self , in_reply_to_status_id ) : self . _in_reply_to_status_id = in_reply_to_status_id in_reply_to_status_id = property ( GetInReplyToStatusId , SetInReplyToStatusId , doc = '' ) def GetTruncated ( self ) : return self . _truncated def SetTruncated ( self , truncated ) : self . _truncated = truncated truncated = property ( GetTruncated , SetTruncated , doc = '' ) def GetSource ( self ) : return self . _source def SetSource ( self , source ) : self . _source = source source = property ( GetSource , SetSource , doc = '' ) def GetText ( self ) : return self . _text def SetText ( self , text ) : self . _text = text text = property ( GetText , SetText , doc = 'The text of this status message' ) def GetLocation ( self ) : return self . _location def SetLocation ( self , location ) : self . _location = location location = property ( GetLocation , SetLocation , doc = 'The geolocation string of this status message' ) def GetRelativeCreatedAt ( self ) : fudge = 1.25 delta = long ( self . now ) - long ( self . created_at_in_seconds ) if delta < ( 1 * fudge ) : return 'about a second ago' elif delta < ( 60 * ( 1 / fudge ) ) : return 'about %d seconds ago' % ( delta ) elif delta < ( 60 * fudge ) : return 'about a minute ago' elif delta < ( 60 * 60 * ( 1 / fudge ) ) : return 'about %d minutes ago' % ( delta / 60 ) elif delta < ( 60 * 60 * fudge ) or delta / ( 60 * 60 ) == 1 : return 'about an hour ago' elif delta < ( 60 * 60 * 24 * ( 1 / fudge ) ) : return 'about %d hours ago' % ( delta / ( 60 * 60 ) ) elif delta < ( 60 * 60 * 24 * fudge ) or delta / ( 60 * 60 * 24 ) == 1 : return 'about a day ago' else : return 'about %d days ago' % ( delta / ( 60 * 60 * 24 ) ) relative_created_at = property ( GetRelativeCreatedAt , doc = 'Get a human readable string representing' ) def GetUser ( self ) : return self . _user def SetUser ( self , user ) : self . _user = user user = property ( GetUser , SetUser , doc = 'A twitter.User reprenting the entity posting this ' ) def GetNow ( self ) : if self . _now is None : self . _now = time . time ( ) return self . _now def SetNow ( self , now ) : self . _now = now now = property ( GetNow , SetNow , doc = 'The wallclock time for this status instance.' ) def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __eq__ ( self , other ) : try : return other and self . created_at == other . created_at and self . id == other . id and self . text == other . text and self . location == other . location and self . user == other . user and self . in_reply_to_screen_name == other . in_reply_to_screen_name and self . in_reply_to_user_id == other . in_reply_to_user_id and self . in_reply_to_status_id == other . in_reply_to_status_id and self . truncated == other . truncated and self . favorited == other . favorited and self . source == other . source except AttributeError : return False def __str__ ( self ) : return self . AsJsonString ( ) def AsJsonString ( self ) : return simplejson . dumps ( self . AsDict ( ) , sort_keys = True ) def AsDict ( self ) : data = { } if self . created_at : data [ 'created_at' ] = self . created_at if self . favorited : data [ 'favorited' ] = self . favorited if self . id : data [ 'id' ] = self . id if self . text : data [ 'text' ] = self . text if self . location : data [ 'location' ] = self . location if self . user : data [ 'user' ] = self . user . AsDict ( ) if self . in_reply_to_screen_name : data [ 'in_reply_to_screen_name' ] = self . in_reply_to_screen_name if self . in_reply_to_user_id : data [ 'in_reply_to_user_id' ] = self . in_reply_to_user_id if self . in_reply_to_status_id : data [ 'in_reply_to_status_id' ] = self . in_reply_to_status_id if self . truncated is not None : data [ 'truncated' ] = self . truncated if self . favorited is not None : data [ 'favorited' ] = self . favorited if self . source : data [ 'source' ] = self . source return data @ staticmethod def NewFromJsonDict ( data ) : if 'user' in data : user = User . NewFromJsonDict ( data [ 'user' ] ) else : user = None return Status ( created_at = data . get ( 'created_at' , None ) , favorited = data . get ( 'favorited' , None ) , id = data . get ( 'id' , None ) , text = data . get ( 'text' , None ) , location = data . get ( 'location' , None ) , in_reply_to_screen_name = data . get ( 'in_reply_to_screen_name' , None ) , in_reply_to_user_id = data . get ( 'in_reply_to_user_id' , None ) , in_reply_to_status_id = data . get ( 'in_reply_to_status_id' , None ) , truncated = data . get ( 'truncated' , None ) , source = data . get ( 'source' , None ) , user = user ) class User ( object ) : def __init__ ( self , id = None , name = None , screen_name = None , location = None , description = None , profile_image_url = None , profile_background_tile = None , profile_background_image_url = None , profile_sidebar_fill_color = None , profile_background_color = None , profile_link_color = None , profile_text_color = None , protected = None , utc_offset = None , time_zone = None , followers_count = None , friends_count = None , statuses_count = None , favourites_count = None , url = None , status = None ) : self . id = id self . name = name self . screen_name = screen_name self . location = location self . description = description self . profile_image_url = profile_image_url self . profile_background_tile = profile_background_tile self . profile_background_image_url = profile_background_image_url self . profile_sidebar_fill_color = profile_sidebar_fill_color self . profile_background_color = profile_background_color self . profile_link_color = profile_link_color self . profile_text_color = profile_text_color self . protected = protected self . utc_offset = utc_offset self . time_zone = time_zone self . followers_count = followers_count self . friends_count = friends_count self . statuses_count = statuses_count self . favourites_count = favourites_count self . url = url self . status = status def GetId ( self ) : return self . _id def SetId ( self , id ) : self . _id = id id = property ( GetId , SetId , doc = 'The unique id of this user.' ) def GetName ( self ) : return self . _name def SetName ( self , name ) : self . _name = name name = property ( GetName , SetName , doc = 'The real name of this user.' ) def GetScreenName ( self ) : return self . _screen_name def SetScreenName ( self , screen_name ) : self . _screen_name = screen_name screen_name = property ( GetScreenName , SetScreenName , doc = 'The short username of this user.' ) def GetLocation ( self ) : return self . _location def SetLocation ( self , location ) : self . _location = location location = property ( GetLocation , SetLocation , doc = 'The geographic location of this user.' ) def GetDescription ( self ) : return self . _description def SetDescription ( self , description ) : self . _description = description description = property ( GetDescription , SetDescription , doc = 'The short text description of this user.' ) def GetUrl ( self ) : return self . _url def SetUrl ( self , url ) : self . _url = url url = property ( GetUrl , SetUrl , doc = 'The homepage url of this user.' ) def GetProfileImageUrl ( self ) : return self . _profile_image_url def SetProfileImageUrl ( self , profile_image_url ) : self . _profile_image_url = profile_image_url profile_image_url = property ( GetProfileImageUrl , SetProfileImageUrl , doc = 'The url of the thumbnail of this user.' ) def GetProfileBackgroundTile ( self ) : return self . _profile_background_tile def SetProfileBackgroundTile ( self , profile_background_tile ) : self . _profile_background_tile = profile_background_tile profile_background_tile = property ( GetProfileBackgroundTile , SetProfileBackgroundTile , doc = 'Boolean for whether to tile the background image.' ) def GetProfileBackgroundImageUrl ( self ) : return self . _profile_background_image_url def SetProfileBackgroundImageUrl ( self , profile_background_image_url ) : self . _profile_background_image_url = profile_background_image_url profile_background_image_url = property ( GetProfileBackgroundImageUrl , SetProfileBackgroundImageUrl , doc = 'The url of the profile background of this user.' ) def GetProfileSidebarFillColor ( self ) : return self . _profile_sidebar_fill_color def SetProfileSidebarFillColor ( self , profile_sidebar_fill_color ) : self . _profile_sidebar_fill_color = profile_sidebar_fill_color profile_sidebar_fill_color = property ( GetProfileSidebarFillColor , SetProfileSidebarFillColor ) def GetProfileBackgroundColor ( self ) : return self . _profile_background_color def SetProfileBackgroundColor ( self , profile_background_color ) : self . _profile_background_color = profile_background_color profile_background_color = property ( GetProfileBackgroundColor , SetProfileBackgroundColor ) def GetProfileLinkColor ( self ) : return self . _profile_link_color def SetProfileLinkColor ( self , profile_link_color ) : self . _profile_link_color = profile_link_color profile_link_color = property ( GetProfileLinkColor , SetProfileLinkColor ) def GetProfileTextColor ( self ) : return self . _profile_text_color def SetProfileTextColor ( self , profile_text_color ) : self . _profile_text_color = profile_text_color profile_text_color = property ( GetProfileTextColor , SetProfileTextColor ) def GetProtected ( self ) : return self . _protected def SetProtected ( self , protected ) : self . _protected = protected protected = property ( GetProtected , SetProtected ) def GetUtcOffset ( self ) : return self . _utc_offset def SetUtcOffset ( self , utc_offset ) : self . _utc_offset = utc_offset utc_offset = property ( GetUtcOffset , SetUtcOffset ) def GetTimeZone ( self ) : return self . _time_zone def SetTimeZone ( self , time_zone ) : self . _time_zone = time_zone time_zone = property ( GetTimeZone , SetTimeZone ) def GetStatus ( self ) : return self . _status def SetStatus ( self , status ) : self . _status = status status = property ( GetStatus , SetStatus , doc = 'The latest twitter.Status of this user.' ) def GetFriendsCount ( self ) : return self . _friends_count def SetFriendsCount ( self , count ) : self . _friends_count = count friends_count = property ( GetFriendsCount , SetFriendsCount , doc = 'The number of friends for this user.' ) def GetFollowersCount ( self ) : return self . _followers_count def SetFollowersCount ( self , count ) : self . _followers_count = count followers_count = property ( GetFollowersCount , SetFollowersCount , doc = 'The number of users following this user.' ) def GetStatusesCount ( self ) : return self . _statuses_count def SetStatusesCount ( self , count ) : self . _statuses_count = count statuses_count = property ( GetStatusesCount , SetStatusesCount , doc = 'The number of updates for this user.' ) def GetFavouritesCount ( self ) : return self . _favourites_count def SetFavouritesCount ( self , count ) : self . _favourites_count = count favourites_count = property ( GetFavouritesCount , SetFavouritesCount , doc = 'The number of favourites for this user.' ) def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __eq__ ( self , other ) : try : return other and self . id == other . id and self . name == other . name and self . screen_name == other . screen_name and self . location == other . location and self . description == other . description and self . profile_image_url == other . profile_image_url and self . profile_background_tile == other . profile_background_tile and self . profile_background_image_url == other . profile_background_image_url and self . profile_sidebar_fill_color == other . profile_sidebar_fill_color and self . profile_background_color == other . profile_background_color and self . profile_link_color == other . profile_link_color and self . profile_text_color == other . profile_text_color and self . protected == other . protected and self . utc_offset == other . utc_offset and self . time_zone == other . time_zone and self . url == other . url and self . statuses_count == other . statuses_count and self . followers_count == other . followers_count and self . favourites_count == other . favourites_count and self . friends_count == other . friends_count and self . status == other . status except AttributeError : return False def __str__ ( self ) : return self . AsJsonString ( ) def AsJsonString ( self ) : return simplejson . dumps ( self . AsDict ( ) , sort_keys = True ) def AsDict ( self ) : data = { } if self . id : data [ 'id' ] = self . id if self . name : data [ 'name' ] = self . name if self . screen_name : data [ 'screen_name' ] = self . screen_name if self . location : data [ 'location' ] = self . location if self . description : data [ 'description' ] = self . description if self . profile_image_url : data [ 'profile_image_url' ] = self . profile_image_url if self . profile_background_tile is not None : data [ 'profile_background_tile' ] = self . profile_background_tile if self . profile_background_image_url : data [ 'profile_sidebar_fill_color' ] = self . profile_background_image_url if self . profile_background_color : data [ 'profile_background_color' ] = self . profile_background_color if self . profile_link_color : data [ 'profile_link_color' ] = self . profile_link_color if self . profile_text_color : data [ 'profile_text_color' ] = self . profile_text_color if self . protected is not None : data [ 'protected' ] = self . protected if self . utc_offset : data [ 'utc_offset' ] = self . utc_offset if self . time_zone : data [ 'time_zone' ] = self . time_zone if self . url : data [ 'url' ] = self . url if self . status : data [ 'status' ] = self . status . AsDict ( ) if self . friends_count : data [ 'friends_count' ] = self . friends_count if self . followers_count : data [ 'followers_count' ] = self . followers_count if self . statuses_count : data [ 'statuses_count' ] = self . statuses_count if self . favourites_count : data [ 'favourites_count' ] = self . favourites_count return data @ staticmethod def NewFromJsonDict ( data ) : if 'status' in data : status = Status . NewFromJsonDict ( data [ 'status' ] ) else : status = None return User ( id = data . get ( 'id' , None ) , name = data . get ( 'name' , None ) , screen_name = data . get ( 'screen_name' , None ) , location = data . get ( 'location' , None ) , description = data . get ( 'description' , None ) , statuses_count = data . get ( 'statuses_count' , None ) , followers_count = data . get ( 'followers_count' , None ) , favourites_count = data . get ( 'favourites_count' , None ) , friends_count = data . get ( 'friends_count' , None ) , profile_image_url = data . get ( 'profile_image_url' , None ) , profile_background_tile = data . get ( 'profile_background_tile' , None ) , profile_background_image_url = data . get ( 'profile_background_image_url' , None ) , profile_sidebar_fill_color = data . get ( 'profile_sidebar_fill_color' , None ) , profile_background_color = data . get ( 'profile_background_color' , None ) , profile_link_color = data . get ( 'profile_link_color' , None ) , profile_text_color = data . get ( 'profile_text_color' , None ) , protected = data . get ( 'protected' , None ) , utc_offset = data . get ( 'utc_offset' , None ) , time_zone = data . get ( 'time_zone' , None ) , url = data . get ( 'url' , None ) , status = status ) class List ( object ) : def __init__ ( self , id = None , name = None , slug = None , description = None , full_name = None , mode = None , uri = None , member_count = None , subscriber_count = None , following = None , user = None ) : self . id = id self . name = name self . slug = slug self . description = description self . full_name = full_name self . mode = mode self . uri = uri self . member_count = member_count self . subscriber_count = subscriber_count self . following = following self . user = user def GetId ( self ) : return self . _id def SetId ( self , id ) : self . _id = id id = property ( GetId , SetId , doc = 'The unique id of this list.' ) def GetName ( self ) : return self . _name def SetName ( self , name ) : self . _name = name name = property ( GetName , SetName , doc = 'The real name of this list.' ) def GetSlug ( self ) : return self . _slug def SetSlug ( self , slug ) : self . _slug = slug slug = property ( GetSlug , SetSlug , doc = 'The slug of this list.' ) def GetDescription ( self ) : return self . _description def SetDescription ( self , description ) : self . _description = description description = property ( GetDescription , SetDescription , doc = 'The description of this list.' ) def GetFull_name ( self ) : return self . _full_name def SetFull_name ( self , full_name ) : self . _full_name = full_name full_name = property ( GetFull_name , SetFull_name , doc = 'The full_name of this list.' ) def GetMode ( self ) : return self . _mode def SetMode ( self , mode ) : self . _mode = mode mode = property ( GetMode , SetMode , doc = 'The mode of this list.' ) def GetUri ( self ) : return self . _uri def SetUri ( self , uri ) : self . _uri = uri uri = property ( GetUri , SetUri , doc = 'The uri of this list.' ) def GetMember_count ( self ) : return self . _member_count def SetMember_count ( self , member_count ) : self . _member_count = member_count member_count = property ( GetMember_count , SetMember_count , doc = 'The member_count of this list.' ) def GetSubscriber_count ( self ) : return self . _subscriber_count def SetSubscriber_count ( self , subscriber_count ) : self . _subscriber_count = subscriber_count subscriber_count = property ( GetSubscriber_count , SetSubscriber_count , doc = 'The subscriber_count of this list.' ) def GetFollowing ( self ) : return self . _following def SetFollowing ( self , following ) : self . _following = following following = property ( GetFollowing , SetFollowing , doc = 'The following status of this list.' ) def GetUser ( self ) : return self . _user def SetUser ( self , user ) : self . _user = user user = property ( GetUser , SetUser , doc = 'The owner of this list.' ) def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __eq__ ( self , other ) : try : return other and self . id == other . id and self . name == other . name and self . slug == other . slug and self . description == other . description and self . full_name == other . full_name and self . mode == other . mode and self . uri == other . uri and self . member_count == other . member_count and self . subscriber_count == other . subscriber_count and self . following == other . following and self . user == other . user except AttributeError : return False def __str__ ( self ) : return self . AsJsonString ( ) def AsJsonString ( self ) : return simplejson . dumps ( self . AsDict ( ) , sort_keys = True ) def AsDict ( self ) : data = { } if self . id : data [ 'id' ] = self . id if self . name : data [ 'name' ] = self . name if self . slug : data [ 'slug' ] = self . slug if self . description : data [ 'description' ] = self . description if self . full_name : data [ 'full_name' ] = self . full_name if self . mode : data [ 'mode' ] = self . mode if self . uri : data [ 'uri' ] = self . uri if self . member_count is not None : data [ 'member_count' ] = self . member_count if self . subscriber_count is not None : data [ 'subscriber_count' ] = self . subscriber_count if self . following is not None : data [ 'following' ] = self . following if self . user is not None : data [ 'user' ] = self . user return data @ staticmethod def NewFromJsonDict ( data ) : if 'user' in data : user = User . NewFromJsonDict ( data [ 'user' ] ) else : user = None return List ( id = data . get ( 'id' , None ) , name = data . get ( 'name' , None ) , slug = data . get ( 'slug' , None ) , description = data . get ( 'description' , None ) , full_name = data . get ( 'full_name' , None ) , mode = data . get ( 'mode' , None ) , uri = data . get ( 'uri' , None ) , member_count = data . get ( 'member_count' , None ) , subscriber_count = data . get ( 'subscriber_count' , None ) , following = data . get ( 'following' , None ) , user = user ) class DirectMessage ( object ) : def __init__ ( self , id = None , created_at = None , sender_id = None , sender_screen_name = None , recipient_id = None , recipient_screen_name = None , text = None ) : self . id = id self . created_at = created_at self . sender_id = sender_id self . sender_screen_name = sender_screen_name self . recipient_id = recipient_id self . recipient_screen_name = recipient_screen_name self . text = text def GetId ( self ) : return self . _id def SetId ( self , id ) : self . _id = id id = property ( GetId , SetId , doc = 'The unique id of this direct message.' ) def GetCreatedAt ( self ) : return self . _created_at def SetCreatedAt ( self , created_at ) : self . _created_at = created_at created_at = property ( GetCreatedAt , SetCreatedAt , doc = 'The time this direct message was posted.' ) def GetCreatedAtInSeconds ( self ) : return calendar . timegm ( rfc822 . parsedate ( self . created_at ) ) created_at_in_seconds = property ( GetCreatedAtInSeconds , doc = "The time this direct message was " ) def GetSenderId ( self ) : return self . _sender_id def SetSenderId ( self , sender_id ) : self . _sender_id = sender_id sender_id = property ( GetSenderId , SetSenderId , doc = 'The unique sender id of this direct message.' ) def GetSenderScreenName ( self ) : return self . _sender_screen_name def SetSenderScreenName ( self , sender_screen_name ) : self . _sender_screen_name = sender_screen_name sender_screen_name = property ( GetSenderScreenName , SetSenderScreenName , doc = 'The unique sender screen name of this direct message.' ) def GetRecipientId ( self ) : return self . _recipient_id def SetRecipientId ( self , recipient_id ) : self . _recipient_id = recipient_id recipient_id = property ( GetRecipientId , SetRecipientId , doc = 'The unique recipient id of this direct message.' ) def GetRecipientScreenName ( self ) : return self . _recipient_screen_name def SetRecipientScreenName ( self , recipient_screen_name ) : self . _recipient_screen_name = recipient_screen_name recipient_screen_name = property ( GetRecipientScreenName , SetRecipientScreenName , doc = 'The unique recipient screen name of this direct message.' ) def GetText ( self ) : return self . _text def SetText ( self , text ) : self . _text = text text = property ( GetText , SetText , doc = 'The text of this direct message' ) def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __eq__ ( self , other ) : try : return other and self . id == other . id and self . created_at == other . created_at and self . sender_id == other . sender_id and self . sender_screen_name == other . sender_screen_name and self . recipient_id == other . recipient_id and self . recipient_screen_name == other . recipient_screen_name and self . text == other . text except AttributeError : return False def __str__ ( self ) : return self . AsJsonString ( ) def AsJsonString ( self ) : return simplejson . dumps ( self . AsDict ( ) , sort_keys = True ) def AsDict ( self ) : data = { } if self . id : data [ 'id' ] = self . id if self . created_at : data [ 'created_at' ] = self . created_at if self . sender_id : data [ 'sender_id' ] = self . sender_id if self . sender_screen_name : data [ 'sender_screen_name' ] = self . sender_screen_name if self . recipient_id : data [ 'recipient_id' ] = self . recipient_id if self . recipient_screen_name : data [ 'recipient_screen_name' ] = self . recipient_screen_name if self . text : data [ 'text' ] = self . text return data @ staticmethod def NewFromJsonDict ( data ) : return DirectMessage ( created_at = data . get ( 'created_at' , None ) , recipient_id = data . get ( 'recipient_id' , None ) , sender_id = data . get ( 'sender_id' , None ) , text = data . get ( 'text' , None ) , sender_screen_name = data . get ( 'sender_screen_name' , None ) , id = data . get ( 'id' , None ) , recipient_screen_name = data . get ( 'recipient_screen_name' , None ) ) class Api ( object ) : DEFAULT_CACHE_TIMEOUT = 60 _API_REALM = 'Twitter API' def __init__ ( self , username = None , password = None , access_token_key = None , access_token_secret = None , input_encoding = None , request_headers = None , cache = DEFAULT_CACHE , shortner = None , base_url = None , use_gzip_compression = False ) : self . SetCache ( cache ) self . _urllib = urllib2 self . _cache_timeout = Api . DEFAULT_CACHE_TIMEOUT self . _input_encoding = input_encoding self . _use_gzip = use_gzip_compression self . _oauth_consumer = None self . _InitializeRequestHeaders ( request_headers ) self . _InitializeUserAgent ( ) self . _InitializeDefaultParameters ( ) if base_url is None : self . base_url = 'https://api.twitter.com/1' else : self . base_url = base_url if username is not None and ( access_token_key is None or access_token_secret is None ) : print >> sys . stderr , 'Twitter now requires an oAuth Access Token for API calls.' print >> sys . stderr , 'If your using this library from a command line utility, please' print >> sys . stderr , 'run the the included get_access_token.py tool to generate one.' raise TwitterError ( 'Twitter requires oAuth Access Token for all API access' ) self . SetCredentials ( username , password , access_token_key , access_token_secret ) def SetCredentials ( self , username , password , access_token_key = None , access_token_secret = None ) : self . _username = username self . _password = password self . _access_token_key = access_token_key self . _access_token_secret = access_token_secret self . _oauth_consumer = None if username is not None and password is not None and access_token_key is not None and access_token_secret is not None : self . _signature_method_plaintext = oauth . SignatureMethod_PLAINTEXT ( ) self . _signature_method_hmac_sha1 = oauth . SignatureMethod_HMAC_SHA1 ( ) self . _oauth_token = oauth . Token ( key = access_token_key , secret = access_token_secret ) self . _oauth_consumer = oauth . Consumer ( key = username , secret = password ) def ClearCredentials ( self ) : self . _username = None self . _password = None self . _access_token_key = None self . _access_token_secret = None self . _oauth_consumer = None def GetPublicTimeline ( self , since_id = None ) : parameters = { } if since_id : parameters [ 'since_id' ] = since_id url = '%s/statuses/public_timeline.json' % self . base_url json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ Status . NewFromJsonDict ( x ) for x in data ] def FilterPublicTimeline ( self , term , since_id = None ) : statuses = self . GetPublicTimeline ( since_id ) results = [ ] for s in statuses : if s . text . lower ( ) . find ( term . lower ( ) ) != - 1 : results . append ( s ) return results def GetSearch ( self , term , geocode = None , since_id = None , per_page = 15 , page = 1 , lang = "en" , show_user = "true" , query_users = False ) : parameters = { } if since_id : parameters [ 'since_id' ] = since_id if not term : return [ ] parameters [ 'q' ] = urllib . quote_plus ( term ) parameters [ 'show_user' ] = show_user parameters [ 'lang' ] = lang parameters [ 'rpp' ] = per_page parameters [ 'page' ] = page if geocode is not None : parameters [ 'geocode' ] = ',' . join ( map ( str , geocode ) ) url = 'http://search.twitter.com/search.json' json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) results = [ ] for x in data [ 'results' ] : temp = Status . NewFromJsonDict ( x ) if query_users : temp . user = self . GetUser ( urllib . quote ( x [ 'from_user' ] ) ) else : temp . user = User ( screen_name = x [ 'from_user' ] , profile_image_url = x [ 'profile_image_url' ] ) results . append ( temp ) return results def GetFriendsTimeline ( self , user = None , count = None , since = None , since_id = None , retweets = False ) : if not user and not self . _oauth_consumer : raise TwitterError ( "User must be specified if API is not authenticated." ) url = '%s/statuses' % self . base_url if retweets : src = 'home_timeline' else : src = 'friends_timeline' if user : url = '%s/%s/%s.json' % ( url , src , user ) else : url = '%s/%s.json' % ( url , src ) parameters = { } if count is not None : try : if int ( count ) > 200 : raise TwitterError ( "'count' may not be greater than 200" ) except ValueError : raise TwitterError ( "'count' must be an integer" ) parameters [ 'count' ] = count if since : parameters [ 'since' ] = since if since_id : parameters [ 'since_id' ] = since_id json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ Status . NewFromJsonDict ( x ) for x in data ] def GetUserTimeline ( self , id = None , user_id = None , screen_name = None , since_id = None , max_id = None , count = None , page = None ) : parameters = { } if id : url = '%s/statuses/user_timeline/%s.json' % ( self . base_url , id ) elif user_id : url = '%s/statuses/user_timeline.json?user_id=%d' % ( self . base_url , user_id ) elif screen_name : url = ( '%s/statuses/user_timeline.json?screen_name=%s' % ( self . base_url , screen_name ) ) elif not self . _oauth_consumer : raise TwitterError ( "User must be specified if API is not authenticated." ) else : url = '%s/statuses/user_timeline.json' % self . base_url if since_id : try : parameters [ 'since_id' ] = long ( since_id ) except : raise TwitterError ( "since_id must be an integer" ) if max_id : try : parameters [ 'max_id' ] = long ( max_id ) except : raise TwitterError ( "max_id must be an integer" ) if count : try : parameters [ 'count' ] = int ( count ) except : raise TwitterError ( "count must be an integer" ) if page : try : parameters [ 'page' ] = int ( page ) except : raise TwitterError ( "page must be an integer" ) json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ Status . NewFromJsonDict ( x ) for x in data ] def GetStatus ( self , id ) : try : if id : long ( id ) except : raise TwitterError ( "id must be an long integer" ) url = '%s/statuses/show/%s.json' % ( self . base_url , id ) json = self . _FetchUrl ( url ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return Status . NewFromJsonDict ( data ) def DestroyStatus ( self , id ) : try : if id : long ( id ) except : raise TwitterError ( "id must be an integer" ) url = '%s/statuses/destroy/%s.json' % ( self . base_url , id ) json = self . _FetchUrl ( url , post_data = { 'id' : id } ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return Status . NewFromJsonDict ( data ) def PostUpdate ( self , status , in_reply_to_status_id = None ) : if not self . _oauth_consumer : raise TwitterError ( "The twitter.Api instance must be authenticated." ) url = '%s/statuses/update.json' % self . base_url if isinstance ( status , unicode ) or self . _input_encoding is None : u_status = status else : u_status = unicode ( status , self . _input_encoding ) if len ( u_status ) > CHARACTER_LIMIT : raise TwitterError ( "Text must be less than or equal to %d characters. " % CHARACTER_LIMIT ) data = { 'status' : status } if in_reply_to_status_id : data [ 'in_reply_to_status_id' ] = in_reply_to_status_id json = self . _FetchUrl ( url , post_data = data ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return Status . NewFromJsonDict ( data ) def PostUpdates ( self , status , continuation = None , ** kwargs ) : results = list ( ) if continuation is None : continuation = '' line_length = CHARACTER_LIMIT - len ( continuation ) lines = textwrap . wrap ( status , line_length ) for line in lines [ 0 : - 1 ] : results . append ( self . PostUpdate ( line + continuation , ** kwargs ) ) results . append ( self . PostUpdate ( lines [ - 1 ] , ** kwargs ) ) return results def GetReplies ( self , since = None , since_id = None , page = None ) : url = '%s/statuses/replies.json' % self . base_url if not self . _oauth_consumer : raise TwitterError ( "The twitter.Api instance must be authenticated." ) parameters = { } if since : parameters [ 'since' ] = since if since_id : parameters [ 'since_id' ] = since_id if page : parameters [ 'page' ] = page json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ Status . NewFromJsonDict ( x ) for x in data ] def GetFriends ( self , user = None , cursor = - 1 ) : if not user and not self . _oauth_consumer : raise TwitterError ( "twitter.Api instance must be authenticated" ) if user : url = '%s/statuses/friends/%s.json' % ( self . base_url , user ) else : url = '%s/statuses/friends.json' % self . base_url parameters = { } parameters [ 'cursor' ] = cursor json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ User . NewFromJsonDict ( x ) for x in data [ 'users' ] ] def GetFriendIDs ( self , user = None , cursor = - 1 ) : if not user and not self . _oauth_consumer : raise TwitterError ( "twitter.Api instance must be authenticated" ) if user : url = '%s/friends/ids/%s.json' % ( self . base_url , user ) else : url = '%s/friends/ids.json' % self . base_url parameters = { } parameters [ 'cursor' ] = cursor json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return data def GetFollowerIDs ( self , userid = None , cursor = - 1 ) : url = 'http://twitter.com/followers/ids.json' parameters = { } parameters [ 'cursor' ] = cursor if userid : parameters [ 'user_id' ] = userid json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return data def GetFollowers ( self , page = None ) : if not self . _oauth_consumer : raise TwitterError ( "twitter.Api instance must be authenticated" ) url = '%s/statuses/followers.json' % self . base_url parameters = { } if page : parameters [ 'page' ] = page json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ User . NewFromJsonDict ( x ) for x in data ] def GetFeatured ( self ) : url = '%s/statuses/featured.json' % self . base_url json = self . _FetchUrl ( url ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ User . NewFromJsonDict ( x ) for x in data ] def GetUser ( self , user ) : url = '%s/users/show/%s.json' % ( self . base_url , user ) json = self . _FetchUrl ( url ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return User . NewFromJsonDict ( data ) def GetDirectMessages ( self , since = None , since_id = None , page = None ) : url = '%s/direct_messages.json' % self . base_url if not self . _oauth_consumer : raise TwitterError ( "The twitter.Api instance must be authenticated." ) parameters = { } if since : parameters [ 'since' ] = since if since_id : parameters [ 'since_id' ] = since_id if page : parameters [ 'page' ] = page json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ DirectMessage . NewFromJsonDict ( x ) for x in data ] def PostDirectMessage ( self , user , text ) : if not self . _oauth_consumer : raise TwitterError ( "The twitter.Api instance must be authenticated." ) url = '%s/direct_messages/new.json' % self . base_url data = { 'text' : text , 'user' : user } json = self . _FetchUrl ( url , post_data = data ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return DirectMessage . NewFromJsonDict ( data ) def DestroyDirectMessage ( self , id ) : url = '%s/direct_messages/destroy/%s.json' % ( self . base_url , id ) json = self . _FetchUrl ( url , post_data = { 'id' : id } ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return DirectMessage . NewFromJsonDict ( data ) def CreateFriendship ( self , user ) : url = '%s/friendships/create/%s.json' % ( self . base_url , user ) json = self . _FetchUrl ( url , post_data = { 'user' : user } ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return User . NewFromJsonDict ( data ) def DestroyFriendship ( self , user ) : url = '%s/friendships/destroy/%s.json' % ( self . base_url , user ) json = self . _FetchUrl ( url , post_data = { 'user' : user } ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return User . NewFromJsonDict ( data ) def CreateFavorite ( self , status ) : url = '%s/favorites/create/%s.json' % ( self . base_url , status . id ) json = self . _FetchUrl ( url , post_data = { 'id' : status . id } ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return Status . NewFromJsonDict ( data ) def DestroyFavorite ( self , status ) : url = '%s/favorites/destroy/%s.json' % ( self . base_url , status . id ) json = self . _FetchUrl ( url , post_data = { 'id' : status . id } ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return Status . NewFromJsonDict ( data ) def GetFavorites ( self , user = None , page = None ) : parameters = { } if page : parameters [ 'page' ] = page if user : url = '%s/favorites/%s.json' % ( self . base_url , user ) elif not user and not self . _oauth_consumer : raise TwitterError ( "User must be specified if API is not authenticated." ) else : url = '%s/favorites.json' % self . base_url json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ Status . NewFromJsonDict ( x ) for x in data ] def GetMentions ( self , since_id = None , max_id = None , page = None ) : url = '%s/statuses/mentions.json' % self . base_url if not self . _oauth_consumer : raise TwitterError ( "The twitter.Api instance must be authenticated." ) parameters = { } if since_id : parameters [ 'since_id' ] = since_id if max_id : parameters [ 'max_id' ] = max_id if page : parameters [ 'page' ] = page json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ Status . NewFromJsonDict ( x ) for x in data ] def CreateList ( self , user , name , mode = None , description = None ) : url = '%s/%s/lists.json' % ( self . base_url , user ) parameters = { 'name' : name } if mode is not None : parameters [ 'mode' ] = mode if description is not None : parameters [ 'description' ] = description json = self . _FetchUrl ( url , post_data = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return List . NewFromJsonDict ( data ) def DestroyList ( self , user , id ) : url = '%s/%s/lists/%s.json' % ( self . base_url , user , id ) json = self . _FetchUrl ( url , post_data = { '_method' : 'DELETE' } ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return List . NewFromJsonDict ( data ) def CreateSubscription ( self , owner , list ) : url = '%s/%s/%s/subscribers.json' % ( self . base_url , owner , list ) json = self . _FetchUrl ( url , post_data = { 'list_id' : list } ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return List . NewFromJsonDict ( data ) def DestroySubscription ( self , owner , list ) : url = '%s/%s/%s/subscribers.json' % ( self . base_url , owner , list ) json = self . _FetchUrl ( url , post_data = { '_method' : 'DELETE' , 'list_id' : list } ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return List . NewFromJsonDict ( data ) def GetSubscriptions ( self , user , cursor = - 1 ) : if not self . _oauth_consumer : raise TwitterError ( "twitter.Api instance must be authenticated" ) url = '%s/%s/lists/subscriptions.json' % ( self . base_url , user ) parameters = { } parameters [ 'cursor' ] = cursor json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) print data return [ List . NewFromJsonDict ( x ) for x in data [ 'lists' ] ] def GetLists ( self , user , cursor = - 1 ) : if not self . _oauth_consumer : raise TwitterError ( "twitter.Api instance must be authenticated" ) url = '%s/%s/lists.json' % ( self . base_url , user ) parameters = { } parameters [ 'cursor' ] = cursor json = self . _FetchUrl ( url , parameters = parameters ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return [ List . NewFromJsonDict ( x ) for x in data [ 'lists' ] ] def GetUserByEmail ( self , email ) : url = '%s/users/show.json?email=%s' % ( self . base_url , email ) json = self . _FetchUrl ( url ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return User . NewFromJsonDict ( data ) def VerifyCredentials ( self ) : if not self . _oauth_consumer : raise TwitterError ( "Api instance must first be given user credentials." ) url = '%s/account/verify_credentials.json' % self . base_url try : json = self . _FetchUrl ( url , no_cache = True ) except urllib2 . HTTPError , http_error : if http_error . code == httplib . UNAUTHORIZED : return None else : raise http_error data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return User . NewFromJsonDict ( data ) def SetCache ( self , cache ) : if cache == DEFAULT_CACHE : self . _cache = _FileCache ( ) else : self . _cache = cache def SetUrllib ( self , urllib ) : self . _urllib = urllib def SetCacheTimeout ( self , cache_timeout ) : self . _cache_timeout = cache_timeout def SetUserAgent ( self , user_agent ) : self . _request_headers [ 'User-Agent' ] = user_agent def SetXTwitterHeaders ( self , client , url , version ) : self . _request_headers [ 'X-Twitter-Client' ] = client self . _request_headers [ 'X-Twitter-Client-URL' ] = url self . _request_headers [ 'X-Twitter-Client-Version' ] = version def SetSource ( self , source ) : self . _default_params [ 'source' ] = source def GetRateLimitStatus ( self ) : url = '%s/account/rate_limit_status.json' % self . base_url json = self . _FetchUrl ( url , no_cache = True ) data = simplejson . loads ( json ) self . _CheckForTwitterError ( data ) return data def MaximumHitFrequency ( self ) : rate_status = self . GetRateLimitStatus ( ) reset_time = rate_status . get ( 'reset_time' , None ) limit = rate_status . get ( 'remaining_hits' , None ) if reset_time and limit : reset = datetime . datetime ( * rfc822 . parsedate ( reset_time ) [ : 7 ] ) delta = reset + datetime . timedelta ( hours = 1 ) - datetime . datetime . utcnow ( ) max_frequency = int ( delta . seconds / limit ) return max_frequency return 0 def _BuildUrl ( self , url , path_elements = None , extra_params = None ) : ( scheme , netloc , path , params , query , fragment ) = urlparse . urlparse ( url ) if path_elements : p = [ i for i in path_elements if i ] if not path . endswith ( '/' ) : path += '/' path += '/' . join ( p ) if extra_params and len ( extra_params ) > 0 : extra_query = self . _EncodeParameters ( extra_params ) if query : query += '&' + extra_query else : query = extra_query return urlparse . urlunparse ( ( scheme , netloc , path , params , query , fragment ) ) def _InitializeRequestHeaders ( self , request_headers ) : if request_headers : self . _request_headers = request_headers else : self . _request_headers = { } def _InitializeUserAgent ( self ) : user_agent = 'Python-urllib/%s (python-twitter/%s)' % ( self . _urllib . __version__ , __version__ ) self . SetUserAgent ( user_agent ) def _InitializeDefaultParameters ( self ) : self . _default_params = { } def _DecompressGzippedResponse ( self , response ) : raw_data = response . read ( ) if response . headers . get ( 'content-encoding' , None ) == 'gzip' : url_data = gzip . GzipFile ( fileobj = StringIO . StringIO ( raw_data ) ) . read ( ) else : url_data = raw_data return url_data def _Encode ( self , s ) : if self . _input_encoding : return unicode ( s , self . _input_encoding ) . encode ( 'utf-8' ) else : return unicode ( s ) . encode ( 'utf-8' ) def _EncodeParameters ( self , parameters ) : if parameters is None : return None else : return urllib . urlencode ( dict ( [ ( k , self . _Encode ( v ) ) for k , v in parameters . items ( ) if v is not None ] ) ) def _EncodePostData ( self , post_data ) : if post_data is None : return None else : return urllib . urlencode ( dict ( [ ( k , self . _Encode ( v ) ) for k , v in post_data . items ( ) ] ) ) def _CheckForTwitterError ( self , data ) : if 'error' in data : raise TwitterError ( data [ 'error' ] ) def _FetchUrl ( self , url , post_data = None , parameters = None , no_cache = None , use_gzip_compression = None ) : extra_params = { } if self . _default_params : extra_params . update ( self . _default_params ) if parameters : extra_params . update ( parameters ) if post_data : http_method = "POST" else : http_method = "GET" http_handler = self . _urllib . HTTPHandler ( ) https_handler = self . _urllib . HTTPSHandler ( ) opener = self . _urllib . OpenerDirector ( ) opener . add_handler ( http_handler ) opener . add_handler ( https_handler ) if use_gzip_compression is None : use_gzip = self . _use_gzip else : use_gzip = use_gzip_compression if use_gzip and not post_data : opener . addheaders . append ( ( 'Accept-Encoding' , 'gzip' ) ) if self . _oauth_consumer is not None : if post_data and http_method == "POST" : parameters = post_data . copy ( ) req = oauth . Request . from_consumer_and_token ( self . _oauth_consumer , token = self . _oauth_token , http_method = http_method , http_url = url , parameters = parameters ) req . sign_request ( self . _signature_method_hmac_sha1 , self . _oauth_consumer , self . _oauth_token ) headers = req . to_header ( ) if http_method == "POST" : encoded_post_data = req . to_postdata ( ) else : encoded_post_data = None url = req . to_url ( ) else : url = self . _BuildUrl ( url , extra_params = extra_params ) encoded_post_data = self . _EncodePostData ( post_data ) if encoded_post_data or no_cache or not self . _cache or not self . _cache_timeout : response = opener . open ( url , encoded_post_data ) url_data = self . _DecompressGzippedResponse ( response ) opener . close ( ) else : if self . _username : key = self . _username + ':' + url else : key = url last_cached = self . _cache . GetCachedTime ( key ) if not last_cached or time . time ( ) >= last_cached + self . _cache_timeout : try : response = opener . open ( url , encoded_post_data ) url_data = self . _DecompressGzippedResponse ( response ) except urllib2 . HTTPError , e : print e opener . close ( ) self . _cache . Set ( key , url_data ) else : url_data = self . _cache . Get ( key ) return url_data class _FileCacheError ( Exception ) : class _FileCache ( object ) : DEPTH = 3 def __init__ ( self , root_directory = None ) : self . _InitializeRootDirectory ( root_directory ) def Get ( self , key ) : path = self . _GetPath ( key ) if os . path . exists ( path ) : return open ( path ) . read ( ) else : return None def Set ( self , key , data ) : path = self . _GetPath ( key ) directory = os . path . dirname ( path ) if not os . path . exists ( directory ) : os . makedirs ( directory ) if not os . path . isdir ( directory ) : raise _FileCacheError ( '%s exists but is not a directory' % directory ) temp_fd , temp_path = tempfile . mkstemp ( ) temp_fp = os . fdopen ( temp_fd , 'w' ) temp_fp . write ( data ) temp_fp . close ( ) if not path . startswith ( self . _root_directory ) : raise _FileCacheError ( '%s does not appear to live under %s' % ( path , self . _root_directory ) ) if os . path . exists ( path ) : os . remove ( path ) os . rename ( temp_path , path ) def Remove ( self , key ) : path = self . _GetPath ( key ) if not path . startswith ( self . _root_directory ) : raise _FileCacheError ( '%s does not appear to live under %s' % ( path , self . _root_directory ) ) if os . path . exists ( path ) : os . remove ( path ) def GetCachedTime ( self , key ) : path = self . _GetPath ( key ) if os . path . exists ( path ) : return os . path . getmtime ( path ) else : return None def _GetUsername ( self ) : try : return os . getenv ( 'USER' ) or os . getenv ( 'LOGNAME' ) or os . getenv ( 'USERNAME' ) or os . getlogin ( ) or 'nobody' except ( AttributeError , IOError , OSError ) , e : return 'nobody' def _GetTmpCachePath ( self ) : username = self . _GetUsername ( ) cache_directory = 'python.cache_' + username return os . path . join ( tempfile . gettempdir ( ) , cache_directory ) def _InitializeRootDirectory ( self , root_directory ) : if not root_directory : root_directory = self . _GetTmpCachePath ( ) root_directory = os . path . abspath ( root_directory ) if not os . path . exists ( root_directory ) : os . mkdir ( root_directory ) if not os . path . isdir ( root_directory ) : raise _FileCacheError ( '%s exists but is not a directory' % root_directory ) self . _root_directory = root_directory def _GetPath ( self , key ) : try : hashed_key = md5 ( key ) . hexdigest ( ) except TypeError : hashed_key = md5 . new ( key ) . hexdigest ( ) return os . path . join ( self . _root_directory , self . _GetPrefix ( hashed_key ) , hashed_key ) def _GetPrefix ( self , hashed_key ) : return os . path . sep . join ( hashed_key [ 0 : _FileCache . DEPTH ] )

from __future__ import with_statement import os import traceback import sickbeard from common import SNATCHED , Quality , SEASON_RESULT , MULTI_EP_RESULT from sickbeard import logger , db , show_name_helpers , exceptions , helpers from sickbeard import sab from sickbeard import nzbget from sickbeard import history from sickbeard import notifiers from sickbeard import nzbSplitter from sickbeard import ui from sickbeard import encodingKludge as ek from sickbeard . exceptions import ex from sickbeard import providers def _downloadResult ( result ) : resProvider = result . provider newResult = False if resProvider == None : logger . log ( u"Invalid provider name - this is a coding error, report it please" , logger . ERROR ) return False if result . resultType == "nzb" : newResult = resProvider . downloadResult ( result ) elif result . resultType == "nzbdata" : fileName = ek . ek ( os . path . join , sickbeard . NZB_DIR , result . name + ".nzb" ) logger . log ( u"Saving NZB to " + fileName ) newResult = True try : fileOut = open ( fileName , "w" ) fileOut . write ( result . extraInfo [ 0 ] ) fileOut . close ( ) helpers . chmodAsParent ( fileName ) except IOError , e : logger . log ( u"Error trying to save NZB to black hole: " + ex ( e ) , logger . ERROR ) newResult = False elif resProvider . providerType == "torrent" : newResult = resProvider . downloadResult ( result ) else : logger . log ( u"Invalid provider type - this is a coding error, report it please" , logger . ERROR ) return False if newResult : ui . notifications . message ( 'Episode snatched' , '<b>%s</b> snatched from <b>%s</b>' % ( result . name , resProvider . name ) ) return newResult def snatchEpisode ( result , endStatus = SNATCHED ) : if result . resultType in ( "nzb" , "nzbdata" ) : if sickbeard . NZB_METHOD == "blackhole" : dlResult = _downloadResult ( result ) elif sickbeard . NZB_METHOD == "sabnzbd" : dlResult = sab . sendNZB ( result ) elif sickbeard . NZB_METHOD == "nzbget" : dlResult = nzbget . sendNZB ( result ) else : logger . log ( u"Unknown NZB action specified in config: " + sickbeard . NZB_METHOD , logger . ERROR ) dlResult = False elif result . resultType == "torrent" : dlResult = _downloadResult ( result ) else : logger . log ( u"Unknown result type, unable to download it" , logger . ERROR ) dlResult = False if dlResult == False : return False history . logSnatch ( result ) for curEpObj in result . episodes : with curEpObj . lock : curEpObj . status = Quality . compositeStatus ( endStatus , result . quality ) curEpObj . saveToDB ( ) if curEpObj . status not in Quality . DOWNLOADED : notifiers . notify_snatch ( curEpObj . prettyName ( True ) ) return True def searchForNeededEpisodes ( ) : logger . log ( u"Searching all providers for any needed episodes" ) foundResults = { } didSearch = False for curProvider in providers . sortedProviderList ( ) : if not curProvider . isActive ( ) : continue curFoundResults = { } try : curFoundResults = curProvider . searchRSS ( ) except exceptions . AuthException , e : logger . log ( u"Authentication error: " + ex ( e ) , logger . ERROR ) continue except Exception , e : logger . log ( u"Error while searching " + curProvider . name + ", skipping: " + ex ( e ) , logger . ERROR ) logger . log ( traceback . format_exc ( ) , logger . DEBUG ) continue didSearch = True for curEp in curFoundResults : if curEp . show . paused : logger . log ( u"Show " + curEp . show . name + " is paused, ignoring all RSS items for " + curEp . prettyName ( True ) , logger . DEBUG ) continue bestResult = None for curResult in curFoundResults [ curEp ] : if not bestResult or bestResult . quality < curResult . quality : bestResult = curResult bestResult = pickBestResult ( curFoundResults [ curEp ] ) if curEp in foundResults and bestResult . quality <= foundResults [ curEp ] . quality : continue foundResults [ curEp ] = bestResult if not didSearch : logger . log ( u"No NZB/Torrent providers found or enabled in the sickbeard config. Please check your settings." , logger . ERROR ) return foundResults . values ( ) def pickBestResult ( results , quality_list = None ) : logger . log ( u"Picking the best result out of " + str ( [ x . name for x in results ] ) , logger . DEBUG ) bestResult = None for cur_result in results : logger . log ( "Quality of " + cur_result . name + " is " + Quality . qualityStrings [ cur_result . quality ] ) if quality_list and cur_result . quality not in quality_list : logger . log ( cur_result . name + " is a quality we know we don't want, rejecting it" , logger . DEBUG ) continue if not bestResult or bestResult . quality < cur_result . quality and cur_result . quality != Quality . UNKNOWN : bestResult = cur_result elif bestResult . quality == cur_result . quality : if "proper" in cur_result . name . lower ( ) or "repack" in cur_result . name . lower ( ) : bestResult = cur_result elif "internal" in bestResult . name . lower ( ) and "internal" not in cur_result . name . lower ( ) : bestResult = cur_result if bestResult : logger . log ( u"Picked " + bestResult . name + " as the best" , logger . DEBUG ) else : logger . log ( u"No result picked." , logger . DEBUG ) return bestResult def isFinalResult ( result ) : logger . log ( u"Checking if we should keep searching after we've found " + result . name , logger . DEBUG ) show_obj = result . episodes [ 0 ] . show any_qualities , best_qualities = Quality . splitQuality ( show_obj . quality ) if best_qualities and result . quality < max ( best_qualities ) : return False elif any_qualities and result . quality == max ( any_qualities ) : return True elif best_qualities and result . quality == max ( best_qualities ) : if any_qualities and result . quality < max ( any_qualities ) : return False else : return True else : return False def findEpisode ( episode , manualSearch = False ) : logger . log ( u"Searching for " + episode . prettyName ( True ) ) foundResults = [ ] didSearch = False for curProvider in providers . sortedProviderList ( ) : if not curProvider . isActive ( ) : continue try : curFoundResults = curProvider . findEpisode ( episode , manualSearch = manualSearch ) except exceptions . AuthException , e : logger . log ( u"Authentication error: " + ex ( e ) , logger . ERROR ) continue except Exception , e : logger . log ( u"Error while searching " + curProvider . name + ", skipping: " + ex ( e ) , logger . ERROR ) logger . log ( traceback . format_exc ( ) , logger . DEBUG ) continue didSearch = True curFoundResults = filter ( lambda x : show_name_helpers . filterBadReleases ( x . name ) and show_name_helpers . isGoodResult ( x . name , episode . show ) , curFoundResults ) done_searching = False for cur_result in curFoundResults : done_searching = isFinalResult ( cur_result ) logger . log ( u"Should we stop searching after finding " + cur_result . name + ": " + str ( done_searching ) , logger . DEBUG ) if done_searching : break foundResults += curFoundResults if done_searching : break if not didSearch : logger . log ( u"No NZB/Torrent providers found or enabled in the sickbeard config. Please check your settings." , logger . ERROR ) bestResult = pickBestResult ( foundResults ) return bestResult def findSeason ( show , season ) : logger . log ( u"Searching for stuff we need from " + show . name + " season " + str ( season ) ) foundResults = { } didSearch = False for curProvider in providers . sortedProviderList ( ) : if not curProvider . isActive ( ) : continue try : curResults = curProvider . findSeasonResults ( show , season ) for curEp in curResults : curResults [ curEp ] = filter ( lambda x : show_name_helpers . filterBadReleases ( x . name ) and show_name_helpers . isGoodResult ( x . name , show ) , curResults [ curEp ] ) if curEp in foundResults : foundResults [ curEp ] += curResults [ curEp ] else : foundResults [ curEp ] = curResults [ curEp ] except exceptions . AuthException , e : logger . log ( u"Authentication error: " + ex ( e ) , logger . ERROR ) continue except Exception , e : logger . log ( u"Error while searching " + curProvider . name + ", skipping: " + ex ( e ) , logger . ERROR ) logger . log ( traceback . format_exc ( ) , logger . DEBUG ) continue didSearch = True if not didSearch : logger . log ( u"No NZB/Torrent providers found or enabled in the sickbeard config. Please check your settings." , logger . ERROR ) finalResults = [ ] anyQualities , bestQualities = Quality . splitQuality ( show . quality ) bestSeasonNZB = None if SEASON_RESULT in foundResults : bestSeasonNZB = pickBestResult ( foundResults [ SEASON_RESULT ] , anyQualities + bestQualities ) highest_quality_overall = 0 for cur_season in foundResults : for cur_result in foundResults [ cur_season ] : if cur_result . quality != Quality . UNKNOWN and cur_result . quality > highest_quality_overall : highest_quality_overall = cur_result . quality logger . log ( u"The highest quality of any match is " + Quality . qualityStrings [ highest_quality_overall ] , logger . DEBUG ) if bestSeasonNZB : seasonQual = Quality . nameQuality ( bestSeasonNZB . name ) seasonQual = bestSeasonNZB . quality logger . log ( u"The quality of the season NZB is " + Quality . qualityStrings [ seasonQual ] , logger . DEBUG ) myDB = db . DBConnection ( ) allEps = [ int ( x [ "episode" ] ) for x in myDB . select ( "SELECT episode FROM tv_episodes WHERE showid = ? AND season = ?" , [ show . tvdbid , season ] ) ] logger . log ( u"Episode list: " + str ( allEps ) , logger . DEBUG ) allWanted = True anyWanted = False for curEpNum in allEps : if not show . wantEpisode ( season , curEpNum , seasonQual ) : allWanted = False else : anyWanted = True if allWanted and bestSeasonNZB . quality == highest_quality_overall : logger . log ( u"Every ep in this season is needed, downloading the whole NZB " + bestSeasonNZB . name ) epObjs = [ ] for curEpNum in allEps : epObjs . append ( show . getEpisode ( season , curEpNum ) ) bestSeasonNZB . episodes = epObjs return [ bestSeasonNZB ] elif not anyWanted : logger . log ( u"No eps from this season are wanted at this quality, ignoring the result of " + bestSeasonNZB . name , logger . DEBUG ) else : logger . log ( u"Breaking apart the NZB and adding the individual ones to our results" , logger . DEBUG ) individualResults = nzbSplitter . splitResult ( bestSeasonNZB ) individualResults = filter ( lambda x : show_name_helpers . filterBadReleases ( x . name ) and show_name_helpers . isGoodResult ( x . name , show ) , individualResults ) for curResult in individualResults : if len ( curResult . episodes ) == 1 : epNum = curResult . episodes [ 0 ] . episode elif len ( curResult . episodes ) > 1 : epNum = MULTI_EP_RESULT if epNum in foundResults : foundResults [ epNum ] . append ( curResult ) else : foundResults [ epNum ] = [ curResult ] multiResults = { } if MULTI_EP_RESULT in foundResults : for multiResult in foundResults [ MULTI_EP_RESULT ] : logger . log ( u"Seeing if we want to bother with multi-episode result " + multiResult . name , logger . DEBUG ) neededEps = [ ] notNeededEps = [ ] for epObj in multiResult . episodes : epNum = epObj . episode if epNum in foundResults and len ( foundResults [ epNum ] ) > 0 : neededEps . append ( epNum ) else : neededEps . append ( epNum ) logger . log ( u"Single-ep check result is neededEps: " + str ( neededEps ) + ", notNeededEps: " + str ( notNeededEps ) , logger . DEBUG ) if not neededEps : logger . log ( u"All of these episodes were covered by single nzbs, ignoring this multi-ep result" , logger . DEBUG ) continue multiNeededEps = [ ] multiNotNeededEps = [ ] for epObj in multiResult . episodes : epNum = epObj . episode if epNum in multiResults : multiNotNeededEps . append ( epNum ) else : multiNeededEps . append ( epNum ) logger . log ( u"Multi-ep check result is multiNeededEps: " + str ( multiNeededEps ) + ", multiNotNeededEps: " + str ( multiNotNeededEps ) , logger . DEBUG ) if not neededEps : logger . log ( u"All of these episodes were covered by another multi-episode nzbs, ignoring this multi-ep result" , logger . DEBUG ) continue for epObj in multiResult . episodes : multiResults [ epObj . episode ] = multiResult for epObj in multiResult . episodes : epNum = epObj . episode if epNum in foundResults : logger . log ( u"A needed multi-episode result overlaps with a single-episode result for ep #" + str ( epNum ) + ", removing the single-episode results from the list" , logger . DEBUG ) del foundResults [ epNum ] finalResults += set ( multiResults . values ( ) ) for curEp in foundResults : if curEp in ( MULTI_EP_RESULT , SEASON_RESULT ) : continue if len ( foundResults [ curEp ] ) == 0 : continue finalResults . append ( pickBestResult ( foundResults [ curEp ] ) ) return finalResults

""" Utilities to convert integers and binary strings to binary (number), binary string, number, hexadecimal, etc. """ from lib . hachoir_core . endian import BIG_ENDIAN , LITTLE_ENDIAN from lib . hachoir_core . compatibility import reversed from itertools import chain , repeat from struct import calcsize , unpack , error as struct_error def swap16 ( value ) : return ( value & 0xFF ) << 8 | ( value >> 8 ) def swap32 ( value ) : value = long ( value ) return ( ( value & 0x000000FFL ) << 24 ) | ( ( value & 0x0000FF00L ) << 8 ) | ( ( value & 0x00FF0000L ) >> 8 ) | ( ( value & 0xFF000000L ) >> 24 ) def bin2long ( text , endian ) : assert endian in ( LITTLE_ENDIAN , BIG_ENDIAN ) bits = [ ( ord ( character ) - ord ( "0" ) ) for character in text if character in "01" ] assert len ( bits ) != 0 if endian is not BIG_ENDIAN : bits = reversed ( bits ) value = 0 for bit in bits : value *= 2 value += bit return value def str2hex ( value , prefix = "" , glue = u"" , format = "%02X" ) : if isinstance ( glue , str ) : glue = unicode ( glue ) if 0 < len ( prefix ) : text = [ prefix ] else : text = [ ] for character in value : text . append ( format % ord ( character ) ) return glue . join ( text ) def countBits ( value ) : assert 0 <= value count = 1 bits = 1 while ( 1 << bits ) <= value : count += bits value >>= bits bits <<= 1 while 2 <= value : if bits != 1 : bits >>= 1 else : bits -= 1 while ( 1 << bits ) <= value : count += bits value >>= bits return count def byte2bin ( number , classic_mode = True ) : text = "" for i in range ( 0 , 8 ) : if classic_mode : mask = 1 << ( 7 - i ) else : mask = 1 << i if ( number & mask ) == mask : text += "1" else : text += "0" return text def long2raw ( value , endian , size = None ) : assert ( not size and 0 < value ) or ( 0 <= value ) assert endian in ( LITTLE_ENDIAN , BIG_ENDIAN ) text = [ ] while ( value != 0 or text == "" ) : byte = value % 256 text . append ( chr ( byte ) ) value >>= 8 if size : need = max ( size - len ( text ) , 0 ) else : need = 0 if need : if endian is BIG_ENDIAN : text = chain ( repeat ( "\0" , need ) , reversed ( text ) ) else : text = chain ( text , repeat ( "\0" , need ) ) else : if endian is BIG_ENDIAN : text = reversed ( text ) return "" . join ( text ) def long2bin ( size , value , endian , classic_mode = False ) : text = "" assert endian in ( LITTLE_ENDIAN , BIG_ENDIAN ) assert 0 <= value for index in xrange ( size ) : if ( value & 1 ) == 1 : text += "1" else : text += "0" value >>= 1 if endian is LITTLE_ENDIAN : text = text [ : : - 1 ] result = "" while len ( text ) != 0 : if len ( result ) != 0 : result += " " if classic_mode : result += text [ 7 : : - 1 ] else : result += text [ : 8 ] text = text [ 8 : ] return result def str2bin ( value , classic_mode = True ) : text = "" for character in value : if text != "" : text += " " byte = ord ( character ) text += byte2bin ( byte , classic_mode ) return text def _createStructFormat ( ) : format = { BIG_ENDIAN : { } , LITTLE_ENDIAN : { } , } for struct_format in "BHILQ" : try : size = calcsize ( struct_format ) format [ BIG_ENDIAN ] [ size ] = '>%s' % struct_format format [ LITTLE_ENDIAN ] [ size ] = '<%s' % struct_format except struct_error : pass return format _struct_format = _createStructFormat ( ) def str2long ( data , endian ) : assert 1 <= len ( data ) <= 32 try : return unpack ( _struct_format [ endian ] [ len ( data ) ] , data ) [ 0 ] except KeyError : pass assert endian in ( BIG_ENDIAN , LITTLE_ENDIAN ) shift = 0 value = 0 if endian is BIG_ENDIAN : data = reversed ( data ) for character in data : byte = ord ( character ) value += ( byte << shift ) shift += 8 return value

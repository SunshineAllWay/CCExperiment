__author__ = "dbr/Ben" __version__ = "1.5" import os import sys import urllib import urllib2 import StringIO import tempfile import warnings import logging import datetime import time import traceback import socket try : import xml . etree . cElementTree as ElementTree except ImportError : import xml . etree . ElementTree as ElementTree try : import gzip except ImportError : gzip = None try : import lib . httplib2 as httplib2 except ImportError : import httplib2 try : import lib . socks as socks except ImportError : try : import socks as socks except ImportError : socks = None from tvdb_ui import BaseUI , ConsoleUI from tvdb_exceptions import ( tvdb_error , tvdb_userabort , tvdb_shownotfound , tvdb_seasonnotfound , tvdb_episodenotfound , tvdb_attributenotfound ) lastTimeout = None def log ( ) : return logging . getLogger ( "tvdb_api" ) def clean_cache ( cachedir ) : if not os . path . isdir ( cachedir ) : log ( ) . debug ( "Told to clean cache dir %s but it does not exist" % cachedir ) return now = time . time ( ) day = 86400 files = os . listdir ( cachedir ) for file in files : ffile = os . path . join ( cachedir , file ) if now - os . stat ( ffile ) . st_mtime > day : try : os . remove ( ffile ) except : raise tvdb_error ( "Couldn't remove %s" % ffile ) class ShowContainer ( dict ) : pass class Show ( dict ) : def __init__ ( self ) : dict . __init__ ( self ) self . data = { } def __repr__ ( self ) : return "<Show %s (containing %s seasons)>" % ( self . data . get ( u'seriesname' , 'instance' ) , len ( self ) ) def __getitem__ ( self , key ) : if key in self : return dict . __getitem__ ( self , key ) if key in self . data : return dict . __getitem__ ( self . data , key ) if isinstance ( key , int ) or key . isdigit ( ) : raise tvdb_seasonnotfound ( "Could not find season %s" % ( repr ( key ) ) ) else : raise tvdb_attributenotfound ( "Cannot find attribute %s" % ( repr ( key ) ) ) def airedOn ( self , date ) : ret = self . search ( str ( date ) , 'firstaired' ) if len ( ret ) == 0 : raise tvdb_episodenotfound ( "Could not find any episodes that aired on %s" % date ) return ret def search ( self , term = None , key = None ) : results = [ ] for cur_season in self . values ( ) : searchresult = cur_season . search ( term = term , key = key ) if len ( searchresult ) != 0 : results . extend ( searchresult ) return results class Season ( dict ) : def __repr__ ( self ) : return "<Season instance (containing %s episodes)>" % ( len ( self . keys ( ) ) ) def __getitem__ ( self , episode_number ) : if episode_number not in self : raise tvdb_episodenotfound ( "Could not find episode %s" % ( repr ( episode_number ) ) ) else : return dict . __getitem__ ( self , episode_number ) def search ( self , term = None , key = None ) : results = [ ] for ep in self . values ( ) : searchresult = ep . search ( term = term , key = key ) if searchresult is not None : results . append ( searchresult ) return results class Episode ( dict ) : def __repr__ ( self ) : seasno = int ( self . get ( u'seasonnumber' , 0 ) ) epno = int ( self . get ( u'episodenumber' , 0 ) ) epname = self . get ( u'episodename' ) if epname is not None : return "<Episode %02dx%02d - %s>" % ( seasno , epno , epname ) else : return "<Episode %02dx%02d>" % ( seasno , epno ) def __getitem__ ( self , key ) : try : return dict . __getitem__ ( self , key ) except KeyError : raise tvdb_attributenotfound ( "Cannot find attribute %s" % ( repr ( key ) ) ) def search ( self , term = None , key = None ) : if term == None : raise TypeError ( "must supply string to search for (contents)" ) term = unicode ( term ) . lower ( ) for cur_key , cur_value in self . items ( ) : cur_key , cur_value = unicode ( cur_key ) . lower ( ) , unicode ( cur_value ) . lower ( ) if key is not None and cur_key != key : continue if cur_value . find ( unicode ( term ) . lower ( ) ) > - 1 : return self class Actors ( list ) : pass class Actor ( dict ) : def __repr__ ( self ) : return "<Actor \"%s\">" % ( self . get ( "name" ) ) class Tvdb : def __init__ ( self , interactive = False , select_first = False , debug = False , cache = True , cache_dir = False , banners = False , actors = False , custom_ui = None , language = None , search_all_languages = False , apikey = None , forceConnect = False , http_proxy = None ) : global lastTimeout if not forceConnect and lastTimeout != None and datetime . datetime . now ( ) - lastTimeout < datetime . timedelta ( minutes = 1 ) : raise tvdb_error ( "We recently timed out, so giving up early this time" ) self . shows = ShowContainer ( ) self . corrections = { } self . config = { } if apikey is not None : self . config [ 'apikey' ] = apikey else : self . config [ 'apikey' ] = "0629B785CE550C8D" self . config [ 'debug_enabled' ] = debug self . config [ 'custom_ui' ] = custom_ui self . config [ 'interactive' ] = interactive self . config [ 'select_first' ] = select_first self . config [ 'search_all_languages' ] = search_all_languages if cache_dir : self . config [ 'cache_location' ] = cache_dir else : self . config [ 'cache_location' ] = self . _getTempDir ( ) if cache : self . config [ 'cache_enabled' ] = cache else : self . config [ 'cache_enabled' ] = False if self . config [ 'cache_enabled' ] and self . config [ 'cache_location' ] : clean_cache ( self . config [ 'cache_location' ] ) self . config [ 'banners_enabled' ] = banners self . config [ 'actors_enabled' ] = actors self . config [ 'http_proxy' ] = http_proxy if self . config [ 'debug_enabled' ] : warnings . warn ( "The debug argument to tvdb_api.__init__ will be removed in the next version. " ) logging . basicConfig ( level = logging . DEBUG ) self . config [ 'valid_languages' ] = [ , "fi" , "nl" , "de" , "it" , "es" , "fr" , "pl" , "hu" , "el" , "tr" , , "he" , "ja" , "pt" , "zh" , "cs" , "sl" , "hr" , "ko" , "en" , "sv" , "no" ] self . config [ 'langabbv_to_id' ] = { 'el' : 20 , 'en' : 7 , 'zh' : 27 , : 15 , 'cs' : 28 , 'es' : 16 , 'ru' : 22 , 'nl' : 13 , 'pt' : 26 , 'no' : 9 , : 21 , 'pl' : 18 , 'fr' : 17 , 'hr' : 31 , 'de' : 14 , 'da' : 10 , 'fi' : 11 , : 19 , 'ja' : 25 , 'he' : 24 , 'ko' : 32 , 'sv' : 8 , 'sl' : 30 } if language is None : self . config [ 'language' ] = None else : if language not in self . config [ 'valid_languages' ] : raise ValueError ( "Invalid language %s, options are: %s" % ( language , self . config [ 'valid_languages' ] ) ) else : self . config [ 'language' ] = language self . config [ 'base_url' ] = "http://www.thetvdb.com" if self . config [ 'search_all_languages' ] : self . config [ 'url_getSeries' ] = "%(base_url)s/api/GetSeries.php?seriesname=%%s&language=all" % self . config else : self . config [ 'url_getSeries' ] = "%(base_url)s/api/GetSeries.php?seriesname=%%s&language=%(language)s" % self . config self . config [ 'url_epInfo' ] = "%(base_url)s/api/%(apikey)s/series/%%s/all/%%s.xml" % self . config self . config [ 'url_seriesInfo' ] = "%(base_url)s/api/%(apikey)s/series/%%s/%%s.xml" % self . config self . config [ 'url_actorsInfo' ] = "%(base_url)s/api/%(apikey)s/series/%%s/actors.xml" % self . config self . config [ 'url_seriesBanner' ] = "%(base_url)s/api/%(apikey)s/series/%%s/banners.xml" % self . config self . config [ 'url_artworkPrefix' ] = "%(base_url)s/banners/%%s" % self . config def _getTempDir ( self ) : return os . path . join ( tempfile . gettempdir ( ) , "tvdb_api" ) def _loadUrl ( self , url , recache = False ) : global lastTimeout if self . config [ 'cache_enabled' ] and self . config [ 'cache_location' ] : h_cache = self . config [ 'cache_location' ] else : h_cache = False if self . config [ 'http_proxy' ] != '' and self . config [ 'http_proxy' ] != None and socks != None : parsedURI = socks . parseproxyuri ( self . config [ 'http_proxy' ] ) h = httplib2 . Http ( cache = h_cache , proxy_info = httplib2 . ProxyInfo ( socks . PROXY_TYPE_HTTP , parsedURI [ 1 ] , int ( parsedURI [ 2 ] ) ) ) else : h = httplib2 . Http ( cache = h_cache ) if str ( self . config [ 'cache_enabled' ] ) . lower ( ) == 'recache' or recache : h_header = { 'cache-control' : 'no-cache' } else : h_header = { } try : log ( ) . debug ( "Retrieving URL %s" % url ) header , resp = h . request ( url , headers = h_header ) except ( socket . error , IOError , httplib2 . HttpLib2Error ) , errormsg : if not str ( errormsg ) . startswith ( 'HTTP Error' ) : lastTimeout = datetime . datetime . now ( ) raise tvdb_error ( "Could not connect to server %s: %s" % ( url , errormsg ) ) except ( AttributeError ) , errormsg : raise tvdb_error ( "Silly upstream module timed out and didn't give a \ good error. Failed hitting %s, error message: %s" % ( url , str ( errormsg ) ) ) return str ( resp ) def _getetsrc ( self , url ) : src = self . _loadUrl ( url ) try : return ElementTree . fromstring ( src . rstrip ( '\r' ) ) except SyntaxError : src = self . _loadUrl ( url , recache = True ) try : return ElementTree . fromstring ( src . rstrip ( '\r' ) ) except SyntaxError , exceptionmsg : errormsg = "There was an error with the XML retrieved from thetvdb.com:\n%s" % ( exceptionmsg ) if self . config [ 'cache_enabled' ] : errormsg += "\nFirst try emptying the cache folder at..\n%s" % ( self . config [ 'cache_location' ] ) errormsg += "\nIf this does not resolve the issue, please try again later." raise tvdb_error ( errormsg ) def _setItem ( self , sid , seas , ep , attrib , value ) : if sid not in self . shows : self . shows [ sid ] = Show ( ) if seas not in self . shows [ sid ] : self . shows [ sid ] [ seas ] = Season ( ) if ep not in self . shows [ sid ] [ seas ] : self . shows [ sid ] [ seas ] [ ep ] = Episode ( ) self . shows [ sid ] [ seas ] [ ep ] [ attrib ] = value def _setShowData ( self , sid , key , value ) : if sid not in self . shows : self . shows [ sid ] = Show ( ) self . shows [ sid ] . data [ key ] = value def _cleanData ( self , data ) : data = data . replace ( u"&amp;" , u"&" ) data = data . strip ( ) return data def _getSeries ( self , series ) : series = urllib . quote ( series . encode ( "utf-8" ) ) log ( ) . debug ( "Searching for show %s" % series ) seriesEt = self . _getetsrc ( self . config [ 'url_getSeries' ] % ( series ) ) allSeries = [ ] for series in seriesEt : result = dict ( ( k . tag . lower ( ) , k . text ) for k in series . getchildren ( ) ) result [ 'lid' ] = self . config [ 'langabbv_to_id' ] [ result [ 'language' ] ] log ( ) . debug ( 'Found series %(seriesname)s' % result ) allSeries . append ( result ) if len ( allSeries ) == 0 : log ( ) . debug ( 'Series result returned zero' ) raise tvdb_shownotfound ( "Show-name search returned zero results (cannot find show on TVDB)" ) if self . config [ 'custom_ui' ] is not None : log ( ) . debug ( "Using custom UI %s" % ( repr ( self . config [ 'custom_ui' ] ) ) ) ui = self . config [ 'custom_ui' ] ( config = self . config ) else : if not self . config [ 'interactive' ] : log ( ) . debug ( 'Auto-selecting first search result using BaseUI' ) ui = BaseUI ( config = self . config ) else : log ( ) . debug ( 'Interactively selecting show using ConsoleUI' ) ui = ConsoleUI ( config = self . config ) return ui . selectSeries ( allSeries ) def _parseBanners ( self , sid ) : log ( ) . debug ( 'Getting season banners for %s' % ( sid ) ) bannersEt = self . _getetsrc ( self . config [ 'url_seriesBanner' ] % ( sid ) ) banners = { } for cur_banner in bannersEt . findall ( 'Banner' ) : bid = cur_banner . find ( 'id' ) . text btype = cur_banner . find ( 'BannerType' ) btype2 = cur_banner . find ( 'BannerType2' ) if btype is None or btype2 is None : continue btype , btype2 = btype . text , btype2 . text if not btype in banners : banners [ btype ] = { } if not btype2 in banners [ btype ] : banners [ btype ] [ btype2 ] = { } if not bid in banners [ btype ] [ btype2 ] : banners [ btype ] [ btype2 ] [ bid ] = { } for cur_element in cur_banner . getchildren ( ) : tag = cur_element . tag . lower ( ) value = cur_element . text if tag is None or value is None : continue tag , value = tag . lower ( ) , value . lower ( ) banners [ btype ] [ btype2 ] [ bid ] [ tag ] = value for k , v in banners [ btype ] [ btype2 ] [ bid ] . items ( ) : if k . endswith ( "path" ) : new_key = "_%s" % ( k ) log ( ) . debug ( "Transforming %s to %s" % ( k , new_key ) ) new_url = self . config [ 'url_artworkPrefix' ] % ( v ) banners [ btype ] [ btype2 ] [ bid ] [ new_key ] = new_url self . _setShowData ( sid , "_banners" , banners ) def _parseActors ( self , sid ) : log ( ) . debug ( "Getting actors for %s" % ( sid ) ) actorsEt = self . _getetsrc ( self . config [ 'url_actorsInfo' ] % ( sid ) ) cur_actors = Actors ( ) for curActorItem in actorsEt . findall ( "Actor" ) : curActor = Actor ( ) for curInfo in curActorItem : tag = curInfo . tag . lower ( ) value = curInfo . text if value is not None : if tag == "image" : value = self . config [ 'url_artworkPrefix' ] % ( value ) else : value = self . _cleanData ( value ) curActor [ tag ] = value cur_actors . append ( curActor ) self . _setShowData ( sid , '_actors' , cur_actors ) def _getShowData ( self , sid , language ) : if self . config [ 'language' ] is None : log ( ) . debug ( 'Config language is none, using show language' ) getShowInLanguage = language else : log ( ) . debug ( % ( self . config [ 'language' ] , language ) ) getShowInLanguage = self . config [ 'language' ] log ( ) . debug ( 'Getting all series data for %s' % ( sid ) ) seriesInfoEt = self . _getetsrc ( self . config [ 'url_seriesInfo' ] % ( sid , getShowInLanguage ) ) for curInfo in seriesInfoEt . findall ( "Series" ) [ 0 ] : tag = curInfo . tag . lower ( ) value = curInfo . text if value is not None : if tag in [ 'banner' , 'fanart' , 'poster' ] : value = self . config [ 'url_artworkPrefix' ] % ( value ) else : value = self . _cleanData ( value ) self . _setShowData ( sid , tag , value ) if self . config [ 'banners_enabled' ] : self . _parseBanners ( sid ) if self . config [ 'actors_enabled' ] : self . _parseActors ( sid ) log ( ) . debug ( 'Getting all episodes of %s' % ( sid ) ) epsEt = self . _getetsrc ( self . config [ 'url_epInfo' ] % ( sid , language ) ) for cur_ep in epsEt . findall ( "Episode" ) : seas_no = int ( cur_ep . find ( 'SeasonNumber' ) . text ) ep_no = int ( cur_ep . find ( 'EpisodeNumber' ) . text ) for cur_item in cur_ep . getchildren ( ) : tag = cur_item . tag . lower ( ) value = cur_item . text if value is not None : if tag == 'filename' : value = self . config [ 'url_artworkPrefix' ] % ( value ) else : value = self . _cleanData ( value ) self . _setItem ( sid , seas_no , ep_no , tag , value ) def _nameToSid ( self , name ) : if name in self . corrections : log ( ) . debug ( 'Correcting %s to %s' % ( name , self . corrections [ name ] ) ) sid = self . corrections [ name ] else : log ( ) . debug ( 'Getting show %s' % ( name ) ) selected_series = self . _getSeries ( name ) sname , sid = selected_series [ 'seriesname' ] , selected_series [ 'id' ] log ( ) . debug ( 'Got %(seriesname)s, id %(id)s' % selected_series ) self . corrections [ name ] = sid self . _getShowData ( selected_series [ 'id' ] , selected_series [ 'language' ] ) return sid def __getitem__ ( self , key ) : if isinstance ( key , ( int , long ) ) : if key not in self . shows : self . _getShowData ( key , self . config [ 'language' ] ) return self . shows [ key ] key = key . lower ( ) sid = self . _nameToSid ( key ) log ( ) . debug ( 'Got series id %s' % ( sid ) ) return self . shows [ sid ] def __repr__ ( self ) : return str ( self . shows ) def main ( ) : import logging logging . basicConfig ( level = logging . DEBUG ) tvdb_instance = Tvdb ( interactive = True , cache = False ) print tvdb_instance [ 'Lost' ] [ 'seriesname' ] print tvdb_instance [ 'Lost' ] [ 1 ] [ 4 ] [ 'episodename' ] if __name__ == '__main__' : main ( )

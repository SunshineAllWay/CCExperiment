import os import string import cherrypy from sickbeard import encodingKludge as ek try : import json except ImportError : from lib import simplejson as json if os . name == 'nt' : from ctypes import windll def getWinDrives ( ) : assert os . name == 'nt' drives = [ ] bitmask = windll . kernel32 . GetLogicalDrives ( ) for letter in string . uppercase : if bitmask & 1 : drives . append ( letter ) bitmask >>= 1 return drives def foldersAtPath ( path , includeParent = False ) : assert os . path . isabs ( path ) or path == "" while path and not os . path . isdir ( path ) : if path == os . path . dirname ( path ) : path = '' break else : path = os . path . dirname ( path ) if path == "" : if os . name == 'nt' : entries = [ { 'current_path' : 'Root' } ] for letter in getWinDrives ( ) : letterPath = letter + ':\\' entries . append ( { 'name' : letterPath , 'path' : letterPath } ) return entries else : path = '/' path = os . path . abspath ( os . path . normpath ( path ) ) parentPath = os . path . dirname ( path ) if path == parentPath and os . name == 'nt' : parentPath = "" fileList = [ { 'name' : filename , 'path' : ek . ek ( os . path . join , path , filename ) } for filename in ek . ek ( os . listdir , path ) ] fileList = filter ( lambda entry : ek . ek ( os . path . isdir , entry [ 'path' ] ) , fileList ) fileList = sorted ( fileList , lambda x , y : cmp ( os . path . basename ( x [ 'name' ] ) . lower ( ) , os . path . basename ( y [ 'path' ] ) . lower ( ) ) ) entries = [ { 'current_path' : path } ] if includeParent and parentPath != path : entries . append ( { 'name' : ".." , 'path' : parentPath } ) entries . extend ( fileList ) return entries class WebFileBrowser : @ cherrypy . expose def index ( self , path = '' ) : cherrypy . response . headers [ 'Content-Type' ] = "application/json" return json . dumps ( foldersAtPath ( path , True ) ) @ cherrypy . expose def complete ( self , term ) : cherrypy . response . headers [ 'Content-Type' ] = "application/json" paths = [ entry [ 'path' ] for entry in foldersAtPath ( os . path . dirname ( term ) ) if 'path' in entry ] return json . dumps ( paths )

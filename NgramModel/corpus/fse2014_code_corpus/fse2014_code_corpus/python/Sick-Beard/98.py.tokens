"""A library for integrating pyOpenSSL with CherryPy. The OpenSSL module must be importable for SSL functionality. You can obtain it from http://pyopenssl.sourceforge.net/ To use this module, set CherryPyWSGIServer.ssl_adapter to an instance of SSLAdapter. There are two ways to use SSL: Method One: ssl_adapter.context: an instance of SSL.Context. If this is not None, it is assumed to be an SSL.Context instance, and will be passed to SSL.Connection on bind(). The developer is responsible for forming a valid Context object. This approach is to be preferred for more flexibility, e.g. if the cert and key are streams instead of files, or need decryption, or SSL.SSLv3_METHOD is desired instead of the default SSL.SSLv23_METHOD, etc. Consult the pyOpenSSL documentation for complete options. Method Two (shortcut): ssl_adapter.certificate: the filename of the server SSL certificate. ssl_adapter.private_key: the filename of the server's private key file. Both are None by default. If ssl_adapter.context is None, but .private_key and .certificate are both given and valid, they will be read, and the context will be automatically created from them. ssl_adapter.certificate_chain: (optional) the filename of CA's intermediate certificate bundle. This is needed for cheaper "chained root" SSL certificates, and should be left as None if not required. """ import socket import threading import time from cherrypy import wsgiserver try : from OpenSSL import SSL from OpenSSL import crypto except ImportError : SSL = None class SSL_fileobject ( wsgiserver . CP_fileobject ) : ssl_timeout = 3 ssl_retry = .01 def _safe_call ( self , is_reader , call , * args , ** kwargs ) : start = time . time ( ) while True : try : return call ( * args , ** kwargs ) except SSL . WantReadError : time . sleep ( self . ssl_retry ) except SSL . WantWriteError : time . sleep ( self . ssl_retry ) except SSL . SysCallError , e : if is_reader and e . args == ( - 1 , 'Unexpected EOF' ) : return "" errnum = e . args [ 0 ] if is_reader and errnum in wsgiserver . socket_errors_to_ignore : return "" raise socket . error ( errnum ) except SSL . Error , e : if is_reader and e . args == ( - 1 , 'Unexpected EOF' ) : return "" thirdarg = None try : thirdarg = e . args [ 0 ] [ 0 ] [ 2 ] except IndexError : pass if thirdarg == 'http request' : raise wsgiserver . NoSSLError ( ) raise wsgiserver . FatalSSLAlert ( * e . args ) except : raise if time . time ( ) - start > self . ssl_timeout : raise socket . timeout ( "timed out" ) def recv ( self , * args , ** kwargs ) : buf = [ ] r = super ( SSL_fileobject , self ) . recv while True : data = self . _safe_call ( True , r , * args , ** kwargs ) buf . append ( data ) p = self . _sock . pending ( ) if not p : return "" . join ( buf ) def sendall ( self , * args , ** kwargs ) : return self . _safe_call ( False , super ( SSL_fileobject , self ) . sendall , * args , ** kwargs ) def send ( self , * args , ** kwargs ) : return self . _safe_call ( False , super ( SSL_fileobject , self ) . send , * args , ** kwargs ) class SSLConnection : def __init__ ( self , * args ) : self . _ssl_conn = SSL . Connection ( * args ) self . _lock = threading . RLock ( ) for f in ( 'get_context' , 'pending' , 'send' , 'write' , 'recv' , 'read' , , 'bind' , 'listen' , 'connect' , 'accept' , , 'fileno' , 'close' , 'get_cipher_list' , , 'getsockname' , 'getsockopt' , 'setsockopt' , , 'get_app_data' , 'set_app_data' , 'state_string' , , 'get_peer_certificate' , 'want_read' , , 'set_connect_state' , 'set_accept_state' , , 'sendall' , 'settimeout' , 'gettimeout' ) : exec ( """def %s(self, *args): self._lock.acquire() try: return self._ssl_conn.%s(*args) finally: self._lock.release() """ % ( f , f ) ) def shutdown ( self , * args ) : self . _lock . acquire ( ) try : return self . _ssl_conn . shutdown ( ) finally : self . _lock . release ( ) class pyOpenSSLAdapter ( wsgiserver . SSLAdapter ) : def __init__ ( self , certificate , private_key , certificate_chain = None ) : if SSL is None : raise ImportError ( "You must install pyOpenSSL to use HTTPS." ) self . context = None self . certificate = certificate self . private_key = private_key self . certificate_chain = certificate_chain self . _environ = None def bind ( self , sock ) : if self . context is None : self . context = self . get_context ( ) conn = SSLConnection ( self . context , sock ) self . _environ = self . get_environ ( ) return conn def wrap ( self , sock ) : return sock , self . _environ . copy ( ) def get_context ( self ) : c = SSL . Context ( SSL . SSLv23_METHOD ) c . use_privatekey_file ( self . private_key ) if self . certificate_chain : c . load_verify_locations ( self . certificate_chain ) c . use_certificate_file ( self . certificate ) return c def get_environ ( self ) : ssl_environ = { : "on" , } if self . certificate : cert = open ( self . certificate , 'rb' ) . read ( ) cert = crypto . load_certificate ( crypto . FILETYPE_PEM , cert ) ssl_environ . update ( { : cert . get_version ( ) , : cert . get_serial_number ( ) , } ) for prefix , dn in [ ( "I" , cert . get_issuer ( ) ) , ( "S" , cert . get_subject ( ) ) ] : dnstr = str ( dn ) [ 18 : - 2 ] wsgikey = 'SSL_SERVER_%s_DN' % prefix ssl_environ [ wsgikey ] = dnstr while dnstr : pos = dnstr . rfind ( "=" ) dnstr , value = dnstr [ : pos ] , dnstr [ pos + 1 : ] pos = dnstr . rfind ( "/" ) dnstr , key = dnstr [ : pos ] , dnstr [ pos + 1 : ] if key and value : wsgikey = 'SSL_SERVER_%s_DN_%s' % ( prefix , key ) ssl_environ [ wsgikey ] = value return ssl_environ def makefile ( self , sock , mode = 'r' , bufsize = - 1 ) : if SSL and isinstance ( sock , SSL . ConnectionType ) : timeout = sock . gettimeout ( ) f = SSL_fileobject ( sock , mode , bufsize ) f . ssl_timeout = timeout return f else : return wsgiserver . CP_fileobject ( sock , mode , bufsize )

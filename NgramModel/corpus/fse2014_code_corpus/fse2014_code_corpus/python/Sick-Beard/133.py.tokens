__author__ = "dbr/Ben" __version__ = "1.1" import os , sys , re from optparse import OptionParser from tvdb_api import ( tvdb_error , tvdb_shownotfound , tvdb_seasonnotfound , tvdb_episodenotfound , tvdb_episodenotfound , tvdb_attributenotfound , tvdb_userabort ) from tvdb_api import Tvdb config = { } config [ 'with_ep_name' ] = '%(seriesname)s - [%(seasno)02dx%(epno)02d] - %(epname)s.%(ext)s' config [ 'without_ep_name' ] = '%(seriesname)s - [%(seasno)02dx%(epno)02d].%(ext)s' config [ 'valid_filename_chars' ] = """0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@Â£$%^&*()_+=-[]{}"'.,<>`~? """ config [ 'force_windows_compliant_filenames' ] = False if sys . platform == "win32" or config [ 'force_windows_compliant_filenames' ] : config [ 'valid_filename_chars' ] = "" . join ( [ x for x in config [ 'valid_filename_chars' ] if x not in "\"*:<>?|\\" ] ) config [ 'name_parse_multi_ep' ] = [ ( re . compile ( '''^(.+?)[ \._\-]\[[Ss](\d+)\]((?:_\[[Ee]\d+\])+)[^\\/]*$''' ) , re . compile ( '''_\[[Ee](\d+)\]''' ) ) , ( re . compile ( '''^(.+?)[ \._\-]\[?([0-9]+)((?:[x-]\d+)+)[^\\/]*$''' ) , re . compile ( '''[x-](\d+)''' ) ) , ( re . compile ( '''^(.+?)[ \._\-][Ss]([0-9]+)((?:[\.\-_ ]?[Ee]\d+)+)[^\\/]*$''' ) , re . compile ( '''[\.\-_ ]?[Ee](\d+)''' ) ) , ( re . compile ( '''^(.+)[ \._\-]([0-9]{1})([0-9]{2})[\._ -][^\\/]*$''' ) , re . compile ( "(\d{2})" ) ) , ( re . compile ( '''^(.+)[ \._\-]([0-9]{2})([0-9]{2,3})[\._ -][^\\/]*$''' ) , re . compile ( "(\d{2,3})" ) ) ] def findFiles ( args , recursive = False , verbose = False ) : allfiles = [ ] for cfile in args : if os . path . isdir ( cfile ) : for sf in os . listdir ( cfile ) : newpath = os . path . join ( cfile , sf ) if os . path . isfile ( newpath ) : allfiles . append ( newpath ) else : if recursive : if verbose : print "Recursively scanning %s" % ( newpath ) allfiles . extend ( findFiles ( [ newpath ] , recursive = recursive , verbose = verbose ) ) elif os . path . isfile ( cfile ) : allfiles . append ( cfile ) return allfiles def processSingleName ( name , verbose = False ) : filepath , filename = os . path . split ( name ) filename , ext = os . path . splitext ( filename ) ext = ext . replace ( "." , "" , 1 ) for r in config [ 'name_parse_multi_ep' ] : match = r [ 0 ] . match ( filename ) if match : seriesname , seasno , eps = match . groups ( ) seriesname = re . sub ( "[\._]|\-(?=$)" , " " , seriesname ) . strip ( ) allEps = re . findall ( r [ 1 ] , eps ) return { 'file_seriesname' : seriesname , : int ( seasno ) , : [ int ( x ) for x in allEps ] , : filepath , : filename , : ext } else : return None def processNames ( names , verbose = False ) : allEps = [ ] for f in names : cur = processSingleName ( f , verbose = verbose ) if cur is not None : allEps . append ( cur ) return allEps def formatName ( cfile ) : if cfile [ 'epname' ] : n = config [ 'with_ep_name' ] % ( cfile ) else : n = config [ 'without_ep_name' ] % ( cfile ) return n def cleanName ( name ) : name = name . encode ( 'ascii' , 'ignore' ) return '' . join ( [ c for c in name if c in config [ 'valid_filename_chars' ] ] ) def renameFile ( oldfile , newfile , force = False ) : new_exists = os . access ( newfile , os . F_OK ) if new_exists : sys . stderr . write ( "New filename already exists.. " ) if force : sys . stderr . write ( "overwriting\n" ) os . rename ( oldfile , newfile ) else : sys . stderr . write ( "skipping\n" ) return False else : os . rename ( oldfile , newfile ) return True def processFile ( t , opts , cfile ) : try : epname = t [ cfile [ 'file_seriesname' ] ] [ cfile [ 'seasno' ] ] [ cfile [ 'epno' ] ] [ 'episodename' ] except tvdb_shownotfound : sys . stderr . write ( "! Warning: Show \"%s\" not found (for file %s.%s)\n" % ( cfile [ 'file_seriesname' ] , cfile [ 'filename' ] , cfile [ 'ext' ] ) ) cfile [ 'seriesname' ] = cfile [ 'file_seriesname' ] cfile [ 'epname' ] = None except ( tvdb_seasonnotfound , tvdb_episodenotfound , tvdb_attributenotfound ) : sys . stderr . write ( "! Warning: Episode name not found for %s (in %s)\n" % ( cfile [ 'file_seriesname' ] , cfile [ 'filepath' ] ) ) cfile [ 'seriesname' ] = t [ cfile [ 'file_seriesname' ] ] [ 'seriesname' ] cfile [ 'epname' ] = None except tvdb_error , errormsg : sys . stderr . write ( % ( errormsg ) ) cfile [ 'seriesname' ] = cfile [ 'file_seriesname' ] cfile [ 'epname' ] = None except tvdb_userabort , errormsg : print "\n" , errormsg sys . exit ( 1 ) else : cfile [ 'epname' ] = epname cfile [ 'seriesname' ] = t [ cfile [ 'file_seriesname' ] ] [ 'seriesname' ] newname = formatName ( cfile ) newname = cleanName ( newname ) oldfile = os . path . join ( cfile [ 'filepath' ] , cfile [ 'filename' ] + "." + cfile [ 'ext' ] ) newfile = os . path . join ( cfile [ 'filepath' ] , newname ) print "#" * 20 print "Old name: %s" % ( cfile [ 'filename' ] + "." + cfile [ 'ext' ] ) print "New name: %s" % ( newname ) if opts . always or ( not opts . interactive ) : rename_result = renameFile ( oldfile , newfile , force = opts . force ) if rename_result : print "..auto-renaming" else : print "..not renamed" return ans = None while ans not in [ 'y' , 'n' , 'a' , 'q' , '' ] : print "Rename?" print "([y]/n/a/q)" , try : ans = raw_input ( ) . strip ( ) except KeyboardInterrupt , errormsg : print "\n" , errormsg sys . exit ( 1 ) if len ( ans ) == 0 : print "Renaming (default)" rename_result = renameFile ( oldfile , newfile , force = opts . force ) elif ans [ 0 ] == "a" : opts . always = True rename_result = renameFile ( oldfile , newfile , force = opts . force ) elif ans [ 0 ] == "q" : print "Aborting" sys . exit ( 1 ) elif ans [ 0 ] == "y" : rename_result = renameFile ( oldfile , newfile , force = opts . force ) elif ans [ 0 ] == "n" : print "Skipping" return else : print "Invalid input, skipping" if rename_result : print "..renamed" else : print "..not renamed" def main ( ) : parser = OptionParser ( usage = "%prog [options] <file or directories>" ) parser . add_option ( "-d" , "--debug" , action = "store_true" , default = False , dest = "debug" , help = "show debugging info" ) parser . add_option ( "-b" , "--batch" , action = "store_false" , dest = "interactive" , help = "selects first search result, requires no human intervention once launched" , default = False ) parser . add_option ( "-i" , "--interactive" , action = "store_true" , dest = "interactive" , default = True , help = "interactivly select correct show from search results [default]" ) parser . add_option ( "-s" , "--selectfirst" , action = "store_true" , dest = "selectfirst" , default = False , help = "automatically select first series search result (instead of showing the select-series interface)" ) parser . add_option ( "-r" , "--recursive" , action = "store_true" , dest = "recursive" , default = True , help = "recursivly search supplied directories for files to rename" ) parser . add_option ( "-a" , "--always" , action = "store_true" , default = False , dest = "always" , help = "always renames files (but still lets user select correct show). Can be changed during runtime with the 'a' prompt-option" ) parser . add_option ( "-f" , "--force" , action = "store_true" , default = False , dest = "force" , help = "forces file to be renamed, even if it will overwrite an existing file" ) opts , args = parser . parse_args ( ) if len ( args ) == 0 : parser . error ( "No filenames or directories supplied" ) allFiles = findFiles ( args , opts . recursive , verbose = opts . debug ) validFiles = processNames ( allFiles , verbose = opts . debug ) if len ( validFiles ) == 0 : sys . stderr . write ( "No valid files found\n" ) sys . exit ( 2 ) print "#" * 20 print "# Starting tvnamer" print "# Processing %d files" % ( len ( validFiles ) ) t = Tvdb ( debug = opts . debug , interactive = opts . interactive , select_first = opts . selectfirst ) print "# ..got tvdb mirrors" print "# Starting to process files" print "#" * 20 for cfile in validFiles : print "# Processing %(file_seriesname)s (season: %(seasno)d, episode %(epno)d)" % ( cfile ) processFile ( t , opts , cfile ) print "# Done" if __name__ == "__main__" : main ( )

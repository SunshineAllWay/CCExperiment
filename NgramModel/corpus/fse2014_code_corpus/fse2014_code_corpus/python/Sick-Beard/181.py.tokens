""" Dictionnary classes which store values order. """ from lib . hachoir_core . error import HachoirError from lib . hachoir_core . i18n import _ class UniqKeyError ( HachoirError ) : pass class Dict ( object ) : def __init__ ( self , values = None ) : self . _index = { } self . _key_list = [ ] self . _value_list = [ ] if values : for key , value in values : self . append ( key , value ) def _getValues ( self ) : return self . _value_list values = property ( _getValues ) def index ( self , key ) : return self . _index . get ( key ) def __getitem__ ( self , key ) : return self . _value_list [ self . _index [ key ] ] def __setitem__ ( self , key , value ) : self . _value_list [ self . _index [ key ] ] = value def append ( self , key , value ) : if key in self . _index : raise UniqKeyError ( _ ( "Key '%s' already exists" ) % key ) self . _index [ key ] = len ( self . _value_list ) self . _key_list . append ( key ) self . _value_list . append ( value ) def __len__ ( self ) : return len ( self . _value_list ) def __contains__ ( self , key ) : return key in self . _index def __iter__ ( self ) : return iter ( self . _value_list ) def iteritems ( self ) : for index in xrange ( len ( self ) ) : yield ( self . _key_list [ index ] , self . _value_list [ index ] ) def itervalues ( self ) : return iter ( self . _value_list ) def iterkeys ( self ) : return iter ( self . _key_list ) def replace ( self , oldkey , newkey , new_value ) : index = self . _index [ oldkey ] self . _value_list [ index ] = new_value if oldkey != newkey : del self . _index [ oldkey ] self . _index [ newkey ] = index self . _key_list [ index ] = newkey def __delitem__ ( self , index ) : if index < 0 : index += len ( self . _value_list ) if not ( 0 <= index < len ( self . _value_list ) ) : raise IndexError ( _ ( "list assignment index out of range (%s/%s)" ) % ( index , len ( self . _value_list ) ) ) del self . _value_list [ index ] del self . _key_list [ index ] for key , item_index in self . _index . iteritems ( ) : if item_index == index : del self . _index [ key ] break for key , item_index in self . _index . iteritems ( ) : if index < item_index : self . _index [ key ] -= 1 def insert ( self , index , key , value ) : if key in self : raise UniqKeyError ( _ ( "Insert error: key '%s' ready exists" ) % key ) _index = index if index < 0 : index += len ( self . _value_list ) if not ( 0 <= index <= len ( self . _value_list ) ) : raise IndexError ( _ ( "Insert error: index '%s' is invalid" ) % _index ) for item_key , item_index in self . _index . iteritems ( ) : if item_index >= index : self . _index [ item_key ] += 1 self . _index [ key ] = index self . _key_list . insert ( index , key ) self . _value_list . insert ( index , value ) def __repr__ ( self ) : items = ( "%r: %r" % ( key , value ) for key , value in self . iteritems ( ) ) return "{%s}" % ", " . join ( items )

""" String field classes: - String: Fixed length string (no prefix/no suffix) ; - CString: String which ends with nul byte ("\0") ; - UnixLine: Unix line of text, string which ends with "\n" ; - PascalString8, PascalString16, PascalString32: String prefixed with length written in a 8, 16, 32-bit integer (use parent endian). Constructor has optional arguments: - strip: value can be a string or True ; - charset: if set, convert string to unicode using this charset (in "replace" mode which replace all buggy characters with "."). Note: For PascalStringXX, prefixed value is the number of bytes and not of characters! """ from lib . hachoir_core . field import FieldError , Bytes from lib . hachoir_core . endian import LITTLE_ENDIAN , BIG_ENDIAN from lib . hachoir_core . tools import alignValue , makePrintable from lib . hachoir_core . i18n import guessBytesCharset , _ from lib . hachoir_core import config from codecs import BOM_UTF16_LE , BOM_UTF16_BE , BOM_UTF32_LE , BOM_UTF32_BE FALLBACK_CHARSET = "ISO-8859-1" class GenericString ( Bytes ) : VALID_FORMATS = ( "C" , "UnixLine" , , "Pascal8" , "Pascal16" , "Pascal32" ) CHARSET_8BIT = set ( ( , , , , , , , , , , , , , , , , , , , , , , , , , , , , ) ) UTF_CHARSET = { : ( 8 , None ) , : ( 16 , LITTLE_ENDIAN ) , : ( 32 , LITTLE_ENDIAN ) , : ( 16 , BIG_ENDIAN ) , : ( 32 , BIG_ENDIAN ) , : ( 16 , "BOM" ) , : ( 32 , "BOM" ) , } UTF_BOM = { 16 : { BOM_UTF16_LE : "UTF-16-LE" , BOM_UTF16_BE : "UTF-16-BE" } , 32 : { BOM_UTF32_LE : "UTF-32LE" , BOM_UTF32_BE : "UTF-32BE" } , } SUFFIX_FORMAT = { : { 8 : { LITTLE_ENDIAN : "\0" , BIG_ENDIAN : "\0" } , 16 : { LITTLE_ENDIAN : "\0\0" , BIG_ENDIAN : "\0\0" } , 32 : { LITTLE_ENDIAN : "\0\0\0\0" , BIG_ENDIAN : "\0\0\0\0" } , } , : { 8 : { LITTLE_ENDIAN : "\n" , BIG_ENDIAN : "\n" } , 16 : { LITTLE_ENDIAN : "\n\0" , BIG_ENDIAN : "\0\n" } , 32 : { LITTLE_ENDIAN : "\n\0\0\0" , BIG_ENDIAN : "\0\0\0\n" } , } , } PASCAL_FORMATS = { : 1 , : 2 , : 4 } _raw_value = None def __init__ ( self , parent , name , format , description = None , strip = None , charset = None , nbytes = None , truncate = None ) : Bytes . __init__ ( self , parent , name , 1 , description ) assert format in self . VALID_FORMATS self . _format = format self . _strip = strip self . _truncate = truncate if not charset or charset in self . CHARSET_8BIT : self . _character_size = 1 elif charset in self . UTF_CHARSET : self . _character_size = None else : raise FieldError ( "Invalid charset for %s: \"%s\"" % ( self . path , charset ) ) self . _charset = charset if nbytes is not None : assert self . _format == "fixed" if not ( 1 <= nbytes <= 0xffff ) : raise FieldError ( "Invalid string size for %s: %s" % ( self . path , nbytes ) ) self . _content_size = nbytes self . _size = nbytes * 8 self . _content_offset = 0 else : if self . _format in self . SUFFIX_FORMAT : self . _content_offset = 0 suffix = self . suffix_str length = self . _parent . stream . searchBytesLength ( suffix , False , self . absolute_address ) if length is None : raise FieldError ( "Unable to find end of string %s (format %s)!" % ( self . path , self . _format ) ) if 1 < len ( suffix ) : length = alignValue ( length , len ( suffix ) ) self . _content_size = length self . _size = ( length + len ( suffix ) ) * 8 else : assert self . _format in self . PASCAL_FORMATS prefix_size = self . PASCAL_FORMATS [ self . _format ] self . _content_offset = prefix_size value = self . _parent . stream . readBits ( self . absolute_address , prefix_size * 8 , self . _parent . endian ) self . _content_size = value self . _size = ( prefix_size + value ) * 8 if self . _charset in self . UTF_CHARSET : bomsize , endian = self . UTF_CHARSET [ self . _charset ] if endian == "BOM" : nbytes = bomsize // 8 bom = self . _parent . stream . readBytes ( self . absolute_address , nbytes ) bom_endian = self . UTF_BOM [ bomsize ] if bom not in bom_endian : raise FieldError ( "String %s has invalid BOM (%s)!" % ( self . path , repr ( bom ) ) ) self . _charset = bom_endian [ bom ] self . _content_size -= nbytes self . _content_offset += nbytes if self . _character_size : self . _length = self . _content_size // self . _character_size else : self . _length = None @ staticmethod def staticSuffixStr ( format , charset , endian ) : if format not in GenericString . SUFFIX_FORMAT : return '' suffix = GenericString . SUFFIX_FORMAT [ format ] if charset in GenericString . UTF_CHARSET : suffix_size = GenericString . UTF_CHARSET [ charset ] [ 0 ] suffix = suffix [ suffix_size ] else : suffix = suffix [ 8 ] return suffix [ endian ] def _getSuffixStr ( self ) : return self . staticSuffixStr ( self . _format , self . _charset , self . _parent . endian ) suffix_str = property ( _getSuffixStr ) def _convertText ( self , text ) : if not self . _charset : self . _charset = guessBytesCharset ( text , default = FALLBACK_CHARSET ) try : return unicode ( text , self . _charset , "strict" ) except UnicodeDecodeError , err : pass if err . reason == "truncated data" and err . end == len ( text ) and self . _charset == "UTF-16-LE" : try : text = unicode ( text + "\0" , self . _charset , "strict" ) self . warning ( "Fix truncated %s string: add missing nul byte" % self . _charset ) return text except UnicodeDecodeError , err : pass self . warning ( u"Unable to convert string to Unicode: %s" % err ) return unicode ( text , FALLBACK_CHARSET , "strict" ) def _guessCharset ( self ) : addr = self . absolute_address + self . _content_offset * 8 bytes = self . _parent . stream . readBytes ( addr , self . _content_size ) return guessBytesCharset ( bytes , default = FALLBACK_CHARSET ) def createValue ( self , human = True ) : if human : addr = self . absolute_address + self . _content_offset * 8 size = self . _content_size else : addr = self . absolute_address size = self . _size // 8 if size == 0 : return u"" text = self . _parent . stream . readBytes ( addr , size ) if not human : return text text = self . _convertText ( text ) if self . _truncate : pos = text . find ( self . _truncate ) if 0 <= pos : text = text [ : pos ] if self . _strip : if isinstance ( self . _strip , ( str , unicode ) ) : text = text . strip ( self . _strip ) else : text = text . strip ( ) assert isinstance ( text , unicode ) return text def createDisplay ( self , human = True ) : if not human : if self . _raw_value is None : self . _raw_value = GenericString . createValue ( self , False ) value = makePrintable ( self . _raw_value , "ASCII" , to_unicode = True ) elif self . _charset : value = makePrintable ( self . value , "ISO-8859-1" , to_unicode = True ) else : value = self . value if config . max_string_length < len ( value ) : value = "%s(...)" % value [ : config . max_string_length ] if not self . _charset or not human : return makePrintable ( value , "ASCII" , quote = '"' , to_unicode = True ) else : if value : return '"%s"' % value . replace ( '"' , '\\"' ) else : return _ ( "(empty)" ) def createRawDisplay ( self ) : return GenericString . createDisplay ( self , human = False ) def _getLength ( self ) : if self . _length is None : self . _length = len ( self . value ) return self . _length length = property ( _getLength , doc = "String length in characters" ) def _getFormat ( self ) : return self . _format format = property ( _getFormat , doc = "String format (eg. 'C')" ) def _getCharset ( self ) : if not self . _charset : self . _charset = self . _guessCharset ( ) return self . _charset charset = property ( _getCharset , doc = "String charset (eg. 'ISO-8859-1')" ) def _getContentSize ( self ) : return self . _content_size content_size = property ( _getContentSize , doc = "Content size in bytes" ) def _getContentOffset ( self ) : return self . _content_offset content_offset = property ( _getContentOffset , doc = "Content offset in bytes" ) def getFieldType ( self ) : info = self . charset if self . _strip : if isinstance ( self . _strip , ( str , unicode ) ) : info += ",strip=%s" % makePrintable ( self . _strip , "ASCII" , quote = "'" ) else : info += ",strip=True" return "%s<%s>" % ( Bytes . getFieldType ( self ) , info ) def stringFactory ( name , format , doc ) : class NewString ( GenericString ) : __doc__ = doc def __init__ ( self , parent , name , description = None , strip = None , charset = None , truncate = None ) : GenericString . __init__ ( self , parent , name , format , description , strip = strip , charset = charset , truncate = truncate ) cls = NewString cls . __name__ = name return cls CString = stringFactory ( "CString" , "C" , ) UnixLine = stringFactory ( "UnixLine" , "UnixLine" , ) PascalString8 = stringFactory ( "PascalString8" , "Pascal8" , ) PascalString16 = stringFactory ( "PascalString16" , "Pascal16" , ) PascalString32 = stringFactory ( "PascalString32" , "Pascal32" , ) class String ( GenericString ) : static_size = staticmethod ( lambda * args , ** kw : args [ 1 ] * 8 ) def __init__ ( self , parent , name , nbytes , description = None , strip = None , charset = None , truncate = None ) : GenericString . __init__ ( self , parent , name , "fixed" , description , strip = strip , charset = charset , nbytes = nbytes , truncate = truncate ) String . __name__ = "FixedString"

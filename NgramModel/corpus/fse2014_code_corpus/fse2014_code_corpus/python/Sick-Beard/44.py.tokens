import datetime import os import sickbeard from sickbeard import logger , exceptions , helpers from sickbeard . metadata import generic from sickbeard import encodingKludge as ek from sickbeard import config from lib . tvdb_api import tvdb_api , tvdb_exceptions class TIVOMetadata ( generic . GenericMetadata ) : def __init__ ( self , show_metadata = False , episode_metadata = False , poster = False , fanart = False , episode_thumbnails = False , season_thumbnails = False ) : generic . GenericMetadata . __init__ ( self , show_metadata , episode_metadata , poster , fanart , episode_thumbnails , season_thumbnails ) self . _ep_nfo_extension = "txt" self . generate_ep_metadata = True self . name = 'TIVO' self . eg_show_metadata = "<i>not supported</i>" self . eg_episode_metadata = "Season##\\.meta\\<i>filename</i>.txt" self . eg_fanart = "<i>not supported</i>" self . eg_poster = "<i>not supported</i>" self . eg_episode_thumbnails = "<i>not supported</i>" self . eg_season_thumbnails = "<i>not supported</i>" def create_show_metadata ( self , show_obj ) : pass def create_fanart ( self , show_obj ) : pass def get_episode_thumb_path ( self , ep_obj ) : pass def get_season_thumb_path ( self , show_obj , season ) : pass def retrieveShowMetadata ( self , dir ) : return ( None , None ) def get_episode_file_path ( self , ep_obj ) : if ek . ek ( os . path . isfile , ep_obj . location ) : metadata_file_name = ek . ek ( os . path . basename , ep_obj . location ) + "." + self . _ep_nfo_extension metadata_dir_name = ek . ek ( os . path . join , ek . ek ( os . path . dirname , ep_obj . location ) , '.meta' ) metadata_file_path = ek . ek ( os . path . join , metadata_dir_name , metadata_file_name ) else : logger . log ( u"Episode location doesn't exist: " + str ( ep_obj . location ) , logger . DEBUG ) return '' return metadata_file_path def _ep_data ( self , ep_obj ) : data = "" ; eps_to_write = [ ep_obj ] + ep_obj . relatedEps tvdb_lang = ep_obj . show . lang try : ltvdb_api_parms = sickbeard . TVDB_API_PARMS . copy ( ) if tvdb_lang and not tvdb_lang == 'en' : ltvdb_api_parms [ 'language' ] = tvdb_lang t = tvdb_api . Tvdb ( actors = True , ** ltvdb_api_parms ) myShow = t [ ep_obj . show . tvdbid ] except tvdb_exceptions . tvdb_shownotfound , e : raise exceptions . ShowNotFoundException ( str ( e ) ) except tvdb_exceptions . tvdb_error , e : logger . log ( "Unable to connect to TVDB while creating meta files - skipping - " + str ( e ) , logger . ERROR ) return False for curEpToWrite in eps_to_write : try : myEp = myShow [ curEpToWrite . season ] [ curEpToWrite . episode ] except ( tvdb_exceptions . tvdb_episodenotfound , tvdb_exceptions . tvdb_seasonnotfound ) : logger . log ( "Unable to find episode " + str ( curEpToWrite . season ) + "x" + str ( curEpToWrite . episode ) + " on tvdb... has it been removed? Should I delete from db?" ) return None if myEp [ "firstaired" ] == None and ep_obj . season == 0 : myEp [ "firstaired" ] = str ( datetime . date . fromordinal ( 1 ) ) if myEp [ "episodename" ] == None or myEp [ "firstaired" ] == None : return None if myShow [ "seriesname" ] != None : data += ( "title : " + myShow [ "seriesname" ] + "\n" ) data += ( "seriesTitle : " + myShow [ "seriesname" ] + "\n" ) data += ( "episodeTitle : " + config . naming_ep_type [ sickbeard . NAMING_EP_TYPE ] % { 'seasonnumber' : curEpToWrite . season , 'episodenumber' : curEpToWrite . episode } + " " + curEpToWrite . name + "\n" ) data += ( "episodeNumber : " + str ( curEpToWrite . episode ) + "\n" ) data += ( "isEpisode : true\n" ) sanitizedDescription = curEpToWrite . description sanitizedDescription = sanitizedDescription . replace ( u"\u201c" , "\"" ) . replace ( u"\u201d" , "\"" ) sanitizedDescription = sanitizedDescription . replace ( u"\u2018" , "'" ) . replace ( u"\u2019" , "'" ) . replace ( u"\u02BC" , "'" ) data += ( "description : " + sanitizedDescription + "\n" ) if myShow [ "zap2it_id" ] != None : data += ( "seriesId : " + myShow [ "zap2it_id" ] + "\n" ) if myShow [ "network" ] != None : data += ( "callsign : " + myShow [ "network" ] + "\n" ) if curEpToWrite . airdate != datetime . date . fromordinal ( 1 ) : data += ( "originalAirDate : " + str ( curEpToWrite . airdate ) + "T00:00:00Z\n" ) if myShow [ "actors" ] : for actor in myShow [ "actors" ] . split ( '|' ) : if actor : data += ( "vActor : " + actor + "\n" ) if myShow [ "rating" ] != None : try : rating = float ( myShow [ 'rating' ] ) except ValueError : rating = 0.0 rating = rating / 10 * 4 data += ( "starRating : " + str ( rating ) + "\n" ) if myShow [ "contentrating" ] : data += ( "tvRating : " + str ( myShow [ "contentrating" ] ) + "\n" ) if ep_obj . show . genre : for genre in ep_obj . show . genre . split ( '|' ) : if genre : data += ( "vProgramGenre : " + str ( genre ) + "\n" ) return data def write_ep_file ( self , ep_obj ) : data = self . _ep_data ( ep_obj ) if not data : return False nfo_file_path = self . get_episode_file_path ( ep_obj ) nfo_file_dir = ek . ek ( os . path . dirname , nfo_file_path ) try : if not ek . ek ( os . path . isdir , nfo_file_dir ) : logger . log ( "Metadata dir didn't exist, creating it at " + nfo_file_dir , logger . DEBUG ) ek . ek ( os . makedirs , nfo_file_dir ) helpers . chmodAsParent ( nfo_file_dir ) logger . log ( u"Writing episode nfo file to " + nfo_file_path ) nfo_file = ek . ek ( open , nfo_file_path , 'w' ) nfo_file . write ( data . encode ( "utf-8" ) ) nfo_file . close ( ) helpers . chmodAsParent ( nfo_file_path ) except IOError , e : logger . log ( u"Unable to write file to " + nfo_file_path + " - are you sure the folder is writable? " + str ( e ) . decode ( 'utf-8' ) , logger . ERROR ) return False return True metadata_class = TIVOMetadata

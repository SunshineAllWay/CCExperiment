from __future__ import absolute_import , division , with_statement import Cookie import cgi import httplib import logging import sys import time import tornado import urllib from tornado import escape from tornado import httputil from tornado import web from tornado . escape import native_str , utf8 from tornado . util import b try : from io import BytesIO except ImportError : from cStringIO import StringIO as BytesIO class WSGIApplication ( web . Application ) : def __init__ ( self , handlers = None , default_host = "" , ** settings ) : web . Application . __init__ ( self , handlers , default_host , transforms = [ ] , wsgi = True , ** settings ) def __call__ ( self , environ , start_response ) : handler = web . Application . __call__ ( self , HTTPRequest ( environ ) ) assert handler . _finished status = str ( handler . _status_code ) + " " + httplib . responses [ handler . _status_code ] headers = handler . _headers . items ( ) for cookie_dict in getattr ( handler , "_new_cookies" , [ ] ) : for cookie in cookie_dict . values ( ) : headers . append ( ( "Set-Cookie" , cookie . OutputString ( None ) ) ) start_response ( status , [ ( native_str ( k ) , native_str ( v ) ) for ( k , v ) in headers ] ) return handler . _write_buffer class HTTPRequest ( object ) : def __init__ ( self , environ ) : self . method = environ [ "REQUEST_METHOD" ] self . path = urllib . quote ( environ . get ( "SCRIPT_NAME" , "" ) ) self . path += urllib . quote ( environ . get ( "PATH_INFO" , "" ) ) self . uri = self . path self . arguments = { } self . query = environ . get ( "QUERY_STRING" , "" ) if self . query : self . uri += "?" + self . query arguments = cgi . parse_qs ( self . query ) for name , values in arguments . iteritems ( ) : values = [ v for v in values if v ] if values : self . arguments [ name ] = values self . version = "HTTP/1.1" self . headers = httputil . HTTPHeaders ( ) if environ . get ( "CONTENT_TYPE" ) : self . headers [ "Content-Type" ] = environ [ "CONTENT_TYPE" ] if environ . get ( "CONTENT_LENGTH" ) : self . headers [ "Content-Length" ] = environ [ "CONTENT_LENGTH" ] for key in environ : if key . startswith ( "HTTP_" ) : self . headers [ key [ 5 : ] . replace ( "_" , "-" ) ] = environ [ key ] if self . headers . get ( "Content-Length" ) : self . body = environ [ "wsgi.input" ] . read ( int ( self . headers [ "Content-Length" ] ) ) else : self . body = "" self . protocol = environ [ "wsgi.url_scheme" ] self . remote_ip = environ . get ( "REMOTE_ADDR" , "" ) if environ . get ( "HTTP_HOST" ) : self . host = environ [ "HTTP_HOST" ] else : self . host = environ [ "SERVER_NAME" ] self . files = { } content_type = self . headers . get ( "Content-Type" , "" ) if content_type . startswith ( "application/x-www-form-urlencoded" ) : for name , values in cgi . parse_qs ( self . body ) . iteritems ( ) : self . arguments . setdefault ( name , [ ] ) . extend ( values ) elif content_type . startswith ( "multipart/form-data" ) : if 'boundary=' in content_type : boundary = content_type . split ( 'boundary=' , 1 ) [ 1 ] if boundary : httputil . parse_multipart_form_data ( utf8 ( boundary ) , self . body , self . arguments , self . files ) else : logging . warning ( "Invalid multipart/form-data" ) self . _start_time = time . time ( ) self . _finish_time = None def supports_http_1_1 ( self ) : return self . version == "HTTP/1.1" @ property def cookies ( self ) : if not hasattr ( self , "_cookies" ) : self . _cookies = Cookie . SimpleCookie ( ) if "Cookie" in self . headers : try : self . _cookies . load ( native_str ( self . headers [ "Cookie" ] ) ) except Exception : self . _cookies = None return self . _cookies def full_url ( self ) : return self . protocol + "://" + self . host + self . uri def request_time ( self ) : if self . _finish_time is None : return time . time ( ) - self . _start_time else : return self . _finish_time - self . _start_time class WSGIContainer ( object ) : def __init__ ( self , wsgi_application ) : self . wsgi_application = wsgi_application def __call__ ( self , request ) : data = { } response = [ ] def start_response ( status , response_headers , exc_info = None ) : data [ "status" ] = status data [ "headers" ] = response_headers return response . append app_response = self . wsgi_application ( WSGIContainer . environ ( request ) , start_response ) response . extend ( app_response ) body = b ( "" ) . join ( response ) if hasattr ( app_response , "close" ) : app_response . close ( ) if not data : raise Exception ( "WSGI app did not call start_response" ) status_code = int ( data [ "status" ] . split ( ) [ 0 ] ) headers = data [ "headers" ] header_set = set ( k . lower ( ) for ( k , v ) in headers ) body = escape . utf8 ( body ) if "content-length" not in header_set : headers . append ( ( "Content-Length" , str ( len ( body ) ) ) ) if "content-type" not in header_set : headers . append ( ( "Content-Type" , "text/html; charset=UTF-8" ) ) if "server" not in header_set : headers . append ( ( "Server" , "TornadoServer/%s" % tornado . version ) ) parts = [ escape . utf8 ( "HTTP/1.1 " + data [ "status" ] + "\r\n" ) ] for key , value in headers : parts . append ( escape . utf8 ( key ) + b ( ": " ) + escape . utf8 ( value ) + b ( "\r\n" ) ) parts . append ( b ( "\r\n" ) ) parts . append ( body ) request . write ( b ( "" ) . join ( parts ) ) request . finish ( ) self . _log ( status_code , request ) @ staticmethod def environ ( request ) : hostport = request . host . split ( ":" ) if len ( hostport ) == 2 : host = hostport [ 0 ] port = int ( hostport [ 1 ] ) else : host = request . host port = 443 if request . protocol == "https" else 80 environ = { : request . method , : "" , : urllib . unquote ( request . path ) , : request . query , : request . remote_ip , : host , : str ( port ) , : request . version , : ( 1 , 0 ) , : request . protocol , : BytesIO ( escape . utf8 ( request . body ) ) , : sys . stderr , : False , : True , : False , } if "Content-Type" in request . headers : environ [ "CONTENT_TYPE" ] = request . headers . pop ( "Content-Type" ) if "Content-Length" in request . headers : environ [ "CONTENT_LENGTH" ] = request . headers . pop ( "Content-Length" ) for key , value in request . headers . iteritems ( ) : environ [ "HTTP_" + key . replace ( "-" , "_" ) . upper ( ) ] = value return environ def _log ( self , status_code , request ) : if status_code < 400 : log_method = logging . info elif status_code < 500 : log_method = logging . warning else : log_method = logging . error request_time = 1000.0 * request . request_time ( ) summary = request . method + " " + request . uri + " (" + request . remote_ip + ")" log_method ( "%d %s %.2fms" , status_code , summary , request_time )

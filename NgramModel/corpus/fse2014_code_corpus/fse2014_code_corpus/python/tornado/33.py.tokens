from __future__ import absolute_import , division , with_statement import functools import logging import os import pkgutil import sys import types import subprocess from tornado import ioloop from tornado import process try : import signal except ImportError : signal = None def start ( io_loop = None , check_time = 500 ) : io_loop = io_loop or ioloop . IOLoop . instance ( ) add_reload_hook ( functools . partial ( _close_all_fds , io_loop ) ) modify_times = { } callback = functools . partial ( _reload_on_update , modify_times ) scheduler = ioloop . PeriodicCallback ( callback , check_time , io_loop = io_loop ) scheduler . start ( ) def wait ( ) : io_loop = ioloop . IOLoop ( ) start ( io_loop ) io_loop . start ( ) _watched_files = set ( ) def watch ( filename ) : _watched_files . add ( filename ) _reload_hooks = [ ] def add_reload_hook ( fn ) : _reload_hooks . append ( fn ) def _close_all_fds ( io_loop ) : for fd in io_loop . _handlers . keys ( ) : try : os . close ( fd ) except Exception : pass _reload_attempted = False def _reload_on_update ( modify_times ) : if _reload_attempted : return if process . task_id ( ) is not None : return for module in sys . modules . values ( ) : if not isinstance ( module , types . ModuleType ) : continue path = getattr ( module , "__file__" , None ) if not path : continue if path . endswith ( ".pyc" ) or path . endswith ( ".pyo" ) : path = path [ : - 1 ] _check_file ( modify_times , path ) for path in _watched_files : _check_file ( modify_times , path ) def _check_file ( modify_times , path ) : try : modified = os . stat ( path ) . st_mtime except Exception : return if path not in modify_times : modify_times [ path ] = modified return if modify_times [ path ] != modified : logging . info ( "%s modified; restarting server" , path ) _reload ( ) def _reload ( ) : global _reload_attempted _reload_attempted = True for fn in _reload_hooks : fn ( ) if hasattr ( signal , "setitimer" ) : signal . setitimer ( signal . ITIMER_REAL , 0 , 0 ) if sys . platform == 'win32' : subprocess . Popen ( [ sys . executable ] + sys . argv ) sys . exit ( 0 ) else : try : os . execv ( sys . executable , [ sys . executable ] + sys . argv ) except OSError : os . spawnv ( os . P_NOWAIT , sys . executable , [ sys . executable ] + sys . argv ) sys . exit ( 0 ) _USAGE = """\ Usage: python -m tornado.autoreload -m module.to.run [args...] python -m tornado.autoreload path/to/script.py [args...] """ def main ( ) : original_argv = sys . argv sys . argv = sys . argv [ : ] if len ( sys . argv ) >= 3 and sys . argv [ 1 ] == "-m" : mode = "module" module = sys . argv [ 2 ] del sys . argv [ 1 : 3 ] elif len ( sys . argv ) >= 2 : mode = "script" script = sys . argv [ 1 ] sys . argv = sys . argv [ 1 : ] else : print >> sys . stderr , _USAGE sys . exit ( 1 ) try : if mode == "module" : import runpy runpy . run_module ( module , run_name = "__main__" , alter_sys = True ) elif mode == "script" : with open ( script ) as f : global __file__ __file__ = script exec f . read ( ) in globals ( ) , globals ( ) except SystemExit , e : logging . info ( "Script exited with status %s" , e . code ) except Exception , e : logging . warning ( "Script exited with uncaught exception" , exc_info = True ) if isinstance ( e , SyntaxError ) : watch ( e . filename ) else : logging . info ( "Script exited normally" ) sys . argv = original_argv if mode == 'module' : watch ( pkgutil . get_loader ( module ) . get_filename ( ) ) wait ( ) if __name__ == "__main__" : path_prefix = '.' + os . pathsep if ( sys . path [ 0 ] == '' and not os . environ . get ( "PYTHONPATH" , "" ) . startswith ( path_prefix ) ) : os . environ [ "PYTHONPATH" ] = path_prefix + os . environ . get ( "PYTHONPATH" , "" ) elif sys . path [ 0 ] == os . path . dirname ( __file__ ) : del sys . path [ 0 ] main ( )

from __future__ import absolute_import , division , with_statement import tornado . escape import unittest from tornado . escape import utf8 , xhtml_escape , xhtml_unescape , url_escape , url_unescape , to_unicode , json_decode , json_encode from tornado . util import b linkify_tests = [ ( "hello http://world.com/!" , { } , ) , ( "hello http://world.com/with?param=true&stuff=yes" , { } , ) , ( "http://url.com/w(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , { } , ) , ( "http://url.com/withmany......................................." , { } , ) , ( "http://url.com/withmany((((((((((((((((((((((((((((((((((a)" , { } , ) , ( "http://foo.com/blah_blah" , { } , ) , ( "http://foo.com/blah_blah/" , { } , ) , ( "(Something like http://foo.com/blah_blah)" , { } , ) , ( "http://foo.com/blah_blah_(wikipedia)" , { } , ) , ( "http://foo.com/blah_(blah)_(wikipedia)_blah" , { } , ) , ( "(Something like http://foo.com/blah_blah_(wikipedia))" , { } , ) , ( "http://foo.com/blah_blah." , { } , ) , ( "http://foo.com/blah_blah/." , { } , ) , ( "<http://foo.com/blah_blah>" , { } , ) , ( "<http://foo.com/blah_blah/>" , { } , ) , ( "http://foo.com/blah_blah," , { } , ) , ( "http://www.example.com/wpstyle/?p=364." , { } , ) , ( "rdar://1234" , { "permitted_protocols" : [ "http" , "rdar" ] } , ) , ( "rdar:/1234" , { "permitted_protocols" : [ "rdar" ] } , ) , ( "http://userid:password@example.com:8080" , { } , ) , ( "http://userid@example.com" , { } , ) , ( "http://userid@example.com:8080" , { } , ) , ( "http://userid:password@example.com" , { } , ) , ( "message://%3c330e7f8409726r6a4ba78dkf1fd71420c1bf6ff@mail.gmail.com%3e" , { "permitted_protocols" : [ "http" , "message" ] } , ) , ( u"http://\u27a1.ws/\u4a39" , { } , ) , ( "<tag>http://example.com</tag>" , { } , ) , ( "Just a www.example.com link." , { } , ) , ( "Just a www.example.com link." , { "require_protocol" : True } , ) , ( "A http://reallylong.com/link/that/exceedsthelenglimit.html" , { "require_protocol" : True , "shorten" : True } , ) , ( "A http://reallylongdomainnamethatwillbetoolong.com/hi!" , { "shorten" : True } , ) , ( "A file:///passwords.txt and http://web.com link" , { } , ) , ( "A file:///passwords.txt and http://web.com link" , { "permitted_protocols" : [ "file" ] } , ) , ( "www.external-link.com" , { "extra_params" : 'rel="nofollow" class="external"' } , ) , ] class EscapeTestCase ( unittest . TestCase ) : def test_linkify ( self ) : for text , kwargs , html in linkify_tests : linked = tornado . escape . linkify ( text , ** kwargs ) self . assertEqual ( linked , html ) def test_xhtml_escape ( self ) : tests = [ ( "<foo>" , "&lt;foo&gt;" ) , ( u"<foo>" , u"&lt;foo&gt;" ) , ( b ( "<foo>" ) , b ( "&lt;foo&gt;" ) ) , ( "<>&\"" , "&lt;&gt;&amp;&quot;" ) , ( "&amp;" , "&amp;amp;" ) , ] for unescaped , escaped in tests : self . assertEqual ( utf8 ( xhtml_escape ( unescaped ) ) , utf8 ( escaped ) ) self . assertEqual ( utf8 ( unescaped ) , utf8 ( xhtml_unescape ( escaped ) ) ) def test_url_escape ( self ) : tests = [ ( u'\u00e9' . encode ( 'utf8' ) , '%C3%A9' ) , ( u'\u00e9' . encode ( 'latin1' ) , '%E9' ) , ( u'\u00e9' , '%C3%A9' ) , ] for unescaped , escaped in tests : self . assertEqual ( url_escape ( unescaped ) , escaped ) def test_url_unescape ( self ) : tests = [ ( '%C3%A9' , u'\u00e9' , 'utf8' ) , ( '%C3%A9' , u'\u00c3\u00a9' , 'latin1' ) , ( '%C3%A9' , utf8 ( u'\u00e9' ) , None ) , ] for escaped , unescaped , encoding in tests : self . assertEqual ( url_unescape ( to_unicode ( escaped ) , encoding ) , unescaped ) self . assertEqual ( url_unescape ( utf8 ( escaped ) , encoding ) , unescaped ) def test_escape_return_types ( self ) : self . assertEqual ( type ( xhtml_escape ( "foo" ) ) , str ) self . assertEqual ( type ( xhtml_escape ( u"foo" ) ) , unicode ) def test_json_decode ( self ) : self . assertEqual ( json_decode ( b ( '"foo"' ) ) , u"foo" ) self . assertEqual ( json_decode ( u'"foo"' ) , u"foo" ) self . assertEqual ( json_decode ( utf8 ( u'"\u00e9"' ) ) , u"\u00e9" ) def test_json_encode ( self ) : self . assertEqual ( json_decode ( json_encode ( u"\u00e9" ) ) , u"\u00e9" ) self . assertEqual ( json_decode ( json_encode ( utf8 ( u"\u00e9" ) ) ) , u"\u00e9" ) self . assertRaises ( UnicodeDecodeError , json_encode , b ( "\xe9" ) )

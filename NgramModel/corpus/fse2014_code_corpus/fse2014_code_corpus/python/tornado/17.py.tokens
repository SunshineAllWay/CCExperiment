from __future__ import absolute_import , division , with_statement import Cookie import base64 import binascii import calendar import datetime import email . utils import functools import gzip import hashlib import hmac import httplib import itertools import logging import mimetypes import os . path import re import stat import sys import threading import time import tornado import traceback import types import urllib import urlparse import uuid from tornado import escape from tornado import locale from tornado import stack_context from tornado import template from tornado . escape import utf8 , _unicode from tornado . util import b , bytes_type , import_object , ObjectDict try : from io import BytesIO except ImportError : from cStringIO import StringIO as BytesIO class RequestHandler ( object ) : SUPPORTED_METHODS = ( "GET" , "HEAD" , "POST" , "DELETE" , "PUT" , "OPTIONS" ) _template_loaders = { } _template_loader_lock = threading . Lock ( ) def __init__ ( self , application , request , ** kwargs ) : self . application = application self . request = request self . _headers_written = False self . _finished = False self . _auto_finish = True self . _transforms = None self . ui = ObjectDict ( ( n , self . _ui_method ( m ) ) for n , m in application . ui_methods . iteritems ( ) ) self . ui [ "_modules" ] = ObjectDict ( ( n , self . _ui_module ( n , m ) ) for n , m in application . ui_modules . iteritems ( ) ) self . ui [ "modules" ] = self . ui [ "_modules" ] self . clear ( ) if hasattr ( self . request , "connection" ) : self . request . connection . stream . set_close_callback ( self . on_connection_close ) self . initialize ( ** kwargs ) def initialize ( self ) : pass @ property def settings ( self ) : return self . application . settings def head ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def get ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def post ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def delete ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def put ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def options ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def prepare ( self ) : pass def on_finish ( self ) : pass def on_connection_close ( self ) : pass def clear ( self ) : self . _headers = { : "TornadoServer/%s" % tornado . version , : "text/html; charset=UTF-8" , } self . _list_headers = [ ] self . set_default_headers ( ) if not self . request . supports_http_1_1 ( ) : if self . request . headers . get ( "Connection" ) == "Keep-Alive" : self . set_header ( "Connection" , "Keep-Alive" ) self . _write_buffer = [ ] self . _status_code = 200 def set_default_headers ( self ) : pass def set_status ( self , status_code ) : assert status_code in httplib . responses self . _status_code = status_code def get_status ( self ) : return self . _status_code def set_header ( self , name , value ) : self . _headers [ name ] = self . _convert_header_value ( value ) def add_header ( self , name , value ) : self . _list_headers . append ( ( name , self . _convert_header_value ( value ) ) ) def _convert_header_value ( self , value ) : if isinstance ( value , bytes_type ) : pass elif isinstance ( value , unicode ) : value = value . encode ( 'utf-8' ) elif isinstance ( value , ( int , long ) ) : return str ( value ) elif isinstance ( value , datetime . datetime ) : t = calendar . timegm ( value . utctimetuple ( ) ) return email . utils . formatdate ( t , localtime = False , usegmt = True ) else : raise TypeError ( "Unsupported header value %r" % value ) if len ( value ) > 4000 or re . match ( b ( r"[\x00-\x1f]" ) , value ) : raise ValueError ( "Unsafe header value %r" , value ) return value _ARG_DEFAULT = [ ] def get_argument ( self , name , default = _ARG_DEFAULT , strip = True ) : args = self . get_arguments ( name , strip = strip ) if not args : if default is self . _ARG_DEFAULT : raise HTTPError ( 400 , "Missing argument %s" % name ) return default return args [ - 1 ] def get_arguments ( self , name , strip = True ) : values = [ ] for v in self . request . arguments . get ( name , [ ] ) : v = self . decode_argument ( v , name = name ) if isinstance ( v , unicode ) : v = re . sub ( r"[\x00-\x08\x0e-\x1f]" , " " , v ) if strip : v = v . strip ( ) values . append ( v ) return values def decode_argument ( self , value , name = None ) : return _unicode ( value ) @ property def cookies ( self ) : return self . request . cookies def get_cookie ( self , name , default = None ) : if self . request . cookies is not None and name in self . request . cookies : return self . request . cookies [ name ] . value return default def set_cookie ( self , name , value , domain = None , expires = None , path = "/" , expires_days = None , ** kwargs ) : name = escape . native_str ( name ) value = escape . native_str ( value ) if re . search ( r"[\x00-\x20]" , name + value ) : raise ValueError ( "Invalid cookie %r: %r" % ( name , value ) ) if not hasattr ( self , "_new_cookies" ) : self . _new_cookies = [ ] new_cookie = Cookie . SimpleCookie ( ) self . _new_cookies . append ( new_cookie ) new_cookie [ name ] = value if domain : new_cookie [ name ] [ "domain" ] = domain if expires_days is not None and not expires : expires = datetime . datetime . utcnow ( ) + datetime . timedelta ( days = expires_days ) if expires : timestamp = calendar . timegm ( expires . utctimetuple ( ) ) new_cookie [ name ] [ "expires" ] = email . utils . formatdate ( timestamp , localtime = False , usegmt = True ) if path : new_cookie [ name ] [ "path" ] = path for k , v in kwargs . iteritems ( ) : if k == 'max_age' : k = 'max-age' new_cookie [ name ] [ k ] = v def clear_cookie ( self , name , path = "/" , domain = None ) : expires = datetime . datetime . utcnow ( ) - datetime . timedelta ( days = 365 ) self . set_cookie ( name , value = "" , path = path , expires = expires , domain = domain ) def clear_all_cookies ( self ) : for name in self . request . cookies . iterkeys ( ) : self . clear_cookie ( name ) def set_secure_cookie ( self , name , value , expires_days = 30 , ** kwargs ) : self . set_cookie ( name , self . create_signed_value ( name , value ) , expires_days = expires_days , ** kwargs ) def create_signed_value ( self , name , value ) : self . require_setting ( "cookie_secret" , "secure cookies" ) return create_signed_value ( self . application . settings [ "cookie_secret" ] , name , value ) def get_secure_cookie ( self , name , value = None , max_age_days = 31 ) : self . require_setting ( "cookie_secret" , "secure cookies" ) if value is None : value = self . get_cookie ( name ) return decode_signed_value ( self . application . settings [ "cookie_secret" ] , name , value , max_age_days = max_age_days ) def redirect ( self , url , permanent = False , status = None ) : if self . _headers_written : raise Exception ( "Cannot redirect after headers have been written" ) if status is None : status = 301 if permanent else 302 else : assert isinstance ( status , int ) and 300 <= status <= 399 self . set_status ( status ) url = re . sub ( b ( r"[\x00-\x20]+" ) , "" , utf8 ( url ) ) self . set_header ( "Location" , urlparse . urljoin ( utf8 ( self . request . uri ) , url ) ) self . finish ( ) def write ( self , chunk ) : if self . _finished : raise RuntimeError ( "Cannot write() after finish(). May be caused " ) if isinstance ( chunk , dict ) : chunk = escape . json_encode ( chunk ) self . set_header ( "Content-Type" , "application/json; charset=UTF-8" ) chunk = utf8 ( chunk ) self . _write_buffer . append ( chunk ) def render ( self , template_name , ** kwargs ) : html = self . render_string ( template_name , ** kwargs ) js_embed = [ ] js_files = [ ] css_embed = [ ] css_files = [ ] html_heads = [ ] html_bodies = [ ] for module in getattr ( self , "_active_modules" , { } ) . itervalues ( ) : embed_part = module . embedded_javascript ( ) if embed_part : js_embed . append ( utf8 ( embed_part ) ) file_part = module . javascript_files ( ) if file_part : if isinstance ( file_part , ( unicode , bytes_type ) ) : js_files . append ( file_part ) else : js_files . extend ( file_part ) embed_part = module . embedded_css ( ) if embed_part : css_embed . append ( utf8 ( embed_part ) ) file_part = module . css_files ( ) if file_part : if isinstance ( file_part , ( unicode , bytes_type ) ) : css_files . append ( file_part ) else : css_files . extend ( file_part ) head_part = module . html_head ( ) if head_part : html_heads . append ( utf8 ( head_part ) ) body_part = module . html_body ( ) if body_part : html_bodies . append ( utf8 ( body_part ) ) def is_absolute ( path ) : return any ( path . startswith ( x ) for x in [ "/" , "http:" , "https:" ] ) if js_files : paths = [ ] unique_paths = set ( ) for path in js_files : if not is_absolute ( path ) : path = self . static_url ( path ) if path not in unique_paths : paths . append ( path ) unique_paths . add ( path ) js = '' . join ( '<script src="' + escape . xhtml_escape ( p ) + for p in paths ) sloc = html . rindex ( b ( '</body>' ) ) html = html [ : sloc ] + utf8 ( js ) + b ( '\n' ) + html [ sloc : ] if js_embed : js = b ( '<script type="text/javascript">\n//<![CDATA[\n' ) + b ( '\n' ) . join ( js_embed ) + b ( '\n//]]>\n</script>' ) sloc = html . rindex ( b ( '</body>' ) ) html = html [ : sloc ] + js + b ( '\n' ) + html [ sloc : ] if css_files : paths = [ ] unique_paths = set ( ) for path in css_files : if not is_absolute ( path ) : path = self . static_url ( path ) if path not in unique_paths : paths . append ( path ) unique_paths . add ( path ) css = '' . join ( '<link href="' + escape . xhtml_escape ( p ) + '" ' for p in paths ) hloc = html . index ( b ( '</head>' ) ) html = html [ : hloc ] + utf8 ( css ) + b ( '\n' ) + html [ hloc : ] if css_embed : css = b ( '<style type="text/css">\n' ) + b ( '\n' ) . join ( css_embed ) + b ( '\n</style>' ) hloc = html . index ( b ( '</head>' ) ) html = html [ : hloc ] + css + b ( '\n' ) + html [ hloc : ] if html_heads : hloc = html . index ( b ( '</head>' ) ) html = html [ : hloc ] + b ( '' ) . join ( html_heads ) + b ( '\n' ) + html [ hloc : ] if html_bodies : hloc = html . index ( b ( '</body>' ) ) html = html [ : hloc ] + b ( '' ) . join ( html_bodies ) + b ( '\n' ) + html [ hloc : ] self . finish ( html ) def render_string ( self , template_name , ** kwargs ) : template_path = self . get_template_path ( ) if not template_path : frame = sys . _getframe ( 0 ) web_file = frame . f_code . co_filename while frame . f_code . co_filename == web_file : frame = frame . f_back template_path = os . path . dirname ( frame . f_code . co_filename ) with RequestHandler . _template_loader_lock : if template_path not in RequestHandler . _template_loaders : loader = self . create_template_loader ( template_path ) RequestHandler . _template_loaders [ template_path ] = loader else : loader = RequestHandler . _template_loaders [ template_path ] t = loader . load ( template_name ) args = dict ( handler = self , request = self . request , current_user = self . current_user , locale = self . locale , _ = self . locale . translate , static_url = self . static_url , xsrf_form_html = self . xsrf_form_html , reverse_url = self . application . reverse_url ) args . update ( self . ui ) args . update ( kwargs ) return t . generate ( ** args ) def create_template_loader ( self , template_path ) : settings = self . application . settings if "template_loader" in settings : return settings [ "template_loader" ] kwargs = { } if "autoescape" in settings : kwargs [ "autoescape" ] = settings [ "autoescape" ] return template . Loader ( template_path , ** kwargs ) def flush ( self , include_footers = False , callback = None ) : if self . application . _wsgi : raise Exception ( "WSGI applications do not support flush()" ) chunk = b ( "" ) . join ( self . _write_buffer ) self . _write_buffer = [ ] if not self . _headers_written : self . _headers_written = True for transform in self . _transforms : self . _headers , chunk = transform . transform_first_chunk ( self . _headers , chunk , include_footers ) headers = self . _generate_headers ( ) else : for transform in self . _transforms : chunk = transform . transform_chunk ( chunk , include_footers ) headers = b ( "" ) if self . request . method == "HEAD" : if headers : self . request . write ( headers , callback = callback ) return if headers or chunk : self . request . write ( headers + chunk , callback = callback ) def finish ( self , chunk = None ) : if self . _finished : raise RuntimeError ( "finish() called twice. May be caused " ) if chunk is not None : self . write ( chunk ) if not self . _headers_written : if ( self . _status_code == 200 and self . request . method in ( "GET" , "HEAD" ) and not in self . _headers ) : etag = self . compute_etag ( ) if etag is not None : inm = self . request . headers . get ( "If-None-Match" ) if inm and inm . find ( etag ) != - 1 : self . _write_buffer = [ ] self . set_status ( 304 ) else : self . set_header ( "Etag" , etag ) if "Content-Length" not in self . _headers : content_length = sum ( len ( part ) for part in self . _write_buffer ) self . set_header ( "Content-Length" , content_length ) if hasattr ( self . request , "connection" ) : self . request . connection . stream . set_close_callback ( None ) if not self . application . _wsgi : self . flush ( include_footers = True ) self . request . finish ( ) self . _log ( ) self . _finished = True self . on_finish ( ) def send_error ( self , status_code = 500 , ** kwargs ) : if self . _headers_written : logging . error ( "Cannot send error response after headers written" ) if not self . _finished : self . finish ( ) return self . clear ( ) self . set_status ( status_code ) try : self . write_error ( status_code , ** kwargs ) except Exception : logging . error ( "Uncaught exception in write_error" , exc_info = True ) if not self . _finished : self . finish ( ) def write_error ( self , status_code , ** kwargs ) : if hasattr ( self , 'get_error_html' ) : if 'exc_info' in kwargs : exc_info = kwargs . pop ( 'exc_info' ) kwargs [ 'exception' ] = exc_info [ 1 ] try : raise exc_info [ 0 ] , exc_info [ 1 ] , exc_info [ 2 ] except Exception : self . finish ( self . get_error_html ( status_code , ** kwargs ) ) else : self . finish ( self . get_error_html ( status_code , ** kwargs ) ) return if self . settings . get ( "debug" ) and "exc_info" in kwargs : self . set_header ( 'Content-Type' , 'text/plain' ) for line in traceback . format_exception ( * kwargs [ "exc_info" ] ) : self . write ( line ) self . finish ( ) else : self . finish ( "<html><title>%(code)d: %(message)s</title>" % { : status_code , : httplib . responses [ status_code ] , } ) @ property def locale ( self ) : if not hasattr ( self , "_locale" ) : self . _locale = self . get_user_locale ( ) if not self . _locale : self . _locale = self . get_browser_locale ( ) assert self . _locale return self . _locale def get_user_locale ( self ) : return None def get_browser_locale ( self , default = "en_US" ) : if "Accept-Language" in self . request . headers : languages = self . request . headers [ "Accept-Language" ] . split ( "," ) locales = [ ] for language in languages : parts = language . strip ( ) . split ( ";" ) if len ( parts ) > 1 and parts [ 1 ] . startswith ( "q=" ) : try : score = float ( parts [ 1 ] [ 2 : ] ) except ( ValueError , TypeError ) : score = 0.0 else : score = 1.0 locales . append ( ( parts [ 0 ] , score ) ) if locales : locales . sort ( key = lambda ( l , s ) : s , reverse = True ) codes = [ l [ 0 ] for l in locales ] return locale . get ( * codes ) return locale . get ( default ) @ property def current_user ( self ) : if not hasattr ( self , "_current_user" ) : self . _current_user = self . get_current_user ( ) return self . _current_user def get_current_user ( self ) : return None def get_login_url ( self ) : self . require_setting ( "login_url" , "@tornado.web.authenticated" ) return self . application . settings [ "login_url" ] def get_template_path ( self ) : return self . application . settings . get ( "template_path" ) @ property def xsrf_token ( self ) : if not hasattr ( self , "_xsrf_token" ) : token = self . get_cookie ( "_xsrf" ) if not token : token = binascii . b2a_hex ( uuid . uuid4 ( ) . bytes ) expires_days = 30 if self . current_user else None self . set_cookie ( "_xsrf" , token , expires_days = expires_days ) self . _xsrf_token = token return self . _xsrf_token def check_xsrf_cookie ( self ) : token = ( self . get_argument ( "_xsrf" , None ) or self . request . headers . get ( "X-Xsrftoken" ) or self . request . headers . get ( "X-Csrftoken" ) ) if not token : raise HTTPError ( 403 , "'_xsrf' argument missing from POST" ) if self . xsrf_token != token : raise HTTPError ( 403 , "XSRF cookie does not match POST argument" ) def xsrf_form_html ( self ) : return '<input type="hidden" name="_xsrf" value="' + escape . xhtml_escape ( self . xsrf_token ) + '"/>' def static_url ( self , path , include_host = None ) : self . require_setting ( "static_path" , "static_url" ) static_handler_class = self . settings . get ( , StaticFileHandler ) if include_host is None : include_host = getattr ( self , "include_host" , False ) if include_host : base = self . request . protocol + "://" + self . request . host else : base = "" return base + static_handler_class . make_static_url ( self . settings , path ) def async_callback ( self , callback , * args , ** kwargs ) : if callback is None : return None if args or kwargs : callback = functools . partial ( callback , * args , ** kwargs ) def wrapper ( * args , ** kwargs ) : try : return callback ( * args , ** kwargs ) except Exception , e : if self . _headers_written : logging . error ( "Exception after headers written" , exc_info = True ) else : self . _handle_request_exception ( e ) return wrapper def require_setting ( self , name , feature = "this feature" ) : if not self . application . settings . get ( name ) : raise Exception ( "You must define the '%s' setting in your " % ( name , feature ) ) def reverse_url ( self , name , * args ) : return self . application . reverse_url ( name , * args ) def compute_etag ( self ) : hasher = hashlib . sha1 ( ) for part in self . _write_buffer : hasher . update ( part ) return '"%s"' % hasher . hexdigest ( ) def _stack_context_handle_exception ( self , type , value , traceback ) : try : raise type , value , traceback except Exception : self . _handle_request_exception ( value ) return True def _execute ( self , transforms , * args , ** kwargs ) : self . _transforms = transforms try : if self . request . method not in self . SUPPORTED_METHODS : raise HTTPError ( 405 ) if self . request . method not in ( "GET" , "HEAD" , "OPTIONS" ) and self . application . settings . get ( "xsrf_cookies" ) : self . check_xsrf_cookie ( ) self . prepare ( ) if not self . _finished : args = [ self . decode_argument ( arg ) for arg in args ] kwargs = dict ( ( k , self . decode_argument ( v , name = k ) ) for ( k , v ) in kwargs . iteritems ( ) ) getattr ( self , self . request . method . lower ( ) ) ( * args , ** kwargs ) if self . _auto_finish and not self . _finished : self . finish ( ) except Exception , e : self . _handle_request_exception ( e ) def _generate_headers ( self ) : lines = [ utf8 ( self . request . version + " " + str ( self . _status_code ) + + httplib . responses [ self . _status_code ] ) ] lines . extend ( [ ( utf8 ( n ) + b ( ": " ) + utf8 ( v ) ) for n , v in itertools . chain ( self . _headers . iteritems ( ) , self . _list_headers ) ] ) for cookie_dict in getattr ( self , "_new_cookies" , [ ] ) : for cookie in cookie_dict . values ( ) : lines . append ( utf8 ( "Set-Cookie: " + cookie . OutputString ( None ) ) ) return b ( "\r\n" ) . join ( lines ) + b ( "\r\n\r\n" ) def _log ( self ) : self . application . log_request ( self ) def _request_summary ( self ) : return self . request . method + " " + self . request . uri + " (" + self . request . remote_ip + ")" def _handle_request_exception ( self , e ) : if isinstance ( e , HTTPError ) : if e . log_message : format = "%d %s: " + e . log_message args = [ e . status_code , self . _request_summary ( ) ] + list ( e . args ) logging . warning ( format , * args ) if e . status_code not in httplib . responses : logging . error ( "Bad HTTP status code: %d" , e . status_code ) self . send_error ( 500 , exc_info = sys . exc_info ( ) ) else : self . send_error ( e . status_code , exc_info = sys . exc_info ( ) ) else : logging . error ( "Uncaught exception %s\n%r" , self . _request_summary ( ) , self . request , exc_info = True ) self . send_error ( 500 , exc_info = sys . exc_info ( ) ) def _ui_module ( self , name , module ) : def render ( * args , ** kwargs ) : if not hasattr ( self , "_active_modules" ) : self . _active_modules = { } if name not in self . _active_modules : self . _active_modules [ name ] = module ( self ) rendered = self . _active_modules [ name ] . render ( * args , ** kwargs ) return rendered return render def _ui_method ( self , method ) : return lambda * args , ** kwargs : method ( self , * args , ** kwargs ) def asynchronous ( method ) : @ functools . wraps ( method ) def wrapper ( self , * args , ** kwargs ) : if self . application . _wsgi : raise Exception ( "@asynchronous is not supported for WSGI apps" ) self . _auto_finish = False with stack_context . ExceptionStackContext ( self . _stack_context_handle_exception ) : return method ( self , * args , ** kwargs ) return wrapper def removeslash ( method ) : @ functools . wraps ( method ) def wrapper ( self , * args , ** kwargs ) : if self . request . path . endswith ( "/" ) : if self . request . method in ( "GET" , "HEAD" ) : uri = self . request . path . rstrip ( "/" ) if uri : if self . request . query : uri += "?" + self . request . query self . redirect ( uri ) return else : raise HTTPError ( 404 ) return method ( self , * args , ** kwargs ) return wrapper def addslash ( method ) : @ functools . wraps ( method ) def wrapper ( self , * args , ** kwargs ) : if not self . request . path . endswith ( "/" ) : if self . request . method in ( "GET" , "HEAD" ) : uri = self . request . path + "/" if self . request . query : uri += "?" + self . request . query self . redirect ( uri ) return raise HTTPError ( 404 ) return method ( self , * args , ** kwargs ) return wrapper class Application ( object ) : def __init__ ( self , handlers = None , default_host = "" , transforms = None , wsgi = False , ** settings ) : if transforms is None : self . transforms = [ ] if settings . get ( "gzip" ) : self . transforms . append ( GZipContentEncoding ) self . transforms . append ( ChunkedTransferEncoding ) else : self . transforms = transforms self . handlers = [ ] self . named_handlers = { } self . default_host = default_host self . settings = settings self . ui_modules = { 'linkify' : _linkify , : _xsrf_form_html , : TemplateModule , } self . ui_methods = { } self . _wsgi = wsgi self . _load_ui_modules ( settings . get ( "ui_modules" , { } ) ) self . _load_ui_methods ( settings . get ( "ui_methods" , { } ) ) if self . settings . get ( "static_path" ) : path = self . settings [ "static_path" ] handlers = list ( handlers or [ ] ) static_url_prefix = settings . get ( "static_url_prefix" , ) static_handler_class = settings . get ( "static_handler_class" , StaticFileHandler ) static_handler_args = settings . get ( "static_handler_args" , { } ) static_handler_args [ 'path' ] = path for pattern in [ re . escape ( static_url_prefix ) + r"(.*)" , , r"/(robots\.txt)" ] : handlers . insert ( 0 , ( pattern , static_handler_class , static_handler_args ) ) if handlers : self . add_handlers ( ".*$" , handlers ) if self . settings . get ( "debug" ) and not wsgi : from tornado import autoreload autoreload . start ( ) def listen ( self , port , address = "" , ** kwargs ) : from tornado . httpserver import HTTPServer server = HTTPServer ( self , ** kwargs ) server . listen ( port , address ) def add_handlers ( self , host_pattern , host_handlers ) : if not host_pattern . endswith ( "$" ) : host_pattern += "$" handlers = [ ] if self . handlers and self . handlers [ - 1 ] [ 0 ] . pattern == '.*$' : self . handlers . insert ( - 1 , ( re . compile ( host_pattern ) , handlers ) ) else : self . handlers . append ( ( re . compile ( host_pattern ) , handlers ) ) for spec in host_handlers : if type ( spec ) is type ( ( ) ) : assert len ( spec ) in ( 2 , 3 ) pattern = spec [ 0 ] handler = spec [ 1 ] if isinstance ( handler , str ) : handler = import_object ( handler ) if len ( spec ) == 3 : kwargs = spec [ 2 ] else : kwargs = { } spec = URLSpec ( pattern , handler , kwargs ) handlers . append ( spec ) if spec . name : if spec . name in self . named_handlers : logging . warning ( , spec . name ) self . named_handlers [ spec . name ] = spec def add_transform ( self , transform_class ) : self . transforms . append ( transform_class ) def _get_host_handlers ( self , request ) : host = request . host . lower ( ) . split ( ':' ) [ 0 ] for pattern , handlers in self . handlers : if pattern . match ( host ) : return handlers if "X-Real-Ip" not in request . headers : for pattern , handlers in self . handlers : if pattern . match ( self . default_host ) : return handlers return None def _load_ui_methods ( self , methods ) : if type ( methods ) is types . ModuleType : self . _load_ui_methods ( dict ( ( n , getattr ( methods , n ) ) for n in dir ( methods ) ) ) elif isinstance ( methods , list ) : for m in methods : self . _load_ui_methods ( m ) else : for name , fn in methods . iteritems ( ) : if not name . startswith ( "_" ) and hasattr ( fn , "__call__" ) and name [ 0 ] . lower ( ) == name [ 0 ] : self . ui_methods [ name ] = fn def _load_ui_modules ( self , modules ) : if type ( modules ) is types . ModuleType : self . _load_ui_modules ( dict ( ( n , getattr ( modules , n ) ) for n in dir ( modules ) ) ) elif isinstance ( modules , list ) : for m in modules : self . _load_ui_modules ( m ) else : assert isinstance ( modules , dict ) for name , cls in modules . iteritems ( ) : try : if issubclass ( cls , UIModule ) : self . ui_modules [ name ] = cls except TypeError : pass def __call__ ( self , request ) : transforms = [ t ( request ) for t in self . transforms ] handler = None args = [ ] kwargs = { } handlers = self . _get_host_handlers ( request ) if not handlers : handler = RedirectHandler ( self , request , url = "http://" + self . default_host + "/" ) else : for spec in handlers : match = spec . regex . match ( request . path ) if match : handler = spec . handler_class ( self , request , ** spec . kwargs ) if spec . regex . groups : def unquote ( s ) : if s is None : return s return escape . url_unescape ( s , encoding = None ) if spec . regex . groupindex : kwargs = dict ( ( k , unquote ( v ) ) for ( k , v ) in match . groupdict ( ) . iteritems ( ) ) else : args = [ unquote ( s ) for s in match . groups ( ) ] break if not handler : handler = ErrorHandler ( self , request , status_code = 404 ) if self . settings . get ( "debug" ) : with RequestHandler . _template_loader_lock : for loader in RequestHandler . _template_loaders . values ( ) : loader . reset ( ) StaticFileHandler . reset ( ) handler . _execute ( transforms , * args , ** kwargs ) return handler def reverse_url ( self , name , * args ) : if name in self . named_handlers : return self . named_handlers [ name ] . reverse ( * args ) raise KeyError ( "%s not found in named urls" % name ) def log_request ( self , handler ) : if "log_function" in self . settings : self . settings [ "log_function" ] ( handler ) return if handler . get_status ( ) < 400 : log_method = logging . info elif handler . get_status ( ) < 500 : log_method = logging . warning else : log_method = logging . error request_time = 1000.0 * handler . request . request_time ( ) log_method ( "%d %s %.2fms" , handler . get_status ( ) , handler . _request_summary ( ) , request_time ) class HTTPError ( Exception ) : def __init__ ( self , status_code , log_message = None , * args ) : self . status_code = status_code self . log_message = log_message self . args = args def __str__ ( self ) : message = "HTTP %d: %s" % ( self . status_code , httplib . responses [ self . status_code ] ) if self . log_message : return message + " (" + ( self . log_message % self . args ) + ")" else : return message class ErrorHandler ( RequestHandler ) : def initialize ( self , status_code ) : self . set_status ( status_code ) def prepare ( self ) : raise HTTPError ( self . _status_code ) class RedirectHandler ( RequestHandler ) : def initialize ( self , url , permanent = True ) : self . _url = url self . _permanent = permanent def get ( self ) : self . redirect ( self . _url , permanent = self . _permanent ) class StaticFileHandler ( RequestHandler ) : CACHE_MAX_AGE = 86400 * 365 * 10 _static_hashes = { } _lock = threading . Lock ( ) def initialize ( self , path , default_filename = None ) : self . root = os . path . abspath ( path ) + os . path . sep self . default_filename = default_filename @ classmethod def reset ( cls ) : with cls . _lock : cls . _static_hashes = { } def head ( self , path ) : self . get ( path , include_body = False ) def get ( self , path , include_body = True ) : path = self . parse_url_path ( path ) abspath = os . path . abspath ( os . path . join ( self . root , path ) ) if not ( abspath + os . path . sep ) . startswith ( self . root ) : raise HTTPError ( 403 , "%s is not in root static directory" , path ) if os . path . isdir ( abspath ) and self . default_filename is not None : if not self . request . path . endswith ( "/" ) : self . redirect ( self . request . path + "/" ) return abspath = os . path . join ( abspath , self . default_filename ) if not os . path . exists ( abspath ) : raise HTTPError ( 404 ) if not os . path . isfile ( abspath ) : raise HTTPError ( 403 , "%s is not a file" , path ) stat_result = os . stat ( abspath ) modified = datetime . datetime . fromtimestamp ( stat_result [ stat . ST_MTIME ] ) self . set_header ( "Last-Modified" , modified ) mime_type , encoding = mimetypes . guess_type ( abspath ) if mime_type : self . set_header ( "Content-Type" , mime_type ) cache_time = self . get_cache_time ( path , modified , mime_type ) if cache_time > 0 : self . set_header ( "Expires" , datetime . datetime . utcnow ( ) + datetime . timedelta ( seconds = cache_time ) ) self . set_header ( "Cache-Control" , "max-age=" + str ( cache_time ) ) else : self . set_header ( "Cache-Control" , "public" ) self . set_extra_headers ( path ) ims_value = self . request . headers . get ( "If-Modified-Since" ) if ims_value is not None : date_tuple = email . utils . parsedate ( ims_value ) if_since = datetime . datetime . fromtimestamp ( time . mktime ( date_tuple ) ) if if_since >= modified : self . set_status ( 304 ) return with open ( abspath , "rb" ) as file : data = file . read ( ) hasher = hashlib . sha1 ( ) hasher . update ( data ) self . set_header ( "Etag" , '"%s"' % hasher . hexdigest ( ) ) if include_body : self . write ( data ) else : assert self . request . method == "HEAD" self . set_header ( "Content-Length" , len ( data ) ) def set_extra_headers ( self , path ) : pass def get_cache_time ( self , path , modified , mime_type ) : return self . CACHE_MAX_AGE if "v" in self . request . arguments else 0 @ classmethod def make_static_url ( cls , settings , path ) : static_url_prefix = settings . get ( 'static_url_prefix' , '/static/' ) version_hash = cls . get_version ( settings , path ) if version_hash : return static_url_prefix + path + "?v=" + version_hash return static_url_prefix + path @ classmethod def get_version ( cls , settings , path ) : abs_path = os . path . join ( settings [ "static_path" ] , path ) with cls . _lock : hashes = cls . _static_hashes if abs_path not in hashes : try : f = open ( abs_path , "rb" ) hashes [ abs_path ] = hashlib . md5 ( f . read ( ) ) . hexdigest ( ) f . close ( ) except Exception : logging . error ( "Could not open static file %r" , path ) hashes [ abs_path ] = None hsh = hashes . get ( abs_path ) if hsh : return hsh [ : 5 ] return None def parse_url_path ( self , url_path ) : if os . path . sep != "/" : url_path = url_path . replace ( "/" , os . path . sep ) return url_path class FallbackHandler ( RequestHandler ) : def initialize ( self , fallback ) : self . fallback = fallback def prepare ( self ) : self . fallback ( self . request ) self . _finished = True class OutputTransform ( object ) : def __init__ ( self , request ) : pass def transform_first_chunk ( self , headers , chunk , finishing ) : return headers , chunk def transform_chunk ( self , chunk , finishing ) : return chunk class GZipContentEncoding ( OutputTransform ) : CONTENT_TYPES = set ( [ , "text/html" , "text/css" , "text/xml" , "application/javascript" , , "application/xml" , "application/atom+xml" , , "application/json" , "application/xhtml+xml" ] ) MIN_LENGTH = 5 def __init__ ( self , request ) : self . _gzipping = request . supports_http_1_1 ( ) and "gzip" in request . headers . get ( "Accept-Encoding" , "" ) def transform_first_chunk ( self , headers , chunk , finishing ) : if self . _gzipping : ctype = _unicode ( headers . get ( "Content-Type" , "" ) ) . split ( ";" ) [ 0 ] self . _gzipping = ( ctype in self . CONTENT_TYPES ) and ( not finishing or len ( chunk ) >= self . MIN_LENGTH ) and ( finishing or "Content-Length" not in headers ) and ( "Content-Encoding" not in headers ) if self . _gzipping : headers [ "Content-Encoding" ] = "gzip" self . _gzip_value = BytesIO ( ) self . _gzip_file = gzip . GzipFile ( mode = "w" , fileobj = self . _gzip_value ) chunk = self . transform_chunk ( chunk , finishing ) if "Content-Length" in headers : headers [ "Content-Length" ] = str ( len ( chunk ) ) return headers , chunk def transform_chunk ( self , chunk , finishing ) : if self . _gzipping : self . _gzip_file . write ( chunk ) if finishing : self . _gzip_file . close ( ) else : self . _gzip_file . flush ( ) chunk = self . _gzip_value . getvalue ( ) self . _gzip_value . truncate ( 0 ) self . _gzip_value . seek ( 0 ) return chunk class ChunkedTransferEncoding ( OutputTransform ) : def __init__ ( self , request ) : self . _chunking = request . supports_http_1_1 ( ) def transform_first_chunk ( self , headers , chunk , finishing ) : if self . _chunking : if "Content-Length" in headers or "Transfer-Encoding" in headers : self . _chunking = False else : headers [ "Transfer-Encoding" ] = "chunked" chunk = self . transform_chunk ( chunk , finishing ) return headers , chunk def transform_chunk ( self , block , finishing ) : if self . _chunking : if block : block = utf8 ( "%x" % len ( block ) ) + b ( "\r\n" ) + block + b ( "\r\n" ) if finishing : block += b ( "0\r\n\r\n" ) return block def authenticated ( method ) : @ functools . wraps ( method ) def wrapper ( self , * args , ** kwargs ) : if not self . current_user : if self . request . method in ( "GET" , "HEAD" ) : url = self . get_login_url ( ) if "?" not in url : if urlparse . urlsplit ( url ) . scheme : next_url = self . request . full_url ( ) else : next_url = self . request . uri url += "?" + urllib . urlencode ( dict ( next = next_url ) ) self . redirect ( url ) return raise HTTPError ( 403 ) return method ( self , * args , ** kwargs ) return wrapper class UIModule ( object ) : def __init__ ( self , handler ) : self . handler = handler self . request = handler . request self . ui = handler . ui self . current_user = handler . current_user self . locale = handler . locale def render ( self , * args , ** kwargs ) : raise NotImplementedError ( ) def embedded_javascript ( self ) : return None def javascript_files ( self ) : return None def embedded_css ( self ) : return None def css_files ( self ) : return None def html_head ( self ) : return None def html_body ( self ) : return None def render_string ( self , path , ** kwargs ) : return self . handler . render_string ( path , ** kwargs ) class _linkify ( UIModule ) : def render ( self , text , ** kwargs ) : return escape . linkify ( text , ** kwargs ) class _xsrf_form_html ( UIModule ) : def render ( self ) : return self . handler . xsrf_form_html ( ) class TemplateModule ( UIModule ) : def __init__ ( self , handler ) : super ( TemplateModule , self ) . __init__ ( handler ) self . _resource_list = [ ] self . _resource_dict = { } def render ( self , path , ** kwargs ) : def set_resources ( ** kwargs ) : if path not in self . _resource_dict : self . _resource_list . append ( kwargs ) self . _resource_dict [ path ] = kwargs else : if self . _resource_dict [ path ] != kwargs : raise ValueError ( "set_resources called with different " ) return "" return self . render_string ( path , set_resources = set_resources , ** kwargs ) def _get_resources ( self , key ) : return ( r [ key ] for r in self . _resource_list if key in r ) def embedded_javascript ( self ) : return "\n" . join ( self . _get_resources ( "embedded_javascript" ) ) def javascript_files ( self ) : result = [ ] for f in self . _get_resources ( "javascript_files" ) : if isinstance ( f , ( unicode , bytes_type ) ) : result . append ( f ) else : result . extend ( f ) return result def embedded_css ( self ) : return "\n" . join ( self . _get_resources ( "embedded_css" ) ) def css_files ( self ) : result = [ ] for f in self . _get_resources ( "css_files" ) : if isinstance ( f , ( unicode , bytes_type ) ) : result . append ( f ) else : result . extend ( f ) return result def html_head ( self ) : return "" . join ( self . _get_resources ( "html_head" ) ) def html_body ( self ) : return "" . join ( self . _get_resources ( "html_body" ) ) class URLSpec ( object ) : def __init__ ( self , pattern , handler_class , kwargs = { } , name = None ) : if not pattern . endswith ( '$' ) : pattern += '$' self . regex = re . compile ( pattern ) assert len ( self . regex . groupindex ) in ( 0 , self . regex . groups ) , ( "groups in url regexes must either be all named or all " % self . regex . pattern ) self . handler_class = handler_class self . kwargs = kwargs self . name = name self . _path , self . _group_count = self . _find_groups ( ) def _find_groups ( self ) : pattern = self . regex . pattern if pattern . startswith ( '^' ) : pattern = pattern [ 1 : ] if pattern . endswith ( '$' ) : pattern = pattern [ : - 1 ] if self . regex . groups != pattern . count ( '(' ) : return ( None , None ) pieces = [ ] for fragment in pattern . split ( '(' ) : if ')' in fragment : paren_loc = fragment . index ( ')' ) if paren_loc >= 0 : pieces . append ( '%s' + fragment [ paren_loc + 1 : ] ) else : pieces . append ( fragment ) return ( '' . join ( pieces ) , self . regex . groups ) def reverse ( self , * args ) : assert self . _path is not None , "Cannot reverse url regex " + self . regex . pattern assert len ( args ) == self . _group_count , "required number of arguments " "not found" if not len ( args ) : return self . _path return self . _path % tuple ( [ str ( a ) for a in args ] ) url = URLSpec def _time_independent_equals ( a , b ) : if len ( a ) != len ( b ) : return False result = 0 if type ( a [ 0 ] ) is int : for x , y in zip ( a , b ) : result |= x ^ y else : for x , y in zip ( a , b ) : result |= ord ( x ) ^ ord ( y ) return result == 0 def create_signed_value ( secret , name , value ) : timestamp = utf8 ( str ( int ( time . time ( ) ) ) ) value = base64 . b64encode ( utf8 ( value ) ) signature = _create_signature ( secret , name , value , timestamp ) value = b ( "|" ) . join ( [ value , timestamp , signature ] ) return value def decode_signed_value ( secret , name , value , max_age_days = 31 ) : if not value : return None parts = utf8 ( value ) . split ( b ( "|" ) ) if len ( parts ) != 3 : return None signature = _create_signature ( secret , name , parts [ 0 ] , parts [ 1 ] ) if not _time_independent_equals ( parts [ 2 ] , signature ) : logging . warning ( "Invalid cookie signature %r" , value ) return None timestamp = int ( parts [ 1 ] ) if timestamp < time . time ( ) - max_age_days * 86400 : logging . warning ( "Expired cookie %r" , value ) return None if timestamp > time . time ( ) + 31 * 86400 : logging . warning ( "Cookie timestamp in future; possible tampering %r" , value ) return None if parts [ 1 ] . startswith ( b ( "0" ) ) : logging . warning ( "Tampered cookie %r" , value ) try : return base64 . b64decode ( parts [ 0 ] ) except Exception : return None def _create_signature ( secret , * parts ) : hash = hmac . new ( utf8 ( secret ) , digestmod = hashlib . sha1 ) for part in parts : hash . update ( utf8 ( part ) ) return utf8 ( hash . hexdigest ( ) )

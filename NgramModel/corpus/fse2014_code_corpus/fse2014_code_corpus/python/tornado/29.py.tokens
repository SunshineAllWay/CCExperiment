"""Server-side implementation of the WebSocket protocol. `WebSockets <http://dev.w3.org/html5/websockets/>`_ allow for bidirectional communication between the browser and server. .. warning:: The WebSocket protocol was recently finalized as `RFC 6455 <http://tools.ietf.org/html/rfc6455>`_ and is not yet supported in all browsers. Refer to http://caniuse.com/websockets for details on compatibility. In addition, during development the protocol went through several incompatible versions, and some browsers only support older versions. By default this module only supports the latest version of the protocol, but optional support for an older version (known as "draft 76" or "hixie-76") can be enabled by overriding `WebSocketHandler.allow_draft76` (see that method's documentation for caveats). """ from __future__ import absolute_import , division , with_statement import array import functools import hashlib import logging import struct import time import base64 import tornado . escape import tornado . web from tornado . util import bytes_type , b class WebSocketHandler ( tornado . web . RequestHandler ) : def __init__ ( self , application , request , ** kwargs ) : tornado . web . RequestHandler . __init__ ( self , application , request , ** kwargs ) self . stream = request . connection . stream self . ws_connection = None def _execute ( self , transforms , * args , ** kwargs ) : self . open_args = args self . open_kwargs = kwargs if self . request . method != 'GET' : self . stream . write ( tornado . escape . utf8 ( ) ) self . stream . close ( ) return if self . request . headers . get ( "Upgrade" , "" ) . lower ( ) != 'websocket' : self . stream . write ( tornado . escape . utf8 ( ) ) self . stream . close ( ) return headers = self . request . headers connection = map ( lambda s : s . strip ( ) . lower ( ) , headers . get ( "Connection" , "" ) . split ( "," ) ) if 'upgrade' not in connection : self . stream . write ( tornado . escape . utf8 ( ) ) self . stream . close ( ) return if self . request . headers . get ( "Sec-WebSocket-Version" ) in ( "7" , "8" , "13" ) : self . ws_connection = WebSocketProtocol13 ( self ) self . ws_connection . accept_connection ( ) elif ( self . allow_draft76 ( ) and not in self . request . headers ) : self . ws_connection = WebSocketProtocol76 ( self ) self . ws_connection . accept_connection ( ) else : self . stream . write ( tornado . escape . utf8 ( ) ) self . stream . close ( ) def write_message ( self , message , binary = False ) : if isinstance ( message , dict ) : message = tornado . escape . json_encode ( message ) self . ws_connection . write_message ( message , binary = binary ) def select_subprotocol ( self , subprotocols ) : return None def open ( self ) : pass def on_message ( self , message ) : raise NotImplementedError def on_close ( self ) : pass def close ( self ) : self . ws_connection . close ( ) def allow_draft76 ( self ) : return False def get_websocket_scheme ( self ) : return "wss" if self . request . protocol == "https" else "ws" def async_callback ( self , callback , * args , ** kwargs ) : return self . ws_connection . async_callback ( callback , * args , ** kwargs ) def _not_supported ( self , * args , ** kwargs ) : raise Exception ( "Method not supported for Web Sockets" ) def on_connection_close ( self ) : if self . ws_connection : self . ws_connection . on_connection_close ( ) self . ws_connection = None self . on_close ( ) for method in [ "write" , "redirect" , "set_header" , "send_error" , "set_cookie" , , "flush" , "finish" ] : setattr ( WebSocketHandler , method , WebSocketHandler . _not_supported ) class WebSocketProtocol ( object ) : def __init__ ( self , handler ) : self . handler = handler self . request = handler . request self . stream = handler . stream self . client_terminated = False self . server_terminated = False def async_callback ( self , callback , * args , ** kwargs ) : if args or kwargs : callback = functools . partial ( callback , * args , ** kwargs ) def wrapper ( * args , ** kwargs ) : try : return callback ( * args , ** kwargs ) except Exception : logging . error ( "Uncaught exception in %s" , self . request . path , exc_info = True ) self . _abort ( ) return wrapper def on_connection_close ( self ) : self . _abort ( ) def _abort ( self ) : self . client_terminated = True self . server_terminated = True self . stream . close ( ) self . close ( ) class WebSocketProtocol76 ( WebSocketProtocol ) : def __init__ ( self , handler ) : WebSocketProtocol . __init__ ( self , handler ) self . challenge = None self . _waiting = None def accept_connection ( self ) : try : self . _handle_websocket_headers ( ) except ValueError : logging . debug ( "Malformed WebSocket request received" ) self . _abort ( ) return scheme = self . handler . get_websocket_scheme ( ) subprotocol_header = '' subprotocol = self . request . headers . get ( "Sec-WebSocket-Protocol" , None ) if subprotocol : selected = self . handler . select_subprotocol ( [ subprotocol ] ) if selected : assert selected == subprotocol subprotocol_header = "Sec-WebSocket-Protocol: %s\r\n" % selected self . stream . write ( tornado . escape . utf8 ( % ( dict ( version = tornado . version , origin = self . request . headers [ "Origin" ] , scheme = scheme , host = self . request . host , uri = self . request . uri , subprotocol = subprotocol_header ) ) ) ) self . stream . read_bytes ( 8 , self . _handle_challenge ) def challenge_response ( self , challenge ) : key_1 = self . request . headers . get ( "Sec-Websocket-Key1" ) key_2 = self . request . headers . get ( "Sec-Websocket-Key2" ) try : part_1 = self . _calculate_part ( key_1 ) part_2 = self . _calculate_part ( key_2 ) except ValueError : raise ValueError ( "Invalid Keys/Challenge" ) return self . _generate_challenge_response ( part_1 , part_2 , challenge ) def _handle_challenge ( self , challenge ) : try : challenge_response = self . challenge_response ( challenge ) except ValueError : logging . debug ( "Malformed key data in WebSocket request" ) self . _abort ( ) return self . _write_response ( challenge_response ) def _write_response ( self , challenge ) : self . stream . write ( challenge ) self . async_callback ( self . handler . open ) ( * self . handler . open_args , ** self . handler . open_kwargs ) self . _receive_message ( ) def _handle_websocket_headers ( self ) : fields = ( "Origin" , "Host" , "Sec-Websocket-Key1" , ) if not all ( map ( lambda f : self . request . headers . get ( f ) , fields ) ) : raise ValueError ( "Missing/Invalid WebSocket headers" ) def _calculate_part ( self , key ) : number = int ( '' . join ( c for c in key if c . isdigit ( ) ) ) spaces = len ( [ c for c in key if c . isspace ( ) ] ) try : key_number = number // spaces except ( ValueError , ZeroDivisionError ) : raise ValueError return struct . pack ( ">I" , key_number ) def _generate_challenge_response ( self , part_1 , part_2 , part_3 ) : m = hashlib . md5 ( ) m . update ( part_1 ) m . update ( part_2 ) m . update ( part_3 ) return m . digest ( ) def _receive_message ( self ) : self . stream . read_bytes ( 1 , self . _on_frame_type ) def _on_frame_type ( self , byte ) : frame_type = ord ( byte ) if frame_type == 0x00 : self . stream . read_until ( b ( "\xff" ) , self . _on_end_delimiter ) elif frame_type == 0xff : self . stream . read_bytes ( 1 , self . _on_length_indicator ) else : self . _abort ( ) def _on_end_delimiter ( self , frame ) : if not self . client_terminated : self . async_callback ( self . handler . on_message ) ( frame [ : - 1 ] . decode ( "utf-8" , "replace" ) ) if not self . client_terminated : self . _receive_message ( ) def _on_length_indicator ( self , byte ) : if ord ( byte ) != 0x00 : self . _abort ( ) return self . client_terminated = True self . close ( ) def write_message ( self , message , binary = False ) : if binary : raise ValueError ( ) if isinstance ( message , unicode ) : message = message . encode ( "utf-8" ) assert isinstance ( message , bytes_type ) self . stream . write ( b ( "\x00" ) + message + b ( "\xff" ) ) def close ( self ) : if not self . server_terminated : if not self . stream . closed ( ) : self . stream . write ( "\xff\x00" ) self . server_terminated = True if self . client_terminated : if self . _waiting is not None : self . stream . io_loop . remove_timeout ( self . _waiting ) self . _waiting = None self . stream . close ( ) elif self . _waiting is None : self . _waiting = self . stream . io_loop . add_timeout ( time . time ( ) + 5 , self . _abort ) class WebSocketProtocol13 ( WebSocketProtocol ) : def __init__ ( self , handler ) : WebSocketProtocol . __init__ ( self , handler ) self . _final_frame = False self . _frame_opcode = None self . _frame_mask = None self . _frame_length = None self . _fragmented_message_buffer = None self . _fragmented_message_opcode = None self . _waiting = None def accept_connection ( self ) : try : self . _handle_websocket_headers ( ) self . _accept_connection ( ) except ValueError : logging . debug ( "Malformed WebSocket request received" ) self . _abort ( ) return def _handle_websocket_headers ( self ) : fields = ( "Host" , "Sec-Websocket-Key" , "Sec-Websocket-Version" ) if not all ( map ( lambda f : self . request . headers . get ( f ) , fields ) ) : raise ValueError ( "Missing/Invalid WebSocket headers" ) def _challenge_response ( self ) : sha1 = hashlib . sha1 ( ) sha1 . update ( tornado . escape . utf8 ( self . request . headers . get ( "Sec-Websocket-Key" ) ) ) sha1 . update ( b ( "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ) ) return tornado . escape . native_str ( base64 . b64encode ( sha1 . digest ( ) ) ) def _accept_connection ( self ) : subprotocol_header = '' subprotocols = self . request . headers . get ( "Sec-WebSocket-Protocol" , '' ) subprotocols = [ s . strip ( ) for s in subprotocols . split ( ',' ) ] if subprotocols : selected = self . handler . select_subprotocol ( subprotocols ) if selected : assert selected in subprotocols subprotocol_header = "Sec-WebSocket-Protocol: %s\r\n" % selected self . stream . write ( tornado . escape . utf8 ( % ( self . _challenge_response ( ) , subprotocol_header ) ) ) self . async_callback ( self . handler . open ) ( * self . handler . open_args , ** self . handler . open_kwargs ) self . _receive_frame ( ) def _write_frame ( self , fin , opcode , data ) : if fin : finbit = 0x80 else : finbit = 0 frame = struct . pack ( "B" , finbit | opcode ) l = len ( data ) if l < 126 : frame += struct . pack ( "B" , l ) elif l <= 0xFFFF : frame += struct . pack ( "!BH" , 126 , l ) else : frame += struct . pack ( "!BQ" , 127 , l ) frame += data self . stream . write ( frame ) def write_message ( self , message , binary = False ) : if binary : opcode = 0x2 else : opcode = 0x1 message = tornado . escape . utf8 ( message ) assert isinstance ( message , bytes_type ) self . _write_frame ( True , opcode , message ) def _receive_frame ( self ) : self . stream . read_bytes ( 2 , self . _on_frame_start ) def _on_frame_start ( self , data ) : header , payloadlen = struct . unpack ( "BB" , data ) self . _final_frame = header & 0x80 reserved_bits = header & 0x70 self . _frame_opcode = header & 0xf self . _frame_opcode_is_control = self . _frame_opcode & 0x8 if reserved_bits : self . _abort ( ) return if not ( payloadlen & 0x80 ) : self . _abort ( ) return payloadlen = payloadlen & 0x7f if self . _frame_opcode_is_control and payloadlen >= 126 : self . _abort ( ) return if payloadlen < 126 : self . _frame_length = payloadlen self . stream . read_bytes ( 4 , self . _on_masking_key ) elif payloadlen == 126 : self . stream . read_bytes ( 2 , self . _on_frame_length_16 ) elif payloadlen == 127 : self . stream . read_bytes ( 8 , self . _on_frame_length_64 ) def _on_frame_length_16 ( self , data ) : self . _frame_length = struct . unpack ( "!H" , data ) [ 0 ] self . stream . read_bytes ( 4 , self . _on_masking_key ) def _on_frame_length_64 ( self , data ) : self . _frame_length = struct . unpack ( "!Q" , data ) [ 0 ] self . stream . read_bytes ( 4 , self . _on_masking_key ) def _on_masking_key ( self , data ) : self . _frame_mask = array . array ( "B" , data ) self . stream . read_bytes ( self . _frame_length , self . _on_frame_data ) def _on_frame_data ( self , data ) : unmasked = array . array ( "B" , data ) for i in xrange ( len ( data ) ) : unmasked [ i ] = unmasked [ i ] ^ self . _frame_mask [ i % 4 ] if self . _frame_opcode_is_control : if not self . _final_frame : self . _abort ( ) return opcode = self . _frame_opcode elif self . _frame_opcode == 0 : if self . _fragmented_message_buffer is None : self . _abort ( ) return self . _fragmented_message_buffer += unmasked if self . _final_frame : opcode = self . _fragmented_message_opcode unmasked = self . _fragmented_message_buffer self . _fragmented_message_buffer = None else : if self . _fragmented_message_buffer is not None : self . _abort ( ) return if self . _final_frame : opcode = self . _frame_opcode else : self . _fragmented_message_opcode = self . _frame_opcode self . _fragmented_message_buffer = unmasked if self . _final_frame : self . _handle_message ( opcode , unmasked . tostring ( ) ) if not self . client_terminated : self . _receive_frame ( ) def _handle_message ( self , opcode , data ) : if self . client_terminated : return if opcode == 0x1 : try : decoded = data . decode ( "utf-8" ) except UnicodeDecodeError : self . _abort ( ) return self . async_callback ( self . handler . on_message ) ( decoded ) elif opcode == 0x2 : self . async_callback ( self . handler . on_message ) ( data ) elif opcode == 0x8 : self . client_terminated = True self . close ( ) elif opcode == 0x9 : self . _write_frame ( True , 0xA , data ) elif opcode == 0xA : pass else : self . _abort ( ) def close ( self ) : if not self . server_terminated : if not self . stream . closed ( ) : self . _write_frame ( True , 0x8 , b ( "" ) ) self . server_terminated = True if self . client_terminated : if self . _waiting is not None : self . stream . io_loop . remove_timeout ( self . _waiting ) self . _waiting = None self . stream . close ( ) elif self . _waiting is None : self . _waiting = self . stream . io_loop . add_timeout ( time . time ( ) + 5 , self . _abort )

"""Support classes for automated testing. This module contains three parts: * `AsyncTestCase`/`AsyncHTTPTestCase`: Subclasses of unittest.TestCase with additional support for testing asynchronous (IOLoop-based) code. * `LogTrapTestCase`: Subclass of unittest.TestCase that discards log output from tests that pass and only produces output for failing tests. * `main()`: A simple test runner (wrapper around unittest.main()) with support for the tornado.autoreload module to rerun the tests when code changes. These components may be used together or independently. In particular, it is safe to combine AsyncTestCase and LogTrapTestCase via multiple inheritance. See the docstrings for each class/function below for more information. """ from __future__ import absolute_import , division , with_statement from cStringIO import StringIO try : from tornado . httpclient import AsyncHTTPClient from tornado . httpserver import HTTPServer from tornado . ioloop import IOLoop except ImportError : AsyncHTTPClient = None HTTPServer = None IOLoop = None from tornado . stack_context import StackContext , NullContext import contextlib import logging import signal import sys import time import unittest _next_port = 10000 def get_unused_port ( ) : global _next_port port = _next_port _next_port = _next_port + 1 return port class AsyncTestCase ( unittest . TestCase ) : def __init__ ( self , * args , ** kwargs ) : super ( AsyncTestCase , self ) . __init__ ( * args , ** kwargs ) self . __stopped = False self . __running = False self . __failure = None self . __stop_args = None def setUp ( self ) : super ( AsyncTestCase , self ) . setUp ( ) self . io_loop = self . get_new_ioloop ( ) def tearDown ( self ) : if ( not IOLoop . initialized ( ) or self . io_loop is not IOLoop . instance ( ) ) : self . io_loop . close ( all_fds = True ) super ( AsyncTestCase , self ) . tearDown ( ) def get_new_ioloop ( self ) : return IOLoop ( ) @ contextlib . contextmanager def _stack_context ( self ) : try : yield except Exception : self . __failure = sys . exc_info ( ) self . stop ( ) def run ( self , result = None ) : with StackContext ( self . _stack_context ) : super ( AsyncTestCase , self ) . run ( result ) def stop ( self , _arg = None , ** kwargs ) : assert _arg is None or not kwargs self . __stop_args = kwargs or _arg if self . __running : self . io_loop . stop ( ) self . __running = False self . __stopped = True def wait ( self , condition = None , timeout = 5 ) : if not self . __stopped : if timeout : def timeout_func ( ) : try : raise self . failureException ( % timeout ) except Exception : self . __failure = sys . exc_info ( ) self . stop ( ) self . io_loop . add_timeout ( time . time ( ) + timeout , timeout_func ) while True : self . __running = True with NullContext ( ) : self . io_loop . start ( ) if ( self . __failure is not None or condition is None or condition ( ) ) : break assert self . __stopped self . __stopped = False if self . __failure is not None : if isinstance ( self . __failure [ 1 ] , self . __failure [ 0 ] ) : raise self . __failure [ 1 ] , None , self . __failure [ 2 ] else : raise self . __failure [ 0 ] , self . __failure [ 1 ] , self . __failure [ 2 ] result = self . __stop_args self . __stop_args = None return result class AsyncHTTPTestCase ( AsyncTestCase ) : def setUp ( self ) : super ( AsyncHTTPTestCase , self ) . setUp ( ) self . __port = None self . http_client = AsyncHTTPClient ( io_loop = self . io_loop ) self . _app = self . get_app ( ) self . http_server = HTTPServer ( self . _app , io_loop = self . io_loop , ** self . get_httpserver_options ( ) ) self . http_server . listen ( self . get_http_port ( ) , address = "127.0.0.1" ) def get_app ( self ) : raise NotImplementedError ( ) def fetch ( self , path , ** kwargs ) : self . http_client . fetch ( self . get_url ( path ) , self . stop , ** kwargs ) return self . wait ( ) def get_httpserver_options ( self ) : return { } def get_http_port ( self ) : if self . __port is None : self . __port = get_unused_port ( ) return self . __port def get_url ( self , path ) : return 'http://localhost:%s%s' % ( self . get_http_port ( ) , path ) def tearDown ( self ) : self . http_server . stop ( ) self . http_client . close ( ) super ( AsyncHTTPTestCase , self ) . tearDown ( ) class LogTrapTestCase ( unittest . TestCase ) : def run ( self , result = None ) : logger = logging . getLogger ( ) if len ( logger . handlers ) > 1 : super ( LogTrapTestCase , self ) . run ( result ) return if not logger . handlers : logging . basicConfig ( ) self . assertEqual ( len ( logger . handlers ) , 1 ) handler = logger . handlers [ 0 ] assert isinstance ( handler , logging . StreamHandler ) old_stream = handler . stream try : handler . stream = StringIO ( ) logging . info ( "RUNNING TEST: " + str ( self ) ) old_error_count = len ( result . failures ) + len ( result . errors ) super ( LogTrapTestCase , self ) . run ( result ) new_error_count = len ( result . failures ) + len ( result . errors ) if new_error_count != old_error_count : old_stream . write ( handler . stream . getvalue ( ) ) finally : handler . stream = old_stream def main ( ) : from tornado . options import define , options , parse_command_line define ( 'autoreload' , type = bool , default = False , help = "DEPRECATED: use tornado.autoreload.main instead" ) define ( 'httpclient' , type = str , default = None ) define ( 'exception_on_interrupt' , type = bool , default = True , help = ( "If true (default), ctrl-c raises a KeyboardInterrupt " ) ) argv = [ sys . argv [ 0 ] ] + parse_command_line ( sys . argv ) if options . httpclient : from tornado . httpclient import AsyncHTTPClient AsyncHTTPClient . configure ( options . httpclient ) if not options . exception_on_interrupt : signal . signal ( signal . SIGINT , signal . SIG_DFL ) if __name__ == '__main__' and len ( argv ) == 1 : print >> sys . stderr , "No tests specified" sys . exit ( 1 ) try : if len ( argv ) > 1 : unittest . main ( module = None , argv = argv ) else : unittest . main ( defaultTest = "all" , argv = argv ) except SystemExit , e : if e . code == 0 : logging . info ( 'PASS' ) else : logging . error ( 'FAIL' ) if not options . autoreload : raise if options . autoreload : import tornado . autoreload tornado . autoreload . wait ( ) if __name__ == '__main__' : main ( )

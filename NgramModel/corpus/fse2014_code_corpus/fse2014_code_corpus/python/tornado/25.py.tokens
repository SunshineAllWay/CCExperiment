"""Blocking and non-blocking HTTP client interfaces. This module defines a common interface shared by two implementations, `simple_httpclient` and `curl_httpclient`. Applications may either instantiate their chosen implementation class directly or use the `AsyncHTTPClient` class from this module, which selects an implementation that can be overridden with the `AsyncHTTPClient.configure` method. The default implementation is `simple_httpclient`, and this is expected to be suitable for most users' needs. However, some applications may wish to switch to `curl_httpclient` for reasons such as the following: * `curl_httpclient` has some features not found in `simple_httpclient`, including support for HTTP proxies and the ability to use a specified network interface. * `curl_httpclient` is more likely to be compatible with sites that are not-quite-compliant with the HTTP spec, or sites that use little-exercised features of HTTP. * `simple_httpclient` only supports SSL on Python 2.6 and above. * `curl_httpclient` is faster * `curl_httpclient` was the default prior to Tornado 2.0. Note that if you are using `curl_httpclient`, it is highly recommended that you use a recent version of ``libcurl`` and ``pycurl``. Currently the minimum supported version is 7.18.2, and the recommended version is 7.21.1 or newer. """ from __future__ import absolute_import , division , with_statement import calendar import email . utils import httplib import time import weakref from tornado . escape import utf8 from tornado import httputil from tornado . ioloop import IOLoop from tornado . util import import_object , bytes_type class HTTPClient ( object ) : def __init__ ( self , async_client_class = None ) : self . _io_loop = IOLoop ( ) if async_client_class is None : async_client_class = AsyncHTTPClient self . _async_client = async_client_class ( self . _io_loop ) self . _response = None self . _closed = False def __del__ ( self ) : self . close ( ) def close ( self ) : if not self . _closed : self . _async_client . close ( ) self . _io_loop . close ( ) self . _closed = True def fetch ( self , request , ** kwargs ) : def callback ( response ) : self . _response = response self . _io_loop . stop ( ) self . _async_client . fetch ( request , callback , ** kwargs ) self . _io_loop . start ( ) response = self . _response self . _response = None response . rethrow ( ) return response class AsyncHTTPClient ( object ) : _impl_class = None _impl_kwargs = None @ classmethod def _async_clients ( cls ) : assert cls is not AsyncHTTPClient , "should only be called on subclasses" if not hasattr ( cls , '_async_client_dict' ) : cls . _async_client_dict = weakref . WeakKeyDictionary ( ) return cls . _async_client_dict def __new__ ( cls , io_loop = None , max_clients = 10 , force_instance = False , ** kwargs ) : io_loop = io_loop or IOLoop . instance ( ) if cls is AsyncHTTPClient : if cls . _impl_class is None : from tornado . simple_httpclient import SimpleAsyncHTTPClient AsyncHTTPClient . _impl_class = SimpleAsyncHTTPClient impl = AsyncHTTPClient . _impl_class else : impl = cls if io_loop in impl . _async_clients ( ) and not force_instance : return impl . _async_clients ( ) [ io_loop ] else : instance = super ( AsyncHTTPClient , cls ) . __new__ ( impl ) args = { } if cls . _impl_kwargs : args . update ( cls . _impl_kwargs ) args . update ( kwargs ) instance . initialize ( io_loop , max_clients , ** args ) if not force_instance : impl . _async_clients ( ) [ io_loop ] = instance return instance def close ( self ) : if self . _async_clients ( ) . get ( self . io_loop ) is self : del self . _async_clients ( ) [ self . io_loop ] def fetch ( self , request , callback , ** kwargs ) : raise NotImplementedError ( ) @ staticmethod def configure ( impl , ** kwargs ) : if isinstance ( impl , ( unicode , bytes_type ) ) : impl = import_object ( impl ) if impl is not None and not issubclass ( impl , AsyncHTTPClient ) : raise ValueError ( "Invalid AsyncHTTPClient implementation" ) AsyncHTTPClient . _impl_class = impl AsyncHTTPClient . _impl_kwargs = kwargs class HTTPRequest ( object ) : def __init__ ( self , url , method = "GET" , headers = None , body = None , auth_username = None , auth_password = None , connect_timeout = 20.0 , request_timeout = 20.0 , if_modified_since = None , follow_redirects = True , max_redirects = 5 , user_agent = None , use_gzip = True , network_interface = None , streaming_callback = None , header_callback = None , prepare_curl_callback = None , proxy_host = None , proxy_port = None , proxy_username = None , proxy_password = '' , allow_nonstandard_methods = False , validate_cert = True , ca_certs = None , allow_ipv6 = None , client_key = None , client_cert = None ) : if headers is None : headers = httputil . HTTPHeaders ( ) if if_modified_since : timestamp = calendar . timegm ( if_modified_since . utctimetuple ( ) ) headers [ "If-Modified-Since" ] = email . utils . formatdate ( timestamp , localtime = False , usegmt = True ) self . proxy_host = proxy_host self . proxy_port = proxy_port self . proxy_username = proxy_username self . proxy_password = proxy_password self . url = url self . method = method self . headers = headers self . body = utf8 ( body ) self . auth_username = auth_username self . auth_password = auth_password self . connect_timeout = connect_timeout self . request_timeout = request_timeout self . follow_redirects = follow_redirects self . max_redirects = max_redirects self . user_agent = user_agent self . use_gzip = use_gzip self . network_interface = network_interface self . streaming_callback = streaming_callback self . header_callback = header_callback self . prepare_curl_callback = prepare_curl_callback self . allow_nonstandard_methods = allow_nonstandard_methods self . validate_cert = validate_cert self . ca_certs = ca_certs self . allow_ipv6 = allow_ipv6 self . client_key = client_key self . client_cert = client_cert self . start_time = time . time ( ) class HTTPResponse ( object ) : def __init__ ( self , request , code , headers = { } , buffer = None , effective_url = None , error = None , request_time = None , time_info = { } ) : self . request = request self . code = code self . headers = headers self . buffer = buffer self . _body = None if effective_url is None : self . effective_url = request . url else : self . effective_url = effective_url if error is None : if self . code < 200 or self . code >= 300 : self . error = HTTPError ( self . code , response = self ) else : self . error = None else : self . error = error self . request_time = request_time self . time_info = time_info def _get_body ( self ) : if self . buffer is None : return None elif self . _body is None : self . _body = self . buffer . getvalue ( ) return self . _body body = property ( _get_body ) def rethrow ( self ) : if self . error : raise self . error def __repr__ ( self ) : args = "," . join ( "%s=%r" % i for i in self . __dict__ . iteritems ( ) ) return "%s(%s)" % ( self . __class__ . __name__ , args ) class HTTPError ( Exception ) : def __init__ ( self , code , message = None , response = None ) : self . code = code message = message or httplib . responses . get ( code , "Unknown" ) self . response = response Exception . __init__ ( self , "HTTP %d: %s" % ( self . code , message ) ) def main ( ) : from tornado . options import define , options , parse_command_line define ( "print_headers" , type = bool , default = False ) define ( "print_body" , type = bool , default = True ) define ( "follow_redirects" , type = bool , default = True ) define ( "validate_cert" , type = bool , default = True ) args = parse_command_line ( ) client = HTTPClient ( ) for arg in args : try : response = client . fetch ( arg , follow_redirects = options . follow_redirects , validate_cert = options . validate_cert , ) except HTTPError , e : if e . response is not None : response = e . response else : raise if options . print_headers : print response . headers if options . print_body : print response . body client . close ( ) if __name__ == "__main__" : main ( )

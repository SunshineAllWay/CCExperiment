from __future__ import absolute_import , division , with_statement import base64 import binascii import hashlib import hmac import logging import time import urllib import urlparse import uuid from tornado import httpclient from tornado import escape from tornado . httputil import url_concat from tornado . util import bytes_type , b class OpenIdMixin ( object ) : def authenticate_redirect ( self , callback_uri = None , ax_attrs = [ "name" , "email" , "language" , "username" ] ) : callback_uri = callback_uri or self . request . uri args = self . _openid_args ( callback_uri , ax_attrs = ax_attrs ) self . redirect ( self . _OPENID_ENDPOINT + "?" + urllib . urlencode ( args ) ) def get_authenticated_user ( self , callback , http_client = None ) : args = dict ( ( k , v [ - 1 ] ) for k , v in self . request . arguments . iteritems ( ) ) args [ "openid.mode" ] = u"check_authentication" url = self . _OPENID_ENDPOINT if http_client is None : http_client = httpclient . AsyncHTTPClient ( ) http_client . fetch ( url , self . async_callback ( self . _on_authentication_verified , callback ) , method = "POST" , body = urllib . urlencode ( args ) ) def _openid_args ( self , callback_uri , ax_attrs = [ ] , oauth_scope = None ) : url = urlparse . urljoin ( self . request . full_url ( ) , callback_uri ) args = { : "http://specs.openid.net/auth/2.0" , : , : , : url , : urlparse . urljoin ( url , '/' ) , : "checkid_setup" , } if ax_attrs : args . update ( { : "http://openid.net/srv/ax/1.0" , : "fetch_request" , } ) ax_attrs = set ( ax_attrs ) required = [ ] if "name" in ax_attrs : ax_attrs -= set ( [ "name" , "firstname" , "fullname" , "lastname" ] ) required += [ "firstname" , "fullname" , "lastname" ] args . update ( { : , : , : , } ) known_attrs = { : "http://axschema.org/contact/email" , : "http://axschema.org/pref/language" , : "http://axschema.org/namePerson/friendly" , } for name in ax_attrs : args [ "openid.ax.type." + name ] = known_attrs [ name ] required . append ( name ) args [ "openid.ax.required" ] = "," . join ( required ) if oauth_scope : args . update ( { : , : self . request . host . split ( ":" ) [ 0 ] , : oauth_scope , } ) return args def _on_authentication_verified ( self , callback , response ) : if response . error or b ( "is_valid:true" ) not in response . body : logging . warning ( "Invalid OpenID response: %s" , response . error or response . body ) callback ( None ) return ax_ns = None for name in self . request . arguments . iterkeys ( ) : if name . startswith ( "openid.ns." ) and self . get_argument ( name ) == u"http://openid.net/srv/ax/1.0" : ax_ns = name [ 10 : ] break def get_ax_arg ( uri ) : if not ax_ns : return u"" prefix = "openid." + ax_ns + ".type." ax_name = None for name in self . request . arguments . iterkeys ( ) : if self . get_argument ( name ) == uri and name . startswith ( prefix ) : part = name [ len ( prefix ) : ] ax_name = "openid." + ax_ns + ".value." + part break if not ax_name : return u"" return self . get_argument ( ax_name , u"" ) email = get_ax_arg ( "http://axschema.org/contact/email" ) name = get_ax_arg ( "http://axschema.org/namePerson" ) first_name = get_ax_arg ( "http://axschema.org/namePerson/first" ) last_name = get_ax_arg ( "http://axschema.org/namePerson/last" ) username = get_ax_arg ( "http://axschema.org/namePerson/friendly" ) locale = get_ax_arg ( "http://axschema.org/pref/language" ) . lower ( ) user = dict ( ) name_parts = [ ] if first_name : user [ "first_name" ] = first_name name_parts . append ( first_name ) if last_name : user [ "last_name" ] = last_name name_parts . append ( last_name ) if name : user [ "name" ] = name elif name_parts : user [ "name" ] = u" " . join ( name_parts ) elif email : user [ "name" ] = email . split ( "@" ) [ 0 ] if email : user [ "email" ] = email if locale : user [ "locale" ] = locale if username : user [ "username" ] = username callback ( user ) class OAuthMixin ( object ) : def authorize_redirect ( self , callback_uri = None , extra_params = None , http_client = None ) : if callback_uri and getattr ( self , "_OAUTH_NO_CALLBACKS" , False ) : raise Exception ( "This service does not support oauth_callback" ) if http_client is None : http_client = httpclient . AsyncHTTPClient ( ) if getattr ( self , "_OAUTH_VERSION" , "1.0a" ) == "1.0a" : http_client . fetch ( self . _oauth_request_token_url ( callback_uri = callback_uri , extra_params = extra_params ) , self . async_callback ( self . _on_request_token , self . _OAUTH_AUTHORIZE_URL , callback_uri ) ) else : http_client . fetch ( self . _oauth_request_token_url ( ) , self . async_callback ( self . _on_request_token , self . _OAUTH_AUTHORIZE_URL , callback_uri ) ) def get_authenticated_user ( self , callback , http_client = None ) : request_key = escape . utf8 ( self . get_argument ( "oauth_token" ) ) oauth_verifier = self . get_argument ( "oauth_verifier" , None ) request_cookie = self . get_cookie ( "_oauth_request_token" ) if not request_cookie : logging . warning ( "Missing OAuth request token cookie" ) callback ( None ) return self . clear_cookie ( "_oauth_request_token" ) cookie_key , cookie_secret = [ base64 . b64decode ( escape . utf8 ( i ) ) for i in request_cookie . split ( "|" ) ] if cookie_key != request_key : logging . info ( ( cookie_key , request_key , request_cookie ) ) logging . warning ( "Request token does not match cookie" ) callback ( None ) return token = dict ( key = cookie_key , secret = cookie_secret ) if oauth_verifier : token [ "verifier" ] = oauth_verifier if http_client is None : http_client = httpclient . AsyncHTTPClient ( ) http_client . fetch ( self . _oauth_access_token_url ( token ) , self . async_callback ( self . _on_access_token , callback ) ) def _oauth_request_token_url ( self , callback_uri = None , extra_params = None ) : consumer_token = self . _oauth_consumer_token ( ) url = self . _OAUTH_REQUEST_TOKEN_URL args = dict ( oauth_consumer_key = consumer_token [ "key" ] , oauth_signature_method = "HMAC-SHA1" , oauth_timestamp = str ( int ( time . time ( ) ) ) , oauth_nonce = binascii . b2a_hex ( uuid . uuid4 ( ) . bytes ) , oauth_version = getattr ( self , "_OAUTH_VERSION" , "1.0a" ) , ) if getattr ( self , "_OAUTH_VERSION" , "1.0a" ) == "1.0a" : if callback_uri : args [ "oauth_callback" ] = urlparse . urljoin ( self . request . full_url ( ) , callback_uri ) if extra_params : args . update ( extra_params ) signature = _oauth10a_signature ( consumer_token , "GET" , url , args ) else : signature = _oauth_signature ( consumer_token , "GET" , url , args ) args [ "oauth_signature" ] = signature return url + "?" + urllib . urlencode ( args ) def _on_request_token ( self , authorize_url , callback_uri , response ) : if response . error : raise Exception ( "Could not get request token" ) request_token = _oauth_parse_response ( response . body ) data = ( base64 . b64encode ( request_token [ "key" ] ) + b ( "|" ) + base64 . b64encode ( request_token [ "secret" ] ) ) self . set_cookie ( "_oauth_request_token" , data ) args = dict ( oauth_token = request_token [ "key" ] ) if callback_uri : args [ "oauth_callback" ] = urlparse . urljoin ( self . request . full_url ( ) , callback_uri ) self . redirect ( authorize_url + "?" + urllib . urlencode ( args ) ) def _oauth_access_token_url ( self , request_token ) : consumer_token = self . _oauth_consumer_token ( ) url = self . _OAUTH_ACCESS_TOKEN_URL args = dict ( oauth_consumer_key = consumer_token [ "key" ] , oauth_token = request_token [ "key" ] , oauth_signature_method = "HMAC-SHA1" , oauth_timestamp = str ( int ( time . time ( ) ) ) , oauth_nonce = binascii . b2a_hex ( uuid . uuid4 ( ) . bytes ) , oauth_version = getattr ( self , "_OAUTH_VERSION" , "1.0a" ) , ) if "verifier" in request_token : args [ "oauth_verifier" ] = request_token [ "verifier" ] if getattr ( self , "_OAUTH_VERSION" , "1.0a" ) == "1.0a" : signature = _oauth10a_signature ( consumer_token , "GET" , url , args , request_token ) else : signature = _oauth_signature ( consumer_token , "GET" , url , args , request_token ) args [ "oauth_signature" ] = signature return url + "?" + urllib . urlencode ( args ) def _on_access_token ( self , callback , response ) : if response . error : logging . warning ( "Could not fetch access token" ) callback ( None ) return access_token = _oauth_parse_response ( response . body ) self . _oauth_get_user ( access_token , self . async_callback ( self . _on_oauth_get_user , access_token , callback ) ) def _oauth_get_user ( self , access_token , callback ) : raise NotImplementedError ( ) def _on_oauth_get_user ( self , access_token , callback , user ) : if not user : callback ( None ) return user [ "access_token" ] = access_token callback ( user ) def _oauth_request_parameters ( self , url , access_token , parameters = { } , method = "GET" ) : consumer_token = self . _oauth_consumer_token ( ) base_args = dict ( oauth_consumer_key = consumer_token [ "key" ] , oauth_token = access_token [ "key" ] , oauth_signature_method = "HMAC-SHA1" , oauth_timestamp = str ( int ( time . time ( ) ) ) , oauth_nonce = binascii . b2a_hex ( uuid . uuid4 ( ) . bytes ) , oauth_version = getattr ( self , "_OAUTH_VERSION" , "1.0a" ) , ) args = { } args . update ( base_args ) args . update ( parameters ) if getattr ( self , "_OAUTH_VERSION" , "1.0a" ) == "1.0a" : signature = _oauth10a_signature ( consumer_token , method , url , args , access_token ) else : signature = _oauth_signature ( consumer_token , method , url , args , access_token ) base_args [ "oauth_signature" ] = signature return base_args class OAuth2Mixin ( object ) : def authorize_redirect ( self , redirect_uri = None , client_id = None , client_secret = None , extra_params = None ) : args = { : redirect_uri , : client_id } if extra_params : args . update ( extra_params ) self . redirect ( url_concat ( self . _OAUTH_AUTHORIZE_URL , args ) ) def _oauth_request_token_url ( self , redirect_uri = None , client_id = None , client_secret = None , code = None , extra_params = None ) : url = self . _OAUTH_ACCESS_TOKEN_URL args = dict ( redirect_uri = redirect_uri , code = code , client_id = client_id , client_secret = client_secret , ) if extra_params : args . update ( extra_params ) return url_concat ( url , args ) class TwitterMixin ( OAuthMixin ) : _OAUTH_REQUEST_TOKEN_URL = "http://api.twitter.com/oauth/request_token" _OAUTH_ACCESS_TOKEN_URL = "http://api.twitter.com/oauth/access_token" _OAUTH_AUTHORIZE_URL = "http://api.twitter.com/oauth/authorize" _OAUTH_AUTHENTICATE_URL = "http://api.twitter.com/oauth/authenticate" _OAUTH_NO_CALLBACKS = False def authenticate_redirect ( self , callback_uri = None ) : http = httpclient . AsyncHTTPClient ( ) http . fetch ( self . _oauth_request_token_url ( callback_uri = callback_uri ) , self . async_callback ( self . _on_request_token , self . _OAUTH_AUTHENTICATE_URL , None ) ) def twitter_request ( self , path , callback , access_token = None , post_args = None , ** args ) : if path . startswith ( 'http:' ) or path . startswith ( 'https:' ) : url = path else : url = "http://api.twitter.com/1" + path + ".json" if access_token : all_args = { } all_args . update ( args ) all_args . update ( post_args or { } ) method = "POST" if post_args is not None else "GET" oauth = self . _oauth_request_parameters ( url , access_token , all_args , method = method ) args . update ( oauth ) if args : url += "?" + urllib . urlencode ( args ) callback = self . async_callback ( self . _on_twitter_request , callback ) http = httpclient . AsyncHTTPClient ( ) if post_args is not None : http . fetch ( url , method = "POST" , body = urllib . urlencode ( post_args ) , callback = callback ) else : http . fetch ( url , callback = callback ) def _on_twitter_request ( self , callback , response ) : if response . error : logging . warning ( "Error response %s fetching %s" , response . error , response . request . url ) callback ( None ) return callback ( escape . json_decode ( response . body ) ) def _oauth_consumer_token ( self ) : self . require_setting ( "twitter_consumer_key" , "Twitter OAuth" ) self . require_setting ( "twitter_consumer_secret" , "Twitter OAuth" ) return dict ( key = self . settings [ "twitter_consumer_key" ] , secret = self . settings [ "twitter_consumer_secret" ] ) def _oauth_get_user ( self , access_token , callback ) : callback = self . async_callback ( self . _parse_user_response , callback ) self . twitter_request ( + access_token [ "screen_name" ] , access_token = access_token , callback = callback ) def _parse_user_response ( self , callback , user ) : if user : user [ "username" ] = user [ "screen_name" ] callback ( user ) class FriendFeedMixin ( OAuthMixin ) : _OAUTH_VERSION = "1.0" _OAUTH_REQUEST_TOKEN_URL = "https://friendfeed.com/account/oauth/request_token" _OAUTH_ACCESS_TOKEN_URL = "https://friendfeed.com/account/oauth/access_token" _OAUTH_AUTHORIZE_URL = "https://friendfeed.com/account/oauth/authorize" _OAUTH_NO_CALLBACKS = True _OAUTH_VERSION = "1.0" def friendfeed_request ( self , path , callback , access_token = None , post_args = None , ** args ) : url = "http://friendfeed-api.com/v2" + path if access_token : all_args = { } all_args . update ( args ) all_args . update ( post_args or { } ) method = "POST" if post_args is not None else "GET" oauth = self . _oauth_request_parameters ( url , access_token , all_args , method = method ) args . update ( oauth ) if args : url += "?" + urllib . urlencode ( args ) callback = self . async_callback ( self . _on_friendfeed_request , callback ) http = httpclient . AsyncHTTPClient ( ) if post_args is not None : http . fetch ( url , method = "POST" , body = urllib . urlencode ( post_args ) , callback = callback ) else : http . fetch ( url , callback = callback ) def _on_friendfeed_request ( self , callback , response ) : if response . error : logging . warning ( "Error response %s fetching %s" , response . error , response . request . url ) callback ( None ) return callback ( escape . json_decode ( response . body ) ) def _oauth_consumer_token ( self ) : self . require_setting ( "friendfeed_consumer_key" , "FriendFeed OAuth" ) self . require_setting ( "friendfeed_consumer_secret" , "FriendFeed OAuth" ) return dict ( key = self . settings [ "friendfeed_consumer_key" ] , secret = self . settings [ "friendfeed_consumer_secret" ] ) def _oauth_get_user ( self , access_token , callback ) : callback = self . async_callback ( self . _parse_user_response , callback ) self . friendfeed_request ( + access_token [ "username" ] , include = "id,name,description" , access_token = access_token , callback = callback ) def _parse_user_response ( self , callback , user ) : if user : user [ "username" ] = user [ "id" ] callback ( user ) class GoogleMixin ( OpenIdMixin , OAuthMixin ) : _OPENID_ENDPOINT = "https://www.google.com/accounts/o8/ud" _OAUTH_ACCESS_TOKEN_URL = "https://www.google.com/accounts/OAuthGetAccessToken" def authorize_redirect ( self , oauth_scope , callback_uri = None , ax_attrs = [ "name" , "email" , "language" , "username" ] ) : callback_uri = callback_uri or self . request . uri args = self . _openid_args ( callback_uri , ax_attrs = ax_attrs , oauth_scope = oauth_scope ) self . redirect ( self . _OPENID_ENDPOINT + "?" + urllib . urlencode ( args ) ) def get_authenticated_user ( self , callback ) : oauth_ns = "" for name , values in self . request . arguments . iteritems ( ) : if name . startswith ( "openid.ns." ) and values [ - 1 ] == u"http://specs.openid.net/extensions/oauth/1.0" : oauth_ns = name [ 10 : ] break token = self . get_argument ( "openid." + oauth_ns + ".request_token" , "" ) if token : http = httpclient . AsyncHTTPClient ( ) token = dict ( key = token , secret = "" ) http . fetch ( self . _oauth_access_token_url ( token ) , self . async_callback ( self . _on_access_token , callback ) ) else : OpenIdMixin . get_authenticated_user ( self , callback ) def _oauth_consumer_token ( self ) : self . require_setting ( "google_consumer_key" , "Google OAuth" ) self . require_setting ( "google_consumer_secret" , "Google OAuth" ) return dict ( key = self . settings [ "google_consumer_key" ] , secret = self . settings [ "google_consumer_secret" ] ) def _oauth_get_user ( self , access_token , callback ) : OpenIdMixin . get_authenticated_user ( self , callback ) class FacebookMixin ( object ) : def authenticate_redirect ( self , callback_uri = None , cancel_uri = None , extended_permissions = None ) : self . require_setting ( "facebook_api_key" , "Facebook Connect" ) callback_uri = callback_uri or self . request . uri args = { : self . settings [ "facebook_api_key" ] , : "1.0" , : "true" , : "page" , : urlparse . urljoin ( self . request . full_url ( ) , callback_uri ) , : "true" , } if cancel_uri : args [ "cancel_url" ] = urlparse . urljoin ( self . request . full_url ( ) , cancel_uri ) if extended_permissions : if isinstance ( extended_permissions , ( unicode , bytes_type ) ) : extended_permissions = [ extended_permissions ] args [ "req_perms" ] = "," . join ( extended_permissions ) self . redirect ( "http://www.facebook.com/login.php?" + urllib . urlencode ( args ) ) def authorize_redirect ( self , extended_permissions , callback_uri = None , cancel_uri = None ) : self . authenticate_redirect ( callback_uri , cancel_uri , extended_permissions ) def get_authenticated_user ( self , callback ) : self . require_setting ( "facebook_api_key" , "Facebook Connect" ) session = escape . json_decode ( self . get_argument ( "session" ) ) self . facebook_request ( method = "facebook.users.getInfo" , callback = self . async_callback ( self . _on_get_user_info , callback , session ) , session_key = session [ "session_key" ] , uids = session [ "uid" ] , fields = "uid,first_name,last_name,name,locale,pic_square," "profile_url,username" ) def facebook_request ( self , method , callback , ** args ) : self . require_setting ( "facebook_api_key" , "Facebook Connect" ) self . require_setting ( "facebook_secret" , "Facebook Connect" ) if not method . startswith ( "facebook." ) : method = "facebook." + method args [ "api_key" ] = self . settings [ "facebook_api_key" ] args [ "v" ] = "1.0" args [ "method" ] = method args [ "call_id" ] = str ( long ( time . time ( ) * 1e6 ) ) args [ "format" ] = "json" args [ "sig" ] = self . _signature ( args ) url = "http://api.facebook.com/restserver.php?" + urllib . urlencode ( args ) http = httpclient . AsyncHTTPClient ( ) http . fetch ( url , callback = self . async_callback ( self . _parse_response , callback ) ) def _on_get_user_info ( self , callback , session , users ) : if users is None : callback ( None ) return callback ( { : users [ 0 ] [ "name" ] , : users [ 0 ] [ "first_name" ] , : users [ 0 ] [ "last_name" ] , : users [ 0 ] [ "uid" ] , : users [ 0 ] [ "locale" ] , : users [ 0 ] [ "pic_square" ] , : users [ 0 ] [ "profile_url" ] , : users [ 0 ] . get ( "username" ) , : session [ "session_key" ] , : session . get ( "expires" ) , } ) def _parse_response ( self , callback , response ) : if response . error : logging . warning ( "HTTP error from Facebook: %s" , response . error ) callback ( None ) return try : json = escape . json_decode ( response . body ) except Exception : logging . warning ( "Invalid JSON from Facebook: %r" , response . body ) callback ( None ) return if isinstance ( json , dict ) and json . get ( "error_code" ) : logging . warning ( "Facebook error: %d: %r" , json [ "error_code" ] , json . get ( "error_msg" ) ) callback ( None ) return callback ( json ) def _signature ( self , args ) : parts = [ "%s=%s" % ( n , args [ n ] ) for n in sorted ( args . keys ( ) ) ] body = "" . join ( parts ) + self . settings [ "facebook_secret" ] if isinstance ( body , unicode ) : body = body . encode ( "utf-8" ) return hashlib . md5 ( body ) . hexdigest ( ) class FacebookGraphMixin ( OAuth2Mixin ) : _OAUTH_ACCESS_TOKEN_URL = "https://graph.facebook.com/oauth/access_token?" _OAUTH_AUTHORIZE_URL = "https://graph.facebook.com/oauth/authorize?" _OAUTH_NO_CALLBACKS = False def get_authenticated_user ( self , redirect_uri , client_id , client_secret , code , callback , extra_fields = None ) : http = httpclient . AsyncHTTPClient ( ) args = { : redirect_uri , : code , : client_id , : client_secret , } fields = set ( [ 'id' , 'name' , 'first_name' , 'last_name' , , 'picture' , 'link' ] ) if extra_fields : fields . update ( extra_fields ) http . fetch ( self . _oauth_request_token_url ( ** args ) , self . async_callback ( self . _on_access_token , redirect_uri , client_id , client_secret , callback , fields ) ) def _on_access_token ( self , redirect_uri , client_id , client_secret , callback , fields , response ) : if response . error : logging . warning ( 'Facebook auth error: %s' % str ( response ) ) callback ( None ) return args = escape . parse_qs_bytes ( escape . native_str ( response . body ) ) session = { : args [ "access_token" ] [ - 1 ] , : args . get ( "expires" ) } self . facebook_request ( path = "/me" , callback = self . async_callback ( self . _on_get_user_info , callback , session , fields ) , access_token = session [ "access_token" ] , fields = "," . join ( fields ) ) def _on_get_user_info ( self , callback , session , fields , user ) : if user is None : callback ( None ) return fieldmap = { } for field in fields : fieldmap [ field ] = user . get ( field ) fieldmap . update ( { "access_token" : session [ "access_token" ] , "session_expires" : session . get ( "expires" ) } ) callback ( fieldmap ) def facebook_request ( self , path , callback , access_token = None , post_args = None , ** args ) : url = "https://graph.facebook.com" + path all_args = { } if access_token : all_args [ "access_token" ] = access_token all_args . update ( args ) all_args . update ( post_args or { } ) if all_args : url += "?" + urllib . urlencode ( all_args ) callback = self . async_callback ( self . _on_facebook_request , callback ) http = httpclient . AsyncHTTPClient ( ) if post_args is not None : http . fetch ( url , method = "POST" , body = urllib . urlencode ( post_args ) , callback = callback ) else : http . fetch ( url , callback = callback ) def _on_facebook_request ( self , callback , response ) : if response . error : logging . warning ( "Error response %s fetching %s" , response . error , response . request . url ) callback ( None ) return callback ( escape . json_decode ( response . body ) ) def _oauth_signature ( consumer_token , method , url , parameters = { } , token = None ) : parts = urlparse . urlparse ( url ) scheme , netloc , path = parts [ : 3 ] normalized_url = scheme . lower ( ) + "://" + netloc . lower ( ) + path base_elems = [ ] base_elems . append ( method . upper ( ) ) base_elems . append ( normalized_url ) base_elems . append ( "&" . join ( "%s=%s" % ( k , _oauth_escape ( str ( v ) ) ) for k , v in sorted ( parameters . items ( ) ) ) ) base_string = "&" . join ( _oauth_escape ( e ) for e in base_elems ) key_elems = [ escape . utf8 ( consumer_token [ "secret" ] ) ] key_elems . append ( escape . utf8 ( token [ "secret" ] if token else "" ) ) key = b ( "&" ) . join ( key_elems ) hash = hmac . new ( key , escape . utf8 ( base_string ) , hashlib . sha1 ) return binascii . b2a_base64 ( hash . digest ( ) ) [ : - 1 ] def _oauth10a_signature ( consumer_token , method , url , parameters = { } , token = None ) : parts = urlparse . urlparse ( url ) scheme , netloc , path = parts [ : 3 ] normalized_url = scheme . lower ( ) + "://" + netloc . lower ( ) + path base_elems = [ ] base_elems . append ( method . upper ( ) ) base_elems . append ( normalized_url ) base_elems . append ( "&" . join ( "%s=%s" % ( k , _oauth_escape ( str ( v ) ) ) for k , v in sorted ( parameters . items ( ) ) ) ) base_string = "&" . join ( _oauth_escape ( e ) for e in base_elems ) key_elems = [ escape . utf8 ( urllib . quote ( consumer_token [ "secret" ] , safe = '~' ) ) ] key_elems . append ( escape . utf8 ( urllib . quote ( token [ "secret" ] , safe = '~' ) if token else "" ) ) key = b ( "&" ) . join ( key_elems ) hash = hmac . new ( key , escape . utf8 ( base_string ) , hashlib . sha1 ) return binascii . b2a_base64 ( hash . digest ( ) ) [ : - 1 ] def _oauth_escape ( val ) : if isinstance ( val , unicode ) : val = val . encode ( "utf-8" ) return urllib . quote ( val , safe = "~" ) def _oauth_parse_response ( body ) : p = escape . parse_qs ( body , keep_blank_values = False ) token = dict ( key = p [ b ( "oauth_token" ) ] [ 0 ] , secret = p [ b ( "oauth_token_secret" ) ] [ 0 ] ) special = ( b ( "oauth_token" ) , b ( "oauth_token_secret" ) ) token . update ( ( k , p [ k ] [ 0 ] ) for k in p if k not in special ) return token

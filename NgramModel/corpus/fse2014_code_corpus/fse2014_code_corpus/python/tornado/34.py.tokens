"""``tornado.gen`` is a generator-based interface to make it easier to work in an asynchronous environment. Code using the ``gen`` module is technically asynchronous, but it is written as a single generator instead of a collection of separate functions. For example, the following asynchronous handler:: class AsyncHandler(RequestHandler): @asynchronous def get(self): http_client = AsyncHTTPClient() http_client.fetch("http://example.com", callback=self.on_fetch) def on_fetch(self, response): do_something_with_response(response) self.render("template.html") could be written with ``gen`` as:: class GenAsyncHandler(RequestHandler): @asynchronous @gen.engine def get(self): http_client = AsyncHTTPClient() response = yield gen.Task(http_client.fetch, "http://example.com") do_something_with_response(response) self.render("template.html") `Task` works with any function that takes a ``callback`` keyword argument. You can also yield a list of ``Tasks``, which will be started at the same time and run in parallel; a list of results will be returned when they are all finished:: def get(self): http_client = AsyncHTTPClient() response1, response2 = yield [gen.Task(http_client.fetch, url1), gen.Task(http_client.fetch, url2)] For more complicated interfaces, `Task` can be split into two parts: `Callback` and `Wait`:: class GenAsyncHandler2(RequestHandler): @asynchronous @gen.engine def get(self): http_client = AsyncHTTPClient() http_client.fetch("http://example.com", callback=(yield gen.Callback("key")) response = yield gen.Wait("key") do_something_with_response(response) self.render("template.html") The ``key`` argument to `Callback` and `Wait` allows for multiple asynchronous operations to be started at different times and proceed in parallel: yield several callbacks with different keys, then wait for them once all the async operations have started. The result of a `Wait` or `Task` yield expression depends on how the callback was run. If it was called with no arguments, the result is ``None``. If it was called with one argument, the result is that argument. If it was called with more than one argument or any keyword arguments, the result is an `Arguments` object, which is a named tuple ``(args, kwargs)``. """ from __future__ import absolute_import , division , with_statement import functools import operator import sys import types from tornado . stack_context import ExceptionStackContext class KeyReuseError ( Exception ) : pass class UnknownKeyError ( Exception ) : pass class LeakedCallbackError ( Exception ) : pass class BadYieldError ( Exception ) : pass def engine ( func ) : @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : runner = None def handle_exception ( typ , value , tb ) : if runner is not None : return runner . handle_exception ( typ , value , tb ) return False with ExceptionStackContext ( handle_exception ) : gen = func ( * args , ** kwargs ) if isinstance ( gen , types . GeneratorType ) : runner = Runner ( gen ) runner . run ( ) return assert gen is None , gen return wrapper class YieldPoint ( object ) : def start ( self , runner ) : raise NotImplementedError ( ) def is_ready ( self ) : raise NotImplementedError ( ) def get_result ( self ) : raise NotImplementedError ( ) class Callback ( YieldPoint ) : def __init__ ( self , key ) : self . key = key def start ( self , runner ) : self . runner = runner runner . register_callback ( self . key ) def is_ready ( self ) : return True def get_result ( self ) : return self . runner . result_callback ( self . key ) class Wait ( YieldPoint ) : def __init__ ( self , key ) : self . key = key def start ( self , runner ) : self . runner = runner def is_ready ( self ) : return self . runner . is_ready ( self . key ) def get_result ( self ) : return self . runner . pop_result ( self . key ) class WaitAll ( YieldPoint ) : def __init__ ( self , keys ) : self . keys = keys def start ( self , runner ) : self . runner = runner def is_ready ( self ) : return all ( self . runner . is_ready ( key ) for key in self . keys ) def get_result ( self ) : return [ self . runner . pop_result ( key ) for key in self . keys ] class Task ( YieldPoint ) : def __init__ ( self , func , * args , ** kwargs ) : assert "callback" not in kwargs self . args = args self . kwargs = kwargs self . func = func def start ( self , runner ) : self . runner = runner self . key = object ( ) runner . register_callback ( self . key ) self . kwargs [ "callback" ] = runner . result_callback ( self . key ) self . func ( * self . args , ** self . kwargs ) def is_ready ( self ) : return self . runner . is_ready ( self . key ) def get_result ( self ) : return self . runner . pop_result ( self . key ) class Multi ( YieldPoint ) : def __init__ ( self , children ) : assert all ( isinstance ( i , YieldPoint ) for i in children ) self . children = children def start ( self , runner ) : for i in self . children : i . start ( runner ) def is_ready ( self ) : return all ( i . is_ready ( ) for i in self . children ) def get_result ( self ) : return [ i . get_result ( ) for i in self . children ] class _NullYieldPoint ( YieldPoint ) : def start ( self , runner ) : pass def is_ready ( self ) : return True def get_result ( self ) : return None class Runner ( object ) : def __init__ ( self , gen ) : self . gen = gen self . yield_point = _NullYieldPoint ( ) self . pending_callbacks = set ( ) self . results = { } self . running = False self . finished = False self . exc_info = None self . had_exception = False def register_callback ( self , key ) : if key in self . pending_callbacks : raise KeyReuseError ( "key %r is already pending" % key ) self . pending_callbacks . add ( key ) def is_ready ( self , key ) : if key not in self . pending_callbacks : raise UnknownKeyError ( "key %r is not pending" % key ) return key in self . results def set_result ( self , key , result ) : self . results [ key ] = result self . run ( ) def pop_result ( self , key ) : self . pending_callbacks . remove ( key ) return self . results . pop ( key ) def run ( self ) : if self . running or self . finished : return try : self . running = True while True : if self . exc_info is None : try : if not self . yield_point . is_ready ( ) : return next = self . yield_point . get_result ( ) except Exception : self . exc_info = sys . exc_info ( ) try : if self . exc_info is not None : self . had_exception = True exc_info = self . exc_info self . exc_info = None yielded = self . gen . throw ( * exc_info ) else : yielded = self . gen . send ( next ) except StopIteration : self . finished = True if self . pending_callbacks and not self . had_exception : raise LeakedCallbackError ( % self . pending_callbacks ) return except Exception : self . finished = True raise if isinstance ( yielded , list ) : yielded = Multi ( yielded ) if isinstance ( yielded , YieldPoint ) : self . yield_point = yielded try : self . yield_point . start ( self ) except Exception : self . exc_info = sys . exc_info ( ) else : self . exc_info = ( BadYieldError ( "yielded unknown object %r" % yielded ) , ) finally : self . running = False def result_callback ( self , key ) : def inner ( * args , ** kwargs ) : if kwargs or len ( args ) > 1 : result = Arguments ( args , kwargs ) elif args : result = args [ 0 ] else : result = None self . set_result ( key , result ) return inner def handle_exception ( self , typ , value , tb ) : if not self . running and not self . finished : self . exc_info = ( typ , value , tb ) self . run ( ) return True else : return False class Arguments ( tuple ) : __slots__ = ( ) def __new__ ( cls , args , kwargs ) : return tuple . __new__ ( cls , ( args , kwargs ) ) args = property ( operator . itemgetter ( 0 ) ) kwargs = property ( operator . itemgetter ( 1 ) )

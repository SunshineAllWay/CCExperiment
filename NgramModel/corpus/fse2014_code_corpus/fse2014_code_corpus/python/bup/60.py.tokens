"""Helper functions and classes for bup.""" import sys , os , pwd , subprocess , errno , socket , select , mmap , stat , re , struct import heapq , operator , time , platform from bup import _version , _helpers import bup . _helpers as _helpers from bup . options import _tty_width tty_width = _tty_width def atoi ( s ) : try : return int ( s or '0' ) except ValueError : return 0 def atof ( s ) : try : return float ( s or '0' ) except ValueError : return 0 buglvl = atoi ( os . environ . get ( 'BUP_DEBUG' , 0 ) ) def _hard_write ( fd , buf ) : while buf : ( r , w , x ) = select . select ( [ ] , [ fd ] , [ ] , None ) if not w : raise IOError ( 'select(fd) returned without being writable' ) try : sz = os . write ( fd , buf ) except OSError , e : if e . errno != errno . EAGAIN : raise assert ( sz >= 0 ) buf = buf [ sz : ] _last_prog = 0 def log ( s ) : global _last_prog sys . stdout . flush ( ) _hard_write ( sys . stderr . fileno ( ) , s ) _last_prog = 0 def debug1 ( s ) : if buglvl >= 1 : log ( s ) def debug2 ( s ) : if buglvl >= 2 : log ( s ) istty1 = os . isatty ( 1 ) or ( atoi ( os . environ . get ( 'BUP_FORCE_TTY' ) ) & 1 ) istty2 = os . isatty ( 2 ) or ( atoi ( os . environ . get ( 'BUP_FORCE_TTY' ) ) & 2 ) _last_progress = '' def progress ( s ) : global _last_progress if istty2 : log ( s ) _last_progress = s def qprogress ( s ) : global _last_prog now = time . time ( ) if now - _last_prog > 0.1 : progress ( s ) _last_prog = now def reprogress ( ) : if _last_progress and _last_progress . endswith ( '\r' ) : progress ( _last_progress ) def mkdirp ( d , mode = None ) : try : if mode : os . makedirs ( d , mode ) else : os . makedirs ( d ) except OSError , e : if e . errno == errno . EEXIST : pass else : raise def next ( it ) : try : return it . next ( ) except StopIteration : return None def merge_iter ( iters , pfreq , pfunc , pfinal , key = None ) : if key : samekey = lambda e , pe : getattr ( e , key ) == getattr ( pe , key , None ) else : samekey = operator . eq count = 0 total = sum ( len ( it ) for it in iters ) iters = ( iter ( it ) for it in iters ) heap = ( ( next ( it ) , it ) for it in iters ) heap = [ ( e , it ) for e , it in heap if e ] heapq . heapify ( heap ) pe = None while heap : if not count % pfreq : pfunc ( count , total ) e , it = heap [ 0 ] if not samekey ( e , pe ) : pe = e yield e count += 1 try : e = it . next ( ) except StopIteration : heapq . heappop ( heap ) else : heapq . heapreplace ( heap , ( e , it ) ) pfinal ( count , total ) def unlink ( f ) : try : os . unlink ( f ) except OSError , e : if e . errno == errno . ENOENT : pass def readpipe ( argv ) : p = subprocess . Popen ( argv , stdout = subprocess . PIPE ) r = p . stdout . read ( ) p . wait ( ) return r def realpath ( p ) : try : st = os . lstat ( p ) except OSError : st = None if st and stat . S_ISLNK ( st . st_mode ) : ( dir , name ) = os . path . split ( p ) dir = os . path . realpath ( dir ) out = os . path . join ( dir , name ) else : out = os . path . realpath ( p ) return out def detect_fakeroot ( ) : return os . getenv ( "FAKEROOTKEY" ) != None def is_superuser ( ) : if platform . system ( ) . startswith ( 'CYGWIN' ) : import ctypes return ctypes . cdll . shell32 . IsUserAnAdmin ( ) else : return os . geteuid ( ) == 0 _username = None def username ( ) : global _username if not _username : uid = os . getuid ( ) try : _username = pwd . getpwuid ( uid ) [ 0 ] except KeyError : _username = 'user%d' % uid return _username _userfullname = None def userfullname ( ) : global _userfullname if not _userfullname : uid = os . getuid ( ) try : _userfullname = pwd . getpwuid ( uid ) [ 4 ] . split ( ',' ) [ 0 ] except KeyError : _userfullname = 'user%d' % uid return _userfullname _hostname = None def hostname ( ) : global _hostname if not _hostname : _hostname = socket . getfqdn ( ) return _hostname _resource_path = None def resource_path ( subdir = '' ) : global _resource_path if not _resource_path : _resource_path = os . environ . get ( 'BUP_RESOURCE_PATH' ) or '.' return os . path . join ( _resource_path , subdir ) class NotOk ( Exception ) : pass class BaseConn : def __init__ ( self , outp ) : self . outp = outp def close ( self ) : while self . _read ( 65536 ) : pass def read ( self , size ) : self . outp . flush ( ) return self . _read ( size ) def readline ( self ) : self . outp . flush ( ) return self . _readline ( ) def write ( self , data ) : self . outp . write ( data ) def has_input ( self ) : raise NotImplemented ( "Subclasses must implement has_input" ) def ok ( self ) : self . write ( '\nok\n' ) def error ( self , s ) : s = re . sub ( r'\s+' , ' ' , str ( s ) ) self . write ( '\nerror %s\n' % s ) def _check_ok ( self , onempty ) : self . outp . flush ( ) rl = '' for rl in linereader ( self ) : if not rl : continue elif rl == 'ok' : return None elif rl . startswith ( 'error ' ) : return NotOk ( rl [ 6 : ] ) else : onempty ( rl ) raise Exception ( 'server exited unexpectedly; see errors above' ) def drain_and_check_ok ( self ) : def onempty ( rl ) : pass return self . _check_ok ( onempty ) def check_ok ( self ) : def onempty ( rl ) : raise Exception ( 'expected "ok", got %r' % rl ) return self . _check_ok ( onempty ) class Conn ( BaseConn ) : def __init__ ( self , inp , outp ) : BaseConn . __init__ ( self , outp ) self . inp = inp def _read ( self , size ) : return self . inp . read ( size ) def _readline ( self ) : return self . inp . readline ( ) def has_input ( self ) : [ rl , wl , xl ] = select . select ( [ self . inp . fileno ( ) ] , [ ] , [ ] , 0 ) if rl : assert ( rl [ 0 ] == self . inp . fileno ( ) ) return True else : return None def checked_reader ( fd , n ) : while n > 0 : rl , _ , _ = select . select ( [ fd ] , [ ] , [ ] ) assert ( rl [ 0 ] == fd ) buf = os . read ( fd , n ) if not buf : raise Exception ( "Unexpected EOF reading %d more bytes" % n ) yield buf n -= len ( buf ) MAX_PACKET = 128 * 1024 def mux ( p , outfd , outr , errr ) : try : fds = [ outr , errr ] while p . poll ( ) is None : rl , _ , _ = select . select ( fds , [ ] , [ ] ) for fd in rl : if fd == outr : buf = os . read ( outr , MAX_PACKET ) if not buf : break os . write ( outfd , struct . pack ( '!IB' , len ( buf ) , 1 ) + buf ) elif fd == errr : buf = os . read ( errr , 1024 ) if not buf : break os . write ( outfd , struct . pack ( '!IB' , len ( buf ) , 2 ) + buf ) finally : os . write ( outfd , struct . pack ( '!IB' , 0 , 3 ) ) class DemuxConn ( BaseConn ) : def __init__ ( self , infd , outp ) : BaseConn . __init__ ( self , outp ) tail = '' while tail != 'BUPMUX' : b = os . read ( infd , ( len ( tail ) < 6 ) and ( 6 - len ( tail ) ) or 1 ) if not b : raise IOError ( 'demux: unexpected EOF during initialization' ) tail += b sys . stderr . write ( tail [ : - 6 ] ) tail = tail [ - 6 : ] self . infd = infd self . reader = None self . buf = None self . closed = False def write ( self , data ) : self . _load_buf ( 0 ) BaseConn . write ( self , data ) def _next_packet ( self , timeout ) : if self . closed : return False rl , wl , xl = select . select ( [ self . infd ] , [ ] , [ ] , timeout ) if not rl : return False assert ( rl [ 0 ] == self . infd ) ns = '' . join ( checked_reader ( self . infd , 5 ) ) n , fdw = struct . unpack ( '!IB' , ns ) assert ( n <= MAX_PACKET ) if fdw == 1 : self . reader = checked_reader ( self . infd , n ) elif fdw == 2 : for buf in checked_reader ( self . infd , n ) : sys . stderr . write ( buf ) elif fdw == 3 : self . closed = True debug2 ( "DemuxConn: marked closed\n" ) return True def _load_buf ( self , timeout ) : if self . buf is not None : return True while not self . closed : while not self . reader : if not self . _next_packet ( timeout ) : return False try : self . buf = self . reader . next ( ) return True except StopIteration : self . reader = None return False def _read_parts ( self , ix_fn ) : while self . _load_buf ( None ) : assert ( self . buf is not None ) i = ix_fn ( self . buf ) if i is None or i == len ( self . buf ) : yv = self . buf self . buf = None else : yv = self . buf [ : i ] self . buf = self . buf [ i : ] yield yv if i is not None : break def _readline ( self ) : def find_eol ( buf ) : try : return buf . index ( '\n' ) + 1 except ValueError : return None return '' . join ( self . _read_parts ( find_eol ) ) def _read ( self , size ) : csize = [ size ] def until_size ( buf ) : if len ( buf ) < csize [ 0 ] : csize [ 0 ] -= len ( buf ) return None else : return csize [ 0 ] return '' . join ( self . _read_parts ( until_size ) ) def has_input ( self ) : return self . _load_buf ( 0 ) def linereader ( f ) : while 1 : line = f . readline ( ) if not line : break yield line [ : - 1 ] def chunkyreader ( f , count = None ) : if count != None : while count > 0 : b = f . read ( min ( count , 65536 ) ) if not b : raise IOError ( 'EOF with %d bytes remaining' % count ) yield b count -= len ( b ) else : while 1 : b = f . read ( 65536 ) if not b : break yield b def slashappend ( s ) : if s and not s . endswith ( '/' ) : return s + '/' else : return s def _mmap_do ( f , sz , flags , prot , close ) : if not sz : st = os . fstat ( f . fileno ( ) ) sz = st . st_size if not sz : return '' map = mmap . mmap ( f . fileno ( ) , sz , flags , prot ) if close : f . close ( ) return map def mmap_read ( f , sz = 0 , close = True ) : return _mmap_do ( f , sz , mmap . MAP_PRIVATE , mmap . PROT_READ , close ) def mmap_readwrite ( f , sz = 0 , close = True ) : return _mmap_do ( f , sz , mmap . MAP_SHARED , mmap . PROT_READ | mmap . PROT_WRITE , close ) def mmap_readwrite_private ( f , sz = 0 , close = True ) : return _mmap_do ( f , sz , mmap . MAP_PRIVATE , mmap . PROT_READ | mmap . PROT_WRITE , close ) def parse_num ( s ) : g = re . match ( r'([-+\d.e]+)\s*(\w*)' , str ( s ) ) if not g : raise ValueError ( "can't parse %r as a number" % s ) ( val , unit ) = g . groups ( ) num = float ( val ) unit = unit . lower ( ) if unit in [ 't' , 'tb' ] : mult = 1024 * 1024 * 1024 * 1024 elif unit in [ 'g' , 'gb' ] : mult = 1024 * 1024 * 1024 elif unit in [ 'm' , 'mb' ] : mult = 1024 * 1024 elif unit in [ 'k' , 'kb' ] : mult = 1024 elif unit in [ '' , 'b' ] : mult = 1 else : raise ValueError ( "invalid unit %r in number %r" % ( unit , s ) ) return int ( num * mult ) def count ( l ) : return reduce ( lambda x , y : x + 1 , l ) saved_errors = [ ] def add_error ( e ) : saved_errors . append ( e ) log ( '%-70s\n' % e ) def clear_errors ( ) : global saved_errors saved_errors = [ ] def handle_ctrl_c ( ) : oldhook = sys . excepthook def newhook ( exctype , value , traceback ) : if exctype == KeyboardInterrupt : log ( 'Interrupted.\n' ) else : return oldhook ( exctype , value , traceback ) sys . excepthook = newhook def columnate ( l , prefix ) : if not l : return "" l = l [ : ] clen = max ( len ( s ) for s in l ) ncols = ( tty_width ( ) - len ( prefix ) ) / ( clen + 2 ) if ncols <= 1 : ncols = 1 clen = 0 cols = [ ] while len ( l ) % ncols : l . append ( '' ) rows = len ( l ) / ncols for s in range ( 0 , len ( l ) , rows ) : cols . append ( l [ s : s + rows ] ) out = '' for row in zip ( * cols ) : out += prefix + '' . join ( ( '%-*s' % ( clen + 2 , s ) ) for s in row ) + '\n' return out def parse_date_or_fatal ( str , fatal ) : try : date = atof ( str ) except ValueError , e : raise fatal ( 'invalid date format (should be a float): %r' % e ) else : return date def strip_path ( prefix , path ) : if prefix == None : raise Exception ( 'no path given' ) normalized_prefix = os . path . realpath ( prefix ) debug2 ( "normalized_prefix: %s\n" % normalized_prefix ) normalized_path = os . path . realpath ( path ) debug2 ( "normalized_path: %s\n" % normalized_path ) if normalized_path . startswith ( normalized_prefix ) : return normalized_path [ len ( normalized_prefix ) : ] else : return path def strip_base_path ( path , base_paths ) : normalized_path = os . path . realpath ( path ) sorted_base_paths = sorted ( base_paths , key = len , reverse = True ) for bp in sorted_base_paths : if normalized_path . startswith ( os . path . realpath ( bp ) ) : return strip_path ( bp , normalized_path ) return path def graft_path ( graft_points , path ) : normalized_path = os . path . realpath ( path ) for graft_point in graft_points : old_prefix , new_prefix = graft_point if normalized_path . startswith ( old_prefix ) : return re . sub ( r'^' + old_prefix , new_prefix , normalized_path ) return normalized_path try : import hashlib except ImportError : import sha Sha1 = sha . sha else : Sha1 = hashlib . sha1 def version_date ( ) : return _version . DATE . split ( ' ' ) [ 0 ] def version_commit ( ) : return _version . COMMIT def version_tag ( ) : names = _version . NAMES . strip ( ) assert ( names [ 0 ] == '(' ) assert ( names [ - 1 ] == ')' ) names = names [ 1 : - 1 ] l = [ n . strip ( ) for n in names . split ( ',' ) ] for n in l : if n . startswith ( 'tag: bup-' ) : return n [ 9 : ] return 'unknown-%s' % _version . COMMIT [ : 7 ]

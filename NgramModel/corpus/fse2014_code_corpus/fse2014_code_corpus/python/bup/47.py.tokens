import datetime import logging import logging . handlers import re import sys import time try : import curses except : curses = None def define ( name , default = None , type = str , help = None , metavar = None , multiple = False ) : if name in options : raise Error ( "Option %r already defined in %s" , name , options [ name ] . file_name ) frame = sys . _getframe ( 0 ) options_file = frame . f_code . co_filename file_name = frame . f_back . f_code . co_filename if file_name == options_file : file_name = "" options [ name ] = _Option ( name , file_name = file_name , default = default , type = type , help = help , metavar = metavar , multiple = multiple ) def parse_command_line ( args = None ) : if args is None : args = sys . argv remaining = [ ] for i in xrange ( 1 , len ( args ) ) : if not args [ i ] . startswith ( "-" ) : remaining = args [ i : ] break if args [ i ] == "--" : remaining = args [ i + 1 : ] break arg = args [ i ] . lstrip ( "-" ) name , equals , value = arg . partition ( "=" ) name = name . replace ( '-' , '_' ) if not name in options : print_help ( ) raise Error ( 'Unrecognized command line option: %r' % name ) option = options [ name ] if not equals : if option . type == bool : value = "true" else : raise Error ( 'Option %r requires a value' % name ) option . parse ( value ) if options . help : print_help ( ) sys . exit ( 0 ) if options . logging != 'none' : logging . getLogger ( ) . setLevel ( getattr ( logging , options . logging . upper ( ) ) ) enable_pretty_logging ( ) return remaining def parse_config_file ( path ) : config = { } execfile ( path , config , config ) for name in config : if name in options : options [ name ] . set ( config [ name ] ) def print_help ( file = sys . stdout ) : print >> file , "Usage: %s [OPTIONS]" % sys . argv [ 0 ] print >> file , "" print >> file , "Options:" by_file = { } for option in options . itervalues ( ) : by_file . setdefault ( option . file_name , [ ] ) . append ( option ) for filename , o in sorted ( by_file . items ( ) ) : if filename : print >> file , filename o . sort ( key = lambda option : option . name ) for option in o : prefix = option . name if option . metavar : prefix += "=" + option . metavar print >> file , " --%-30s %s" % ( prefix , option . help or "" ) print >> file class _Options ( dict ) : @ classmethod def instance ( cls ) : if not hasattr ( cls , "_instance" ) : cls . _instance = cls ( ) return cls . _instance def __getattr__ ( self , name ) : if isinstance ( self . get ( name ) , _Option ) : return self [ name ] . value ( ) raise AttributeError ( "Unrecognized option %r" % name ) class _Option ( object ) : def __init__ ( self , name , default = None , type = str , help = None , metavar = None , multiple = False , file_name = None ) : if default is None and multiple : default = [ ] self . name = name self . type = type self . help = help self . metavar = metavar self . multiple = multiple self . file_name = file_name self . default = default self . _value = None def value ( self ) : return self . default if self . _value is None else self . _value def parse ( self , value ) : _parse = { datetime . datetime : self . _parse_datetime , datetime . timedelta : self . _parse_timedelta , bool : self . _parse_bool , str : self . _parse_string , } . get ( self . type , self . type ) if self . multiple : if self . _value is None : self . _value = [ ] for part in value . split ( "," ) : if self . type in ( int , long ) : lo , _ , hi = part . partition ( ":" ) lo = _parse ( lo ) hi = _parse ( hi ) if hi else lo self . _value . extend ( range ( lo , hi + 1 ) ) else : self . _value . append ( _parse ( part ) ) else : self . _value = _parse ( value ) return self . value ( ) def set ( self , value ) : if self . multiple : if not isinstance ( value , list ) : raise Error ( "Option %r is required to be a list of %s" % ( self . name , self . type . __name__ ) ) for item in value : if item != None and not isinstance ( item , self . type ) : raise Error ( "Option %r is required to be a list of %s" % ( self . name , self . type . __name__ ) ) else : if value != None and not isinstance ( value , self . type ) : raise Error ( "Option %r is required to be a %s" % ( self . name , self . type . __name__ ) ) self . _value = value _DATETIME_FORMATS = [ , , , , , , , , , , ] def _parse_datetime ( self , value ) : for format in self . _DATETIME_FORMATS : try : return datetime . datetime . strptime ( value , format ) except ValueError : pass raise Error ( 'Unrecognized date/time format: %r' % value ) _TIMEDELTA_ABBREVS = [ ( 'hours' , [ 'h' ] ) , ( 'minutes' , [ 'm' , 'min' ] ) , ( 'seconds' , [ 's' , 'sec' ] ) , ( 'milliseconds' , [ 'ms' ] ) , ( 'microseconds' , [ 'us' ] ) , ( 'days' , [ 'd' ] ) , ( 'weeks' , [ 'w' ] ) , ] _TIMEDELTA_ABBREV_DICT = dict ( ( abbrev , full ) for full , abbrevs in _TIMEDELTA_ABBREVS for abbrev in abbrevs ) _FLOAT_PATTERN = r'[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?' _TIMEDELTA_PATTERN = re . compile ( % _FLOAT_PATTERN , re . IGNORECASE ) def _parse_timedelta ( self , value ) : try : sum = datetime . timedelta ( ) start = 0 while start < len ( value ) : m = self . _TIMEDELTA_PATTERN . match ( value , start ) if not m : raise Exception ( ) num = float ( m . group ( 1 ) ) units = m . group ( 2 ) or 'seconds' units = self . _TIMEDELTA_ABBREV_DICT . get ( units , units ) sum += datetime . timedelta ( ** { units : num } ) start = m . end ( ) return sum except : raise def _parse_bool ( self , value ) : return value . lower ( ) not in ( "false" , "0" , "f" ) def _parse_string ( self , value ) : return value . decode ( "utf-8" ) class Error ( Exception ) : pass def enable_pretty_logging ( ) : if ( options . log_to_stderr or ( options . log_to_stderr is None and not options . log_file_prefix ) ) : color = False if curses and sys . stderr . isatty ( ) : try : curses . setupterm ( ) if curses . tigetnum ( "colors" ) > 0 : color = True except : pass channel = logging . StreamHandler ( ) channel . setFormatter ( _LogFormatter ( color = color ) ) logging . getLogger ( ) . addHandler ( channel ) if options . log_file_prefix : channel = logging . handlers . RotatingFileHandler ( filename = options . log_file_prefix , maxBytes = options . log_file_max_size , backupCount = options . log_file_num_backups ) channel . setFormatter ( _LogFormatter ( color = False ) ) logging . getLogger ( ) . addHandler ( channel ) class _LogFormatter ( logging . Formatter ) : def __init__ ( self , color , * args , ** kwargs ) : logging . Formatter . __init__ ( self , * args , ** kwargs ) self . _color = color if color : fg_color = curses . tigetstr ( "setaf" ) or curses . tigetstr ( "setf" ) or "" self . _colors = { logging . DEBUG : curses . tparm ( fg_color , 4 ) , logging . INFO : curses . tparm ( fg_color , 2 ) , logging . WARNING : curses . tparm ( fg_color , 3 ) , logging . ERROR : curses . tparm ( fg_color , 1 ) , } self . _normal = curses . tigetstr ( "sgr0" ) def format ( self , record ) : try : record . message = record . getMessage ( ) except Exception , e : record . message = "Bad message (%r): %r" % ( e , record . __dict__ ) record . asctime = time . strftime ( , self . converter ( record . created ) ) prefix = '[%(levelname)1.1s %(asctime)s %(module)s:%(lineno)d]' % record . __dict__ if self . _color : prefix = ( self . _colors . get ( record . levelno , self . _normal ) + prefix + self . _normal ) formatted = prefix + " " + record . message if record . exc_info : if not record . exc_text : record . exc_text = self . formatException ( record . exc_info ) if record . exc_text : formatted = formatted . rstrip ( ) + "\n" + record . exc_text return formatted . replace ( "\n" , "\n " ) options = _Options . instance ( ) define ( "help" , type = bool , help = "show this help information" ) define ( "logging" , default = "info" , help = ( "Set the Python log level. If 'none', tornado won't touch the " ) , metavar = "info|warning|error|none" ) define ( "log_to_stderr" , type = bool , default = None , help = ( "Send log output to stderr (colorized if possible). " ) ) define ( "log_file_prefix" , type = str , default = None , metavar = "PATH" , help = ( "Path prefix for log files. " ) ) define ( "log_file_max_size" , type = int , default = 100 * 1000 * 1000 , help = "max size of log files before rollover" ) define ( "log_file_num_backups" , type = int , default = 10 , help = "number of log files to keep" )

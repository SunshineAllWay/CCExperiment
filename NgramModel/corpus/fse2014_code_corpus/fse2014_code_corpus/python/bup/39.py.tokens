import base64 import binascii import calendar import Cookie import cStringIO import datetime import email . utils import escape import functools import gzip import hashlib import hmac import httplib import locale import logging import mimetypes import os . path import re import stat import sys import template import time import types import urllib import urlparse import uuid class RequestHandler ( object ) : SUPPORTED_METHODS = ( "GET" , "HEAD" , "POST" , "DELETE" , "PUT" ) def __init__ ( self , application , request , transforms = None ) : self . application = application self . request = request self . _headers_written = False self . _finished = False self . _auto_finish = True self . _transforms = transforms or [ ] self . ui = _O ( ( n , self . _ui_method ( m ) ) for n , m in application . ui_methods . iteritems ( ) ) self . ui [ "modules" ] = _O ( ( n , self . _ui_module ( n , m ) ) for n , m in application . ui_modules . iteritems ( ) ) self . clear ( ) if hasattr ( self . request , "connection" ) : self . request . connection . stream . set_close_callback ( self . on_connection_close ) @ property def settings ( self ) : return self . application . settings def head ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def get ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def post ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def delete ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def put ( self , * args , ** kwargs ) : raise HTTPError ( 405 ) def prepare ( self ) : pass def on_connection_close ( self ) : pass def clear ( self ) : self . _headers = { : "TornadoServer/0.1" , : "text/html; charset=UTF-8" , } if not self . request . supports_http_1_1 ( ) : if self . request . headers . get ( "Connection" ) == "Keep-Alive" : self . set_header ( "Connection" , "Keep-Alive" ) self . _write_buffer = [ ] self . _status_code = 200 def set_status ( self , status_code ) : assert status_code in httplib . responses self . _status_code = status_code def set_header ( self , name , value ) : if isinstance ( value , datetime . datetime ) : t = calendar . timegm ( value . utctimetuple ( ) ) value = email . utils . formatdate ( t , localtime = False , usegmt = True ) elif isinstance ( value , int ) or isinstance ( value , long ) : value = str ( value ) else : value = _utf8 ( value ) safe_value = re . sub ( r"[\x00-\x1f]" , " " , value ) [ : 4000 ] if safe_value != value : raise ValueError ( "Unsafe header value %r" , value ) self . _headers [ name ] = value _ARG_DEFAULT = [ ] def get_argument ( self , name , default = _ARG_DEFAULT , strip = True ) : args = self . get_arguments ( name , strip = strip ) if not args : if default is self . _ARG_DEFAULT : raise HTTPError ( 404 , "Missing argument %s" % name ) return default return args [ - 1 ] def get_arguments ( self , name , strip = True ) : values = self . request . arguments . get ( name , [ ] ) values = [ re . sub ( r"[\x00-\x08\x0e-\x1f]" , " " , x ) for x in values ] values = [ _unicode ( x ) for x in values ] if strip : values = [ x . strip ( ) for x in values ] return values @ property def cookies ( self ) : if not hasattr ( self , "_cookies" ) : self . _cookies = Cookie . BaseCookie ( ) if "Cookie" in self . request . headers : try : self . _cookies . load ( self . request . headers [ "Cookie" ] ) except : self . clear_all_cookies ( ) return self . _cookies def get_cookie ( self , name , default = None ) : if name in self . cookies : return self . cookies [ name ] . value return default def set_cookie ( self , name , value , domain = None , expires = None , path = "/" , expires_days = None , ** kwargs ) : name = _utf8 ( name ) value = _utf8 ( value ) if re . search ( r"[\x00-\x20]" , name + value ) : raise ValueError ( "Invalid cookie %r: %r" % ( name , value ) ) if not hasattr ( self , "_new_cookies" ) : self . _new_cookies = [ ] new_cookie = Cookie . BaseCookie ( ) self . _new_cookies . append ( new_cookie ) new_cookie [ name ] = value if domain : new_cookie [ name ] [ "domain" ] = domain if expires_days is not None and not expires : expires = datetime . datetime . utcnow ( ) + datetime . timedelta ( days = expires_days ) if expires : timestamp = calendar . timegm ( expires . utctimetuple ( ) ) new_cookie [ name ] [ "expires" ] = email . utils . formatdate ( timestamp , localtime = False , usegmt = True ) if path : new_cookie [ name ] [ "path" ] = path for k , v in kwargs . iteritems ( ) : new_cookie [ name ] [ k ] = v def clear_cookie ( self , name , path = "/" , domain = None ) : expires = datetime . datetime . utcnow ( ) - datetime . timedelta ( days = 365 ) self . set_cookie ( name , value = "" , path = path , expires = expires , domain = domain ) def clear_all_cookies ( self ) : for name in self . cookies . iterkeys ( ) : self . clear_cookie ( name ) def set_secure_cookie ( self , name , value , expires_days = 30 , ** kwargs ) : timestamp = str ( int ( time . time ( ) ) ) value = base64 . b64encode ( value ) signature = self . _cookie_signature ( name , value , timestamp ) value = "|" . join ( [ value , timestamp , signature ] ) self . set_cookie ( name , value , expires_days = expires_days , ** kwargs ) def get_secure_cookie ( self , name , include_name = True , value = None ) : if value is None : value = self . get_cookie ( name ) if not value : return None parts = value . split ( "|" ) if len ( parts ) != 3 : return None if include_name : signature = self . _cookie_signature ( name , parts [ 0 ] , parts [ 1 ] ) else : signature = self . _cookie_signature ( parts [ 0 ] , parts [ 1 ] ) if not _time_independent_equals ( parts [ 2 ] , signature ) : logging . warning ( "Invalid cookie signature %r" , value ) return None timestamp = int ( parts [ 1 ] ) if timestamp < time . time ( ) - 31 * 86400 : logging . warning ( "Expired cookie %r" , value ) return None try : return base64 . b64decode ( parts [ 0 ] ) except : return None def _cookie_signature ( self , * parts ) : self . require_setting ( "cookie_secret" , "secure cookies" ) hash = hmac . new ( self . application . settings [ "cookie_secret" ] , digestmod = hashlib . sha1 ) for part in parts : hash . update ( part ) return hash . hexdigest ( ) def redirect ( self , url , permanent = False ) : if self . _headers_written : raise Exception ( "Cannot redirect after headers have been written" ) self . set_status ( 301 if permanent else 302 ) url = re . sub ( r"[\x00-\x20]+" , "" , _utf8 ( url ) ) self . set_header ( "Location" , urlparse . urljoin ( self . request . uri , url ) ) self . finish ( ) def write ( self , chunk ) : assert not self . _finished if isinstance ( chunk , dict ) : chunk = escape . json_encode ( chunk ) self . set_header ( "Content-Type" , "text/javascript; charset=UTF-8" ) chunk = _utf8 ( chunk ) self . _write_buffer . append ( chunk ) def render ( self , template_name , ** kwargs ) : html = self . render_string ( template_name , ** kwargs ) js_embed = [ ] js_files = [ ] css_embed = [ ] css_files = [ ] html_heads = [ ] html_bodies = [ ] for module in getattr ( self , "_active_modules" , { } ) . itervalues ( ) : embed_part = module . embedded_javascript ( ) if embed_part : js_embed . append ( _utf8 ( embed_part ) ) file_part = module . javascript_files ( ) if file_part : if isinstance ( file_part , basestring ) : js_files . append ( file_part ) else : js_files . extend ( file_part ) embed_part = module . embedded_css ( ) if embed_part : css_embed . append ( _utf8 ( embed_part ) ) file_part = module . css_files ( ) if file_part : if isinstance ( file_part , basestring ) : css_files . append ( file_part ) else : css_files . extend ( file_part ) head_part = module . html_head ( ) if head_part : html_heads . append ( _utf8 ( head_part ) ) body_part = module . html_body ( ) if body_part : html_bodies . append ( _utf8 ( body_part ) ) if js_files : paths = [ ] unique_paths = set ( ) for path in js_files : if not path . startswith ( "/" ) and not path . startswith ( "http:" ) : path = self . static_url ( path ) if path not in unique_paths : paths . append ( path ) unique_paths . add ( path ) js = '' . join ( '<script src="' + escape . xhtml_escape ( p ) + for p in paths ) sloc = html . rindex ( '</body>' ) html = html [ : sloc ] + js + '\n' + html [ sloc : ] if js_embed : js = '<script type="text/javascript">\n//<![CDATA[\n' + '\n' . join ( js_embed ) + '\n//]]>\n</script>' sloc = html . rindex ( '</body>' ) html = html [ : sloc ] + js + '\n' + html [ sloc : ] if css_files : paths = set ( ) for path in css_files : if not path . startswith ( "/" ) and not path . startswith ( "http:" ) : paths . add ( self . static_url ( path ) ) else : paths . add ( path ) css = '' . join ( '<link href="' + escape . xhtml_escape ( p ) + '" ' for p in paths ) hloc = html . index ( '</head>' ) html = html [ : hloc ] + css + '\n' + html [ hloc : ] if css_embed : css = '<style type="text/css">\n' + '\n' . join ( css_embed ) + '\n</style>' hloc = html . index ( '</head>' ) html = html [ : hloc ] + css + '\n' + html [ hloc : ] if html_heads : hloc = html . index ( '</head>' ) html = html [ : hloc ] + '' . join ( html_heads ) + '\n' + html [ hloc : ] if html_bodies : hloc = html . index ( '</body>' ) html = html [ : hloc ] + '' . join ( html_bodies ) + '\n' + html [ hloc : ] self . finish ( html ) def render_string ( self , template_name , ** kwargs ) : template_path = self . get_template_path ( ) if not template_path : frame = sys . _getframe ( 0 ) web_file = frame . f_code . co_filename while frame . f_code . co_filename == web_file : frame = frame . f_back template_path = os . path . dirname ( frame . f_code . co_filename ) if not getattr ( RequestHandler , "_templates" , None ) : RequestHandler . _templates = { } if template_path not in RequestHandler . _templates : loader = self . application . settings . get ( "template_loader" ) or template . Loader ( template_path ) RequestHandler . _templates [ template_path ] = loader t = RequestHandler . _templates [ template_path ] . load ( template_name ) args = dict ( handler = self , request = self . request , current_user = self . current_user , locale = self . locale , _ = self . locale . translate , static_url = self . static_url , xsrf_form_html = self . xsrf_form_html , reverse_url = self . application . reverse_url ) args . update ( self . ui ) args . update ( kwargs ) return t . generate ( ** args ) def flush ( self , include_footers = False ) : if self . application . _wsgi : raise Exception ( "WSGI applications do not support flush()" ) chunk = "" . join ( self . _write_buffer ) self . _write_buffer = [ ] if not self . _headers_written : self . _headers_written = True for transform in self . _transforms : self . _headers , chunk = transform . transform_first_chunk ( self . _headers , chunk , include_footers ) headers = self . _generate_headers ( ) else : for transform in self . _transforms : chunk = transform . transform_chunk ( chunk , include_footers ) headers = "" if self . request . method == "HEAD" : if headers : self . request . write ( headers ) return if headers or chunk : self . request . write ( headers + chunk ) def finish ( self , chunk = None ) : assert not self . _finished if chunk is not None : self . write ( chunk ) if not self . _headers_written : if ( self . _status_code == 200 and self . request . method == "GET" and not in self . _headers ) : hasher = hashlib . sha1 ( ) for part in self . _write_buffer : hasher . update ( part ) etag = '"%s"' % hasher . hexdigest ( ) inm = self . request . headers . get ( "If-None-Match" ) if inm and inm . find ( etag ) != - 1 : self . _write_buffer = [ ] self . set_status ( 304 ) else : self . set_header ( "Etag" , etag ) if "Content-Length" not in self . _headers : content_length = sum ( len ( part ) for part in self . _write_buffer ) self . set_header ( "Content-Length" , content_length ) if hasattr ( self . request , "connection" ) : self . request . connection . stream . set_close_callback ( None ) if not self . application . _wsgi : self . flush ( include_footers = True ) self . request . finish ( ) self . _log ( ) self . _finished = True def send_error ( self , status_code = 500 , ** kwargs ) : if self . _headers_written : logging . error ( "Cannot send error response after headers written" ) if not self . _finished : self . finish ( ) return self . clear ( ) self . set_status ( status_code ) message = self . get_error_html ( status_code , ** kwargs ) self . finish ( message ) def get_error_html ( self , status_code , ** kwargs ) : return "<html><title>%(code)d: %(message)s</title>" "<body>%(code)d: %(message)s</body></html>" % { : status_code , : httplib . responses [ status_code ] , } @ property def locale ( self ) : if not hasattr ( self , "_locale" ) : self . _locale = self . get_user_locale ( ) if not self . _locale : self . _locale = self . get_browser_locale ( ) assert self . _locale return self . _locale def get_user_locale ( self ) : return None def get_browser_locale ( self , default = "en_US" ) : if "Accept-Language" in self . request . headers : languages = self . request . headers [ "Accept-Language" ] . split ( "," ) locales = [ ] for language in languages : parts = language . strip ( ) . split ( ";" ) if len ( parts ) > 1 and parts [ 1 ] . startswith ( "q=" ) : try : score = float ( parts [ 1 ] [ 2 : ] ) except ( ValueError , TypeError ) : score = 0.0 else : score = 1.0 locales . append ( ( parts [ 0 ] , score ) ) if locales : locales . sort ( key = lambda ( l , s ) : s , reverse = True ) codes = [ l [ 0 ] for l in locales ] return locale . get ( * codes ) return locale . get ( default ) @ property def current_user ( self ) : if not hasattr ( self , "_current_user" ) : self . _current_user = self . get_current_user ( ) return self . _current_user def get_current_user ( self ) : return None def get_login_url ( self ) : self . require_setting ( "login_url" , "@tornado.web.authenticated" ) return self . application . settings [ "login_url" ] def get_template_path ( self ) : return self . application . settings . get ( "template_path" ) @ property def xsrf_token ( self ) : if not hasattr ( self , "_xsrf_token" ) : token = self . get_cookie ( "_xsrf" ) if not token : token = binascii . b2a_hex ( uuid . uuid4 ( ) . bytes ) expires_days = 30 if self . current_user else None self . set_cookie ( "_xsrf" , token , expires_days = expires_days ) self . _xsrf_token = token return self . _xsrf_token def check_xsrf_cookie ( self ) : if self . request . headers . get ( "X-Requested-With" ) == "XMLHttpRequest" : return token = self . get_argument ( "_xsrf" , None ) if not token : raise HTTPError ( 403 , "'_xsrf' argument missing from POST" ) if self . xsrf_token != token : raise HTTPError ( 403 , "XSRF cookie does not match POST argument" ) def xsrf_form_html ( self ) : return '<input type="hidden" name="_xsrf" value="' + escape . xhtml_escape ( self . xsrf_token ) + '"/>' def static_url ( self , path ) : self . require_setting ( "static_path" , "static_url" ) if not hasattr ( RequestHandler , "_static_hashes" ) : RequestHandler . _static_hashes = { } hashes = RequestHandler . _static_hashes if path not in hashes : try : f = open ( os . path . join ( self . application . settings [ "static_path" ] , path ) ) hashes [ path ] = hashlib . md5 ( f . read ( ) ) . hexdigest ( ) f . close ( ) except : logging . error ( "Could not open static file %r" , path ) hashes [ path ] = None base = self . request . protocol + "://" + self . request . host if getattr ( self , "include_host" , False ) else "" static_url_prefix = self . settings . get ( 'static_url_prefix' , '/static/' ) if hashes . get ( path ) : return base + static_url_prefix + path + "?v=" + hashes [ path ] [ : 5 ] else : return base + static_url_prefix + path def async_callback ( self , callback , * args , ** kwargs ) : if callback is None : return None if args or kwargs : callback = functools . partial ( callback , * args , ** kwargs ) def wrapper ( * args , ** kwargs ) : try : return callback ( * args , ** kwargs ) except Exception , e : if self . _headers_written : logging . error ( "Exception after headers written" , exc_info = True ) else : self . _handle_request_exception ( e ) return wrapper def require_setting ( self , name , feature = "this feature" ) : if not self . application . settings . get ( name ) : raise Exception ( "You must define the '%s' setting in your " % ( name , feature ) ) def reverse_url ( self , name , * args ) : return self . application . reverse_url ( name , * args ) def _execute ( self , transforms , * args , ** kwargs ) : self . _transforms = transforms try : if self . request . method not in self . SUPPORTED_METHODS : raise HTTPError ( 405 ) if self . request . method == "POST" and self . application . settings . get ( "xsrf_cookies" ) : self . check_xsrf_cookie ( ) self . prepare ( ) if not self . _finished : getattr ( self , self . request . method . lower ( ) ) ( * args , ** kwargs ) if self . _auto_finish and not self . _finished : self . finish ( ) except Exception , e : self . _handle_request_exception ( e ) def _generate_headers ( self ) : lines = [ self . request . version + " " + str ( self . _status_code ) + " " + httplib . responses [ self . _status_code ] ] lines . extend ( [ "%s: %s" % ( n , v ) for n , v in self . _headers . iteritems ( ) ] ) for cookie_dict in getattr ( self , "_new_cookies" , [ ] ) : for cookie in cookie_dict . values ( ) : lines . append ( "Set-Cookie: " + cookie . OutputString ( None ) ) return "\r\n" . join ( lines ) + "\r\n\r\n" def _log ( self ) : if self . _status_code < 400 : log_method = logging . info elif self . _status_code < 500 : log_method = logging . warning else : log_method = logging . error request_time = 1000.0 * self . request . request_time ( ) log_method ( "%d %s %.2fms" , self . _status_code , self . _request_summary ( ) , request_time ) def _request_summary ( self ) : return self . request . method + " " + self . request . uri + " (" + self . request . remote_ip + ")" def _handle_request_exception ( self , e ) : if isinstance ( e , HTTPError ) : if e . log_message : format = "%d %s: " + e . log_message args = [ e . status_code , self . _request_summary ( ) ] + list ( e . args ) logging . warning ( format , * args ) if e . status_code not in httplib . responses : logging . error ( "Bad HTTP status code: %d" , e . status_code ) self . send_error ( 500 , exception = e ) else : self . send_error ( e . status_code , exception = e ) else : logging . error ( "Uncaught exception %s\n%r" , self . _request_summary ( ) , self . request , exc_info = e ) self . send_error ( 500 , exception = e ) def _ui_module ( self , name , module ) : def render ( * args , ** kwargs ) : if not hasattr ( self , "_active_modules" ) : self . _active_modules = { } if name not in self . _active_modules : self . _active_modules [ name ] = module ( self ) rendered = self . _active_modules [ name ] . render ( * args , ** kwargs ) return rendered return render def _ui_method ( self , method ) : return lambda * args , ** kwargs : method ( self , * args , ** kwargs ) def asynchronous ( method ) : @ functools . wraps ( method ) def wrapper ( self , * args , ** kwargs ) : if self . application . _wsgi : raise Exception ( "@asynchronous is not supported for WSGI apps" ) self . _auto_finish = False return method ( self , * args , ** kwargs ) return wrapper def removeslash ( method ) : @ functools . wraps ( method ) def wrapper ( self , * args , ** kwargs ) : if self . request . path . endswith ( "/" ) : if self . request . method == "GET" : uri = self . request . path . rstrip ( "/" ) if self . request . query : uri += "?" + self . request . query self . redirect ( uri ) return raise HTTPError ( 404 ) return method ( self , * args , ** kwargs ) return wrapper def addslash ( method ) : @ functools . wraps ( method ) def wrapper ( self , * args , ** kwargs ) : if not self . request . path . endswith ( "/" ) : if self . request . method == "GET" : uri = self . request . path + "/" if self . request . query : uri += "?" + self . request . query self . redirect ( uri ) return raise HTTPError ( 404 ) return method ( self , * args , ** kwargs ) return wrapper class Application ( object ) : def __init__ ( self , handlers = None , default_host = "" , transforms = None , wsgi = False , ** settings ) : if transforms is None : self . transforms = [ ] if settings . get ( "gzip" ) : self . transforms . append ( GZipContentEncoding ) self . transforms . append ( ChunkedTransferEncoding ) else : self . transforms = transforms self . handlers = [ ] self . named_handlers = { } self . default_host = default_host self . settings = settings self . ui_modules = { } self . ui_methods = { } self . _wsgi = wsgi self . _load_ui_modules ( settings . get ( "ui_modules" , { } ) ) self . _load_ui_methods ( settings . get ( "ui_methods" , { } ) ) if self . settings . get ( "static_path" ) : path = self . settings [ "static_path" ] handlers = list ( handlers or [ ] ) static_url_prefix = settings . get ( "static_url_prefix" , ) handlers = [ ( re . escape ( static_url_prefix ) + r"(.*)" , StaticFileHandler , dict ( path = path ) ) , ( r"/(favicon\.ico)" , StaticFileHandler , dict ( path = path ) ) , ( r"/(robots\.txt)" , StaticFileHandler , dict ( path = path ) ) , ] + handlers if handlers : self . add_handlers ( ".*$" , handlers ) if self . settings . get ( "debug" ) and not wsgi : import autoreload autoreload . start ( ) def add_handlers ( self , host_pattern , host_handlers ) : if not host_pattern . endswith ( "$" ) : host_pattern += "$" handlers = [ ] if self . handlers and self . handlers [ - 1 ] [ 0 ] . pattern == '.*$' : self . handlers . insert ( - 1 , ( re . compile ( host_pattern ) , handlers ) ) else : self . handlers . append ( ( re . compile ( host_pattern ) , handlers ) ) for spec in host_handlers : if type ( spec ) is type ( ( ) ) : assert len ( spec ) in ( 2 , 3 ) pattern = spec [ 0 ] handler = spec [ 1 ] if len ( spec ) == 3 : kwargs = spec [ 2 ] else : kwargs = { } spec = URLSpec ( pattern , handler , kwargs ) handlers . append ( spec ) if spec . name : if spec . name in self . named_handlers : logging . warning ( , spec . name ) self . named_handlers [ spec . name ] = spec def add_transform ( self , transform_class ) : self . transforms . append ( transform_class ) def _get_host_handlers ( self , request ) : host = request . host . lower ( ) . split ( ':' ) [ 0 ] for pattern , handlers in self . handlers : if pattern . match ( host ) : return handlers if "X-Real-Ip" not in request . headers : for pattern , handlers in self . handlers : if pattern . match ( self . default_host ) : return handlers return None def _load_ui_methods ( self , methods ) : if type ( methods ) is types . ModuleType : self . _load_ui_methods ( dict ( ( n , getattr ( methods , n ) ) for n in dir ( methods ) ) ) elif isinstance ( methods , list ) : for m in methods : self . _load_ui_methods ( m ) else : for name , fn in methods . iteritems ( ) : if not name . startswith ( "_" ) and hasattr ( fn , "__call__" ) and name [ 0 ] . lower ( ) == name [ 0 ] : self . ui_methods [ name ] = fn def _load_ui_modules ( self , modules ) : if type ( modules ) is types . ModuleType : self . _load_ui_modules ( dict ( ( n , getattr ( modules , n ) ) for n in dir ( modules ) ) ) elif isinstance ( modules , list ) : for m in modules : self . _load_ui_modules ( m ) else : assert isinstance ( modules , dict ) for name , cls in modules . iteritems ( ) : try : if issubclass ( cls , UIModule ) : self . ui_modules [ name ] = cls except TypeError : pass def __call__ ( self , request ) : transforms = [ t ( request ) for t in self . transforms ] handler = None args = [ ] kwargs = { } handlers = self . _get_host_handlers ( request ) if not handlers : handler = RedirectHandler ( request , "http://" + self . default_host + "/" ) else : for spec in handlers : match = spec . regex . match ( request . path ) if match : handler = spec . handler_class ( self , request , ** spec . kwargs ) kwargs = dict ( ( k , urllib . unquote ( v ) ) for ( k , v ) in match . groupdict ( ) . iteritems ( ) ) if kwargs : args = [ ] else : args = [ urllib . unquote ( s ) for s in match . groups ( ) ] break if not handler : handler = ErrorHandler ( self , request , 404 ) if self . settings . get ( "debug" ) : if getattr ( RequestHandler , "_templates" , None ) : map ( lambda loader : loader . reset ( ) , RequestHandler . _templates . values ( ) ) RequestHandler . _static_hashes = { } handler . _execute ( transforms , * args , ** kwargs ) return handler def reverse_url ( self , name , * args ) : if name in self . named_handlers : return self . named_handlers [ name ] . reverse ( * args ) raise KeyError ( "%s not found in named urls" % name ) class HTTPError ( Exception ) : def __init__ ( self , status_code , log_message = None , * args ) : self . status_code = status_code self . log_message = log_message self . args = args def __str__ ( self ) : message = "HTTP %d: %s" % ( self . status_code , httplib . responses [ self . status_code ] ) if self . log_message : return message + " (" + ( self . log_message % self . args ) + ")" else : return message class ErrorHandler ( RequestHandler ) : def __init__ ( self , application , request , status_code ) : RequestHandler . __init__ ( self , application , request ) self . set_status ( status_code ) def prepare ( self ) : raise HTTPError ( self . _status_code ) class RedirectHandler ( RequestHandler ) : def __init__ ( self , application , request , url , permanent = True ) : RequestHandler . __init__ ( self , application , request ) self . _url = url self . _permanent = permanent def get ( self ) : self . redirect ( self . _url , permanent = self . _permanent ) class StaticFileHandler ( RequestHandler ) : def __init__ ( self , application , request , path ) : RequestHandler . __init__ ( self , application , request ) self . root = os . path . abspath ( path ) + os . path . sep def head ( self , path ) : self . get ( path , include_body = False ) def get ( self , path , include_body = True ) : abspath = os . path . abspath ( os . path . join ( self . root , path ) ) if not abspath . startswith ( self . root ) : raise HTTPError ( 403 , "%s is not in root static directory" , path ) if not os . path . exists ( abspath ) : raise HTTPError ( 404 ) if not os . path . isfile ( abspath ) : raise HTTPError ( 403 , "%s is not a file" , path ) stat_result = os . stat ( abspath ) modified = datetime . datetime . fromtimestamp ( stat_result [ stat . ST_MTIME ] ) self . set_header ( "Last-Modified" , modified ) if "v" in self . request . arguments : self . set_header ( "Expires" , datetime . datetime . utcnow ( ) + datetime . timedelta ( days = 365 * 10 ) ) self . set_header ( "Cache-Control" , "max-age=" + str ( 86400 * 365 * 10 ) ) else : self . set_header ( "Cache-Control" , "public" ) mime_type , encoding = mimetypes . guess_type ( abspath ) if mime_type : self . set_header ( "Content-Type" , mime_type ) self . set_extra_headers ( path ) ims_value = self . request . headers . get ( "If-Modified-Since" ) if ims_value is not None : date_tuple = email . utils . parsedate ( ims_value ) if_since = datetime . datetime . fromtimestamp ( time . mktime ( date_tuple ) ) if if_since >= modified : self . set_status ( 304 ) return if not include_body : return self . set_header ( "Content-Length" , stat_result [ stat . ST_SIZE ] ) file = open ( abspath , "rb" ) try : self . write ( file . read ( ) ) finally : file . close ( ) def set_extra_headers ( self , path ) : pass class FallbackHandler ( RequestHandler ) : def __init__ ( self , app , request , fallback ) : RequestHandler . __init__ ( self , app , request ) self . fallback = fallback def prepare ( self ) : self . fallback ( self . request ) self . _finished = True class OutputTransform ( object ) : def __init__ ( self , request ) : pass def transform_first_chunk ( self , headers , chunk , finishing ) : return headers , chunk def transform_chunk ( self , chunk , finishing ) : return chunk class GZipContentEncoding ( OutputTransform ) : CONTENT_TYPES = set ( [ , "text/html" , "text/css" , "text/xml" , , "application/xml" , "application/atom+xml" , , "application/json" , "application/xhtml+xml" ] ) MIN_LENGTH = 5 def __init__ ( self , request ) : self . _gzipping = request . supports_http_1_1 ( ) and "gzip" in request . headers . get ( "Accept-Encoding" , "" ) def transform_first_chunk ( self , headers , chunk , finishing ) : if self . _gzipping : ctype = headers . get ( "Content-Type" , "" ) . split ( ";" ) [ 0 ] self . _gzipping = ( ctype in self . CONTENT_TYPES ) and ( not finishing or len ( chunk ) >= self . MIN_LENGTH ) and ( finishing or "Content-Length" not in headers ) and ( "Content-Encoding" not in headers ) if self . _gzipping : headers [ "Content-Encoding" ] = "gzip" self . _gzip_value = cStringIO . StringIO ( ) self . _gzip_file = gzip . GzipFile ( mode = "w" , fileobj = self . _gzip_value ) self . _gzip_pos = 0 chunk = self . transform_chunk ( chunk , finishing ) if "Content-Length" in headers : headers [ "Content-Length" ] = str ( len ( chunk ) ) return headers , chunk def transform_chunk ( self , chunk , finishing ) : if self . _gzipping : self . _gzip_file . write ( chunk ) if finishing : self . _gzip_file . close ( ) else : self . _gzip_file . flush ( ) chunk = self . _gzip_value . getvalue ( ) if self . _gzip_pos > 0 : chunk = chunk [ self . _gzip_pos : ] self . _gzip_pos += len ( chunk ) return chunk class ChunkedTransferEncoding ( OutputTransform ) : def __init__ ( self , request ) : self . _chunking = request . supports_http_1_1 ( ) def transform_first_chunk ( self , headers , chunk , finishing ) : if self . _chunking : if "Content-Length" in headers or "Transfer-Encoding" in headers : self . _chunking = False else : headers [ "Transfer-Encoding" ] = "chunked" chunk = self . transform_chunk ( chunk , finishing ) return headers , chunk def transform_chunk ( self , block , finishing ) : if self . _chunking : if block : block = ( "%x" % len ( block ) ) + "\r\n" + block + "\r\n" if finishing : block += "0\r\n\r\n" return block def authenticated ( method ) : @ functools . wraps ( method ) def wrapper ( self , * args , ** kwargs ) : if not self . current_user : if self . request . method == "GET" : url = self . get_login_url ( ) if "?" not in url : url += "?" + urllib . urlencode ( dict ( next = self . request . uri ) ) self . redirect ( url ) return raise HTTPError ( 403 ) return method ( self , * args , ** kwargs ) return wrapper class UIModule ( object ) : def __init__ ( self , handler ) : self . handler = handler self . request = handler . request self . ui = handler . ui self . current_user = handler . current_user self . locale = handler . locale def render ( self , * args , ** kwargs ) : raise NotImplementedError ( ) def embedded_javascript ( self ) : return None def javascript_files ( self ) : return None def embedded_css ( self ) : return None def css_files ( self ) : return None def html_head ( self ) : return None def html_body ( self ) : return None def render_string ( self , path , ** kwargs ) : return self . handler . render_string ( path , ** kwargs ) class URLSpec ( object ) : def __init__ ( self , pattern , handler_class , kwargs = { } , name = None ) : if not pattern . endswith ( '$' ) : pattern += '$' self . regex = re . compile ( pattern ) self . handler_class = handler_class self . kwargs = kwargs self . name = name self . _path , self . _group_count = self . _find_groups ( ) def _find_groups ( self ) : pattern = self . regex . pattern if pattern . startswith ( '^' ) : pattern = pattern [ 1 : ] if pattern . endswith ( '$' ) : pattern = pattern [ : - 1 ] if self . regex . groups != pattern . count ( '(' ) : return ( None , None ) pieces = [ ] for fragment in pattern . split ( '(' ) : if ')' in fragment : paren_loc = fragment . index ( ')' ) if paren_loc >= 0 : pieces . append ( '%s' + fragment [ paren_loc + 1 : ] ) else : pieces . append ( fragment ) return ( '' . join ( pieces ) , self . regex . groups ) def reverse ( self , * args ) : assert self . _path is not None , "Cannot reverse url regex " + self . regex . pattern assert len ( args ) == self . _group_count , "required number of arguments " "not found" if not len ( args ) : return self . _path return self . _path % tuple ( [ str ( a ) for a in args ] ) url = URLSpec def _utf8 ( s ) : if isinstance ( s , unicode ) : return s . encode ( "utf-8" ) assert isinstance ( s , str ) return s def _unicode ( s ) : if isinstance ( s , str ) : try : return s . decode ( "utf-8" ) except UnicodeDecodeError : raise HTTPError ( 400 , "Non-utf8 argument" ) assert isinstance ( s , unicode ) return s def _time_independent_equals ( a , b ) : if len ( a ) != len ( b ) : return False result = 0 for x , y in zip ( a , b ) : result |= ord ( x ) ^ ord ( y ) return result == 0 class _O ( dict ) : def __getattr__ ( self , name ) : try : return self [ name ] except KeyError : raise AttributeError ( name ) def __setattr__ ( self , name , value ) : self [ name ] = value

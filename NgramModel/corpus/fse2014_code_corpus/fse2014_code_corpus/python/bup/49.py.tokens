import functools import ioloop import logging import os import sys import types try : import signal except ImportError : signal = None def start ( io_loop = None , check_time = 500 ) : io_loop = io_loop or ioloop . IOLoop . instance ( ) modify_times = { } callback = functools . partial ( _reload_on_update , io_loop , modify_times ) scheduler = ioloop . PeriodicCallback ( callback , check_time , io_loop = io_loop ) scheduler . start ( ) _reload_attempted = False def _reload_on_update ( io_loop , modify_times ) : global _reload_attempted if _reload_attempted : return for module in sys . modules . values ( ) : if not isinstance ( module , types . ModuleType ) : continue path = getattr ( module , "__file__" , None ) if not path : continue if path . endswith ( ".pyc" ) or path . endswith ( ".pyo" ) : path = path [ : - 1 ] try : modified = os . stat ( path ) . st_mtime except : continue if path not in modify_times : modify_times [ path ] = modified continue if modify_times [ path ] != modified : logging . info ( "%s modified; restarting server" , path ) _reload_attempted = True for fd in io_loop . _handlers . keys ( ) : try : os . close ( fd ) except : pass if hasattr ( signal , "setitimer" ) : signal . setitimer ( signal . ITIMER_REAL , 0 , 0 ) try : os . execv ( sys . executable , [ sys . executable ] + sys . argv ) except OSError : os . spawnv ( os . P_NOWAIT , sys . executable , [ sys . executable ] + sys . argv ) sys . exit ( 0 )

"""Virtual File System representing bup's repository contents. The vfs.py library makes it possible to expose contents from bup's repository and abstracts internal name mangling and storage from the exposition layer. """ import os , re , stat , time from bup import git from helpers import * from bup . hashsplit import GIT_MODE_TREE , GIT_MODE_FILE EMPTY_SHA = '\0' * 20 _cp = None def cp ( ) : global _cp if not _cp : _cp = git . CatPipe ( ) return _cp class NodeError ( Exception ) : pass class NoSuchFile ( NodeError ) : pass class NotDir ( NodeError ) : pass class NotFile ( NodeError ) : pass class TooManySymlinks ( NodeError ) : pass def _treeget ( hash ) : it = cp ( ) . get ( hash . encode ( 'hex' ) ) type = it . next ( ) assert ( type == 'tree' ) return git . tree_decode ( '' . join ( it ) ) def _tree_decode ( hash ) : tree = [ ( int ( name , 16 ) , stat . S_ISDIR ( mode ) , sha ) for ( mode , name , sha ) in _treeget ( hash ) ] assert ( tree == list ( sorted ( tree ) ) ) return tree def _chunk_len ( hash ) : return sum ( len ( b ) for b in cp ( ) . join ( hash . encode ( 'hex' ) ) ) def _last_chunk_info ( hash ) : tree = _tree_decode ( hash ) assert ( tree ) ( ofs , isdir , sha ) = tree [ - 1 ] if isdir : ( subofs , sublen ) = _last_chunk_info ( sha ) return ( ofs + subofs , sublen ) else : return ( ofs , _chunk_len ( sha ) ) def _total_size ( hash ) : ( lastofs , lastsize ) = _last_chunk_info ( hash ) return lastofs + lastsize def _chunkiter ( hash , startofs ) : assert ( startofs >= 0 ) tree = _tree_decode ( hash ) for i in xrange ( len ( tree ) ) : if i + 1 >= len ( tree ) or tree [ i + 1 ] [ 0 ] > startofs : break first = i for i in xrange ( first , len ( tree ) ) : ( ofs , isdir , sha ) = tree [ i ] skipmore = startofs - ofs if skipmore < 0 : skipmore = 0 if isdir : for b in _chunkiter ( sha , skipmore ) : yield b else : yield '' . join ( cp ( ) . join ( sha . encode ( 'hex' ) ) ) [ skipmore : ] class _ChunkReader : def __init__ ( self , hash , isdir , startofs ) : if isdir : self . it = _chunkiter ( hash , startofs ) self . blob = None else : self . it = None self . blob = '' . join ( cp ( ) . join ( hash . encode ( 'hex' ) ) ) [ startofs : ] self . ofs = startofs def next ( self , size ) : out = '' while len ( out ) < size : if self . it and not self . blob : try : self . blob = self . it . next ( ) except StopIteration : self . it = None if self . blob : want = size - len ( out ) out += self . blob [ : want ] self . blob = self . blob [ want : ] if not self . it : break debug2 ( 'next(%d) returned %d\n' % ( size , len ( out ) ) ) self . ofs += len ( out ) return out class _FileReader ( object ) : def __init__ ( self , hash , size , isdir ) : self . hash = hash self . ofs = 0 self . size = size self . isdir = isdir self . reader = None def seek ( self , ofs ) : if ofs > self . size : self . ofs = self . size elif ofs < 0 : self . ofs = 0 else : self . ofs = ofs def tell ( self ) : return self . ofs def read ( self , count = - 1 ) : if count < 0 : count = self . size - self . ofs if not self . reader or self . reader . ofs != self . ofs : self . reader = _ChunkReader ( self . hash , self . isdir , self . ofs ) try : buf = self . reader . next ( count ) except : self . reader = None raise self . ofs += len ( buf ) return buf def close ( self ) : pass class Node : def __init__ ( self , parent , name , mode , hash ) : self . parent = parent self . name = name self . mode = mode self . hash = hash self . ctime = self . mtime = self . atime = 0 self . _subs = None def __cmp__ ( a , b ) : return cmp ( a and a . name or None , b and b . name or None ) def __iter__ ( self ) : return iter ( self . subs ( ) ) def fullname ( self , stop_at = None ) : assert ( self != stop_at ) if self . parent and self . parent != stop_at : return os . path . join ( self . parent . fullname ( stop_at = stop_at ) , self . name ) else : return self . name def _mksubs ( self ) : self . _subs = { } def subs ( self ) : if self . _subs == None : self . _mksubs ( ) return sorted ( self . _subs . values ( ) ) def sub ( self , name ) : if self . _subs == None : self . _mksubs ( ) ret = self . _subs . get ( name ) if not ret : raise NoSuchFile ( "no file %r in %r" % ( name , self . name ) ) return ret def top ( self ) : if self . parent : return self . parent . top ( ) else : return self def fs_top ( self ) : if self . parent and not isinstance ( self . parent , CommitList ) : return self . parent . fs_top ( ) else : return self def _lresolve ( self , parts ) : if not parts : return self ( first , rest ) = ( parts [ 0 ] , parts [ 1 : ] ) if first == '.' : return self . _lresolve ( rest ) elif first == '..' : if not self . parent : raise NoSuchFile ( "no parent dir for %r" % self . name ) return self . parent . _lresolve ( rest ) elif rest : return self . sub ( first ) . _lresolve ( rest ) else : return self . sub ( first ) def lresolve ( self , path , stay_inside_fs = False ) : start = self if not path : return start if path . startswith ( '/' ) : if stay_inside_fs : start = self . fs_top ( ) else : start = self . top ( ) path = path [ 1 : ] parts = re . split ( r'/+' , path or '.' ) if not parts [ - 1 ] : parts [ - 1 ] = '.' return start . _lresolve ( parts ) def resolve ( self , path = '' ) : return self . lresolve ( path ) . lresolve ( '.' ) def try_resolve ( self , path = '' ) : n = self . lresolve ( path ) try : n = n . lresolve ( '.' ) except NoSuchFile : pass return n def nlinks ( self ) : if self . _subs == None : self . _mksubs ( ) return 1 def size ( self ) : return 0 def open ( self ) : raise NotFile ( '%s is not a regular file' % self . name ) class File ( Node ) : def __init__ ( self , parent , name , mode , hash , bupmode ) : Node . __init__ ( self , parent , name , mode , hash ) self . bupmode = bupmode self . _cached_size = None self . _filereader = None def open ( self ) : if not self . _filereader : self . _filereader = _FileReader ( self . hash , self . size ( ) , self . bupmode == git . BUP_CHUNKED ) self . _filereader . seek ( 0 ) return self . _filereader def size ( self ) : if self . _cached_size == None : debug1 ( '<<<<File.size() is calculating (for %r)...\n' % self . name ) if self . bupmode == git . BUP_CHUNKED : self . _cached_size = _total_size ( self . hash ) else : self . _cached_size = _chunk_len ( self . hash ) debug1 ( '<<<<File.size() done.\n' ) return self . _cached_size _symrefs = 0 class Symlink ( File ) : def __init__ ( self , parent , name , hash , bupmode ) : File . __init__ ( self , parent , name , 0120000 , hash , bupmode ) def size ( self ) : return len ( self . readlink ( ) ) def readlink ( self ) : return '' . join ( cp ( ) . join ( self . hash . encode ( 'hex' ) ) ) def dereference ( self ) : global _symrefs if _symrefs > 100 : raise TooManySymlinks ( 'too many levels of symlinks: %r' % self . fullname ( ) ) _symrefs += 1 try : try : return self . parent . lresolve ( self . readlink ( ) , stay_inside_fs = True ) except NoSuchFile : raise NoSuchFile ( "%s: broken symlink to %r" % ( self . fullname ( ) , self . readlink ( ) ) ) finally : _symrefs -= 1 def _lresolve ( self , parts ) : return self . dereference ( ) . _lresolve ( parts ) class FakeSymlink ( Symlink ) : def __init__ ( self , parent , name , toname ) : Symlink . __init__ ( self , parent , name , EMPTY_SHA , git . BUP_NORMAL ) self . toname = toname def readlink ( self ) : return self . toname class Dir ( Node ) : def _mksubs ( self ) : self . _subs = { } it = cp ( ) . get ( self . hash . encode ( 'hex' ) ) type = it . next ( ) if type == 'commit' : del it it = cp ( ) . get ( self . hash . encode ( 'hex' ) + ':' ) type = it . next ( ) assert ( type == 'tree' ) for ( mode , mangled_name , sha ) in git . tree_decode ( '' . join ( it ) ) : name = mangled_name ( name , bupmode ) = git . demangle_name ( mangled_name ) if bupmode == git . BUP_CHUNKED : mode = GIT_MODE_FILE if stat . S_ISDIR ( mode ) : self . _subs [ name ] = Dir ( self , name , mode , sha ) elif stat . S_ISLNK ( mode ) : self . _subs [ name ] = Symlink ( self , name , sha , bupmode ) else : self . _subs [ name ] = File ( self , name , mode , sha , bupmode ) class CommitDir ( Node ) : def __init__ ( self , parent , name ) : Node . __init__ ( self , parent , name , GIT_MODE_TREE , EMPTY_SHA ) def _mksubs ( self ) : self . _subs = { } refs = git . list_refs ( ) for ref in refs : revs = git . rev_list ( ref [ 1 ] . encode ( 'hex' ) ) for ( date , commit ) in revs : commithex = commit . encode ( 'hex' ) containername = commithex [ : 2 ] dirname = commithex [ 2 : ] n1 = self . _subs . get ( containername ) if not n1 : n1 = CommitList ( self , containername ) self . _subs [ containername ] = n1 if n1 . commits . get ( dirname ) : break n1 . commits [ dirname ] = ( commit , date ) class CommitList ( Node ) : def __init__ ( self , parent , name ) : Node . __init__ ( self , parent , name , GIT_MODE_TREE , EMPTY_SHA ) self . commits = { } def _mksubs ( self ) : self . _subs = { } for ( name , ( hash , date ) ) in self . commits . items ( ) : n1 = Dir ( self , name , GIT_MODE_TREE , hash ) n1 . ctime = n1 . mtime = date self . _subs [ name ] = n1 class TagDir ( Node ) : def __init__ ( self , parent , name ) : Node . __init__ ( self , parent , name , GIT_MODE_TREE , EMPTY_SHA ) def _mksubs ( self ) : self . _subs = { } for ( name , sha ) in git . list_refs ( ) : if name . startswith ( 'refs/tags/' ) : name = name [ 10 : ] date = git . rev_get_date ( sha . encode ( 'hex' ) ) commithex = sha . encode ( 'hex' ) target = '../.commit/%s/%s' % ( commithex [ : 2 ] , commithex [ 2 : ] ) tag1 = FakeSymlink ( self , name , target ) tag1 . ctime = tag1 . mtime = date self . _subs [ name ] = tag1 class BranchList ( Node ) : def __init__ ( self , parent , name , hash ) : Node . __init__ ( self , parent , name , GIT_MODE_TREE , hash ) def _mksubs ( self ) : self . _subs = { } tags = git . tags ( ) revs = list ( git . rev_list ( self . hash . encode ( 'hex' ) ) ) for ( date , commit ) in revs : l = time . localtime ( date ) ls = time . strftime ( '%Y-%m-%d-%H%M%S' , l ) commithex = commit . encode ( 'hex' ) target = '../.commit/%s/%s' % ( commithex [ : 2 ] , commithex [ 2 : ] ) n1 = FakeSymlink ( self , ls , target ) n1 . ctime = n1 . mtime = date self . _subs [ ls ] = n1 for tag in tags . get ( commit , [ ] ) : t1 = FakeSymlink ( self , tag , target ) t1 . ctime = t1 . mtime = date self . _subs [ tag ] = t1 latest = max ( revs ) if latest : ( date , commit ) = latest commithex = commit . encode ( 'hex' ) target = '../.commit/%s/%s' % ( commithex [ : 2 ] , commithex [ 2 : ] ) n1 = FakeSymlink ( self , 'latest' , target ) n1 . ctime = n1 . mtime = date self . _subs [ 'latest' ] = n1 class RefList ( Node ) : def __init__ ( self , parent ) : Node . __init__ ( self , parent , '/' , GIT_MODE_TREE , EMPTY_SHA ) def _mksubs ( self ) : self . _subs = { } commit_dir = CommitDir ( self , '.commit' ) self . _subs [ '.commit' ] = commit_dir tag_dir = TagDir ( self , '.tag' ) self . _subs [ '.tag' ] = tag_dir for ( name , sha ) in git . list_refs ( ) : if name . startswith ( 'refs/heads/' ) : name = name [ 11 : ] date = git . rev_get_date ( sha . encode ( 'hex' ) ) n1 = BranchList ( self , name , sha ) n1 . ctime = n1 . mtime = date self . _subs [ name ] = n1

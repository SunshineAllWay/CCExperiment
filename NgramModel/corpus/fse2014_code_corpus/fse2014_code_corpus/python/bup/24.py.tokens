import sys , stat , urllib , mimetypes , posixpath , time import tornado . httpserver import tornado . ioloop import tornado . web from bup import options , git , vfs from bup . helpers import * handle_ctrl_c ( ) def _compute_breadcrumbs ( path , show_hidden = False ) : breadcrumbs = [ ] breadcrumbs . append ( ( '[root]' , '/' ) ) path_parts = path . split ( '/' ) [ 1 : - 1 ] full_path = '/' for part in path_parts : full_path += part + "/" url_append = "" if show_hidden : url_append = '?hidden=1' breadcrumbs . append ( ( part , full_path + url_append ) ) return breadcrumbs def _contains_hidden_files ( n ) : for sub in n : name = sub . name if len ( name ) > 1 and name . startswith ( '.' ) : return True return False def _compute_dir_contents ( n , path , show_hidden = False ) : url_append = "" if show_hidden : url_append = "?hidden=1" if path != "/" : yield ( '..' , '../' + url_append , '' ) for sub in n : display = link = sub . name if stat . S_ISDIR ( sub . try_resolve ( ) . mode ) : link = sub . name + "/" if not show_hidden and len ( display ) > 1 and display . startswith ( '.' ) : continue size = None if stat . S_ISDIR ( sub . mode ) : display = sub . name + '/' elif stat . S_ISLNK ( sub . mode ) : display = sub . name + '@' else : size = sub . size ( ) yield ( display , link + url_append , size ) class BupRequestHandler ( tornado . web . RequestHandler ) : def get ( self , path ) : return self . _process_request ( path ) def head ( self , path ) : return self . _process_request ( path ) @ tornado . web . asynchronous def _process_request ( self , path ) : path = urllib . unquote ( path ) print 'Handling request for %s' % path try : n = top . resolve ( path ) except vfs . NoSuchFile : self . send_error ( 404 ) return f = None if stat . S_ISDIR ( n . mode ) : self . _list_directory ( path , n ) else : self . _get_file ( path , n ) def _list_directory ( self , path , n ) : if not path . endswith ( '/' ) and len ( path ) > 0 : print 'Redirecting from %s to %s' % ( path , path + '/' ) return self . redirect ( path + '/' , permanent = True ) try : show_hidden = int ( self . request . arguments . get ( 'hidden' , [ 0 ] ) [ - 1 ] ) except ValueError , e : show_hidden = False self . render ( , path = path , breadcrumbs = _compute_breadcrumbs ( path , show_hidden ) , files_hidden = _contains_hidden_files ( n ) , hidden_shown = show_hidden , dir_contents = _compute_dir_contents ( n , path , show_hidden ) ) def _get_file ( self , path , n ) : ctype = self . _guess_type ( path ) self . set_header ( "Last-Modified" , self . date_time_string ( n . mtime ) ) self . set_header ( "Content-Type" , ctype ) size = n . size ( ) self . set_header ( "Content-Length" , str ( size ) ) assert ( len ( n . hash ) == 20 ) self . set_header ( "Etag" , n . hash . encode ( 'hex' ) ) if self . request . method != 'HEAD' : self . flush ( ) f = n . open ( ) it = chunkyreader ( f ) def write_more ( me ) : try : blob = it . next ( ) except StopIteration : f . close ( ) self . finish ( ) return self . request . connection . stream . write ( blob , callback = lambda : me ( me ) ) write_more ( write_more ) def _guess_type ( self , path ) : base , ext = posixpath . splitext ( path ) if ext in self . extensions_map : return self . extensions_map [ ext ] ext = ext . lower ( ) if ext in self . extensions_map : return self . extensions_map [ ext ] else : return self . extensions_map [ '' ] if not mimetypes . inited : mimetypes . init ( ) extensions_map = mimetypes . types_map . copy ( ) extensions_map . update ( { : 'text/plain' , : 'text/plain' , : 'text/plain' , : 'text/plain' , } ) def date_time_string ( self , t ) : return time . strftime ( '%a, %d %b %Y %H:%M:%S' , time . gmtime ( t ) ) optspec = """ bup web [[hostname]:port] -- """ o = options . Options ( optspec ) ( opt , flags , extra ) = o . parse ( sys . argv [ 1 : ] ) if len ( extra ) > 1 : o . fatal ( "at most one argument expected" ) address = ( '127.0.0.1' , 8080 ) if len ( extra ) > 0 : addressl = extra [ 0 ] . split ( ':' , 1 ) addressl [ 1 ] = int ( addressl [ 1 ] ) address = tuple ( addressl ) git . check_repo_or_die ( ) top = vfs . RefList ( None ) settings = dict ( debug = 1 , template_path = resource_path ( 'web' ) , static_path = resource_path ( 'web/static' ) ) sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) application = tornado . web . Application ( [ ( r"(/.*)" , BupRequestHandler ) , ] , ** settings ) if __name__ == "__main__" : http_server = tornado . httpserver . HTTPServer ( application ) http_server . listen ( address [ 1 ] , address = address [ 0 ] ) print "Serving HTTP on %s:%d..." % http_server . _socket . getsockname ( ) loop = tornado . ioloop . IOLoop . instance ( ) loop . start ( )

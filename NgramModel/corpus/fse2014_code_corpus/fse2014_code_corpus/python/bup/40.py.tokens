import binascii import cgi import hashlib import hmac import httpclient import escape import logging import time import urllib import urlparse import uuid class OpenIdMixin ( object ) : def authenticate_redirect ( self , callback_uri = None , ax_attrs = [ "name" , "email" , "language" , "username" ] ) : callback_uri = callback_uri or self . request . path args = self . _openid_args ( callback_uri , ax_attrs = ax_attrs ) self . redirect ( self . _OPENID_ENDPOINT + "?" + urllib . urlencode ( args ) ) def get_authenticated_user ( self , callback ) : args = dict ( ( k , v [ - 1 ] ) for k , v in self . request . arguments . iteritems ( ) ) args [ "openid.mode" ] = u"check_authentication" url = self . _OPENID_ENDPOINT + "?" + urllib . urlencode ( args ) http = httpclient . AsyncHTTPClient ( ) http . fetch ( url , self . async_callback ( self . _on_authentication_verified , callback ) ) def _openid_args ( self , callback_uri , ax_attrs = [ ] , oauth_scope = None ) : url = urlparse . urljoin ( self . request . full_url ( ) , callback_uri ) args = { : "http://specs.openid.net/auth/2.0" , : , : , : url , : self . request . protocol + "://" + self . request . host + "/" , : "checkid_setup" , } if ax_attrs : args . update ( { : "http://openid.net/srv/ax/1.0" , : "fetch_request" , } ) ax_attrs = set ( ax_attrs ) required = [ ] if "name" in ax_attrs : ax_attrs -= set ( [ "name" , "firstname" , "fullname" , "lastname" ] ) required += [ "firstname" , "fullname" , "lastname" ] args . update ( { : , : , : , } ) known_attrs = { : "http://axschema.org/contact/email" , : "http://axschema.org/pref/language" , : "http://axschema.org/namePerson/friendly" , } for name in ax_attrs : args [ "openid.ax.type." + name ] = known_attrs [ name ] required . append ( name ) args [ "openid.ax.required" ] = "," . join ( required ) if oauth_scope : args . update ( { : , : self . request . host . split ( ":" ) [ 0 ] , : oauth_scope , } ) return args def _on_authentication_verified ( self , callback , response ) : if response . error or u"is_valid:true" not in response . body : logging . warning ( "Invalid OpenID response: %s" , response . error or response . body ) callback ( None ) return ax_ns = None for name , values in self . request . arguments . iteritems ( ) : if name . startswith ( "openid.ns." ) and values [ - 1 ] == u"http://openid.net/srv/ax/1.0" : ax_ns = name [ 10 : ] break def get_ax_arg ( uri ) : if not ax_ns : return u"" prefix = "openid." + ax_ns + ".type." ax_name = None for name , values in self . request . arguments . iteritems ( ) : if values [ - 1 ] == uri and name . startswith ( prefix ) : part = name [ len ( prefix ) : ] ax_name = "openid." + ax_ns + ".value." + part break if not ax_name : return u"" return self . get_argument ( ax_name , u"" ) email = get_ax_arg ( "http://axschema.org/contact/email" ) name = get_ax_arg ( "http://axschema.org/namePerson" ) first_name = get_ax_arg ( "http://axschema.org/namePerson/first" ) last_name = get_ax_arg ( "http://axschema.org/namePerson/last" ) username = get_ax_arg ( "http://axschema.org/namePerson/friendly" ) locale = get_ax_arg ( "http://axschema.org/pref/language" ) . lower ( ) user = dict ( ) name_parts = [ ] if first_name : user [ "first_name" ] = first_name name_parts . append ( first_name ) if last_name : user [ "last_name" ] = last_name name_parts . append ( last_name ) if name : user [ "name" ] = name elif name_parts : user [ "name" ] = u" " . join ( name_parts ) elif email : user [ "name" ] = email . split ( "@" ) [ 0 ] if email : user [ "email" ] = email if locale : user [ "locale" ] = locale if username : user [ "username" ] = username callback ( user ) class OAuthMixin ( object ) : def authorize_redirect ( self , callback_uri = None ) : if callback_uri and getattr ( self , "_OAUTH_NO_CALLBACKS" , False ) : raise Exception ( "This service does not support oauth_callback" ) http = httpclient . AsyncHTTPClient ( ) http . fetch ( self . _oauth_request_token_url ( ) , self . async_callback ( self . _on_request_token , self . _OAUTH_AUTHORIZE_URL , callback_uri ) ) def get_authenticated_user ( self , callback ) : request_key = self . get_argument ( "oauth_token" ) request_cookie = self . get_cookie ( "_oauth_request_token" ) if not request_cookie : logging . warning ( "Missing OAuth request token cookie" ) callback ( None ) return cookie_key , cookie_secret = request_cookie . split ( "|" ) if cookie_key != request_key : logging . warning ( "Request token does not match cookie" ) callback ( None ) return token = dict ( key = cookie_key , secret = cookie_secret ) http = httpclient . AsyncHTTPClient ( ) http . fetch ( self . _oauth_access_token_url ( token ) , self . async_callback ( self . _on_access_token , callback ) ) def _oauth_request_token_url ( self ) : consumer_token = self . _oauth_consumer_token ( ) url = self . _OAUTH_REQUEST_TOKEN_URL args = dict ( oauth_consumer_key = consumer_token [ "key" ] , oauth_signature_method = "HMAC-SHA1" , oauth_timestamp = str ( int ( time . time ( ) ) ) , oauth_nonce = binascii . b2a_hex ( uuid . uuid4 ( ) . bytes ) , oauth_version = "1.0" , ) signature = _oauth_signature ( consumer_token , "GET" , url , args ) args [ "oauth_signature" ] = signature return url + "?" + urllib . urlencode ( args ) def _on_request_token ( self , authorize_url , callback_uri , response ) : if response . error : raise Exception ( "Could not get request token" ) request_token = _oauth_parse_response ( response . body ) data = "|" . join ( [ request_token [ "key" ] , request_token [ "secret" ] ] ) self . set_cookie ( "_oauth_request_token" , data ) args = dict ( oauth_token = request_token [ "key" ] ) if callback_uri : args [ "oauth_callback" ] = urlparse . urljoin ( self . request . full_url ( ) , callback_uri ) self . redirect ( authorize_url + "?" + urllib . urlencode ( args ) ) def _oauth_access_token_url ( self , request_token ) : consumer_token = self . _oauth_consumer_token ( ) url = self . _OAUTH_ACCESS_TOKEN_URL args = dict ( oauth_consumer_key = consumer_token [ "key" ] , oauth_token = request_token [ "key" ] , oauth_signature_method = "HMAC-SHA1" , oauth_timestamp = str ( int ( time . time ( ) ) ) , oauth_nonce = binascii . b2a_hex ( uuid . uuid4 ( ) . bytes ) , oauth_version = "1.0" , ) signature = _oauth_signature ( consumer_token , "GET" , url , args , request_token ) args [ "oauth_signature" ] = signature return url + "?" + urllib . urlencode ( args ) def _on_access_token ( self , callback , response ) : if response . error : logging . warning ( "Could not fetch access token" ) callback ( None ) return access_token = _oauth_parse_response ( response . body ) user = self . _oauth_get_user ( access_token , self . async_callback ( self . _on_oauth_get_user , access_token , callback ) ) def _oauth_get_user ( self , access_token , callback ) : raise NotImplementedError ( ) def _on_oauth_get_user ( self , access_token , callback , user ) : if not user : callback ( None ) return user [ "access_token" ] = access_token callback ( user ) def _oauth_request_parameters ( self , url , access_token , parameters = { } , method = "GET" ) : consumer_token = self . _oauth_consumer_token ( ) base_args = dict ( oauth_consumer_key = consumer_token [ "key" ] , oauth_token = access_token [ "key" ] , oauth_signature_method = "HMAC-SHA1" , oauth_timestamp = str ( int ( time . time ( ) ) ) , oauth_nonce = binascii . b2a_hex ( uuid . uuid4 ( ) . bytes ) , oauth_version = "1.0" , ) args = { } args . update ( base_args ) args . update ( parameters ) signature = _oauth_signature ( consumer_token , method , url , args , access_token ) base_args [ "oauth_signature" ] = signature return base_args class TwitterMixin ( OAuthMixin ) : _OAUTH_REQUEST_TOKEN_URL = "http://api.twitter.com/oauth/request_token" _OAUTH_ACCESS_TOKEN_URL = "http://api.twitter.com/oauth/access_token" _OAUTH_AUTHORIZE_URL = "http://api.twitter.com/oauth/authorize" _OAUTH_AUTHENTICATE_URL = "http://api.twitter.com/oauth/authenticate" _OAUTH_NO_CALLBACKS = True def authenticate_redirect ( self ) : http = httpclient . AsyncHTTPClient ( ) http . fetch ( self . _oauth_request_token_url ( ) , self . async_callback ( self . _on_request_token , self . _OAUTH_AUTHENTICATE_URL , None ) ) def twitter_request ( self , path , callback , access_token = None , post_args = None , ** args ) : url = "http://api.twitter.com/1" + path + ".json" if access_token : all_args = { } all_args . update ( args ) all_args . update ( post_args or { } ) consumer_token = self . _oauth_consumer_token ( ) method = "POST" if post_args is not None else "GET" oauth = self . _oauth_request_parameters ( url , access_token , all_args , method = method ) args . update ( oauth ) if args : url += "?" + urllib . urlencode ( args ) callback = self . async_callback ( self . _on_twitter_request , callback ) http = httpclient . AsyncHTTPClient ( ) if post_args is not None : http . fetch ( url , method = "POST" , body = urllib . urlencode ( post_args ) , callback = callback ) else : http . fetch ( url , callback = callback ) def _on_twitter_request ( self , callback , response ) : if response . error : logging . warning ( "Error response %s fetching %s" , response . error , response . request . url ) callback ( None ) return callback ( escape . json_decode ( response . body ) ) def _oauth_consumer_token ( self ) : self . require_setting ( "twitter_consumer_key" , "Twitter OAuth" ) self . require_setting ( "twitter_consumer_secret" , "Twitter OAuth" ) return dict ( key = self . settings [ "twitter_consumer_key" ] , secret = self . settings [ "twitter_consumer_secret" ] ) def _oauth_get_user ( self , access_token , callback ) : callback = self . async_callback ( self . _parse_user_response , callback ) self . twitter_request ( + access_token [ "screen_name" ] , access_token = access_token , callback = callback ) def _parse_user_response ( self , callback , user ) : if user : user [ "username" ] = user [ "screen_name" ] callback ( user ) class FriendFeedMixin ( OAuthMixin ) : _OAUTH_REQUEST_TOKEN_URL = "https://friendfeed.com/account/oauth/request_token" _OAUTH_ACCESS_TOKEN_URL = "https://friendfeed.com/account/oauth/access_token" _OAUTH_AUTHORIZE_URL = "https://friendfeed.com/account/oauth/authorize" _OAUTH_NO_CALLBACKS = True def friendfeed_request ( self , path , callback , access_token = None , post_args = None , ** args ) : url = "http://friendfeed-api.com/v2" + path if access_token : all_args = { } all_args . update ( args ) all_args . update ( post_args or { } ) consumer_token = self . _oauth_consumer_token ( ) method = "POST" if post_args is not None else "GET" oauth = self . _oauth_request_parameters ( url , access_token , all_args , method = method ) args . update ( oauth ) if args : url += "?" + urllib . urlencode ( args ) callback = self . async_callback ( self . _on_friendfeed_request , callback ) http = httpclient . AsyncHTTPClient ( ) if post_args is not None : http . fetch ( url , method = "POST" , body = urllib . urlencode ( post_args ) , callback = callback ) else : http . fetch ( url , callback = callback ) def _on_friendfeed_request ( self , callback , response ) : if response . error : logging . warning ( "Error response %s fetching %s" , response . error , response . request . url ) callback ( None ) return callback ( escape . json_decode ( response . body ) ) def _oauth_consumer_token ( self ) : self . require_setting ( "friendfeed_consumer_key" , "FriendFeed OAuth" ) self . require_setting ( "friendfeed_consumer_secret" , "FriendFeed OAuth" ) return dict ( key = self . settings [ "friendfeed_consumer_key" ] , secret = self . settings [ "friendfeed_consumer_secret" ] ) def _oauth_get_user ( self , access_token , callback ) : callback = self . async_callback ( self . _parse_user_response , callback ) self . friendfeed_request ( + access_token [ "username" ] , include = "id,name,description" , access_token = access_token , callback = callback ) def _parse_user_response ( self , callback , user ) : if user : user [ "username" ] = user [ "id" ] callback ( user ) class GoogleMixin ( OpenIdMixin , OAuthMixin ) : _OPENID_ENDPOINT = "https://www.google.com/accounts/o8/ud" _OAUTH_ACCESS_TOKEN_URL = "https://www.google.com/accounts/OAuthGetAccessToken" def authorize_redirect ( self , oauth_scope , callback_uri = None , ax_attrs = [ "name" , "email" , "language" , "username" ] ) : callback_uri = callback_uri or self . request . path args = self . _openid_args ( callback_uri , ax_attrs = ax_attrs , oauth_scope = oauth_scope ) self . redirect ( self . _OPENID_ENDPOINT + "?" + urllib . urlencode ( args ) ) def get_authenticated_user ( self , callback ) : oauth_ns = "" for name , values in self . request . arguments . iteritems ( ) : if name . startswith ( "openid.ns." ) and values [ - 1 ] == u"http://specs.openid.net/extensions/oauth/1.0" : oauth_ns = name [ 10 : ] break token = self . get_argument ( "openid." + oauth_ns + ".request_token" , "" ) if token : http = httpclient . AsyncHTTPClient ( ) token = dict ( key = token , secret = "" ) http . fetch ( self . _oauth_access_token_url ( token ) , self . async_callback ( self . _on_access_token , callback ) ) else : OpenIdMixin . get_authenticated_user ( self , callback ) def _oauth_consumer_token ( self ) : self . require_setting ( "google_consumer_key" , "Google OAuth" ) self . require_setting ( "google_consumer_secret" , "Google OAuth" ) return dict ( key = self . settings [ "google_consumer_key" ] , secret = self . settings [ "google_consumer_secret" ] ) def _oauth_get_user ( self , access_token , callback ) : OpenIdMixin . get_authenticated_user ( self , callback ) class FacebookMixin ( object ) : def authenticate_redirect ( self , callback_uri = None , cancel_uri = None , extended_permissions = None ) : self . require_setting ( "facebook_api_key" , "Facebook Connect" ) callback_uri = callback_uri or self . request . path args = { : self . settings [ "facebook_api_key" ] , : "1.0" , : "true" , : "page" , : urlparse . urljoin ( self . request . full_url ( ) , callback_uri ) , : "true" , } if cancel_uri : args [ "cancel_url" ] = urlparse . urljoin ( self . request . full_url ( ) , cancel_uri ) if extended_permissions : if isinstance ( extended_permissions , basestring ) : extended_permissions = [ extended_permissions ] args [ "req_perms" ] = "," . join ( extended_permissions ) self . redirect ( "http://www.facebook.com/login.php?" + urllib . urlencode ( args ) ) def authorize_redirect ( self , extended_permissions , callback_uri = None , cancel_uri = None ) : self . authenticate_redirect ( callback_uri , cancel_uri , extended_permissions ) def get_authenticated_user ( self , callback ) : self . require_setting ( "facebook_api_key" , "Facebook Connect" ) session = escape . json_decode ( self . get_argument ( "session" ) ) self . facebook_request ( method = "facebook.users.getInfo" , callback = self . async_callback ( self . _on_get_user_info , callback , session ) , session_key = session [ "session_key" ] , uids = session [ "uid" ] , fields = "uid,first_name,last_name,name,locale,pic_square," "profile_url,username" ) def facebook_request ( self , method , callback , ** args ) : self . require_setting ( "facebook_api_key" , "Facebook Connect" ) self . require_setting ( "facebook_secret" , "Facebook Connect" ) if not method . startswith ( "facebook." ) : method = "facebook." + method args [ "api_key" ] = self . settings [ "facebook_api_key" ] args [ "v" ] = "1.0" args [ "method" ] = method args [ "call_id" ] = str ( long ( time . time ( ) * 1e6 ) ) args [ "format" ] = "json" args [ "sig" ] = self . _signature ( args ) url = "http://api.facebook.com/restserver.php?" + urllib . urlencode ( args ) http = httpclient . AsyncHTTPClient ( ) http . fetch ( url , callback = self . async_callback ( self . _parse_response , callback ) ) def _on_get_user_info ( self , callback , session , users ) : if users is None : callback ( None ) return callback ( { : users [ 0 ] [ "name" ] , : users [ 0 ] [ "first_name" ] , : users [ 0 ] [ "last_name" ] , : users [ 0 ] [ "uid" ] , : users [ 0 ] [ "locale" ] , : users [ 0 ] [ "pic_square" ] , : users [ 0 ] [ "profile_url" ] , : users [ 0 ] . get ( "username" ) , : session [ "session_key" ] , : session . get ( "expires" ) , } ) def _parse_response ( self , callback , response ) : if response . error : logging . warning ( "HTTP error from Facebook: %s" , response . error ) callback ( None ) return try : json = escape . json_decode ( response . body ) except : logging . warning ( "Invalid JSON from Facebook: %r" , response . body ) callback ( None ) return if isinstance ( json , dict ) and json . get ( "error_code" ) : logging . warning ( "Facebook error: %d: %r" , json [ "error_code" ] , json . get ( "error_msg" ) ) callback ( None ) return callback ( json ) def _signature ( self , args ) : parts = [ "%s=%s" % ( n , args [ n ] ) for n in sorted ( args . keys ( ) ) ] body = "" . join ( parts ) + self . settings [ "facebook_secret" ] if isinstance ( body , unicode ) : body = body . encode ( "utf-8" ) return hashlib . md5 ( body ) . hexdigest ( ) def _oauth_signature ( consumer_token , method , url , parameters = { } , token = None ) : parts = urlparse . urlparse ( url ) scheme , netloc , path = parts [ : 3 ] normalized_url = scheme . lower ( ) + "://" + netloc . lower ( ) + path base_elems = [ ] base_elems . append ( method . upper ( ) ) base_elems . append ( normalized_url ) base_elems . append ( "&" . join ( "%s=%s" % ( k , _oauth_escape ( str ( v ) ) ) for k , v in sorted ( parameters . items ( ) ) ) ) base_string = "&" . join ( _oauth_escape ( e ) for e in base_elems ) key_elems = [ consumer_token [ "secret" ] ] key_elems . append ( token [ "secret" ] if token else "" ) key = "&" . join ( key_elems ) hash = hmac . new ( key , base_string , hashlib . sha1 ) return binascii . b2a_base64 ( hash . digest ( ) ) [ : - 1 ] def _oauth_escape ( val ) : if isinstance ( val , unicode ) : val = val . encode ( "utf-8" ) return urllib . quote ( val , safe = "~" ) def _oauth_parse_response ( body ) : p = cgi . parse_qs ( body , keep_blank_values = False ) token = dict ( key = p [ "oauth_token" ] [ 0 ] , secret = p [ "oauth_token_secret" ] [ 0 ] ) special = ( "oauth_token" , "oauth_token_secret" ) token . update ( ( k , p [ k ] [ 0 ] ) for k in p if k not in special ) return token

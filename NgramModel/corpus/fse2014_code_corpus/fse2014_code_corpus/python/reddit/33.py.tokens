from r2 . models import Thing , Link , Subreddit , AllSR , admintools from r2 . lib . utils import Storage , tup from r2 . lib . memoize import memoize from datetime import datetime from pylons import g class Trial ( Storage ) : def __init__ ( self , defendant ) : from r2 . lib . utils . trial_utils import trial_info if not defendant . _loaded : defendant . _load ( ) if not trial_info ( defendant ) : raise ValueError ( "Defendant %s is not on trial" % defendant . _id ) self . defendant = defendant def convict ( self , details = '' ) : admintools . spam ( self . defendant , auto = False , moderator_banned = True , banner = "deputy moderation" + details ) def acquit ( self , details = '' ) : admintools . unspam ( self . defendant , unbanner = "deputy moderation" + details ) def mistrial ( self ) : if self . defendant . _spam : pass def verdict ( self ) : from r2 . models import Jury from r2 . lib . utils . trial_utils import update_voting koshers = 0 spams = 0 nones = 0 now = datetime . now ( g . tz ) defendant_age = now - self . defendant . _date if defendant_age . days > 0 : return ( "jury timeout" , None , None ) latest_juryvote = None for j in Jury . by_defendant ( self . defendant ) : if j . _name == "0" : nones += 1 continue if latest_juryvote is None : latest_juryvote = j . _date else : latest_juryvote = max ( latest_juryvote , j . _date ) if j . _name == "1" : koshers += 1 elif j . _name == "-1" : spams += 1 else : raise ValueError ( "weird jury vote: [%s]" % j . _name ) print "%d koshers, %d spams, %d haven't voted yet" % ( koshers , spams , nones ) update_voting ( self . defendant , koshers , spams ) total_votes = koshers + spams if total_votes < 7 : g . log . debug ( "not enough votes yet" ) return ( None , koshers , spams ) if total_votes >= 20 : g . cache . set ( "quench_jurors-" + self . defendant . _fullname , True ) quenching = True else : quenching = False if defendant_age . seconds < 3600 and ( now - latest_juryvote ) . seconds < 300 : trickling = True else : trickling = False kosher_pct = float ( koshers ) / float ( total_votes ) if kosher_pct < 0.13 : return ( "guilty" , koshers , spams ) elif kosher_pct > 0.86 : return ( "innocent" , koshers , spams ) elif trickling : g . log . debug ( "votes still trickling in" ) return ( None , koshers , spams ) elif kosher_pct < 0.34 : return ( "guilty" , koshers , spams ) elif kosher_pct > 0.66 : return ( "innocent" , koshers , spams ) elif not quenching : g . log . debug ( "not yet quenching" ) return ( None , koshers , spams ) elif kosher_pct < 0.3999 : return ( "guilty" , koshers , spams ) elif kosher_pct > 0.6001 : return ( "innocent" , koshers , spams ) elif total_votes >= 100 : return ( "hung jury" , koshers , spams ) else : g . log . debug ( "hung jury, so far" ) return ( None , koshers , spams ) def check_verdict ( self ) : from r2 . lib . utils . trial_utils import end_trial verdict , koshers , spams = self . verdict ( ) if verdict is None : return if verdict in ( "jury timeout" , "hung jury" ) : self . mistrial ( ) else : details = ", %d-%d" % ( spams , koshers ) if verdict == "guilty" : self . convict ( details ) elif verdict == "innocent" : self . acquit ( details ) else : raise ValueError ( "Invalid verdict [%s]" % verdict ) end_trial ( self . defendant , verdict ) return verdict @ classmethod @ memoize ( 'trial.all_defendants' ) def all_defendants_cache ( cls ) : fnames = g . hardcache . backend . ids_by_category ( "trial" ) return fnames @ classmethod def all_defendants ( cls , quench = False , _update = False ) : all = cls . all_defendants_cache ( _update = _update ) defs = Thing . _by_fullname ( all , data = True ) . values ( ) if quench : return filter ( lambda d : not g . cache . get ( "quench_jurors-" + d . _fullname ) , defs ) else : return defs @ classmethod def defendants_by_sr ( cls , sr ) : all = cls . all_defendants ( ) if isinstance ( sr , AllSR ) : return all sr = tup ( sr ) sr_ids = [ s . _id for s in sr ] return filter ( lambda x : x . sr_id in sr_ids , all )

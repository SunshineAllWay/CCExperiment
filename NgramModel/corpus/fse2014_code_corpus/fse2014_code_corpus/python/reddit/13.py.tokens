from account import * from link import * from vote import * from report import * from pylons import i18n , request , g from r2 . lib . wrapped import Wrapped from r2 . lib import utils from r2 . lib . db import operators from r2 . lib . cache import sgm from copy import deepcopy , copy class Listing ( object ) : _js_cls = "Listing" def __init__ ( self , builder , nextprev = True , next_link = True , prev_link = True , vote_hash_type = 'valid' , ** kw ) : self . builder = builder self . nextprev = nextprev self . next_link = True self . prev_link = True self . next = None self . prev = None self . max_num = 1 self . vote_hash_type = vote_hash_type @ property def max_score ( self ) : scores = [ x . score for x in self . things if hasattr ( x , 'score' ) ] return max ( scores ) if scores else 0 def get_items ( self , * a , ** kw ) : from r2 . lib . template_helpers import replace_render builder_items = self . builder . get_items ( * a , ** kw ) for item in self . builder . item_iter ( builder_items ) : if not hasattr ( item , "render_replaced" ) : item . render = replace_render ( self , item , item . render ) item . render_replaced = True return builder_items def listing ( self ) : self . things , prev , next , bcount , acount = self . get_items ( ) self . max_num = max ( acount , bcount ) self . after = None self . before = None if self . nextprev and self . prev_link and prev and bcount > 1 : p = request . get . copy ( ) p . update ( { 'after' : None , 'before' : prev . _fullname , 'count' : bcount } ) self . before = prev . _fullname self . prev = ( request . path + utils . query_string ( p ) ) p_first = request . get . copy ( ) p_first . update ( { 'after' : None , 'before' : None , 'count' : None } ) self . first = ( request . path + utils . query_string ( p_first ) ) if self . nextprev and self . next_link and next : p = request . get . copy ( ) p . update ( { 'after' : next . _fullname , 'before' : None , 'count' : acount } ) self . after = next . _fullname self . next = ( request . path + utils . query_string ( p ) ) return Wrapped ( self ) def __iter__ ( self ) : return iter ( self . things ) class TableListing ( Listing ) : pass class ModActionListing ( TableListing ) : pass class LinkListing ( Listing ) : def __init__ ( self , * a , ** kw ) : Listing . __init__ ( self , * a , ** kw ) self . show_nums = kw . get ( 'show_nums' , False ) class NestedListing ( Listing ) : def __init__ ( self , * a , ** kw ) : Listing . __init__ ( self , * a , ** kw ) self . num = kw . get ( 'num' , g . num_comments ) self . parent_name = kw . get ( 'parent_name' ) def listing ( self ) : wrapped_items = self . get_items ( num = self . num ) self . things = wrapped_items return Wrapped ( self ) class SpotlightListing ( Listing ) : _js_cls = "OrganicListing" def __init__ ( self , * a , ** kw ) : kw [ 'vote_hash_type' ] = kw . get ( 'vote_hash_type' , 'organic' ) Listing . __init__ ( self , * a , ** kw ) self . nextprev = False self . show_nums = True self . _max_num = kw . get ( 'max_num' , 0 ) self . _max_score = kw . get ( 'max_score' , 0 ) self . spotlight_links = kw . get ( 'spotlight_links' , [ ] ) self . visible_link = kw . get ( 'visible_link' , '' ) @ property def max_score ( self ) : return self . _max_score def listing ( self ) : res = Listing . listing ( self ) res . max_num = self . _max_num res . max_score = self . _max_score for t in res . things : t . num = "" return res

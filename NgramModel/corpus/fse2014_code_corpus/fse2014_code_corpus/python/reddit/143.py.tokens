from api import * from pylons import g from r2 . models . bidding import Bid test_card = dict ( AMEX = ( "370000000000002" , 1234 ) , DISCOVER = ( "6011000000000012" , 123 ) , MASTERCARD = ( "5424000000000015" , 123 ) , VISA = ( "4007000000027" , 123 ) , ERRORCARD = ( "4222222222222" , 123 ) ) test_card = Storage ( ( k , CreditCard ( cardNumber = x , expirationDate = "2011-11" , cardCode = y ) ) for k , ( x , y ) in test_card . iteritems ( ) ) test_address = Address ( firstName = "John" , lastName = "Doe" , address = "123 Fake St." , city = "Anytown" , state = "MN" , zip = "12346" ) def get_account_info ( user , recursed = False ) : if not CustomerID . get_id ( user ) : cust_id = CreateCustomerProfileRequest ( user ) . make_request ( ) try : u , data = GetCustomerProfileRequest ( user ) . make_request ( ) except AuthorizeNetException : u = None if u != user : if not recursed : CustomerID . delete ( user ) return get_account_info ( user , True ) else : raise AuthorizeNetException , "error creating user" return data def edit_profile ( user , address , creditcard , pay_id = None ) : if pay_id : return UpdateCustomerPaymentProfileRequest ( user , pay_id , address , creditcard ) . make_request ( ) else : return CreateCustomerPaymentProfileRequest ( user , address , creditcard ) . make_request ( ) def _make_transaction ( trans_cls , amount , user , pay_id , order = None , trans_id = None , test = None ) : if amount : amount = "%.2f" % amount cust_id = CustomerID . get_id ( user ) trans = trans_cls ( amount , cust_id , pay_id , trans_id = trans_id , order = order ) extra = { } if isinstance ( test , int ) : extra = dict ( x_test_request = "TRUE" , x_card_num = test_card . ERRORCARD . cardNumber , x_amount = test ) req = CreateCustomerProfileTransactionRequest ( transaction = trans , extraOptions = extra ) return req . make_request ( ) def auth_transaction ( amount , user , payid , thing , campaign , test = None ) : if payid < 0 : trans_id = - thing . _id try : bid = Bid . one ( thing_id = thing . _id , transaction = trans_id , campaign = campaign ) bid . bid = amount bid . auth ( ) except NotFound : bid = Bid . _new ( trans_id , user , payid , thing . _id , amount , campaign ) return bid . transaction , "" elif int ( payid ) in PayID . get_ids ( user ) : order = Order ( invoiceNumber = "%dT%d" % ( user . _id , thing . _id ) ) success , res = _make_transaction ( ProfileTransAuthOnly , amount , user , payid , order = order , test = test ) if success : if test : return auth_transaction ( amount , user , - 1 , thing , campaign , test = test ) else : Bid . _new ( res . trans_id , user , payid , thing . _id , amount , campaign ) return res . trans_id , "" elif res is None : return auth_transaction ( amount , user , - 1 , thing , test = test ) elif ( res . response_code , res . response_reason_code ) == ( 3 , 11 ) : try : Bid . one ( res . trans_id ) except NotFound : Bid . _new ( res . trans_id , user , payid , thing . _id , amount ) return res . trans_id , res . response_reason_text def void_transaction ( user , trans_id , campaign , test = None ) : bid = Bid . one ( transaction = trans_id , campaign = campaign ) bid . void ( ) if trans_id > 0 : res = _make_transaction ( ProfileTransVoid , None , user , None , trans_id = trans_id , test = test ) return res def is_charged_transaction ( trans_id , campaign ) : bid = Bid . one ( transaction = trans_id , campaign = campaign ) return bid . is_charged ( ) def charge_transaction ( user , trans_id , campaign , test = None ) : bid = Bid . one ( transaction = trans_id , campaign = campaign ) if not bid . is_charged ( ) : bid . charged ( ) if trans_id < 0 : return True elif bid . account_id == user . _id : res = _make_transaction ( ProfileTransPriorAuthCapture , bid . bid , user , bid . pay_id , trans_id = trans_id , test = test ) return bool ( res ) return True def get_transactions ( * trans_keys ) : from sqlalchemy import and_ , or_ if trans_keys : f = or_ ( * [ and_ ( Bid . transaction == trans_id , Bid . campaign == camp ) for trans_id , camp in trans_keys ] ) q = Bid . query ( ) q = q . filter ( f ) return dict ( ( ( p . transaction , p . campaign ) , p ) for p in q ) return { }

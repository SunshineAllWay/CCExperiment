from r2 . lib . db import tdb_cassandra from r2 . lib . utils import tup from r2 . models import Account , Subreddit , Link , Comment , Printable from pycassa . system_manager import TIME_UUID_TYPE from uuid import UUID from pylons . i18n import _ from pylons import request class ModAction ( tdb_cassandra . UuidThing , Printable ) : _use_db = True _connection_pool = 'main' _str_props = ( 'sr_id36' , 'mod_id36' , 'target_fullname' , 'action' , 'details' , ) _defaults = { } actions = ( 'banuser' , 'unbanuser' , 'removelink' , 'approvelink' , , 'approvecomment' , 'addmoderator' , , 'addcontributor' , 'removecontributor' , , 'editflair' , 'distinguish' , 'marknsfw' ) _menu = { 'banuser' : _ ( 'ban user' ) , : _ ( 'unban user' ) , : _ ( 'remove post' ) , : _ ( 'approve post' ) , : _ ( 'remove comment' ) , : _ ( 'approve comment' ) , : _ ( 'add moderator' ) , : _ ( 'remove moderator' ) , : _ ( 'add contributor' ) , : _ ( 'remove contributor' ) , : _ ( 'edit settings' ) , : _ ( 'edit user flair' ) , : _ ( 'distinguish' ) , : _ ( 'mark nsfw' ) } _text = { 'banuser' : _ ( 'banned' ) , : _ ( 'unbanned' ) , : _ ( 'removed' ) , : _ ( 'approved' ) , : _ ( 'removed' ) , : _ ( 'approved' ) , : _ ( 'added moderator' ) , : _ ( 'removed moderator' ) , : _ ( 'added approved contributor' ) , : _ ( 'removed approved contributor' ) , : _ ( 'edited settings' ) , : _ ( 'edited user flair' ) , : _ ( 'distinguished' ) , : _ ( 'marked nsfw' ) } _details_text = { : _ ( 'unspam' ) , : _ ( 'confirmed spam' ) , : _ ( 'removed self' ) , : _ ( 'title' ) , : _ ( 'description' ) , : _ ( 'language' ) , : _ ( 'type' ) , : _ ( 'link type' ) , : _ ( 'toggle viewers must be over 18' ) , : _ ( 'toggle allow in default set' ) , : _ ( 'toggle show thumbnail images of content' ) , : _ ( 'domain' ) , : _ ( 'toggle show sidebar from cname' ) , : _ ( 'toggle custom CSS from cname' ) , : _ ( 'header title' ) , : _ ( 'stylesheet' ) , : _ ( 'delete header image' ) , : _ ( 'delete image' ) , : _ ( 'upload header image' ) , : _ ( 'upload image' ) , : _ ( 'add/edit flair' ) , : _ ( 'delete flair' ) , : _ ( 'edit by csv' ) , : _ ( 'toggle flair enabled' ) , : _ ( 'toggle flair position' ) , : _ ( 'toggle user assigned flair enabled' ) , : _ ( 'add/edit flair templates' ) , : _ ( 'delete flair template' ) , : _ ( 'clear flair templates' ) , : _ ( 'remove' ) } cache_ignore = set ( [ 'subreddit' , 'target' ] ) . union ( Printable . cache_ignore ) @ property def author_id ( self ) : return int ( self . mod_id36 , 36 ) @ property def sr_id ( self ) : return int ( self . sr_id36 , 36 ) @ property def _ups ( self ) : return 0 @ property def _downs ( self ) : return 0 @ property def _deleted ( self ) : return False @ property def _spam ( self ) : return False @ property def reported ( self ) : return False @ classmethod def create ( cls , sr , mod , action , details = None , target = None , description = None ) : if not action in cls . actions : raise ValueError ( "Invalid ModAction: %s" % action ) kw = dict ( sr_id36 = sr . _id36 , mod_id36 = mod . _id36 , action = action ) if target : kw [ 'target_fullname' ] = target . _fullname if details : kw [ 'details' ] = details if description : kw [ 'description' ] = description ma = cls ( ** kw ) ma . _commit ( ) return ma def _on_create ( self ) : views = ( ModActionBySR , ModActionBySRMod , ModActionBySRAction ) for v in views : v . add_object ( self ) @ classmethod def get_actions ( cls , srs , mod = None , action = None , after = None , reverse = False , count = 1000 ) : if after and isinstance ( after , basestring ) : after = cls . _byID ( UUID ( after ) ) elif after and isinstance ( after , UUID ) : after = cls . _byID ( after ) if not isinstance ( after , cls ) : after = None srs = tup ( srs ) if not mod and not action : rowkeys = [ sr . _id36 for sr in srs ] q = ModActionBySR . query ( rowkeys , after = after , reverse = reverse , count = count ) elif mod and not action : rowkeys = [ '%s_%s' % ( sr . _id36 , mod . _id36 ) for sr in srs ] q = ModActionBySRMod . query ( rowkeys , after = after , reverse = reverse , count = count ) elif not mod and action : rowkeys = [ '%s_%s' % ( sr . _id36 , action ) for sr in srs ] q = ModActionBySRAction . query ( rowkeys , after = after , reverse = reverse , count = count ) else : raise NotImplementedError ( "Can't query by both mod and action" ) return q def get_extra_text ( self ) : text = '' if hasattr ( self , 'details' ) and not self . details == None : text += self . _details_text . get ( self . details , self . details ) if hasattr ( self , 'description' ) and not self . description == None : text += ' %s' % self . description return text @ staticmethod def get_rgb ( i , fade = 0.8 ) : r = int ( 256 - ( hash ( str ( i ) ) % 256 ) * ( 1 - fade ) ) g = int ( 256 - ( hash ( str ( i ) + ' ' ) % 256 ) * ( 1 - fade ) ) b = int ( 256 - ( hash ( str ( i ) + ' ' ) % 256 ) * ( 1 - fade ) ) return ( r , g , b ) @ classmethod def add_props ( cls , user , wrapped ) : from r2 . lib . menus import NavButton from r2 . lib . db . thing import Thing from r2 . lib . pages import WrappedUser from r2 . lib . filters import _force_unicode TITLE_MAX_WIDTH = 50 request_path = request . path target_fullnames = [ item . target_fullname for item in wrapped if hasattr ( item , 'target_fullname' ) ] targets = Thing . _by_fullname ( target_fullnames , data = True ) authors = Account . _byID ( [ t . author_id for t in targets . values ( ) if hasattr ( t , 'author_id' ) ] , data = True ) links = Link . _byID ( [ t . link_id for t in targets . values ( ) if hasattr ( t , 'link_id' ) ] , data = True ) subreddits = Subreddit . _byID ( [ item . sr_id for item in wrapped ] , data = True ) target_links = { } target_accounts = { } for fullname , target in targets . iteritems ( ) : if isinstance ( target , Link ) : author = authors [ target . author_id ] title = _force_unicode ( target . title ) if len ( title ) > TITLE_MAX_WIDTH : short_title = title [ : TITLE_MAX_WIDTH ] + '...' else : short_title = title text = '%(link)s "%(title)s" %(by)s %(author)s' % { : _ ( 'link' ) , : short_title , : _ ( 'by' ) , : author . name } path = target . make_permalink ( subreddits [ target . sr_id ] ) target_links [ fullname ] = ( text , path , title ) elif isinstance ( target , Comment ) : author = authors [ target . author_id ] link = links [ target . link_id ] title = _force_unicode ( link . title ) if len ( title ) > TITLE_MAX_WIDTH : short_title = title [ : TITLE_MAX_WIDTH ] + '...' else : short_title = title text = '%(comment)s %(by)s %(author)s %(on)s "%(title)s"' % { : _ ( 'comment' ) , : _ ( 'by' ) , : author . name , : _ ( 'on' ) , : short_title } path = target . make_permalink ( link , subreddits [ link . sr_id ] ) target_links [ fullname ] = ( text , path , title ) elif isinstance ( target , Account ) : target_accounts [ fullname ] = WrappedUser ( target ) for item in wrapped : css_class = 'modactions %s' % item . action item . button = NavButton ( '' , item . action , opt = 'type' , css_class = css_class ) item . button . build ( base_path = request_path ) mod_name = item . author . name item . mod = NavButton ( mod_name , mod_name , opt = 'mod' ) item . mod . build ( base_path = request_path ) item . text = ModAction . _text . get ( item . action , '' ) item . details = item . get_extra_text ( ) if hasattr ( item , 'target_fullname' ) and item . target_fullname : target = targets [ item . target_fullname ] if isinstance ( target , Account ) : item . target_wrapped_user = target_accounts [ item . target_fullname ] elif isinstance ( target , Link ) or isinstance ( target , Comment ) : item . target_text , item . target_path , item . target_title = target_links [ item . target_fullname ] item . bgcolor = ModAction . get_rgb ( item . sr_id ) item . sr_name = subreddits [ item . sr_id ] . name item . sr_path = subreddits [ item . sr_id ] . path Printable . add_props ( user , wrapped ) class ModActionBySR ( tdb_cassandra . View ) : _use_db = True _connection_pool = 'main' _compare_with = TIME_UUID_TYPE _view_of = ModAction _ttl = 60 * 60 * 24 * 30 * 3 @ classmethod def _rowkey ( cls , ma ) : return ma . sr_id36 class ModActionBySRMod ( tdb_cassandra . View ) : _use_db = True _connection_pool = 'main' _compare_with = TIME_UUID_TYPE _view_of = ModAction _ttl = 60 * 60 * 24 * 30 * 3 @ classmethod def _rowkey ( cls , ma ) : return '%s_%s' % ( ma . sr_id36 , ma . mod_id36 ) class ModActionBySRAction ( tdb_cassandra . View ) : _use_db = True _connection_pool = 'main' _compare_with = TIME_UUID_TYPE _view_of = ModAction _ttl = 60 * 60 * 24 * 30 * 3 @ classmethod def _rowkey ( cls , ma ) : return '%s_%s' % ( ma . sr_id36 , ma . action )

iters = ( list , tuple , set ) def tup ( item , ret_is_single = False ) : if isinstance ( item , iters ) : return ( item , False ) if ret_is_single else item else : return ( ( item , ) , True ) if ret_is_single else ( item , ) class Storage ( dict ) : def __getattr__ ( self , key ) : try : return self [ key ] except KeyError , k : raise AttributeError , k def __setattr__ ( self , key , value ) : self [ key ] = value def __delattr__ ( self , key ) : try : del self [ key ] except KeyError , k : raise AttributeError , k def __repr__ ( self ) : return '<Storage ' + dict . __repr__ ( self ) + '>' storage = Storage def storify ( mapping , * requireds , ** defaults ) : def getvalue ( x ) : if hasattr ( x , 'value' ) : return x . value else : return x stor = Storage ( ) for key in requireds + tuple ( mapping . keys ( ) ) : value = mapping [ key ] if isinstance ( value , list ) : if isinstance ( defaults . get ( key ) , list ) : value = [ getvalue ( x ) for x in value ] else : value = value [ - 1 ] if not isinstance ( defaults . get ( key ) , dict ) : value = getvalue ( value ) if isinstance ( defaults . get ( key ) , list ) and not isinstance ( value , list ) : value = [ value ] setattr ( stor , key , value ) for ( key , value ) in defaults . iteritems ( ) : result = value if hasattr ( stor , key ) : result = stor [ key ] if value == ( ) and not isinstance ( result , tuple ) : result = ( result , ) setattr ( stor , key , result ) return stor def _strips ( direction , text , remove ) : if direction == 'l' : if text . startswith ( remove ) : return text [ len ( remove ) : ] elif direction == 'r' : if text . endswith ( remove ) : return text [ : - len ( remove ) ] else : raise ValueError , "Direction needs to be r or l." return text def rstrips ( text , remove ) : return _strips ( 'r' , text , remove ) def lstrips ( text , remove ) : return _strips ( 'l' , text , remove ) def strips ( text , remove ) : return rstrips ( lstrips ( text , remove ) , remove ) class Results ( ) : def __init__ ( self , sa_ResultProxy , build_fn , do_batch = False ) : self . rp = sa_ResultProxy self . fn = build_fn self . do_batch = do_batch @ property def rowcount ( self ) : return self . rp . rowcount def _fetch ( self , res ) : if self . do_batch : return self . fn ( res ) else : return [ self . fn ( row ) for row in res ] def fetchall ( self ) : return self . _fetch ( self . rp . fetchall ( ) ) def fetchmany ( self , n ) : rows = self . _fetch ( self . rp . fetchmany ( n ) ) if rows : return rows else : raise StopIteration def fetchone ( self ) : row = self . rp . fetchone ( ) if row : return self . fn ( row ) else : raise StopIteration def string2js ( s ) : ESCAPE = re . compile ( r'[\x00-\x19\\"\b\f\n\r\t]' ) ESCAPE_ASCII = re . compile ( r'([\\"/]|[^\ -~])' ) ESCAPE_DCT = { : '\\/' , : '\\\\' , : '\\"' , : '\\b' , : '\\f' , : '\\n' , : '\\r' , : '\\t' , } for i in range ( 20 ) : ESCAPE_DCT . setdefault ( chr ( i ) , '\\u%04x' % ( i , ) ) def replace ( match ) : return ESCAPE_DCT [ match . group ( 0 ) ] return '"' + ESCAPE . sub ( replace , s ) + '"'

import sys import multiprocessing from r2 . lib . mr_tools . _mr_tools import mr_map , mr_reduce , format_dataspec from r2 . lib . mr_tools . _mr_tools import stdin , emit def join_things ( fields , deleted = False , spam = True ) : def process ( thing_id , vals ) : data = { } thing = None for val in vals : if val [ 0 ] == 'thing' : thing = format_dataspec ( val , [ 'data_type' , , , , , , ] ) elif val [ 0 ] == 'data' : val = format_dataspec ( val , [ 'data_type' , , , ] ) if val . key in fields : data [ val . key ] = val . value if ( thing is not None and ( deleted or thing . deleted == 'f' ) and ( spam or thing . spam == 'f' ) and all ( field in data for field in fields ) ) : yield ( ( thing_id , thing . thing_type , thing . ups , thing . downs , thing . deleted , thing . spam , thing . timestamp ) + tuple ( data [ field ] for field in fields ) ) mr_reduce ( process ) class Mapper ( object ) : def __init__ ( self ) : pass def process ( self , values ) : raise NotImplemented def __call__ ( self , line ) : line = line . strip ( '\n' ) vals = line . split ( '\t' ) return list ( self . process ( vals ) ) def mr_map_parallel ( processor , fd = stdin , workers = multiprocessing . cpu_count ( ) , chunk_size = 1000 ) : if workers == 1 : return mr_map ( process , fd = fd ) pool = multiprocessing . Pool ( workers ) for res in pool . imap_unordered ( processor , fd , chunk_size ) : for subres in res : emit ( subres ) def test ( ) : from r2 . lib . mr_tools . _mr_tools import keyiter for key , vals in keyiter ( ) : print key , vals for val in vals : print '\t' , val class UpperMapper ( Mapper ) : def process ( self , values ) : yield map ( str . upper , values ) def test_parallel ( ) : return mr_map_parallel ( UpperMapper ( ) )

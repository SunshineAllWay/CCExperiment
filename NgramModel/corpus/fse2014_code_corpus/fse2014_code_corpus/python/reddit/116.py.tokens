from __future__ import with_statement from time import sleep from datetime import datetime from threading import local from traceback import format_stack import os import socket locks = local ( ) reddit_host = socket . gethostname ( ) reddit_pid = os . getpid ( ) class TimeoutExpired ( Exception ) : pass class MemcacheLock ( object ) : def __init__ ( self , key , cache , time = 30 , timeout = 30 , verbose = True ) : self . locks = locks . locks = getattr ( locks , 'locks' , set ( ) ) self . key = key self . cache = cache self . time = time self . timeout = timeout self . have_lock = False self . verbose = verbose def __enter__ ( self ) : start = datetime . now ( ) my_info = ( reddit_host , reddit_pid , '' . join ( format_stack ( ) ) ) if self . key in self . locks : return while not self . cache . add ( self . key , my_info , time = self . time ) : if ( datetime . now ( ) - start ) . seconds > self . timeout : if self . verbose : info = self . cache . get ( self . key ) if info : info = "%s %s\n%s" % info else : info = "(nonexistent)" msg = ( "\nSome jerk is hogging %s:\n%s" % ( self . key , info ) ) msg += "^^^ that was the stack trace of the lock hog, not me." else : msg = "Timed out waiting for %s" % self . key raise TimeoutExpired ( msg ) sleep ( .01 ) self . locks . add ( self . key ) self . have_lock = True def __exit__ ( self , type , value , tb ) : if self . have_lock : self . cache . delete ( self . key ) self . locks . remove ( self . key ) def make_lock_factory ( cache ) : def factory ( key , ** kw ) : return MemcacheLock ( key , cache , ** kw ) return factory

from email . MIMEText import MIMEText from pylons . i18n import _ from pylons import c , g from r2 . lib . utils import timeago , query_string , randstr from r2 . models import passhash , Email , DefaultSR , has_opted_out , Account , Award import os , random , datetime import traceback , sys , smtplib def _feedback_email ( email , body , kind , name = '' , reply_to = '' ) : Email . handler . add_to_queue ( c . user if c . user_is_loggedin else None , g . feedback_email , name , email , kind , body = body , reply_to = reply_to ) def _system_email ( email , body , kind , reply_to = "" , thing = None ) : Email . handler . add_to_queue ( c . user if c . user_is_loggedin else None , email , g . domain , g . feedback_email , kind , body = body , reply_to = reply_to , thing = thing ) def _nerds_email ( body , from_name , kind ) : Email . handler . add_to_queue ( None , g . nerds_email , from_name , g . nerds_email , kind , body = body ) def _gold_email ( body , to_address , from_name , kind ) : Email . handler . add_to_queue ( None , to_address , from_name , g . goldthanks_email , kind , body = body ) def verify_email ( user , dest ) : from r2 . lib . pages import VerifyEmail key = passhash ( user . name , user . email ) user . email_verified = False user . _commit ( ) Award . take_away ( "verified_email" , user ) emaillink = ( 'http://' + g . domain + '/verification/' + key + query_string ( dict ( dest = dest ) ) ) g . log . debug ( "Generated email verification link: " + emaillink ) g . cache . set ( "email_verify_%s" % key , user . _id , time = 1800 ) _system_email ( user . email , VerifyEmail ( user = user , emaillink = emaillink ) . render ( style = 'email' ) , Email . Kind . VERIFY_EMAIL ) def password_email ( user ) : from r2 . lib . pages import PasswordReset reset_count_key = "email-reset_count_%s" % user . _id g . cache . add ( reset_count_key , 0 , time = 3600 * 12 ) if g . cache . incr ( reset_count_key ) > 3 : return False reset_count_global = "email-reset_count_global" g . cache . add ( reset_count_global , 0 , time = 3600 ) if g . cache . incr ( reset_count_global ) > 1000 : raise ValueError ( "Somebody's beating the hell out of the password reset box" ) key = passhash ( randstr ( 64 , reallyrandom = True ) , user . email ) passlink = 'http://' + g . domain + '/resetpassword/' + key g . log . info ( "Generated password reset link: " + passlink ) g . hardcache . set ( "email-reset_%s" % key , user . _id , time = 3600 * 12 ) _system_email ( user . email , PasswordReset ( user = user , passlink = passlink ) . render ( style = 'email' ) , Email . Kind . RESET_PASSWORD ) return True def feedback_email ( email , body , name = '' , reply_to = '' ) : return _feedback_email ( email , body , Email . Kind . FEEDBACK , name = name , reply_to = reply_to ) def ad_inq_email ( email , body , name = '' , reply_to = '' ) : return _feedback_email ( email , body , Email . Kind . ADVERTISE , name = name , reply_to = reply_to ) def i18n_email ( email , body , name = '' , reply_to = '' ) : return _feedback_email ( email , body , Email . Kind . HELP_TRANSLATE , name = name , reply_to = reply_to ) def gold_email ( body , to_address , from_name = g . domain ) : return _gold_email ( body , to_address , from_name , Email . Kind . GOLDMAIL ) def nerds_email ( body , from_name = g . domain ) : return _nerds_email ( body , from_name , Email . Kind . NERDMAIL ) def share ( link , emails , from_name = "" , reply_to = "" , body = "" ) : now = datetime . datetime . now ( g . tz ) ival = now - timeago ( g . new_link_share_delay ) date = max ( now , link . _date + ival ) Email . handler . add_to_queue ( c . user , emails , from_name , g . share_reply , Email . Kind . SHARE , date = date , body = body , reply_to = reply_to , thing = link ) def send_queued_mail ( test = False ) : from r2 . lib . pages import PasswordReset , Share , Mail_Opt , VerifyEmail now = datetime . datetime . now ( g . tz ) if not c . site : c . site = DefaultSR ( ) clear = False if not test : session = smtplib . SMTP ( g . smtp_server ) def sendmail ( email ) : try : mimetext = email . to_MIMEText ( ) if mimetext is None : print ( "Got None mimetext for email from %r and to %r" % ( email . fr_addr , email . to_addr ) ) if test : print mimetext . as_string ( ) else : session . sendmail ( email . fr_addr , email . to_addr , mimetext . as_string ( ) ) email . set_sent ( rejected = False ) except ( smtplib . SMTPRecipientsRefused , smtplib . SMTPSenderRefused , UnicodeDecodeError , AttributeError ) : print "Handled error sending mail (traceback to follow)" traceback . print_exc ( file = sys . stdout ) email . set_sent ( rejected = True ) try : for email in Email . get_unsent ( now ) : clear = True should_queue = email . should_queue ( ) if email . kind == Email . Kind . SHARE : if should_queue : email . body = Share ( username = email . from_name ( ) , msg_hash = email . msg_hash , link = email . thing , body = email . body ) . render ( style = "email" ) else : email . set_sent ( rejected = True ) continue elif email . kind == Email . Kind . OPTOUT : email . body = Mail_Opt ( msg_hash = email . msg_hash , leave = True ) . render ( style = "email" ) elif email . kind == Email . Kind . OPTIN : email . body = Mail_Opt ( msg_hash = email . msg_hash , leave = False ) . render ( style = "email" ) elif not email . body : email . set_sent ( rejected = True ) continue sendmail ( email ) finally : if not test : session . quit ( ) if clear : Email . handler . clear_queue ( now ) def opt_out ( msg_hash ) : email , added = Email . handler . opt_out ( msg_hash ) if email and added : _system_email ( email , "" , Email . Kind . OPTOUT ) return email , added def opt_in ( msg_hash ) : email , removed = Email . handler . opt_in ( msg_hash ) if email and removed : _system_email ( email , "" , Email . Kind . OPTIN ) return email , removed def _promo_email ( thing , kind , body = "" , ** kw ) : from r2 . lib . pages import Promo_Email a = Account . _byID ( thing . author_id , True ) body = Promo_Email ( link = thing , kind = kind , body = body , ** kw ) . render ( style = "email" ) return _system_email ( a . email , body , kind , thing = thing , reply_to = "selfservicesupport@reddit.com" ) def new_promo ( thing ) : return _promo_email ( thing , Email . Kind . NEW_PROMO ) def promo_bid ( thing , bid , start_date ) : return _promo_email ( thing , Email . Kind . BID_PROMO , bid = bid , start_date = start_date ) def accept_promo ( thing ) : return _promo_email ( thing , Email . Kind . ACCEPT_PROMO ) def reject_promo ( thing , reason = "" ) : return _promo_email ( thing , Email . Kind . REJECT_PROMO , reason ) def queue_promo ( thing , bid , trans_id ) : return _promo_email ( thing , Email . Kind . QUEUED_PROMO , bid = bid , trans_id = trans_id ) def live_promo ( thing ) : return _promo_email ( thing , Email . Kind . LIVE_PROMO ) def finished_promo ( thing ) : return _promo_email ( thing , Email . Kind . FINISHED_PROMO ) def send_html_email ( to_addr , from_addr , subject , html , subtype = "html" ) : from r2 . lib . filters import _force_utf8 msg = MIMEText ( _force_utf8 ( html ) , subtype ) msg [ "Subject" ] = subject msg [ "From" ] = from_addr msg [ "To" ] = to_addr session = smtplib . SMTP ( g . smtp_server ) session . sendmail ( from_addr , to_addr , msg . as_string ( ) ) session . quit ( )

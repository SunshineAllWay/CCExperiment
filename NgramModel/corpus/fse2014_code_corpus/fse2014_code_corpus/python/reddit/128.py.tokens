from r2 . models import * from r2 . lib . memoize import memoize from r2 . lib . normalized_hot import get_hot from r2 . lib import count from r2 . lib . utils import UniqueIterator , timeago from pylons import c import random from time import time organic_lifetime = 5 * 60 organic_length = 30 organic_max_length = 50 def keep_fresh_links ( item ) : return ( c . user_is_loggedin and c . user . _id == item . author_id ) or item . fresh @ memoize ( 'cached_organic_links' , time = organic_lifetime ) def cached_organic_links ( * sr_ids ) : sr_count = count . get_link_counts ( ) link_names = filter ( lambda n : sr_count [ n ] [ 1 ] in sr_ids , sr_count . keys ( ) ) link_names . sort ( key = lambda n : sr_count [ n ] [ 0 ] ) if not link_names and g . debug : q = All . get_links ( 'new' , 'all' ) q . _limit = 100 link_names = [ x . _fullname for x in q if x . promoted is None ] g . log . debug ( 'Used inorganic links' ) if random . choice ( ( True , False ) ) and sr_ids : sr = Subreddit . _byID ( random . choice ( sr_ids ) ) fnames = get_hot ( [ sr ] ) if fnames : if len ( fnames ) == 1 : new_item = fnames [ 0 ] else : new_item = random . choice ( fnames [ 1 : 4 ] ) link_names . insert ( 0 , new_item ) return link_names def organic_links ( user ) : from r2 . controllers . reddit_base import organic_pos sr_ids = Subreddit . user_subreddits ( user ) sr_ids . sort ( ) user_id = None if isinstance ( user , FakeAccount ) else user sr_ids = Subreddit . user_subreddits ( user , True ) sr_ids . sort ( ) return cached_organic_links ( * sr_ids ) [ : organic_max_length ] def update_pos ( pos ) : from r2 . controllers import reddit_base reddit_base . set_organic_pos ( pos )

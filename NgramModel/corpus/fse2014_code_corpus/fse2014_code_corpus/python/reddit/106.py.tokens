import json import os import pylons from pylons . i18n . translation import translation , LanguageError , NullTranslations try : import reddit_i18n except ImportError : import r2 . i18n as reddit_i18n I18N_PATH = os . path . dirname ( reddit_i18n . __file__ ) _domain = 'r2' def _get_translator ( lang , graceful_fail = False , ** kwargs ) : from pylons import config as conf if not isinstance ( lang , list ) : lang = [ lang ] try : translator = translation ( conf [ 'pylons.package' ] , I18N_PATH , languages = lang , ** kwargs ) except IOError , ioe : if graceful_fail : translator = NullTranslations ( ) else : raise LanguageError ( 'IOError: %s' % ioe ) translator . pylons_lang = lang return translator def set_lang ( lang , graceful_fail = False , fallback_lang = None , ** kwargs ) : registry = pylons . request . environ [ 'paste.registry' ] if not lang : registry . replace ( pylons . translator , NullTranslations ( ) ) else : translator = _get_translator ( lang , graceful_fail = graceful_fail , ** kwargs ) base_lang , is_dialect , dialect = lang . partition ( "-" ) if is_dialect : try : base_translator = _get_translator ( base_lang ) except LanguageError : pass else : translator . add_fallback ( base_translator ) if fallback_lang : fallback_translator = _get_translator ( fallback_lang , graceful_fail = True ) translator . add_fallback ( fallback_translator ) registry . replace ( pylons . translator , translator ) def load_data ( lang_path , domain = _domain , extension = 'data' ) : filename = os . path . join ( lang_path , domain + '.' + extension ) with open ( filename ) as datafile : data = json . load ( datafile ) return data def iter_langs ( base_path = I18N_PATH ) : for lang in os . listdir ( base_path ) : full_path = os . path . join ( base_path , lang , 'LC_MESSAGES' ) if os . path . isdir ( full_path ) : yield lang , full_path def get_active_langs ( path = I18N_PATH , default_lang = 'en' ) : trans = [ ] trans_name = { } for lang , lang_path in iter_langs ( path ) : data = load_data ( lang_path ) name = [ data [ 'name' ] , '' ] if data [ '_is_enabled' ] and lang != default_lang : trans . append ( lang ) completion = float ( data [ 'num_completed' ] ) / float ( data [ 'num_total' ] ) if completion < .5 : name [ 1 ] = ' (*)' trans_name [ lang ] = name trans . sort ( ) trans . insert ( 0 , default_lang ) if default_lang not in trans_name : trans_name [ default_lang ] = default_lang return trans , trans_name

from r2 . models import * from filters import unsafe , websafe , _force_unicode from r2 . lib . utils import vote_hash , UrlParser , timesince , is_subdomain from r2 . lib . media import s3_direct_url from mako . filters import url_escape import simplejson import os . path from copy import copy import random import urlparse from pylons import g , c from pylons . i18n import _ , ungettext from paste . util . mimeparse import desired_matches def is_encoding_acceptable ( encoding_to_check ) : header = request . headers . get ( 'Accept-Encoding' , '' ) return 'gzip' in desired_matches ( [ 'gzip' ] , header ) def static ( path , allow_gzip = True ) : dirname , filename = os . path . split ( path ) extension = os . path . splitext ( filename ) [ 1 ] is_text = extension in ( '.js' , '.css' ) can_gzip = is_text and is_encoding_acceptable ( 'gzip' ) should_gzip = allow_gzip and can_gzip path_components = [ ] actual_filename = None if not c . secure and g . static_domain : scheme = 'http' domain = g . static_domain query = None suffix = '.gzip' if should_gzip and g . static_pre_gzipped else '' elif c . secure and g . static_secure_domain : scheme = 'https' domain = g . static_secure_domain query = None suffix = '.gzip' if should_gzip and g . static_secure_pre_gzipped else '' else : path_components . append ( c . site . static_path ) query = None if g . uncompressedJS : query = 'v=' + str ( random . randint ( 1 , 1000000 ) ) if not dirname and is_text : path_components . append ( extension [ 1 : ] ) actual_filename = filename scheme = None domain = None suffix = '' path_components . append ( dirname ) if not actual_filename : actual_filename = g . static_names . get ( filename , filename ) path_components . append ( actual_filename + suffix ) actual_path = os . path . join ( * path_components ) return urlparse . urlunsplit ( ( scheme , domain , actual_path , query , None ) ) def s3_https_if_secure ( url ) : if not c . secure : return url replace = "https://" if not url . startswith ( "http://%s" % s3_direct_url ) : replace = "https://%s/" % s3_direct_url return url . replace ( "http://" , replace ) def js_config ( ) : config = { : c . user_is_loggedin and c . user . name , : c . site . name if not c . default_sr else "" , : bool ( c . cname and not c . authorized_cname ) , : _force_unicode ( request . referer ) or "" , : c . modhash or False , : c . render_style , : get_domain ( cname = c . frameless_cname , subreddit = False , no_www = True ) , : get_domain ( cname = c . authorized_cname , subreddit = False ) , : c . extension , : is_subdomain ( request . host , g . domain ) and g . https_endpoint , : g . debug , : { } , : { } , : { : _ ( "fetching title..." ) , : _ ( "submitting..." ) , : _ ( "loading..." ) } , : isinstance ( c . site , FakeSubreddit ) , : g . tracking_domain , : g . adtracker_url , : g . clicktracker_url , : static ( '' ) , } return config def generateurl ( context , path , ** kw ) : if kw : return path + '?' + '&' . join ( [ "%s=%s" % ( k , url_escape ( v ) ) for k , v in kw . iteritems ( ) if v ] ) return path def class_dict ( ) : t_cls = [ Link , Comment , Message , Subreddit ] l_cls = [ Listing , OrganicListing ] classes = [ ( '%s: %s' ) % ( 't' + str ( cl . _type_id ) , cl . __name__ ) for cl in t_cls ] + [ ( '%s: %s' ) % ( cl . __name__ , cl . _js_cls ) for cl in l_cls ] res = ', ' . join ( classes ) return unsafe ( '{ %s }' % res ) def calc_time_period ( comment_time ) : previous_visits = c . previous_visits if not previous_visits : return "" rv = "" for i , visit in enumerate ( previous_visits ) : if comment_time > visit : rv = "comment-period-%d" % i return rv def replace_render ( listing , item , render_func ) : def _replace_render ( style = None , display = True ) : style = style or c . render_style or 'html' replacements = { } child_txt = ( hasattr ( item , "child" ) and item . child ) and item . child . render ( style = style ) or "" replacements [ "childlisting" ] = child_txt if listing : if hasattr ( listing , "show_nums" ) : if listing . show_nums : num_str = str ( item . num ) if hasattr ( listing , "num_margin" ) : num_margin = str ( listing . num_margin ) else : num_margin = "%.2fex" % ( len ( str ( listing . max_num ) ) * 1.1 ) else : num_str = '' num_margin = "0px;display:none" replacements [ "numcolmargin" ] = num_margin replacements [ "num" ] = num_str if hasattr ( listing , "max_score" ) : mid_margin = len ( str ( listing . max_score ) ) if hasattr ( listing , "mid_margin" ) : mid_margin = str ( listing . mid_margin ) elif mid_margin == 1 : mid_margin = "15px" else : mid_margin = "%dex" % ( mid_margin + 1 ) replacements [ "midcolmargin" ] = mid_margin if c . user_is_loggedin : replacements [ 'votehash' ] = vote_hash ( c . user , item , listing . vote_hash_type ) if hasattr ( item , "num_comments" ) : if not item . num_comments : com_label = _ ( "comment {verb}" ) com_cls = 'comments empty' else : com_label = ungettext ( "comment" , "comments" , item . num_comments ) com_label = strings . number_label % dict ( num = item . num_comments , thing = com_label ) com_cls = 'comments' if style == "compact" : com_label = unicode ( item . num_comments ) replacements [ 'numcomments' ] = com_label replacements [ 'commentcls' ] = com_cls replacements [ 'display' ] = "" if display else "style='display:none'" if hasattr ( item , "render_score" ) : ( replacements [ 'scoredislikes' ] , replacements [ 'scoreunvoted' ] , replacements [ 'scorelikes' ] ) = item . render_score if hasattr ( item , "_date" ) : if hasattr ( item , "promoted" ) and item . promoted is not None : from r2 . lib import promote replacements [ 'timesince' ] = timesince ( item . _date - promote . timezone_offset ) else : replacements [ 'timesince' ] = timesince ( item . _date ) replacements [ 'time_period' ] = calc_time_period ( item . _date ) replacements [ 'previous_visits_hex' ] = c . previous_visits_hex renderer = render_func or item . render res = renderer ( style = style , ** replacements ) if isinstance ( res , ( str , unicode ) ) : rv = unsafe ( res ) if g . debug : for leftover in re . findall ( '<\$>(.+?)(?:<|$)' , rv ) : print "replace_render didn't replace %s" % leftover return rv return res return _replace_render def get_domain ( cname = False , subreddit = True , no_www = False ) : domain = g . domain domain_prefix = c . domain_prefix site = c . site ccname = c . cname if not no_www and domain_prefix : domain = domain_prefix + "." + domain if cname and ccname and site . domain : domain = site . domain if hasattr ( request , "port" ) and request . port : domain += ":" + str ( request . port ) if ( not ccname or not cname ) and subreddit : domain += site . path . rstrip ( '/' ) return domain def dockletStr ( context , type , browser ) : domain = get_domain ( ) site_domain = get_domain ( True ) if type == "serendipity!" : return "http://" + site_domain + "/random" elif type == "submit" : return ( "javascript:location.href='http://" + site_domain + ) elif type == "reddit toolbar" : return ( "javascript:%20var%20h%20=%20window.location.href;%20h%20=%20'http://" + site_domain + "/s/'%20+%20escape(h);%20window.location%20=%20h;" ) else : return ( ( "javascript:function b(){var u=encodeURIComponent(location.href);" ) % dict ( position = "absolute" if browser == "ie" else "fixed" , domain = domain , site_domain = site_domain , type = type , modhash = c . modhash if c . user else '' ) ) def add_sr ( path , sr_path = True , nocname = False , force_hostname = False , retain_extension = True ) : if path . startswith ( '#' ) or path . startswith ( 'javascript:' ) : return path u = UrlParser ( path ) if sr_path and ( nocname or not c . cname ) : u . path_add_subreddit ( c . site ) if not u . hostname or force_hostname : if c . secure : u . hostname = request . host else : u . hostname = get_domain ( cname = ( c . cname and not nocname ) , subreddit = False ) if c . secure : u . scheme = "https" if retain_extension : if c . render_style == 'mobile' : u . set_extension ( 'mobile' ) elif c . render_style == 'compact' : u . set_extension ( 'compact' ) return u . unparse ( ) def join_urls ( * urls ) : if not urls : return url = urls [ 0 ] for u in urls [ 1 : ] : if not url . endswith ( '/' ) : url += '/' while u . startswith ( '/' ) : u = utils . lstrips ( u , '/' ) url += u return url def style_line ( button_width = None , bgcolor = "" , bordercolor = "" ) : style_line = '' bordercolor = c . bordercolor or bordercolor bgcolor = c . bgcolor or bgcolor if bgcolor : style_line += "background-color: #%s;" % bgcolor if bordercolor : style_line += "border: 1px solid #%s;" % bordercolor if button_width : style_line += "width: %spx;" % button_width return style_line def choose_width ( link , width ) : if width : return width - 5 else : if hasattr ( link , "_ups" ) : return 100 + ( 10 * ( len ( str ( link . _ups - link . _downs ) ) ) ) else : return 110 def panel_size ( state ) : return '400px, 100%' if state == 'expanded' else '0px, 100%x' def add_attr ( attrs , kind , label = None , link = None , cssclass = None , symbol = None ) : from r2 . lib . template_helpers import static img = None symbol = symbol or kind if kind == 'F' : priority = 1 cssclass = 'friend' if not label : label = _ ( 'friend' ) if not link : link = '/prefs/friends' elif kind == 'S' : priority = 2 cssclass = 'submitter' if not label : label = _ ( 'submitter' ) if not link : raise ValueError ( "Need a link" ) elif kind == 'M' : priority = 3 cssclass = 'moderator' if not label : raise ValueError ( "Need a label" ) if not link : raise ValueError ( "Need a link" ) elif kind == 'A' : priority = 4 cssclass = 'admin' if not label : label = _ ( 'reddit admin, speaking officially' ) if not link : link = '/help/faq#Whorunsreddit' elif kind in ( 'X' , '@' ) : priority = 5 cssclass = 'gray' if not label : raise ValueError ( "Need a label" ) elif kind == 'V' : priority = 6 cssclass = 'green' if not label : raise ValueError ( "Need a label" ) elif kind == 'B' : priority = 7 cssclass = 'wrong' if not label : raise ValueError ( "Need a label" ) elif kind == 'special' : priority = 98 elif kind . startswith ( 'trophy:' ) : img = ( kind [ 7 : ] , '!' , 11 , 8 ) priority = 99 cssclass = 'recent-trophywinner' if not label : raise ValueError ( "Need a label" ) if not link : raise ValueError ( "Need a link" ) else : raise ValueError ( "Got weird kind [%s]" % kind ) attrs . append ( ( priority , symbol , cssclass , label , link , img ) )

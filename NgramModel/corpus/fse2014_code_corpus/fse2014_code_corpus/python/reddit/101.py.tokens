from Queue import Queue from threading import local , Thread from datetime import datetime import os import sys import time import errno import socket import itertools import cPickle as pickle from amqplib import client_0_8 as amqp from pylons import g amqp_host = g . amqp_host amqp_user = g . amqp_user amqp_pass = g . amqp_pass amqp_exchange = 'reddit_exchange' log = g . log amqp_virtual_host = g . amqp_virtual_host amqp_logging = g . amqp_logging reset_caches = g . reset_caches class Worker : def __init__ ( self ) : self . q = Queue ( ) self . t = Thread ( target = self . _handle ) self . t . setDaemon ( True ) self . t . start ( ) def _handle ( self ) : while True : reset_caches ( ) fn = self . q . get ( ) try : fn ( ) self . q . task_done ( ) except : import traceback print traceback . format_exc ( ) def do ( self , fn , * a , ** kw ) : fn1 = lambda : fn ( * a , ** kw ) self . q . put ( fn1 ) def join ( self ) : self . q . join ( ) worker = Worker ( ) class ConnectionManager ( local ) : def __init__ ( self ) : self . connection = None self . channel = None self . have_init = False def get_connection ( self ) : while not self . connection : try : self . connection = amqp . Connection ( host = amqp_host , userid = amqp_user , password = amqp_pass , virtual_host = amqp_virtual_host , insist = False ) except ( socket . error , IOError ) , e : print 'error connecting to amqp %s @ %s (%r)' % ( amqp_user , amqp_host , e ) time . sleep ( 1 ) if not self . have_init : self . init_queue ( ) self . have_init = True return self . connection def get_channel ( self , reconnect = False ) : if self . connection and self . connection . channels is None : log . error ( "Error: amqp.py, connection object with no available channels. Reconnecting..." ) self . connection = None if not self . connection or reconnect : self . connection = None self . channel = None self . get_connection ( ) if not self . channel : self . channel = self . connection . channel ( ) return self . channel def init_queue ( self ) : from r2 . lib . queues import RedditQueueMap chan = self . get_channel ( ) RedditQueueMap ( amqp_exchange , chan ) . init ( ) connection_manager = ConnectionManager ( ) DELIVERY_TRANSIENT = 1 DELIVERY_DURABLE = 2 def _add_item ( routing_key , body , message_id = None , delivery_mode = DELIVERY_DURABLE ) : if not amqp_host : log . error ( "Ignoring amqp message %r to %r" % ( body , routing_key ) ) return chan = connection_manager . get_channel ( ) msg = amqp . Message ( body , timestamp = datetime . now ( ) , delivery_mode = delivery_mode ) if message_id : msg . properties [ 'message_id' ] = message_id try : chan . basic_publish ( msg , exchange = amqp_exchange , routing_key = routing_key ) except Exception as e : if e . errno == errno . EPIPE : connection_manager . get_channel ( True ) add_item ( routing_key , body , message_id ) else : raise def add_item ( routing_key , body , message_id = None , delivery_mode = DELIVERY_DURABLE ) : if amqp_host and amqp_logging : log . debug ( "amqp: adding item %r to %r" % ( body , routing_key ) ) worker . do ( _add_item , routing_key , body , message_id = message_id , delivery_mode = delivery_mode ) def add_kw ( routing_key , ** kw ) : add_item ( routing_key , pickle . dumps ( kw ) ) def consume_items ( queue , callback , verbose = True ) : from pylons import c chan = connection_manager . get_channel ( ) def _callback ( msg ) : if verbose : count_str = '' if 'message_count' in msg . delivery_info : count_str = '(%d remaining)' % msg . delivery_info [ 'message_count' ] print "%s: 1 item %s" % ( queue , count_str ) g . reset_caches ( ) c . use_write_db = { } ret = callback ( msg ) msg . channel . basic_ack ( msg . delivery_tag ) sys . stdout . flush ( ) return ret chan . basic_consume ( queue = queue , callback = _callback ) try : while chan . callbacks : try : chan . wait ( ) except KeyboardInterrupt : break finally : worker . join ( ) if chan . is_open : chan . close ( ) def handle_items ( queue , callback , ack = True , limit = 1 , drain = False , verbose = True , sleep_time = 1 ) : from pylons import c chan = connection_manager . get_channel ( ) countdown = None while True : if countdown == 0 : break msg = chan . basic_get ( queue ) if not msg and drain : return elif not msg : time . sleep ( sleep_time ) continue if countdown is None and drain and 'message_count' in msg . delivery_info : countdown = 1 + msg . delivery_info [ 'message_count' ] g . reset_caches ( ) c . use_write_db = { } items = [ ] while msg and countdown != 0 : items . append ( msg ) if countdown is not None : countdown -= 1 if len ( items ) >= limit : break msg = chan . basic_get ( queue ) try : count_str = '' if 'message_count' in items [ - 1 ] . delivery_info : count_str = '(%d remaining)' % items [ - 1 ] . delivery_info [ 'message_count' ] if verbose : print "%s: %d items %s" % ( queue , len ( items ) , count_str ) callback ( items , chan ) if ack : chan . basic_ack ( 0 , multiple = True ) sys . stdout . flush ( ) except : for item in items : chan . basic_reject ( item . delivery_tag , requeue = True ) raise def empty_queue ( queue ) : chan = connection_manager . get_channel ( ) chan . queue_purge ( queue ) def black_hole ( queue ) : chan = connection_manager . get_channel ( ) def _ignore ( msg ) : print 'Ignoring msg: %r' % msg . body consume_items ( queue , _ignore ) def dedup_queue ( queue , rk = None , limit = None , delivery_mode = DELIVERY_DURABLE ) : chan = connection_manager . get_channel ( ) if rk is None : rk = queue bodies = set ( ) while True : msg = chan . basic_get ( queue ) if msg is None : break if msg . body not in bodies : bodies . add ( msg . body ) if limit is None : limit = msg . delivery_info . get ( 'message_count' ) if limit is None : default_max = 100 * 1000 print ( "Message count was unavailable, defaulting to %d" % ( default_max , ) ) limit = default_max else : print "Grabbing %d messages" % ( limit , ) else : limit -= 1 if limit <= 0 : break elif limit % 1000 == 0 : print limit print "Grabbed %d unique bodies" % ( len ( bodies ) , ) if bodies : for body in bodies : _add_item ( rk , body , delivery_mode = delivery_mode ) worker . join ( ) chan . basic_ack ( 0 , multiple = True ) def _test_setup ( test_q = 'test_q' ) : from r2 . lib . queues import RedditQueueMap chan = connection_manager . get_channel ( ) rqm = RedditQueueMap ( amqp_exchange , chan ) rqm . _q ( test_q , durable = False , auto_delete = True , self_refer = True ) return chan def test_consume ( test_q = 'test_q' ) : chan = _test_setup ( ) def _print ( msg ) : print msg . body consume_items ( test_q , _print ) def test_produce ( test_q = 'test_q' , msg_body = 'hello, world!' ) : _test_setup ( ) add_item ( test_q , msg_body ) worker . join ( )

import logging , socket , types , os , string , cPickle , struct , time , re from stat import ST_DEV , ST_INO try : import codecs except ImportError : codecs = None DEFAULT_TCP_LOGGING_PORT = 9020 DEFAULT_UDP_LOGGING_PORT = 9021 DEFAULT_HTTP_LOGGING_PORT = 9022 DEFAULT_SOAP_LOGGING_PORT = 9023 SYSLOG_UDP_PORT = 514 _MIDNIGHT = 24 * 60 * 60 class BaseRotatingHandler ( logging . FileHandler ) : def __init__ ( self , filename , mode , encoding = None , delay = 0 ) : if codecs is None : encoding = None logging . FileHandler . __init__ ( self , filename , mode , encoding , delay ) self . mode = mode self . encoding = encoding def emit ( self , record ) : try : if self . shouldRollover ( record ) : self . doRollover ( ) logging . FileHandler . emit ( self , record ) except ( KeyboardInterrupt , SystemExit ) : raise except : self . handleError ( record ) class RotatingFileHandler ( BaseRotatingHandler ) : def __init__ ( self , filename , mode = 'a' , maxBytes = 0 , backupCount = 0 , encoding = None , delay = 0 ) : if maxBytes > 0 : mode = 'a' BaseRotatingHandler . __init__ ( self , filename , mode , encoding , delay ) self . maxBytes = maxBytes self . backupCount = backupCount def doRollover ( self ) : self . stream . close ( ) if self . backupCount > 0 : for i in range ( self . backupCount - 1 , 0 , - 1 ) : sfn = "%s.%d" % ( self . baseFilename , i ) dfn = "%s.%d" % ( self . baseFilename , i + 1 ) if os . path . exists ( sfn ) : if os . path . exists ( dfn ) : os . remove ( dfn ) os . rename ( sfn , dfn ) dfn = self . baseFilename + ".1" if os . path . exists ( dfn ) : os . remove ( dfn ) os . rename ( self . baseFilename , dfn ) self . mode = 'w' self . stream = self . _open ( ) def shouldRollover ( self , record ) : if self . maxBytes > 0 : msg = "%s\n" % self . format ( record ) self . stream . seek ( 0 , 2 ) if self . stream . tell ( ) + len ( msg ) >= self . maxBytes : return 1 return 0 class TimedRotatingFileHandler ( BaseRotatingHandler ) : def __init__ ( self , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = 0 , utc = 0 ) : BaseRotatingHandler . __init__ ( self , filename , 'a' , encoding , delay ) self . when = string . upper ( when ) self . backupCount = backupCount self . utc = utc currentTime = int ( time . time ( ) ) if self . when == 'S' : self . interval = 1 self . suffix = "%Y-%m-%d_%H-%M-%S" self . extMatch = r"^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}$" elif self . when == 'M' : self . interval = 60 self . suffix = "%Y-%m-%d_%H-%M" self . extMatch = r"^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}$" elif self . when == 'H' : self . interval = 60 * 60 self . suffix = "%Y-%m-%d_%H" self . extMatch = r"^\d{4}-\d{2}-\d{2}_\d{2}$" elif self . when == 'D' or self . when == 'MIDNIGHT' : self . interval = 60 * 60 * 24 self . suffix = "%Y-%m-%d" self . extMatch = r"^\d{4}-\d{2}-\d{2}$" elif self . when . startswith ( 'W' ) : self . interval = 60 * 60 * 24 * 7 if len ( self . when ) != 2 : raise ValueError ( "You must specify a day for weekly rollover from 0 to 6 (0 is Monday): %s" % self . when ) if self . when [ 1 ] < '0' or self . when [ 1 ] > '6' : raise ValueError ( "Invalid day specified for weekly rollover: %s" % self . when ) self . dayOfWeek = int ( self . when [ 1 ] ) self . suffix = "%Y-%m-%d" self . extMatch = r"^\d{4}-\d{2}-\d{2}$" else : raise ValueError ( "Invalid rollover interval specified: %s" % self . when ) self . extMatch = re . compile ( self . extMatch ) self . interval = self . interval * interval self . rolloverAt = currentTime + self . interval if self . when == 'MIDNIGHT' or self . when . startswith ( 'W' ) : if utc : t = time . gmtime ( currentTime ) else : t = time . localtime ( currentTime ) currentHour = t [ 3 ] currentMinute = t [ 4 ] currentSecond = t [ 5 ] r = _MIDNIGHT - ( ( currentHour * 60 + currentMinute ) * 60 + currentSecond ) self . rolloverAt = currentTime + r if when . startswith ( 'W' ) : day = t [ 6 ] if day != self . dayOfWeek : if day < self . dayOfWeek : daysToWait = self . dayOfWeek - day else : daysToWait = 6 - day + self . dayOfWeek + 1 newRolloverAt = self . rolloverAt + ( daysToWait * ( 60 * 60 * 24 ) ) if not utc : dstNow = t [ - 1 ] dstAtRollover = time . localtime ( newRolloverAt ) [ - 1 ] if dstNow != dstAtRollover : if not dstNow : newRolloverAt = newRolloverAt - 3600 else : newRolloverAt = newRolloverAt + 3600 self . rolloverAt = newRolloverAt def shouldRollover ( self , record ) : t = int ( time . time ( ) ) if t >= self . rolloverAt : return 1 return 0 def getFilesToDelete ( self ) : dirName , baseName = os . path . split ( self . baseFilename ) fileNames = os . listdir ( dirName ) result = [ ] prefix = baseName + "." plen = len ( prefix ) for fileName in fileNames : if fileName [ : plen ] == prefix : suffix = fileName [ plen : ] if self . extMatch . match ( suffix ) : result . append ( os . path . join ( dirName , fileName ) ) result . sort ( ) if len ( result ) < self . backupCount : result = [ ] else : result = result [ : len ( result ) - self . backupCount ] return result def doRollover ( self ) : self . stream . close ( ) t = self . rolloverAt - self . interval if self . utc : timeTuple = time . gmtime ( t ) else : timeTuple = time . localtime ( t ) dfn = self . baseFilename + "." + time . strftime ( self . suffix , timeTuple ) if os . path . exists ( dfn ) : os . remove ( dfn ) os . rename ( self . baseFilename , dfn ) if self . backupCount > 0 : for s in self . getFilesToDelete ( ) : os . remove ( s ) self . mode = 'w' self . stream = self . _open ( ) newRolloverAt = self . rolloverAt + self . interval currentTime = int ( time . time ( ) ) while newRolloverAt <= currentTime : newRolloverAt = newRolloverAt + self . interval if ( self . when == 'MIDNIGHT' or self . when . startswith ( 'W' ) ) and not self . utc : dstNow = time . localtime ( currentTime ) [ - 1 ] dstAtRollover = time . localtime ( newRolloverAt ) [ - 1 ] if dstNow != dstAtRollover : if not dstNow : newRolloverAt = newRolloverAt - 3600 else : newRolloverAt = newRolloverAt + 3600 self . rolloverAt = newRolloverAt class WatchedFileHandler ( logging . FileHandler ) : def __init__ ( self , filename , mode = 'a' , encoding = None , delay = 0 ) : logging . FileHandler . __init__ ( self , filename , mode , encoding , delay ) if not os . path . exists ( self . baseFilename ) : self . dev , self . ino = - 1 , - 1 else : stat = os . stat ( self . baseFilename ) self . dev , self . ino = stat [ ST_DEV ] , stat [ ST_INO ] def emit ( self , record ) : if not os . path . exists ( self . baseFilename ) : stat = None changed = 1 else : stat = os . stat ( self . baseFilename ) changed = ( stat [ ST_DEV ] != self . dev ) or ( stat [ ST_INO ] != self . ino ) if changed and self . stream is not None : self . stream . flush ( ) self . stream . close ( ) self . stream = self . _open ( ) if stat is None : stat = os . stat ( self . baseFilename ) self . dev , self . ino = stat [ ST_DEV ] , stat [ ST_INO ] logging . FileHandler . emit ( self , record ) class SocketHandler ( logging . Handler ) : def __init__ ( self , host , port ) : logging . Handler . __init__ ( self ) self . host = host self . port = port self . sock = None self . closeOnError = 0 self . retryTime = None self . retryStart = 1.0 self . retryMax = 30.0 self . retryFactor = 2.0 def makeSocket ( self , timeout = 1 ) : s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) if hasattr ( s , 'settimeout' ) : s . settimeout ( timeout ) s . connect ( ( self . host , self . port ) ) return s def createSocket ( self ) : now = time . time ( ) if self . retryTime is None : attempt = 1 else : attempt = ( now >= self . retryTime ) if attempt : try : self . sock = self . makeSocket ( ) self . retryTime = None except socket . error : if self . retryTime is None : self . retryPeriod = self . retryStart else : self . retryPeriod = self . retryPeriod * self . retryFactor if self . retryPeriod > self . retryMax : self . retryPeriod = self . retryMax self . retryTime = now + self . retryPeriod def send ( self , s ) : if self . sock is None : self . createSocket ( ) if self . sock : try : if hasattr ( self . sock , "sendall" ) : self . sock . sendall ( s ) else : sentsofar = 0 left = len ( s ) while left > 0 : sent = self . sock . send ( s [ sentsofar : ] ) sentsofar = sentsofar + sent left = left - sent except socket . error : self . sock . close ( ) self . sock = None def makePickle ( self , record ) : ei = record . exc_info if ei : dummy = self . format ( record ) record . exc_info = None s = cPickle . dumps ( record . __dict__ , 1 ) if ei : record . exc_info = ei slen = struct . pack ( ">L" , len ( s ) ) return slen + s def handleError ( self , record ) : if self . closeOnError and self . sock : self . sock . close ( ) self . sock = None else : logging . Handler . handleError ( self , record ) def emit ( self , record ) : try : s = self . makePickle ( record ) self . send ( s ) except ( KeyboardInterrupt , SystemExit ) : raise except : self . handleError ( record ) def close ( self ) : if self . sock : self . sock . close ( ) self . sock = None logging . Handler . close ( self ) class DatagramHandler ( SocketHandler ) : def __init__ ( self , host , port ) : SocketHandler . __init__ ( self , host , port ) self . closeOnError = 0 def makeSocket ( self ) : s = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) return s def send ( self , s ) : if self . sock is None : self . createSocket ( ) self . sock . sendto ( s , ( self . host , self . port ) ) class SysLogHandler ( logging . Handler ) : LOG_EMERG = 0 LOG_ALERT = 1 LOG_CRIT = 2 LOG_ERR = 3 LOG_WARNING = 4 LOG_NOTICE = 5 LOG_INFO = 6 LOG_DEBUG = 7 LOG_KERN = 0 LOG_USER = 1 LOG_MAIL = 2 LOG_DAEMON = 3 LOG_AUTH = 4 LOG_SYSLOG = 5 LOG_LPR = 6 LOG_NEWS = 7 LOG_UUCP = 8 LOG_CRON = 9 LOG_AUTHPRIV = 10 LOG_LOCAL0 = 16 LOG_LOCAL1 = 17 LOG_LOCAL2 = 18 LOG_LOCAL3 = 19 LOG_LOCAL4 = 20 LOG_LOCAL5 = 21 LOG_LOCAL6 = 22 LOG_LOCAL7 = 23 priority_names = { : LOG_ALERT , : LOG_CRIT , : LOG_CRIT , : LOG_DEBUG , : LOG_EMERG , : LOG_ERR , : LOG_ERR , : LOG_INFO , : LOG_NOTICE , : LOG_EMERG , : LOG_WARNING , : LOG_WARNING , } facility_names = { : LOG_AUTH , : LOG_AUTHPRIV , : LOG_CRON , : LOG_DAEMON , : LOG_KERN , : LOG_LPR , : LOG_MAIL , : LOG_NEWS , : LOG_AUTH , : LOG_SYSLOG , : LOG_USER , : LOG_UUCP , : LOG_LOCAL0 , : LOG_LOCAL1 , : LOG_LOCAL2 , : LOG_LOCAL3 , : LOG_LOCAL4 , : LOG_LOCAL5 , : LOG_LOCAL6 , : LOG_LOCAL7 , } priority_map = { : "debug" , : "info" , : "warning" , : "error" , : "critical" } def __init__ ( self , address = ( 'localhost' , SYSLOG_UDP_PORT ) , facility = LOG_USER ) : logging . Handler . __init__ ( self ) self . address = address self . facility = facility if type ( address ) == types . StringType : self . unixsocket = 1 self . _connect_unixsocket ( address ) else : self . unixsocket = 0 self . socket = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) self . formatter = None def _connect_unixsocket ( self , address ) : self . socket = socket . socket ( socket . AF_UNIX , socket . SOCK_DGRAM ) try : self . socket . connect ( address ) except socket . error : self . socket . close ( ) self . socket = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM ) self . socket . connect ( address ) log_format_string = '<%d>%s\000' def encodePriority ( self , facility , priority ) : if type ( facility ) == types . StringType : facility = self . facility_names [ facility ] if type ( priority ) == types . StringType : priority = self . priority_names [ priority ] return ( facility << 3 ) | priority def close ( self ) : if self . unixsocket : self . socket . close ( ) logging . Handler . close ( self ) def mapPriority ( self , levelName ) : return self . priority_map . get ( levelName , "warning" ) def emit ( self , record ) : msg = self . format ( record ) msg = self . log_format_string % ( self . encodePriority ( self . facility , self . mapPriority ( record . levelname ) ) , msg ) try : if self . unixsocket : try : self . socket . send ( msg ) except socket . error : self . _connect_unixsocket ( self . address ) self . socket . send ( msg ) else : self . socket . sendto ( msg , self . address ) except ( KeyboardInterrupt , SystemExit ) : raise except : self . handleError ( record ) class SMTPHandler ( logging . Handler ) : def __init__ ( self , mailhost , fromaddr , toaddrs , subject , credentials = None ) : logging . Handler . __init__ ( self ) if type ( mailhost ) == types . TupleType : self . mailhost , self . mailport = mailhost else : self . mailhost , self . mailport = mailhost , None if type ( credentials ) == types . TupleType : self . username , self . password = credentials else : self . username = None self . fromaddr = fromaddr if type ( toaddrs ) == types . StringType : toaddrs = [ toaddrs ] self . toaddrs = toaddrs self . subject = subject def getSubject ( self , record ) : return self . subject weekdayname = [ 'Mon' , 'Tue' , 'Wed' , 'Thu' , 'Fri' , 'Sat' , 'Sun' ] monthname = [ None , , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' ] def date_time ( self ) : year , month , day , hh , mm , ss , wd , y , z = time . gmtime ( time . time ( ) ) s = "%s, %02d %3s %4d %02d:%02d:%02d GMT" % ( self . weekdayname [ wd ] , day , self . monthname [ month ] , year , hh , mm , ss ) return s def emit ( self , record ) : try : import smtplib try : from email . utils import formatdate except ImportError : formatdate = self . date_time port = self . mailport if not port : port = smtplib . SMTP_PORT smtp = smtplib . SMTP ( self . mailhost , port ) msg = self . format ( record ) msg = "From: %s\r\nTo: %s\r\nSubject: %s\r\nDate: %s\r\n\r\n%s" % ( self . fromaddr , string . join ( self . toaddrs , "," ) , self . getSubject ( record ) , formatdate ( ) , msg ) if self . username : smtp . login ( self . username , self . password ) smtp . sendmail ( self . fromaddr , self . toaddrs , msg ) smtp . quit ( ) except ( KeyboardInterrupt , SystemExit ) : raise except : self . handleError ( record ) class NTEventLogHandler ( logging . Handler ) : def __init__ ( self , appname , dllname = None , logtype = "Application" ) : logging . Handler . __init__ ( self ) try : import win32evtlogutil , win32evtlog self . appname = appname self . _welu = win32evtlogutil if not dllname : dllname = os . path . split ( self . _welu . __file__ ) dllname = os . path . split ( dllname [ 0 ] ) dllname = os . path . join ( dllname [ 0 ] , r'win32service.pyd' ) self . dllname = dllname self . logtype = logtype self . _welu . AddSourceToRegistry ( appname , dllname , logtype ) self . deftype = win32evtlog . EVENTLOG_ERROR_TYPE self . typemap = { logging . DEBUG : win32evtlog . EVENTLOG_INFORMATION_TYPE , logging . INFO : win32evtlog . EVENTLOG_INFORMATION_TYPE , logging . WARNING : win32evtlog . EVENTLOG_WARNING_TYPE , logging . ERROR : win32evtlog . EVENTLOG_ERROR_TYPE , logging . CRITICAL : win32evtlog . EVENTLOG_ERROR_TYPE , } except ImportError : print "The Python Win32 extensions for NT (service, event " "logging) appear not to be available." self . _welu = None def getMessageID ( self , record ) : return 1 def getEventCategory ( self , record ) : return 0 def getEventType ( self , record ) : return self . typemap . get ( record . levelno , self . deftype ) def emit ( self , record ) : if self . _welu : try : id = self . getMessageID ( record ) cat = self . getEventCategory ( record ) type = self . getEventType ( record ) msg = self . format ( record ) self . _welu . ReportEvent ( self . appname , id , cat , type , [ msg ] ) except ( KeyboardInterrupt , SystemExit ) : raise except : self . handleError ( record ) def close ( self ) : logging . Handler . close ( self ) class HTTPHandler ( logging . Handler ) : def __init__ ( self , host , url , method = "GET" ) : logging . Handler . __init__ ( self ) method = string . upper ( method ) if method not in [ "GET" , "POST" ] : raise ValueError , "method must be GET or POST" self . host = host self . url = url self . method = method def mapLogRecord ( self , record ) : return record . __dict__ def emit ( self , record ) : try : import httplib , urllib host = self . host h = httplib . HTTP ( host ) url = self . url data = urllib . urlencode ( self . mapLogRecord ( record ) ) if self . method == "GET" : if ( string . find ( url , '?' ) >= 0 ) : sep = '&' else : sep = '?' url = url + "%c%s" % ( sep , data ) h . putrequest ( self . method , url ) i = string . find ( host , ":" ) if i >= 0 : host = host [ : i ] h . putheader ( "Host" , host ) if self . method == "POST" : h . putheader ( "Content-type" , ) h . putheader ( "Content-length" , str ( len ( data ) ) ) h . endheaders ( ) if self . method == "POST" : h . send ( data ) h . getreply ( ) except ( KeyboardInterrupt , SystemExit ) : raise except : self . handleError ( record ) class BufferingHandler ( logging . Handler ) : def __init__ ( self , capacity ) : logging . Handler . __init__ ( self ) self . capacity = capacity self . buffer = [ ] def shouldFlush ( self , record ) : return ( len ( self . buffer ) >= self . capacity ) def emit ( self , record ) : self . buffer . append ( record ) if self . shouldFlush ( record ) : self . flush ( ) def flush ( self ) : self . buffer = [ ] def close ( self ) : self . flush ( ) logging . Handler . close ( self ) class MemoryHandler ( BufferingHandler ) : def __init__ ( self , capacity , flushLevel = logging . ERROR , target = None ) : BufferingHandler . __init__ ( self , capacity ) self . flushLevel = flushLevel self . target = target def shouldFlush ( self , record ) : return ( len ( self . buffer ) >= self . capacity ) or ( record . levelno >= self . flushLevel ) def setTarget ( self , target ) : self . target = target def flush ( self ) : if self . target : for record in self . buffer : self . target . handle ( record ) self . buffer = [ ] def close ( self ) : self . flush ( ) self . target = None BufferingHandler . close ( self )

''' Performance Data Helper (PDH) Query Classes Wrapper classes for end-users and high-level access to the PDH query mechanisms. PDH is a win32-specific mechanism for accessing the performance data made available by the system. The Python for Windows PDH module does not implement the "Registry" interface, implementing the more straightforward Query-based mechanism. The basic idea of a PDH Query is an object which can query the system about the status of any number of "counters." The counters are paths to a particular piece of performance data. For instance, the path '\\Memory\\Available Bytes' describes just about exactly what it says it does, the amount of free memory on the default computer expressed in Bytes. These paths can be considerably more complex than this, but part of the point of this wrapper module is to hide that complexity from the end-user/programmer. EXAMPLE: A more complex Path '\\\\RAISTLIN\\PhysicalDisk(_Total)\\Avg. Disk Bytes/Read' Raistlin --> Computer Name PhysicalDisk --> Object Name _Total --> The particular Instance (in this case, all instances, i.e. all drives) Avg. Disk Bytes/Read --> The piece of data being monitored. EXAMPLE: Collecting Data with a Query As an example, the following code implements a logger which allows the user to choose what counters they would like to log, and logs those counters for 30 seconds, at two-second intervals. query = Query() query.addcounterbybrowsing() query.collectdatafor(30,2) The data is now stored in a list of lists as: query.curresults The counters(paths) which were used to collect the data are: query.curpaths You can use the win32pdh.ParseCounterPath(path) utility function to turn the paths into more easily read values for your task, or write the data to a file, or do whatever you want with it. OTHER NOTABLE METHODS: query.collectdatawhile(period) # start a logging thread for collecting data query.collectdatawhile_stop() # signal the logging thread to stop logging query.collectdata() # run the query only once query.addperfcounter(object, counter, machine=None) # add a standard performance counter query.addinstcounter(object, counter,machine=None,objtype = 'Process',volatile=1,format = win32pdh.PDH_FMT_LONG) # add a possibly volatile counter ### Known bugs and limitations ### Due to a problem with threading under the PythonWin interpreter, there will be no data logged if the PythonWin window is not the foreground application. Workaround: scripts using threading should be run in the python.exe interpreter. The volatile-counter handlers are possibly buggy, they haven't been tested to any extent. The wrapper Query makes it safe to pass invalid paths (a -1 will be returned, or the Query will be totally ignored, depending on the missing element), so you should be able to work around the error by including all possible paths and filtering out the -1's. There is no way I know of to stop a thread which is currently sleeping, so you have to wait until the thread in collectdatawhile is activated again. This might become a problem in situations where the collection period is multiple minutes (or hours, or whatever). Should make the win32pdh.ParseCounter function available to the Query classes as a method or something similar, so that it can be accessed by programmes that have just picked up an instance from somewhere. Should explicitly mention where QueryErrors can be raised, and create a full test set to see if there are any uncaught win32api.error's still hanging around. When using the python.exe interpreter, the addcounterbybrowsing- generated browser window is often hidden behind other windows. No known workaround other than Alt-tabing to reach the browser window. ### Other References ### The win32pdhutil module (which should be in the %pythonroot%/win32/lib directory) provides quick-and-dirty utilities for one-off access to variables from the PDH. Almost everything in that module can be done with a Query object, but it provides task-oriented functions for a number of common one-off tasks. If you can access the MS Developers Network Library, you can find information about the PDH API as MS describes it. For a background article, try: http://msdn.microsoft.com/library/en-us/dnperfmo/html/msdn_pdhlib.asp The reference guide for the PDH API was last spotted at: http://msdn.microsoft.com/library/en-us/perfmon/base/using_the_pdh_interface.asp In general the Python version of the API is just a wrapper around the Query-based version of this API (as far as I can see), so you can learn what you need to from there. From what I understand, the MSDN Online resources are available for the price of signing up for them. I can't guarantee how long that's supposed to last. (Or anything for that matter). http://premium.microsoft.com/isapi/devonly/prodinfo/msdnprod/msdnlib.idc?theURL=/msdn/library/sdkdoc/perfdata_4982.htm The eventual plan is for my (Mike Fletcher's) Starship account to include a section on NT Administration, and the Query is the first project in this plan. There should be an article describing the creation of a simple logger there, but the example above is 90% of the work of that project, so don't sweat it if you don't find anything there. (currently the account hasn't been set up). http://starship.skyport.net/crew/mcfletch/ If you need to contact me immediately, (why I can't imagine), you can email me at mcfletch@golden.net, or just post your question to the Python newsgroup with a catchy subject line. news:comp.lang.python ### Other Stuff ### The Query classes are by Mike Fletcher, with the working code being corruptions of Mark Hammonds win32pdhutil module. Use at your own risk, no warranties, no guarantees, no assurances, if you use it, you accept the risk of using it, etceteras. ''' import win32pdh , win32api , time , thread , copy class BaseQuery : def __init__ ( self , paths = None ) : self . counters = [ ] if paths : self . paths = paths else : self . paths = [ ] self . _base = None self . active = 0 self . curpaths = [ ] def addcounterbybrowsing ( self , flags = win32pdh . PERF_DETAIL_WIZARD , windowtitle = "Python Browser" ) : win32pdh . BrowseCounters ( None , 0 , self . paths . append , flags , windowtitle ) def rawaddcounter ( self , object , counter , instance = None , inum = - 1 , machine = None ) : path = win32pdh . MakeCounterPath ( ( machine , object , instance , None , inum , counter ) ) self . paths . append ( path ) def addcounter ( self , object , counter , instance = None , inum = - 1 , machine = None ) : if not self . active : try : self . rawaddcounter ( object , counter , instance , inum , machine ) return 0 except win32api . error : return - 1 else : return - 1 def open ( self ) : if not self . active : self . curpaths = copy . copy ( self . paths ) try : base = win32pdh . OpenQuery ( ) for path in self . paths : try : self . counters . append ( win32pdh . AddCounter ( base , path ) ) except win32api . error : self . counters . append ( 0 ) pass self . _base = base self . active = 1 return 0 except : try : self . killbase ( base ) except NameError : pass self . active = 0 self . curpaths = [ ] raise QueryError ( self ) return 1 def killbase ( self , base = None ) : self . _base = None counters = self . counters self . counters = [ ] self . active = 0 try : map ( win32pdh . RemoveCounter , counters ) except : pass try : win32pdh . CloseQuery ( base ) except : pass del ( counters ) del ( base ) def close ( self ) : try : self . killbase ( self . _base ) except AttributeError : self . killbase ( ) __del__ = close def collectdata ( self , format = win32pdh . PDH_FMT_LONG ) : if self . _base : return self . collectdataslave ( format ) else : self . open ( ) temp = self . collectdataslave ( format ) self . close ( ) return temp def collectdataslave ( self , format = win32pdh . PDH_FMT_LONG ) : try : win32pdh . CollectQueryData ( self . _base ) temp = [ ] for counter in self . counters : ok = 0 try : if counter : temp . append ( win32pdh . GetFormattedCounterValue ( counter , format ) [ 1 ] ) ok = 1 except win32api . error : pass if not ok : temp . append ( - 1 ) return temp except win32api . error : return [ - 1 ] * len ( self . counters ) def __getinitargs__ ( self ) : return ( self . paths , ) class Query ( BaseQuery ) : def __init__ ( self , * args , ** namedargs ) : self . volatilecounters = [ ] apply ( BaseQuery . __init__ , ( self , ) + args , namedargs ) def addperfcounter ( self , object , counter , machine = None ) : BaseQuery . addcounter ( self , object = object , counter = counter , machine = machine ) def addinstcounter ( self , object , counter , machine = None , objtype = 'Process' , volatile = 1 , format = win32pdh . PDH_FMT_LONG ) : if volatile : self . volatilecounters . append ( ( object , counter , machine , objtype , format ) ) else : self . paths [ len ( self . paths ) : ] = self . getinstpaths ( object , counter , machine , objtype , format ) def getinstpaths ( self , object , counter , machine = None , objtype = 'Process' , format = win32pdh . PDH_FMT_LONG ) : items , instances = win32pdh . EnumObjectItems ( None , None , objtype , - 1 ) instances . sort ( ) try : cur = instances . index ( object ) except ValueError : return [ ] temp = [ object ] try : while instances [ cur + 1 ] == object : temp . append ( object ) cur = cur + 1 except IndexError : pass paths = [ ] for ind in range ( len ( temp ) ) : paths . append ( win32pdh . MakeCounterPath ( ( machine , 'Process' , object , None , ind , counter ) ) ) return paths def open ( self , * args , ** namedargs ) : apply ( BaseQuery . open , ( self , ) + args , namedargs ) paths = [ ] for tup in self . volatilecounters : paths [ len ( paths ) : ] = apply ( self . getinstpaths , tup ) for path in paths : try : self . counters . append ( win32pdh . AddCounter ( self . _base , path ) ) self . curpaths . append ( path ) except win32api . error : pass def collectdatafor ( self , totalperiod , period = 1 ) : tempresults = [ ] try : self . open ( ) for ind in xrange ( totalperiod / period ) : tempresults . append ( self . collectdata ( ) ) time . sleep ( period ) self . curresults = tempresults finally : self . close ( ) def collectdatawhile ( self , period = 1 ) : self . collectdatawhile_active = 1 thread . start_new_thread ( self . collectdatawhile_slave , ( period , ) ) def collectdatawhile_stop ( self ) : self . collectdatawhile_active = 0 def collectdatawhile_slave ( self , period ) : tempresults = [ ] try : self . open ( ) while self . collectdatawhile_active : tempresults . append ( self . collectdata ( ) ) time . sleep ( period ) self . curresults = tempresults finally : self . close ( ) def __getinitargs__ ( self ) : return ( self . paths , ) def __getstate__ ( self ) : return self . volatilecounters def __setstate__ ( self , volatilecounters ) : self . volatilecounters = volatilecounters class QueryError : def __init__ ( self , query ) : self . query = query def __repr__ ( self ) : return '<Query Error in %s>' % repr ( self . query ) __str__ = __repr__

import os , sys , time import pyreadline . logger as logger from pyreadline . logger import log , log_sock from pyreadline . lineeditor . lineobj import Point import pyreadline . lineeditor . lineobj as lineobj import pyreadline . lineeditor . history as history import basemode import string from pyreadline . unicode_helper import ensure_unicode def format ( keyinfo ) : if len ( keyinfo [ - 1 ] ) != 1 : k = keyinfo + ( - 1 , ) else : k = keyinfo + ( ord ( keyinfo [ - 1 ] ) , ) return "(%s,%s,%s,%s,%x)" % k in_ironpython = "IronPython" in sys . version class EmacsMode ( basemode . BaseMode ) : mode = "emacs" def __init__ ( self , rlobj ) : super ( EmacsMode , self ) . __init__ ( rlobj ) self . _keylog = ( lambda x , y : None ) self . previous_func = None self . prompt = ">>>" def __repr__ ( self ) : return "<EmacsMode>" def add_key_logger ( self , logfun ) : self . _keylog = logfun def _readline_from_keyboard ( self ) : c = self . console def nop ( e ) : pass while 1 : self . _update_line ( ) lbuf = self . l_buffer log_sock ( "point:%d mark:%d selection_mark:%d" % ( lbuf . point , lbuf . mark , lbuf . selection_mark ) ) try : event = c . getkeypress ( ) log_sock ( u">>%s" % event ) except KeyboardInterrupt : from pyreadline . keysyms . common import KeyPress from pyreadline . console . event import Event event = Event ( 0 , 0 ) event . char = "c" event . keyinfo = KeyPress ( "c" , shift = False , control = True , meta = False , keyname = None ) log_sock ( "KBDIRQ" ) if self . allow_ctrl_c : now = time . time ( ) if ( now - self . ctrl_c_timeout ) < self . ctrl_c_tap_time_interval : raise else : self . ctrl_c_timeout = now pass else : raise if self . next_meta : self . next_meta = False control , meta , shift , code = event . keyinfo event . keyinfo = ( control , True , shift , code ) keyinfo = event . keyinfo . tuple ( ) if keyinfo in self . exit_dispatch : if lineobj . EndOfLine ( self . l_buffer ) == 0 : raise EOFError if len ( keyinfo [ - 1 ] ) > 1 : default = nop else : default = self . self_insert dispatch_func = self . key_dispatch . get ( keyinfo , default ) log ( "readline from keyboard:%s,%s" % ( keyinfo , dispatch_func ) ) log_sock ( ( u"%s|%s" % ( ensure_unicode ( format ( keyinfo ) ) , dispatch_func . __name__ ) ) , "bound_function" ) r = None if dispatch_func : r = dispatch_func ( event ) self . _keylog ( dispatch_func , self . l_buffer ) self . l_buffer . push_undo ( ) self . previous_func = dispatch_func if r : self . _update_line ( ) break def readline ( self , prompt = '' ) : self . ctrl_c_timeout = time . time ( ) self . l_buffer . selection_mark = - 1 if self . first_prompt : self . first_prompt = False if self . startup_hook : try : self . startup_hook ( ) except : print 'startup hook failed' traceback . print_exc ( ) c = self . console self . l_buffer . reset_line ( ) self . prompt = prompt self . _print_prompt ( ) if self . pre_input_hook : try : self . pre_input_hook ( ) except : print 'pre_input_hook failed' traceback . print_exc ( ) self . pre_input_hook = None log ( "in readline: %s" % self . paste_line_buffer ) if len ( self . paste_line_buffer ) > 0 : self . l_buffer = lineobj . ReadLineTextBuffer ( self . paste_line_buffer [ 0 ] ) self . _update_line ( ) self . paste_line_buffer = self . paste_line_buffer [ 1 : ] c . write ( '\r\n' ) else : self . _readline_from_keyboard ( ) c . write ( '\r\n' ) self . add_history ( self . l_buffer . copy ( ) ) log ( 'returning(%s)' % self . l_buffer . get_line_text ( ) ) return self . l_buffer . get_line_text ( ) + '\n' def previous_history ( self , e ) : self . _history . previous_history ( self . l_buffer ) self . l_buffer . point = lineobj . EndOfLine def next_history ( self , e ) : self . _history . next_history ( self . l_buffer ) def beginning_of_history ( self , e ) : self . _history . beginning_of_history ( ) def end_of_history ( self , e ) : self . _history . end_of_history ( self . l_buffer ) def _i_search ( self , searchfun , direction , init_event ) : c = self . console line = self . l_buffer . get_line_text ( ) query = '' if ( self . previous_func != self . history_search_forward and self . previous_func != self . history_search_backward ) : self . query = '' . join ( self . l_buffer [ 0 : Point ] . get_line_text ( ) ) hc_start = self . _history . history_cursor while 1 : x , y = self . prompt_end_pos c . pos ( 0 , y ) if direction < 0 : prompt = 'reverse-i-search' else : prompt = 'forward-i-search' scroll = c . write_scrolling ( "%s`%s': %s" % ( prompt , query , line ) ) self . _update_prompt_pos ( scroll ) self . _clear_after ( ) event = c . getkeypress ( ) if event . keyinfo . keyname == 'backspace' : query = query [ : - 1 ] if len ( query ) > 0 : line = searchfun ( query ) else : self . _bell ( ) line = "" elif event . char in string . letters + string . digits + string . punctuation + ' ' : query += event . char line = searchfun ( query ) elif event . keyinfo == init_event . keyinfo : self . _history . history_cursor += direction line = searchfun ( query ) else : if event . keyinfo . keyname != 'return' : self . _bell ( ) break px , py = self . prompt_begin_pos c . pos ( 0 , py ) self . l_buffer . set_line ( line ) self . _print_prompt ( ) self . _history . history_cursor = len ( self . _history . history ) def reverse_search_history ( self , e ) : self . _i_search ( self . _history . reverse_search_history , - 1 , e ) def forward_search_history ( self , e ) : self . _i_search ( self . _history . forward_search_history , 1 , e ) def non_incremental_reverse_search_history ( self , e ) : q = self . _history . non_incremental_reverse_search_history ( self . l_buffer ) self . l_buffer = q def non_incremental_forward_search_history ( self , e ) : q = self . _history . non_incremental_reverse_search_history ( self . l_buffer ) self . l_buffer = q def history_search_forward ( self , e ) : if self . previous_func and hasattr ( self . _history , self . previous_func . __name__ ) : self . _history . lastcommand = getattr ( self . _history , self . previous_func . __name__ ) else : self . _history . lastcommand = None q = self . _history . history_search_forward ( self . l_buffer ) self . l_buffer = q self . l_buffer . point = q . point def history_search_backward ( self , e ) : if self . previous_func and hasattr ( self . _history , self . previous_func . __name__ ) : self . _history . lastcommand = getattr ( self . _history , self . previous_func . __name__ ) else : self . _history . lastcommand = None q = self . _history . history_search_backward ( self . l_buffer ) self . l_buffer = q self . l_buffer . point = q . point def yank_nth_arg ( self , e ) : pass def yank_last_arg ( self , e ) : pass def forward_backward_delete_char ( self , e ) : pass def quoted_insert ( self , e ) : e = self . console . getkeypress ( ) self . insert_text ( e . char ) def tab_insert ( self , e ) : ws = ' ' * ( self . tabstop - ( self . line_cursor % self . tabstop ) ) self . insert_text ( ws ) def transpose_chars ( self , e ) : self . l_buffer . transpose_chars ( ) def transpose_words ( self , e ) : self . l_buffer . transpose_words ( ) def overwrite_mode ( self , e ) : pass def kill_line ( self , e ) : self . l_buffer . kill_line ( ) def backward_kill_line ( self , e ) : self . l_buffer . backward_kill_line ( ) def unix_line_discard ( self , e ) : self . l_buffer . unix_line_discard ( ) def kill_whole_line ( self , e ) : self . l_buffer . kill_whole_line ( ) def kill_word ( self , e ) : self . l_buffer . kill_word ( ) forward_kill_word = kill_word def backward_kill_word ( self , e ) : self . l_buffer . backward_kill_word ( ) def unix_word_rubout ( self , e ) : self . l_buffer . unix_word_rubout ( ) def kill_region ( self , e ) : pass def copy_region_as_kill ( self , e ) : pass def copy_backward_word ( self , e ) : pass def copy_forward_word ( self , e ) : pass def yank ( self , e ) : self . l_buffer . yank ( ) def yank_pop ( self , e ) : self . l_buffer . yank_pop ( ) def digit_argument ( self , e ) : args = e . char c = self . console line = self . l_buffer . get_line_text ( ) oldprompt = self . prompt def nop ( e ) : pass while 1 : x , y = self . prompt_end_pos c . pos ( 0 , y ) self . prompt = "(arg: %s) " % args self . _print_prompt ( ) self . _update_line ( ) event = c . getkeypress ( ) if event . keyinfo . keyname == 'enter' : break elif event . char in "0123456789" : args += event . char else : self . argument = int ( args ) keyinfo = event . keyinfo . tuple ( ) if len ( keyinfo [ - 1 ] ) > 1 : default = nop else : default = self . self_insert dispatch_func = self . key_dispatch . get ( keyinfo , default ) dispatch_func ( event ) break self . prompt = oldprompt x , y = self . prompt_end_pos c . pos ( 0 , y ) self . _print_prompt ( ) self . _update_line ( ) def universal_argument ( self , e ) : pass def delete_char_or_list ( self , e ) : pass def start_kbd_macro ( self , e ) : pass def end_kbd_macro ( self , e ) : pass def call_last_kbd_macro ( self , e ) : pass def re_read_init_file ( self , e ) : pass def abort ( self , e ) : self . _bell ( ) def do_uppercase_version ( self , e ) : pass def prefix_meta ( self , e ) : self . next_meta = True def undo ( self , e ) : self . l_buffer . pop_undo ( ) def revert_line ( self , e ) : pass def tilde_expand ( self , e ) : pass def set_mark ( self , e ) : self . l_buffer . set_mark ( ) def exchange_point_and_mark ( self , e ) : pass def character_search ( self , e ) : pass def character_search_backward ( self , e ) : pass def insert_comment ( self , e ) : pass def dump_variables ( self , e ) : pass def dump_macros ( self , e ) : pass def init_editing_mode ( self , e ) : self . _bind_exit_key ( 'Control-d' ) self . _bind_exit_key ( 'Control-z' ) self . _bind_key ( 'space' , self . self_insert ) self . _bind_key ( 'Shift-space' , self . self_insert ) self . _bind_key ( 'Control-space' , self . self_insert ) self . _bind_key ( 'Return' , self . accept_line ) self . _bind_key ( 'Left' , self . backward_char ) self . _bind_key ( 'Control-b' , self . backward_char ) self . _bind_key ( 'Right' , self . forward_char ) self . _bind_key ( 'Control-f' , self . forward_char ) self . _bind_key ( 'BackSpace' , self . backward_delete_char ) self . _bind_key ( 'Control-BackSpace' , self . backward_delete_word ) self . _bind_key ( 'Home' , self . beginning_of_line ) self . _bind_key ( 'End' , self . end_of_line ) self . _bind_key ( 'Delete' , self . delete_char ) self . _bind_key ( 'Control-d' , self . delete_char ) self . _bind_key ( 'Clear' , self . clear_screen ) self . _bind_key ( 'Alt-f' , self . forward_word ) self . _bind_key ( 'Alt-b' , self . backward_word ) self . _bind_key ( 'Control-l' , self . clear_screen ) self . _bind_key ( 'Control-p' , self . previous_history ) self . _bind_key ( 'Up' , self . history_search_backward ) self . _bind_key ( 'Control-n' , self . next_history ) self . _bind_key ( 'Down' , self . history_search_forward ) self . _bind_key ( 'Control-a' , self . beginning_of_line ) self . _bind_key ( 'Control-e' , self . end_of_line ) self . _bind_key ( 'Alt-<' , self . beginning_of_history ) self . _bind_key ( 'Alt->' , self . end_of_history ) self . _bind_key ( 'Control-r' , self . reverse_search_history ) self . _bind_key ( 'Control-s' , self . forward_search_history ) self . _bind_key ( 'Alt-p' , self . non_incremental_reverse_search_history ) self . _bind_key ( 'Alt-n' , self . non_incremental_forward_search_history ) self . _bind_key ( 'Control-z' , self . undo ) self . _bind_key ( 'Control-_' , self . undo ) self . _bind_key ( 'Escape' , self . kill_whole_line ) self . _bind_key ( 'Meta-d' , self . kill_word ) self . _bind_key ( 'Control-Delete' , self . forward_delete_word ) self . _bind_key ( 'Control-w' , self . unix_word_rubout ) self . _bind_key ( 'Control-v' , self . paste ) self . _bind_key ( 'Alt-v' , self . ipython_paste ) self . _bind_key ( 'Control-y' , self . yank ) self . _bind_key ( 'Control-k' , self . kill_line ) self . _bind_key ( 'Control-m' , self . set_mark ) self . _bind_key ( 'Control-q' , self . copy_region_to_clipboard ) self . _bind_key ( 'Control-Shift-v' , self . paste_mulitline_code ) self . _bind_key ( "Control-Right" , self . forward_word_end ) self . _bind_key ( "Control-Left" , self . backward_word ) self . _bind_key ( "Shift-Right" , self . forward_char_extend_selection ) self . _bind_key ( "Shift-Left" , self . backward_char_extend_selection ) self . _bind_key ( "Shift-Control-Right" , self . forward_word_end_extend_selection ) self . _bind_key ( "Shift-Control-Left" , self . backward_word_extend_selection ) self . _bind_key ( "Shift-Home" , self . beginning_of_line_extend_selection ) self . _bind_key ( "Shift-End" , self . end_of_line_extend_selection ) self . _bind_key ( "numpad0" , self . self_insert ) self . _bind_key ( "numpad1" , self . self_insert ) self . _bind_key ( "numpad2" , self . self_insert ) self . _bind_key ( "numpad3" , self . self_insert ) self . _bind_key ( "numpad4" , self . self_insert ) self . _bind_key ( "numpad5" , self . self_insert ) self . _bind_key ( "numpad6" , self . self_insert ) self . _bind_key ( "numpad7" , self . self_insert ) self . _bind_key ( "numpad8" , self . self_insert ) self . _bind_key ( "numpad9" , self . self_insert ) self . _bind_key ( "add" , self . self_insert ) self . _bind_key ( "subtract" , self . self_insert ) self . _bind_key ( "multiply" , self . self_insert ) self . _bind_key ( "divide" , self . self_insert ) self . _bind_key ( "vk_decimal" , self . self_insert ) log ( "RUNNING INIT EMACS" ) def commonprefix ( m ) : if not m : return '' prefix = m [ 0 ] for item in m : for i in range ( len ( prefix ) ) : if prefix [ : i + 1 ] . lower ( ) != item [ : i + 1 ] . lower ( ) : prefix = prefix [ : i ] if i == 0 : return '' break return prefix

"""Convenient HTTP UserAgent class. This is a subclass of urllib2.OpenerDirector. Copyright 2003-2006 John J. Lee <jjl@pobox.com> This code is free software; you can redistribute it and/or modify it under the terms of the BSD or ZPL 2.1 licenses (see the file COPYING.txt included with the distribution). """ import warnings import _auth import _gzip import _opener import _response import _sockettimeout import _urllib2 class UserAgentBase ( _opener . OpenerDirector ) : handler_classes = { : _urllib2 . HTTPHandler , : _urllib2 . FTPHandler , : _urllib2 . FileHandler , : _urllib2 . UnknownHandler , : _urllib2 . HTTPErrorProcessor , : _urllib2 . HTTPRequestUpgradeProcessor , : _urllib2 . HTTPDefaultErrorHandler , : _urllib2 . HTTPBasicAuthHandler , : _urllib2 . HTTPDigestAuthHandler , : _urllib2 . HTTPRedirectHandler , : _urllib2 . HTTPCookieProcessor , : _urllib2 . HTTPRefreshProcessor , : _urllib2 . HTTPEquivProcessor , : _urllib2 . ProxyHandler , : _urllib2 . ProxyBasicAuthHandler , : _urllib2 . ProxyDigestAuthHandler , : _urllib2 . HTTPRobotRulesProcessor , : _gzip . HTTPGzipProcessor , : _urllib2 . HTTPRedirectDebugProcessor , : _urllib2 . HTTPResponseDebugProcessor , } default_schemes = [ "http" , "ftp" , "file" ] default_others = [ "_unknown" , "_http_error" , "_http_request_upgrade" , , ] default_features = [ "_redirect" , "_cookies" , , "_equiv" , , "_digestauth" , , "_proxy_basicauth" , "_proxy_digestauth" , , ] if hasattr ( _urllib2 , 'HTTPSHandler' ) : handler_classes [ "https" ] = _urllib2 . HTTPSHandler default_schemes . append ( "https" ) def __init__ ( self ) : _opener . OpenerDirector . __init__ ( self ) ua_handlers = self . _ua_handlers = { } for scheme in ( self . default_schemes + self . default_others + self . default_features ) : klass = self . handler_classes [ scheme ] ua_handlers [ scheme ] = klass ( ) for handler in ua_handlers . itervalues ( ) : self . add_handler ( handler ) if "_refresh" in ua_handlers : self . set_handle_refresh ( True ) if "_equiv" in ua_handlers : self . set_handle_equiv ( True ) pm = ppm = None if "_basicauth" in ua_handlers or "_digestauth" in ua_handlers : pm = _urllib2 . HTTPPasswordMgrWithDefaultRealm ( ) if ( "_proxy_basicauth" in ua_handlers or in ua_handlers ) : ppm = _auth . HTTPProxyPasswordMgr ( ) self . set_password_manager ( pm ) self . set_proxy_password_manager ( ppm ) if "https" in ua_handlers : cm = _urllib2 . HTTPSClientCertMgr ( ) self . set_client_cert_manager ( cm ) def close ( self ) : _opener . OpenerDirector . close ( self ) self . _ua_handlers = None def set_handled_schemes ( self , schemes ) : want = { } for scheme in schemes : if scheme . startswith ( "_" ) : raise ValueError ( "not a scheme '%s'" % scheme ) if scheme not in self . handler_classes : raise ValueError ( "unknown scheme '%s'" ) want [ scheme ] = None for scheme , oldhandler in self . _ua_handlers . items ( ) : if scheme . startswith ( "_" ) : continue if scheme not in want : self . _replace_handler ( scheme , None ) else : del want [ scheme ] for scheme in want . keys ( ) : self . _set_handler ( scheme , True ) def set_cookiejar ( self , cookiejar ) : self . _set_handler ( "_cookies" , obj = cookiejar ) def set_proxies ( self , proxies ) : self . _set_handler ( "_proxy" , obj = proxies ) def add_password ( self , url , user , password , realm = None ) : self . _password_manager . add_password ( realm , url , user , password ) def add_proxy_password ( self , user , password , hostport = None , realm = None ) : self . _proxy_password_manager . add_password ( realm , hostport , user , password ) def add_client_certificate ( self , url , key_file , cert_file ) : self . _client_cert_manager . add_key_cert ( url , key_file , cert_file ) def set_password_manager ( self , password_manager ) : self . _password_manager = password_manager self . _set_handler ( "_basicauth" , obj = password_manager ) self . _set_handler ( "_digestauth" , obj = password_manager ) def set_proxy_password_manager ( self , password_manager ) : self . _proxy_password_manager = password_manager self . _set_handler ( "_proxy_basicauth" , obj = password_manager ) self . _set_handler ( "_proxy_digestauth" , obj = password_manager ) def set_client_cert_manager ( self , cert_manager ) : self . _client_cert_manager = cert_manager handler = self . _ua_handlers [ "https" ] handler . client_cert_manager = cert_manager def set_handle_robots ( self , handle ) : self . _set_handler ( "_robots" , handle ) def set_handle_redirect ( self , handle ) : self . _set_handler ( "_redirect" , handle ) def set_handle_refresh ( self , handle , max_time = None , honor_time = True ) : self . _set_handler ( "_refresh" , handle , constructor_kwds = { "max_time" : max_time , "honor_time" : honor_time } ) def set_handle_equiv ( self , handle , head_parser_class = None ) : if head_parser_class is not None : constructor_kwds = { "head_parser_class" : head_parser_class } else : constructor_kwds = { } self . _set_handler ( "_equiv" , handle , constructor_kwds = constructor_kwds ) def set_handle_gzip ( self , handle ) : if handle : warnings . warn ( , stacklevel = 2 ) self . _set_handler ( "_gzip" , handle ) def set_debug_redirects ( self , handle ) : self . _set_handler ( "_debug_redirect" , handle ) def set_debug_responses ( self , handle ) : self . _set_handler ( "_debug_response_body" , handle ) def set_debug_http ( self , handle ) : level = int ( bool ( handle ) ) for scheme in "http" , "https" : h = self . _ua_handlers . get ( scheme ) if h is not None : h . set_http_debuglevel ( level ) def _set_handler ( self , name , handle = None , obj = None , constructor_args = ( ) , constructor_kwds = { } ) : if handle is None : handle = obj is not None if handle : handler_class = self . handler_classes [ name ] if obj is not None : newhandler = handler_class ( obj ) else : newhandler = handler_class ( * constructor_args , ** constructor_kwds ) else : newhandler = None self . _replace_handler ( name , newhandler ) def _replace_handler ( self , name , newhandler = None ) : if name is not None : handler = self . _ua_handlers . get ( name ) if handler : try : self . handlers . remove ( handler ) except ValueError : pass if newhandler is not None : self . add_handler ( newhandler ) self . _ua_handlers [ name ] = newhandler class UserAgent ( UserAgentBase ) : def __init__ ( self ) : UserAgentBase . __init__ ( self ) self . _seekable = False def set_seekable_responses ( self , handle ) : self . _seekable = bool ( handle ) def open ( self , fullurl , data = None , timeout = _sockettimeout . _GLOBAL_DEFAULT_TIMEOUT ) : if self . _seekable : def bound_open ( fullurl , data = None , timeout = _sockettimeout . _GLOBAL_DEFAULT_TIMEOUT ) : return UserAgentBase . open ( self , fullurl , data , timeout ) response = _opener . wrapped_open ( bound_open , _response . seek_wrapped_response , fullurl , data , timeout ) else : response = UserAgentBase . open ( self , fullurl , data ) return response

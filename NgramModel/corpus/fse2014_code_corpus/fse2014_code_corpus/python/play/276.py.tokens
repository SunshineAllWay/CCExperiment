'''Cursor control and color for the .NET console. ''' import clr , sys clr . AddReferenceToFileAndPath ( sys . executable ) import IronPythonConsole import sys import re import os import System from event import Event from pyreadline . logger import log , log_sock from pyreadline . keysyms import make_keysym , make_keyinfo , make_KeyPress , make_KeyPress_from_keydescr from pyreadline . console . ansi import AnsiState color = System . ConsoleColor ansicolor = { "0;30" : color . Black , : color . DarkRed , : color . DarkGreen , : color . DarkYellow , : color . DarkBlue , : color . DarkMagenta , : color . DarkCyan , : color . DarkGray , : color . Gray , : color . Red , : color . Green , : color . Yellow , : color . Blue , : color . Magenta , : color . Cyan , : color . White } winattr = { "black" : 0 , "darkgray" : 0 + 8 , : 4 , "red" : 4 + 8 , : 2 , "green" : 2 + 8 , : 6 , "yellow" : 6 + 8 , : 1 , "blue" : 1 + 8 , : 5 , "magenta" : 5 + 8 , : 3 , "cyan" : 3 + 8 , : 7 , "white" : 7 + 8 } class Console ( object ) : def __init__ ( self , newbuffer = 0 ) : self . serial = 0 self . attr = System . Console . ForegroundColor self . saveattr = winattr [ str ( System . Console . ForegroundColor ) . lower ( ) ] self . savebg = System . Console . BackgroundColor log ( 'initial attr=%s' % self . attr ) log_sock ( "%s" % self . saveattr ) def _get ( self ) : top = System . Console . WindowTop log_sock ( "WindowTop:%s" % top , "console" ) return top def _set ( self , value ) : top = System . Console . WindowTop log_sock ( "Set WindowTop:old:%s,new:%s" % ( top , value ) , "console" ) WindowTop = property ( _get , _set ) del _get , _set def __del__ ( self ) : pass def pos ( self , x = None , y = None ) : if x is not None : System . Console . CursorLeft = x else : x = System . Console . CursorLeft if y is not None : System . Console . CursorTop = y else : y = System . Console . CursorTop return x , y def home ( self ) : self . pos ( 0 , 0 ) terminal_escape = re . compile ( '(\001?\033\\[[0-9;]*m\002?)' ) escape_parts = re . compile ( '\001?\033\\[([0-9;]*)m\002?' ) motion_char_re = re . compile ( '([\n\r\t\010\007])' ) def write_scrolling ( self , text , attr = None ) : x , y = self . pos ( ) w , h = self . size ( ) scroll = 0 chunks = self . motion_char_re . split ( text ) for chunk in chunks : log ( 'C:' + chunk ) n = self . write_color ( chunk , attr ) if len ( chunk ) == 1 : if chunk [ 0 ] == '\n' : x = 0 y += 1 elif chunk [ 0 ] == '\r' : x = 0 elif chunk [ 0 ] == '\t' : x = 8 * ( int ( x / 8 ) + 1 ) if x > w : x -= w y += 1 elif chunk [ 0 ] == '\007' : pass elif chunk [ 0 ] == '\010' : x -= 1 if x < 0 : y -= 1 else : x += 1 if x == w : x = 0 y += 1 if y == h : scroll += 1 y = h - 1 else : x += n l = int ( x / w ) x = x % w y += l if y >= h : scroll += y - h + 1 y = h - 1 return scroll trtable = { 0 : color . Black , 4 : color . DarkRed , 2 : color . DarkGreen , 6 : color . DarkYellow , 1 : color . DarkBlue , 5 : color . DarkMagenta , 3 : color . DarkCyan , 7 : color . Gray , 8 : color . DarkGray , 4 + 8 : color . Red , 2 + 8 : color . Green , 6 + 8 : color . Yellow , 1 + 8 : color . Blue , 5 + 8 : color . Magenta , 3 + 8 : color . Cyan , 7 + 8 : color . White } def write_color ( self , text , attr = None ) : log ( 'write_color("%s", %s)' % ( text , attr ) ) chunks = self . terminal_escape . split ( text ) log ( 'chunks=%s' % repr ( chunks ) ) bg = self . savebg n = 0 if attr is None : attr = self . attr try : fg = self . trtable [ ( 0x000f & attr ) ] bg = self . trtable [ ( 0x00f0 & attr ) >> 4 ] except TypeError : fg = attr for chunk in chunks : m = self . escape_parts . match ( chunk ) if m : log ( m . group ( 1 ) ) attr = ansicolor . get ( m . group ( 1 ) , self . attr ) n += len ( chunk ) System . Console . ForegroundColor = fg System . Console . BackgroundColor = bg System . Console . Write ( chunk ) return n def write_plain ( self , text , attr = None ) : log ( 'write("%s", %s)' % ( text , attr ) ) if attr is None : attr = self . attr n = c_int ( 0 ) self . SetConsoleTextAttribute ( self . hout , attr ) self . WriteConsoleA ( self . hout , text , len ( text ) , byref ( n ) , None ) return len ( text ) if os . environ . has_key ( "EMACS" ) : def write_color ( self , text , attr = None ) : junk = c_int ( 0 ) self . WriteFile ( self . hout , text , len ( text ) , byref ( junk ) , None ) return len ( text ) write_plain = write_color def write ( self , text ) : log ( 'write("%s")' % text ) return self . write_color ( text ) def isatty ( self ) : return True def flush ( self ) : pass def page ( self , attr = None , fill = ' ' ) : System . Console . Clear ( ) def text ( self , x , y , text , attr = None ) : self . pos ( x , y ) self . write_color ( text , attr ) def clear_to_end_of_window ( self ) : oldtop = self . WindowTop lastline = self . WindowTop + System . Console . WindowHeight pos = self . pos ( ) w , h = self . size ( ) length = w - pos [ 0 ] + min ( ( lastline - pos [ 1 ] - 1 ) , 5 ) * w - 1 self . write_color ( length * " " ) self . pos ( * pos ) self . WindowTop = oldtop def rectangle ( self , rect , attr = None , fill = ' ' ) : pass oldtop = self . WindowTop oldpos = self . pos ( ) x0 , y0 , x1 , y1 = rect if attr is None : attr = self . attr if fill : rowfill = fill [ : 1 ] * abs ( x1 - x0 ) else : rowfill = ' ' * abs ( x1 - x0 ) for y in range ( y0 , y1 ) : System . Console . SetCursorPosition ( x0 , y ) self . write_color ( rowfill , attr ) self . pos ( * oldpos ) def scroll ( self , rect , dx , dy , attr = None , fill = ' ' ) : pass raise NotImplementedError def scroll_window ( self , lines ) : top = self . WindowTop + lines if top < 0 : top = 0 if top + System . Console . WindowHeight > System . Console . BufferHeight : top = System . Console . BufferHeight self . WindowTop = top def getkeypress ( self ) : ck = System . ConsoleKey while 1 : e = System . Console . ReadKey ( True ) if e . Key == System . ConsoleKey . PageDown : self . scroll_window ( 12 ) elif e . Key == System . ConsoleKey . PageUp : self . scroll_window ( - 12 ) elif str ( e . KeyChar ) == "\000" : log_sock ( "Deadkey: %s" % e ) return event ( self , e ) pass else : return event ( self , e ) def title ( self , txt = None ) : if txt : System . Console . Title = txt else : return System . Console . Title def size ( self , width = None , height = None ) : sc = System . Console if width is not None and height is not None : sc . BufferWidth , sc . BufferHeight = width , height else : return sc . BufferWidth , sc . BufferHeight if width is not None and height is not None : sc . WindowWidth , sc . WindowHeight = width , height else : return sc . WindowWidth - 1 , sc . WindowHeight - 1 def cursor ( self , visible = True , size = None ) : System . Console . CursorVisible = visible def bell ( self ) : System . Console . Beep ( ) def next_serial ( self ) : self . serial += 1 return self . serial class event ( Event ) : def __init__ ( self , console , input ) : self . type = '??' self . serial = console . next_serial ( ) self . width = 0 self . height = 0 self . x = 0 self . y = 0 self . char = str ( input . KeyChar ) self . keycode = input . Key self . state = input . Modifiers log_sock ( "%s,%s,%s" % ( input . Modifiers , input . Key , input . KeyChar ) , "console" ) self . type = "KeyRelease" self . keysym = make_keysym ( self . keycode ) self . keyinfo = make_KeyPress ( self . char , self . state , self . keycode ) def make_event_from_keydescr ( keydescr ) : def input ( ) : return 1 input . KeyChar = "a" input . Key = System . ConsoleKey . A input . Modifiers = System . ConsoleModifiers . Shift input . next_serial = input e = event ( input , input ) del input . next_serial keyinfo = make_KeyPress_from_keydescr ( keydescr ) e . keyinfo = keyinfo return e CTRL_C_EVENT = make_event_from_keydescr ( "Control-c" ) def install_readline ( hook ) : def hook_wrap ( ) : try : res = hook ( ) except KeyboardInterrupt , x : res = "" except EOFError : return None if res [ - 1 : ] == "\n" : return res [ : - 1 ] else : return res class IronPythonWrapper ( IronPythonConsole . IConsole ) : def ReadLine ( self , autoIndentSize ) : return hook_wrap ( ) def Write ( self , text , style ) : System . Console . Write ( text ) def WriteLine ( self , text , style ) : System . Console . WriteLine ( text ) IronPythonConsole . PythonCommandLine . MyConsole = IronPythonWrapper ( ) if __name__ == '__main__' : import time , sys c = Console ( 0 ) sys . stdout = c sys . stderr = c c . page ( ) c . pos ( 5 , 10 ) c . write ( 'hi there' ) c . title ( "Testing console" ) print print "size" , c . size ( ) print ' some printed output' for i in range ( 10 ) : e = c . getkeypress ( ) print e . Key , chr ( e . KeyChar ) , ord ( e . KeyChar ) , e . Modifiers del c System . Console . Clear ( )

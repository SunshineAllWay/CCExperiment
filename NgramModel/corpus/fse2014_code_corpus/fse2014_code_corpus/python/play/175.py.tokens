"""Mutual exclusion -- for use with module sched A mutex has two pieces of state -- a 'locked' bit and a queue. When the mutex is not locked, the queue is empty. Otherwise, the queue contains 0 or more (function, argument) pairs representing functions (or methods) waiting to acquire the lock. When the mutex is unlocked while the queue is not empty, the first queue entry is removed and its function(argument) pair called, implying it now has the lock. Of course, no multi-threading is implied -- hence the funny interface for lock, where a function is called once the lock is aquired. """ from warnings import warnpy3k warnpy3k ( "the mutex module has been removed in Python 3.0" , stacklevel = 2 ) del warnpy3k from collections import deque class mutex : def __init__ ( self ) : self . locked = 0 self . queue = deque ( ) def test ( self ) : return self . locked def testandset ( self ) : if not self . locked : self . locked = 1 return True else : return False def lock ( self , function , argument ) : if self . testandset ( ) : function ( argument ) else : self . queue . append ( ( function , argument ) ) def unlock ( self ) : if self . queue : function , argument = self . queue . popleft ( ) function ( argument ) else : self . locked = 0

from __future__ import generators __author__ = 'Jason R. Coombs <jaraco@jaraco.com>' __version__ = '$Revision: 1.9 $' [ 11 : - 2 ] __sccauthor__ = '$Author: mhammond $' [ 9 : - 2 ] __date__ = '$Date: 2008/04/11 03:15:15 $' [ 10 : - 2 ] import os , _winreg , struct , datetime , win32api , re , sys , operator import logging log = logging . getLogger ( __file__ ) class WinTZI ( object ) : format = '3l8h8h' def __init__ ( self , key , name = None ) : if ( not name and len ( key ) == struct . calcsize ( self . format ) ) : self . __init_from_bytes__ ( key ) else : self . __init_from_reg_key__ ( key , name ) def __init_from_reg_key__ ( self , key , name = None ) : if not name : key , name = os . path . split ( key ) value , type = _winreg . QueryValueEx ( key , name ) self . __init_from_bytes__ ( value ) def __init_from_bytes__ ( self , bytes ) : components = struct . unpack ( self . format , bytes ) makeMinuteTimeDelta = lambda x : datetime . timedelta ( minutes = x ) self . bias , self . standardBiasOffset , self . daylightBiasOffset = map ( makeMinuteTimeDelta , components [ : 3 ] ) self . daylightEnd , self . daylightStart = components [ 3 : 11 ] , components [ 11 : 19 ] def LocateStartDay ( self , year ) : return self . _LocateDay ( year , self . daylightStart ) def LocateEndDay ( self , year ) : return self . _LocateDay ( year , self . daylightEnd ) def _LocateDay ( self , year , win32SystemTime ) : month = win32SystemTime [ 1 ] targetWeekday = ( win32SystemTime [ 2 ] + 6 ) % 7 day = ( win32SystemTime [ 3 ] - 1 ) * 7 + 1 hour , min , sec , msec = win32SystemTime [ 4 : ] result = datetime . datetime ( year , month , day , hour , min , sec , msec ) daysToGo = targetWeekday - result . weekday ( ) result += datetime . timedelta ( daysToGo ) while result . month == month + 1 : result -= datetime . timedelta ( weeks = 1 ) return result def __cmp__ ( self , other ) : return cmp ( self . __dict__ , other . __dict__ ) class TimeZoneInfo ( datetime . tzinfo ) : tzRegKey = r'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones' def __init__ ( self , timeZoneName , fixedStandardTime = False ) : self . timeZoneName = timeZoneName key = self . _FindTimeZoneKey ( ) self . _LoadInfoFromKey ( key ) self . fixedStandardTime = fixedStandardTime def _FindTimeZoneKey ( self ) : zoneNames = dict ( GetIndexedTimeZoneNames ( 'Std' ) ) timeZoneName = zoneNames . get ( self . timeZoneName , self . timeZoneName ) tzRegKeyPath = os . path . join ( self . tzRegKey , timeZoneName ) try : key = _winreg . OpenKeyEx ( _winreg . HKEY_LOCAL_MACHINE , tzRegKeyPath ) except : raise ValueError , 'Timezone Name %s not found.' % timeZoneName return key def __getinitargs__ ( self ) : return ( self . timeZoneName , ) def _LoadInfoFromKey ( self , key ) : self . displayName = _winreg . QueryValueEx ( key , "Display" ) [ 0 ] self . standardName = _winreg . QueryValueEx ( key , "Std" ) [ 0 ] self . daylightName = _winreg . QueryValueEx ( key , "Dlt" ) [ 0 ] self . staticInfo = WinTZI ( key , "TZI" ) self . _LoadDynamicInfoFromKey ( key ) def _LoadDynamicInfoFromKey ( self , key ) : try : dkey = _winreg . OpenKeyEx ( key , 'Dynamic DST' ) except WindowsError : return info = _RegKeyDict ( dkey ) del info [ 'FirstEntry' ] del info [ 'LastEntry' ] years = map ( int , info . keys ( ) ) values = map ( WinTZI , info . values ( ) ) self . dynamicInfo = RangeMap ( zip ( years , values ) , descending , operator . ge ) def __repr__ ( self ) : result = '%s( %s' % ( self . __class__ . __name__ , repr ( self . timeZoneName ) ) if self . fixedStandardTime : result += ', True' result += ' )' return result def __str__ ( self ) : return self . displayName def tzname ( self , dt ) : winInfo = self . getWinInfo ( dt ) if self . dst ( dt ) == winInfo . daylightBiasOffset : result = self . daylightName elif self . dst ( dt ) == winInfo . standardBiasOffset : result = self . standardName return result def getWinInfo ( self , targetYear ) : if not hasattr ( self , 'dynamicInfo' ) or not self . dynamicInfo : return self . staticInfo return self . dynamicInfo . get ( targetYear , self . dynamicInfo [ RangeItemLast ( ) ] ) def _getStandardBias ( self , dt ) : winInfo = self . getWinInfo ( dt . year ) return winInfo . bias + winInfo . standardBiasOffset def _getDaylightBias ( self , dt ) : winInfo = self . getWinInfo ( dt . year ) return winInfo . bias + winInfo . daylightBiasOffset def utcoffset ( self , dt ) : if dt is None : return winInfo = self . getWinInfo ( dt . year ) return - ( winInfo . bias + self . dst ( dt ) ) def dst ( self , dt ) : if dt is None : return assert dt . tzinfo is self winInfo = self . getWinInfo ( dt . year ) if not self . fixedStandardTime and self . _inDaylightSavings ( dt ) : result = winInfo . daylightBiasOffset else : result = winInfo . standardBiasOffset return result def _inDaylightSavings ( self , dt ) : try : dstStart = self . GetDSTStartTime ( dt . year ) dstEnd = self . GetDSTEndTime ( dt . year ) if dstStart < dstEnd : inDaylightSavings = dstStart <= dt . replace ( tzinfo = None ) < dstEnd else : inDaylightSavings = not ( dstEnd < dt . replace ( tzinfo = None ) <= dstStart ) except ValueError : inDaylightSavings = False return inDaylightSavings def GetDSTStartTime ( self , year ) : return self . getWinInfo ( year ) . LocateStartDay ( year ) def GetDSTEndTime ( self , year ) : return self . getWinInfo ( year ) . LocateEndDay ( year ) def __cmp__ ( self , other ) : return cmp ( self . __dict__ , other . __dict__ ) def _RegKeyEnumerator ( key ) : return _RegEnumerator ( key , _winreg . EnumKey ) def _RegValueEnumerator ( key ) : return _RegEnumerator ( key , _winreg . EnumValue ) def _RegEnumerator ( key , func ) : index = 0 try : while 1 : yield func ( key , index ) index += 1 except WindowsError : pass def _RegKeyDict ( key ) : values = _RegValueEnumerator ( key ) values = tuple ( values ) return dict ( map ( lambda ( name , value , type ) : ( name , value ) , values ) ) def GetTimeZoneNames ( ) : key = _winreg . OpenKeyEx ( _winreg . HKEY_LOCAL_MACHINE , TimeZoneInfo . tzRegKey ) return _RegKeyEnumerator ( key ) def GetIndexedTimeZoneNames ( index_key = 'Index' ) : for timeZoneName in GetTimeZoneNames ( ) : tzRegKeyPath = os . path . join ( TimeZoneInfo . tzRegKey , timeZoneName ) key = _winreg . OpenKeyEx ( _winreg . HKEY_LOCAL_MACHINE , tzRegKeyPath ) tzIndex , type = _winreg . QueryValueEx ( key , index_key ) yield ( tzIndex , timeZoneName ) def GetSortedTimeZoneNames ( ) : tzs = list ( GetIndexedTimeZoneNames ( ) ) tzs . sort ( ) return zip ( * tzs ) [ 1 ] def GetLocalTimeZone ( ) : tzRegKey = r'SYSTEM\CurrentControlSet\Control\TimeZoneInformation' key = _winreg . OpenKeyEx ( _winreg . HKEY_LOCAL_MACHINE , tzRegKey ) local = _RegKeyDict ( key ) fixStandardTime = local [ 'StandardName' ] == local [ 'DaylightName' ] and local [ 'StandardBias' ] == local [ 'DaylightBias' ] keyName = [ 'StandardName' , 'TimeZoneKeyName' ] [ sys . getwindowsversion ( ) >= ( 6 , ) ] standardName = local [ keyName ] standardName = __TimeZoneKeyNameWorkaround ( standardName ) return TimeZoneInfo ( standardName , fixStandardTime ) def __TimeZoneKeyNameWorkaround ( name ) : try : return name [ : name . index ( '\x00' ) ] except ValueError : return name def GetTZCapabilities ( ) : tzi = TimeZoneInfo ( 'Mountain Standard Time' ) MissingTZPatch = datetime . datetime ( 2007 , 11 , 2 , tzinfo = tzi ) . utctimetuple ( ) != ( 2007 , 11 , 2 , 6 , 0 , 0 , 4 , 306 , 0 ) DynamicTZSupport = not MissingTZPatch and datetime . datetime ( 2003 , 11 , 2 , tzinfo = tzi ) . utctimetuple ( ) == ( 2003 , 11 , 2 , 7 , 0 , 0 , 6 , 306 , 0 ) del tzi return vars ( ) class DLLHandleCache ( object ) : def __init__ ( self ) : self . __cache = { } def __getitem__ ( self , filename ) : key = filename . lower ( ) return self . __cache . setdefault ( key , win32api . LoadLibrary ( key ) ) DLLCache = DLLHandleCache ( ) def resolveMUITimeZone ( spec ) : pattern = re . compile ( '@(?P<dllname>.*),-(?P<index>\d+)(?:;(?P<comment>.*))?' ) matcher = pattern . match ( spec ) assert matcher , 'Could not parse MUI spec' try : handle = DLLCache [ matcher . groupdict ( ) [ 'dllname' ] ] result = win32api . LoadString ( handle , int ( matcher . groupdict ( ) [ 'index' ] ) ) except win32api . error , e : result = None return result ascending = cmp def descending ( a , b ) : return - ascending ( a , b ) class RangeMap ( dict ) : def __init__ ( self , source , keySortComparator = ascending , keyMatchComparator = operator . le ) : dict . __init__ ( self , source ) self . sort = keySortComparator self . match = keyMatchComparator def __getitem__ ( self , item ) : sortedKeys = self . keys ( ) sortedKeys . sort ( self . sort ) if isinstance ( item , RangeItem ) : result = self . __getitem__ ( sortedKeys [ item ] ) else : key = self . _find_first_match_ ( sortedKeys , item ) result = dict . __getitem__ ( self , key ) if isinstance ( result , RangeValueUndefined ) : raise KeyError , key return result def _find_first_match_ ( self , keys , item ) : is_match = lambda k : self . match ( item , k ) matches = filter ( is_match , keys ) if matches : return matches [ 0 ] raise KeyError ( item ) def bounds ( self ) : sortedKeys = self . keys ( ) sortedKeys . sort ( self . sort ) return sortedKeys [ RangeItemFirst ( ) ] , sortedKeys [ RangeItemLast ( ) ] class RangeValueUndefined ( object ) : pass class RangeItem ( int ) : def __new__ ( cls , value ) : return int . __new__ ( cls , value ) class RangeItemFirst ( RangeItem ) : def __new__ ( cls ) : return RangeItem . __new__ ( cls , 0 ) class RangeItemLast ( RangeItem ) : def __new__ ( cls ) : return RangeItem . __new__ ( cls , - 1 )

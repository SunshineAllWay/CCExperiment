"""Append module search paths for third-party packages to sys.path. **************************************************************** * This module is automatically imported during initialization. * **************************************************************** In earlier versions of Python (up to 1.5a3), scripts or modules that needed to use site-specific modules would place ``import site'' somewhere near the top of their code. Because of the automatic import, this is no longer necessary (but code that does it still works). This will append site-specific paths to the module search path. On Unix (including Mac OSX), it starts with sys.prefix and sys.exec_prefix (if different) and appends lib/python<version>/site-packages as well as lib/site-python. On other platforms (such as Windows), it tries each of the prefixes directly, as well as with lib/site-packages appended. The resulting directories, if they exist, are appended to sys.path, and also inspected for path configuration files. A path configuration file is a file whose name has the form <package>.pth; its contents are additional directories (one per line) to be added to sys.path. Non-existing directories (or non-directories) are never added to sys.path; no directory is added to sys.path more than once. Blank lines and lines beginning with '#' are skipped. Lines starting with 'import' are executed. For example, suppose sys.prefix and sys.exec_prefix are set to /usr/local and there is a directory /usr/local/lib/python2.5/site-packages with three subdirectories, foo, bar and spam, and two path configuration files, foo.pth and bar.pth. Assume foo.pth contains the following: # foo package configuration foo bar bletch and bar.pth contains: # bar package configuration bar Then the following directories are added to sys.path, in this order: /usr/local/lib/python2.5/site-packages/bar /usr/local/lib/python2.5/site-packages/foo Note that bletch is omitted because it doesn't exist; bar precedes foo because bar.pth comes alphabetically before foo.pth; and spam is omitted because it is not mentioned in either path configuration file. After these path manipulations, an attempt is made to import a module named sitecustomize, which can perform arbitrary additional site-specific customizations. If this import fails with an ImportError exception, it is silently ignored. """ import sys import os import __builtin__ PREFIXES = [ sys . prefix , sys . exec_prefix ] ENABLE_USER_SITE = None USER_SITE = None USER_BASE = None def makepath ( * paths ) : dir = os . path . abspath ( os . path . join ( * paths ) ) return dir , os . path . normcase ( dir ) def abs__file__ ( ) : for m in sys . modules . values ( ) : if hasattr ( m , '__loader__' ) : continue try : m . __file__ = os . path . abspath ( m . __file__ ) except AttributeError : continue def removeduppaths ( ) : L = [ ] known_paths = set ( ) for dir in sys . path : dir , dircase = makepath ( dir ) if not dircase in known_paths : L . append ( dir ) known_paths . add ( dircase ) sys . path [ : ] = L return known_paths def addbuilddir ( ) : from distutils . util import get_platform s = "build/lib.%s-%.3s" % ( get_platform ( ) , sys . version ) if hasattr ( sys , 'gettotalrefcount' ) : s += '-pydebug' s = os . path . join ( os . path . dirname ( sys . path [ - 1 ] ) , s ) sys . path . append ( s ) def _init_pathinfo ( ) : d = set ( ) for dir in sys . path : try : if os . path . isdir ( dir ) : dir , dircase = makepath ( dir ) d . add ( dircase ) except TypeError : continue return d def addpackage ( sitedir , name , known_paths ) : if known_paths is None : _init_pathinfo ( ) reset = 1 else : reset = 0 fullname = os . path . join ( sitedir , name ) try : f = open ( fullname , "rU" ) except IOError : return with f : for line in f : if line . startswith ( "#" ) : continue if line . startswith ( ( "import " , "import\t" ) ) : exec line continue line = line . rstrip ( ) dir , dircase = makepath ( sitedir , line ) if not dircase in known_paths and os . path . exists ( dir ) : sys . path . append ( dir ) known_paths . add ( dircase ) if reset : known_paths = None return known_paths def addsitedir ( sitedir , known_paths = None ) : if known_paths is None : known_paths = _init_pathinfo ( ) reset = 1 else : reset = 0 sitedir , sitedircase = makepath ( sitedir ) if not sitedircase in known_paths : sys . path . append ( sitedir ) try : names = os . listdir ( sitedir ) except os . error : return dotpth = os . extsep + "pth" names = [ name for name in names if name . endswith ( dotpth ) ] for name in sorted ( names ) : addpackage ( sitedir , name , known_paths ) if reset : known_paths = None return known_paths def check_enableusersite ( ) : if sys . flags . no_user_site : return False if hasattr ( os , "getuid" ) and hasattr ( os , "geteuid" ) : if os . geteuid ( ) != os . getuid ( ) : return None if hasattr ( os , "getgid" ) and hasattr ( os , "getegid" ) : if os . getegid ( ) != os . getgid ( ) : return None return True def addusersitepackages ( known_paths ) : global USER_BASE , USER_SITE , ENABLE_USER_SITE env_base = os . environ . get ( "PYTHONUSERBASE" , None ) def joinuser ( * args ) : return os . path . expanduser ( os . path . join ( * args ) ) if os . name == "nt" : base = os . environ . get ( "APPDATA" ) or "~" USER_BASE = env_base if env_base else joinuser ( base , "Python" ) USER_SITE = os . path . join ( USER_BASE , + sys . version [ 0 ] + sys . version [ 2 ] , ) else : USER_BASE = env_base if env_base else joinuser ( "~" , ".local" ) USER_SITE = os . path . join ( USER_BASE , "lib" , + sys . version [ : 3 ] , ) if ENABLE_USER_SITE and os . path . isdir ( USER_SITE ) : addsitedir ( USER_SITE , known_paths ) return known_paths def addsitepackages ( known_paths ) : sitedirs = [ ] seen = [ ] for prefix in PREFIXES : if not prefix or prefix in seen : continue seen . append ( prefix ) if sys . platform in ( 'os2emx' , 'riscos' ) : sitedirs . append ( os . path . join ( prefix , "Lib" , "site-packages" ) ) elif os . sep == '/' : sitedirs . append ( os . path . join ( prefix , "lib" , + sys . version [ : 3 ] , ) ) sitedirs . append ( os . path . join ( prefix , "lib" , "site-python" ) ) else : sitedirs . append ( prefix ) sitedirs . append ( os . path . join ( prefix , "lib" , "site-packages" ) ) if sys . platform == "darwin" : if 'Python.framework' in prefix : sitedirs . append ( os . path . expanduser ( os . path . join ( "~" , "Library" , "Python" , sys . version [ : 3 ] , "site-packages" ) ) ) for sitedir in sitedirs : if os . path . isdir ( sitedir ) : addsitedir ( sitedir , known_paths ) return known_paths def setBEGINLIBPATH ( ) : dllpath = os . path . join ( sys . prefix , "Lib" , "lib-dynload" ) libpath = os . environ [ 'BEGINLIBPATH' ] . split ( ';' ) if libpath [ - 1 ] : libpath . append ( dllpath ) else : libpath [ - 1 ] = dllpath os . environ [ 'BEGINLIBPATH' ] = ';' . join ( libpath ) def setquit ( ) : if os . sep == ':' : eof = 'Cmd-Q' elif os . sep == '\\' : eof = 'Ctrl-Z plus Return' else : eof = 'Ctrl-D (i.e. EOF)' class Quitter ( object ) : def __init__ ( self , name ) : self . name = name def __repr__ ( self ) : return 'Use %s() or %s to exit' % ( self . name , eof ) def __call__ ( self , code = None ) : try : sys . stdin . close ( ) except : pass raise SystemExit ( code ) __builtin__ . quit = Quitter ( 'quit' ) __builtin__ . exit = Quitter ( 'exit' ) class _Printer ( object ) : MAXLINES = 23 def __init__ ( self , name , data , files = ( ) , dirs = ( ) ) : self . __name = name self . __data = data self . __files = files self . __dirs = dirs self . __lines = None def __setup ( self ) : if self . __lines : return data = None for dir in self . __dirs : for filename in self . __files : filename = os . path . join ( dir , filename ) try : fp = file ( filename , "rU" ) data = fp . read ( ) fp . close ( ) break except IOError : pass if data : break if not data : data = self . __data self . __lines = data . split ( '\n' ) self . __linecnt = len ( self . __lines ) def __repr__ ( self ) : self . __setup ( ) if len ( self . __lines ) <= self . MAXLINES : return "\n" . join ( self . __lines ) else : return "Type %s() to see the full %s text" % ( ( self . __name , ) * 2 ) def __call__ ( self ) : self . __setup ( ) prompt = 'Hit Return for more, or q (and Return) to quit: ' lineno = 0 while 1 : try : for i in range ( lineno , lineno + self . MAXLINES ) : print self . __lines [ i ] except IndexError : break else : lineno += self . MAXLINES key = None while key is None : key = raw_input ( prompt ) if key not in ( '' , 'q' ) : key = None if key == 'q' : break def setcopyright ( ) : __builtin__ . copyright = _Printer ( "copyright" , sys . copyright ) if sys . platform [ : 4 ] == 'java' : __builtin__ . credits = _Printer ( , ) else : __builtin__ . credits = _Printer ( "credits" , """\ Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands for supporting Python development. See www.python.org for more information.""" ) here = os . path . dirname ( os . __file__ ) __builtin__ . license = _Printer ( , "See http://www.python.org/%.3s/license.html" % sys . version , [ "LICENSE.txt" , "LICENSE" ] , [ os . path . join ( here , os . pardir ) , here , os . curdir ] ) class _Helper ( object ) : def __repr__ ( self ) : return "Type help() for interactive help, " "or help(object) for help about object." def __call__ ( self , * args , ** kwds ) : import pydoc return pydoc . help ( * args , ** kwds ) def sethelper ( ) : __builtin__ . help = _Helper ( ) def aliasmbcs ( ) : if sys . platform == 'win32' : import locale , codecs enc = locale . getdefaultlocale ( ) [ 1 ] if enc . startswith ( 'cp' ) : try : codecs . lookup ( enc ) except LookupError : import encodings encodings . _cache [ enc ] = encodings . _unknown encodings . aliases . aliases [ enc ] = 'mbcs' def setencoding ( ) : encoding = "ascii" if 0 : import locale loc = locale . getdefaultlocale ( ) if loc [ 1 ] : encoding = loc [ 1 ] if 0 : encoding = "undefined" if encoding != "ascii" : sys . setdefaultencoding ( encoding ) def execsitecustomize ( ) : try : import sitecustomize except ImportError : pass def execusercustomize ( ) : try : import usercustomize except ImportError : pass def main ( ) : global ENABLE_USER_SITE abs__file__ ( ) known_paths = removeduppaths ( ) if ( os . name == "posix" and sys . path and os . path . basename ( sys . path [ - 1 ] ) == "Modules" ) : addbuilddir ( ) if ENABLE_USER_SITE is None : ENABLE_USER_SITE = check_enableusersite ( ) known_paths = addusersitepackages ( known_paths ) known_paths = addsitepackages ( known_paths ) if sys . platform == 'os2emx' : setBEGINLIBPATH ( ) setquit ( ) setcopyright ( ) sethelper ( ) aliasmbcs ( ) setencoding ( ) execsitecustomize ( ) if ENABLE_USER_SITE : execusercustomize ( ) if hasattr ( sys , "setdefaultencoding" ) : del sys . setdefaultencoding main ( ) def _script ( ) : help = """\ %s [--user-base] [--user-site] Without arguments print some useful information With arguments print the value of USER_BASE and/or USER_SITE separated by '%s'. Exit codes with --user-base or --user-site: 0 - user site directory is enabled 1 - user site directory is disabled by user 2 - uses site directory is disabled by super user or for security reasons >2 - unknown error """ args = sys . argv [ 1 : ] if not args : print "sys.path = [" for dir in sys . path : print " %r," % ( dir , ) print "]" print "USER_BASE: %r (%s)" % ( USER_BASE , if os . path . isdir ( USER_BASE ) else "doesn't exist" ) print "USER_SITE: %r (%s)" % ( USER_SITE , if os . path . isdir ( USER_SITE ) else "doesn't exist" ) print "ENABLE_USER_SITE: %r" % ENABLE_USER_SITE sys . exit ( 0 ) buffer = [ ] if '--user-base' in args : buffer . append ( USER_BASE ) if '--user-site' in args : buffer . append ( USER_SITE ) if buffer : print os . pathsep . join ( buffer ) if ENABLE_USER_SITE : sys . exit ( 0 ) elif ENABLE_USER_SITE is False : sys . exit ( 1 ) elif ENABLE_USER_SITE is None : sys . exit ( 2 ) else : sys . exit ( 3 ) else : import textwrap print textwrap . dedent ( help % ( sys . argv [ 0 ] , os . pathsep ) ) sys . exit ( 10 ) if __name__ == '__main__' : _script ( )

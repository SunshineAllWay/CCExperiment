'''Cursor control and color for the Windows console. This was modeled after the C extension of the same name by Fredrik Lundh. ''' import sys import traceback import re from pyreadline . logger import log , log_sock from pyreadline . unicode_helper import ensure_unicode , ensure_str import pyreadline . unicode_helper as unicode_helper try : from ctypes import * from _ctypes import call_function except ImportError : raise ImportError ( "You need ctypes to run this code" ) from pyreadline . keysyms import make_KeyPress from pyreadline . console . ansi import AnsiState , AnsiWriter STD_INPUT_HANDLE = - 10 STD_OUTPUT_HANDLE = - 11 ENABLE_WINDOW_INPUT = 0x0008 ENABLE_MOUSE_INPUT = 0x0010 ENABLE_PROCESSED_INPUT = 0x0001 WHITE = 0x7 BLACK = 0 MENU_EVENT = 0x0008 KEY_EVENT = 0x0001 MOUSE_MOVED = 0x0001 MOUSE_EVENT = 0x0002 WINDOW_BUFFER_SIZE_EVENT = 0x0004 FOCUS_EVENT = 0x0010 MENU_EVENT = 0x0008 VK_SHIFT = 0x10 VK_CONTROL = 0x11 VK_MENU = 0x12 GENERIC_READ = int ( 0x80000000L ) GENERIC_WRITE = 0x40000000 class COORD ( Structure ) : _fields_ = [ ( "X" , c_short ) , ( "Y" , c_short ) ] class SMALL_RECT ( Structure ) : _fields_ = [ ( "Left" , c_short ) , ( "Top" , c_short ) , ( "Right" , c_short ) , ( "Bottom" , c_short ) ] class CONSOLE_SCREEN_BUFFER_INFO ( Structure ) : _fields_ = [ ( "dwSize" , COORD ) , ( "dwCursorPosition" , COORD ) , ( "wAttributes" , c_short ) , ( "srWindow" , SMALL_RECT ) , ( "dwMaximumWindowSize" , COORD ) ] class CHAR_UNION ( Union ) : _fields_ = [ ( "UnicodeChar" , c_wchar ) , ( "AsciiChar" , c_char ) ] class CHAR_INFO ( Structure ) : _fields_ = [ ( "Char" , CHAR_UNION ) , ( "Attributes" , c_short ) ] class KEY_EVENT_RECORD ( Structure ) : _fields_ = [ ( "bKeyDown" , c_byte ) , ( "pad2" , c_byte ) , ( 'pad1' , c_short ) , ( "wRepeatCount" , c_short ) , ( "wVirtualKeyCode" , c_short ) , ( "wVirtualScanCode" , c_short ) , ( "uChar" , CHAR_UNION ) , ( "dwControlKeyState" , c_int ) ] class MOUSE_EVENT_RECORD ( Structure ) : _fields_ = [ ( "dwMousePosition" , COORD ) , ( "dwButtonState" , c_int ) , ( "dwControlKeyState" , c_int ) , ( "dwEventFlags" , c_int ) ] class WINDOW_BUFFER_SIZE_RECORD ( Structure ) : _fields_ = [ ( "dwSize" , COORD ) ] class MENU_EVENT_RECORD ( Structure ) : _fields_ = [ ( "dwCommandId" , c_uint ) ] class FOCUS_EVENT_RECORD ( Structure ) : _fields_ = [ ( "bSetFocus" , c_byte ) ] class INPUT_UNION ( Union ) : _fields_ = [ ( "KeyEvent" , KEY_EVENT_RECORD ) , ( "MouseEvent" , MOUSE_EVENT_RECORD ) , ( "WindowBufferSizeEvent" , WINDOW_BUFFER_SIZE_RECORD ) , ( "MenuEvent" , MENU_EVENT_RECORD ) , ( "FocusEvent" , FOCUS_EVENT_RECORD ) ] class INPUT_RECORD ( Structure ) : _fields_ = [ ( "EventType" , c_short ) , ( "Event" , INPUT_UNION ) ] class CONSOLE_CURSOR_INFO ( Structure ) : _fields_ = [ ( "dwSize" , c_int ) , ( "bVisible" , c_byte ) ] funcs = [ , , , , , , , , , , , , , , , , , , , , , , , , ] key_modifiers = { VK_SHIFT : 1 , VK_CONTROL : 1 , VK_MENU : 1 , 0x5b : 1 , } class Console ( object ) : def __init__ ( self , newbuffer = 0 ) : if newbuffer : self . hout = self . CreateConsoleScreenBuffer ( GENERIC_READ | GENERIC_WRITE , 0 , None , 1 , None ) self . SetConsoleActiveScreenBuffer ( self . hout ) else : self . hout = self . GetStdHandle ( STD_OUTPUT_HANDLE ) self . hin = self . GetStdHandle ( STD_INPUT_HANDLE ) self . inmode = c_int ( 0 ) self . GetConsoleMode ( self . hin , byref ( self . inmode ) ) self . SetConsoleMode ( self . hin , 0xf ) info = CONSOLE_SCREEN_BUFFER_INFO ( ) self . GetConsoleScreenBufferInfo ( self . hout , byref ( info ) ) self . attr = info . wAttributes self . saveattr = info . wAttributes self . defaultstate = AnsiState ( ) self . defaultstate . winattr = info . wAttributes self . ansiwriter = AnsiWriter ( self . defaultstate ) background = self . attr & 0xf0 for escape in self . escape_to_color : if self . escape_to_color [ escape ] is not None : self . escape_to_color [ escape ] |= background log ( 'initial attr=%x' % self . attr ) self . softspace = 0 self . serial = 0 self . pythondll = CDLL ( 'python%s%s' % ( sys . version [ 0 ] , sys . version [ 2 ] ) ) self . inputHookPtr = c_int . from_address ( addressof ( self . pythondll . PyOS_InputHook ) ) . value setattr ( Console , 'PyMem_Malloc' , self . pythondll . PyMem_Malloc ) def __del__ ( self ) : self . SetConsoleTextAttribute ( self . hout , self . saveattr ) self . SetConsoleMode ( self . hin , self . inmode ) self . FreeConsole ( ) def _get_top_bot ( self ) : info = CONSOLE_SCREEN_BUFFER_INFO ( ) self . GetConsoleScreenBufferInfo ( self . hout , byref ( info ) ) rect = info . srWindow top = rect . Top bot = rect . Bottom return top , bot def fixcoord ( self , x , y ) : if x < 0 or y < 0 : info = CONSOLE_SCREEN_BUFFER_INFO ( ) self . GetConsoleScreenBufferInfo ( self . hout , byref ( info ) ) if x < 0 : x = info . srWindow . Right - x y = info . srWindow . Bottom + y return c_int ( y << 16 | x ) def pos ( self , x = None , y = None ) : if x is None : info = CONSOLE_SCREEN_BUFFER_INFO ( ) self . GetConsoleScreenBufferInfo ( self . hout , byref ( info ) ) return ( info . dwCursorPosition . X , info . dwCursorPosition . Y ) else : return self . SetConsoleCursorPosition ( self . hout , self . fixcoord ( x , y ) ) def home ( self ) : self . pos ( 0 , 0 ) terminal_escape = re . compile ( '(\001?\033\\[[0-9;]+m\002?)' ) escape_parts = re . compile ( '\001?\033\\[([0-9;]+)m\002?' ) escape_to_color = { '0;30' : 0x0 , : 0x4 , : 0x2 , : 0x4 + 0x2 , : 0x1 , : 0x1 + 0x4 , : 0x2 + 0x4 , : 0x1 + 0x2 + 0x4 , : 0x1 + 0x2 + 0x4 , : 0x4 + 0x8 , : 0x2 + 0x8 , : 0x4 + 0x2 + 0x8 , : 0x1 + 0x8 , : 0x1 + 0x4 + 0x8 , : 0x1 + 0x2 + 0x8 , : 0x1 + 0x2 + 0x4 + 0x8 , : None , } motion_char_re = re . compile ( '([\n\r\t\010\007])' ) def write_scrolling ( self , text , attr = None ) : x , y = self . pos ( ) w , h = self . size ( ) scroll = 0 chunks = self . motion_char_re . split ( text ) for chunk in chunks : log ( 'C:' + chunk ) n = self . write_color ( chunk , attr ) if len ( chunk ) == 1 : if chunk [ 0 ] == '\n' : x = 0 y += 1 elif chunk [ 0 ] == '\r' : x = 0 elif chunk [ 0 ] == '\t' : x = 8 * ( int ( x / 8 ) + 1 ) if x > w : x -= w y += 1 elif chunk [ 0 ] == '\007' : pass elif chunk [ 0 ] == '\010' : x -= 1 if x < 0 : y -= 1 else : x += 1 if x == w : x = 0 y += 1 if y == h : scroll += 1 y = h - 1 else : x += n l = int ( x / w ) x = x % w y += l if y >= h : scroll += y - h + 1 y = h - 1 return scroll def write_color ( self , text , attr = None ) : log ( 'write_color("%s", %s)' % ( text , attr ) ) chunks = self . terminal_escape . split ( text ) log ( 'chunks=%s' % repr ( chunks ) ) junk = c_int ( 0 ) n = 0 for chunk in chunks : m = self . escape_parts . match ( chunk ) if m : attr = self . escape_to_color [ m . group ( 1 ) ] continue n += len ( chunk ) log ( 'attr=%s' % attr ) if attr is None : attr = self . attr self . SetConsoleTextAttribute ( self . hout , attr ) return n def write_color ( self , text , attr = None ) : text = ensure_unicode ( text ) n , res = self . ansiwriter . write_color ( text , attr ) junk = c_int ( 0 ) for attr , chunk in res : log ( unicode ( attr ) ) log ( unicode ( chunk ) ) self . SetConsoleTextAttribute ( self . hout , attr . winattr ) self . WriteConsoleW ( self . hout , chunk , len ( chunk ) , byref ( junk ) , None ) return n def write_plain ( self , text , attr = None ) : log ( 'write("%s", %s)' % ( text , attr ) ) if attr is None : attr = self . attr n = c_int ( 0 ) self . SetConsoleTextAttribute ( self . hout , attr ) self . WriteConsoleW ( self . hout , ensure_unicode ( chunk ) , len ( chunk ) , byref ( junk ) , None ) return len ( text ) def write ( self , text ) : log ( 'write("%s")' % text ) return self . write_color ( text ) def isatty ( self ) : return True def flush ( self ) : pass def page ( self , attr = None , fill = ' ' ) : if attr is None : attr = self . attr if len ( fill ) != 1 : raise ValueError info = CONSOLE_SCREEN_BUFFER_INFO ( ) self . GetConsoleScreenBufferInfo ( self . hout , byref ( info ) ) if info . dwCursorPosition . X != 0 or info . dwCursorPosition . Y != 0 : self . SetConsoleCursorPosition ( self . hout , self . fixcoord ( 0 , 0 ) ) w = info . dwSize . X n = c_int ( 0 ) for y in range ( info . dwSize . Y ) : self . FillConsoleOutputAttribute ( self . hout , attr , w , self . fixcoord ( 0 , y ) , byref ( n ) ) self . FillConsoleOutputCharacterW ( self . hout , ord ( fill [ 0 ] ) , w , self . fixcoord ( 0 , y ) , byref ( n ) ) self . attr = attr def text ( self , x , y , text , attr = None ) : if attr is None : attr = self . attr pos = self . fixcoord ( x , y ) n = c_int ( 0 ) self . WriteConsoleOutputCharacterW ( self . hout , text , len ( text ) , pos , byref ( n ) ) self . FillConsoleOutputAttribute ( self . hout , attr , n , pos , byref ( n ) ) def clear_to_end_of_window ( self ) : top , bot = self . _get_top_bot ( ) pos = self . pos ( ) w , h = self . size ( ) self . rectangle ( ( pos [ 0 ] , pos [ 1 ] , w , pos [ 1 ] + 1 ) ) if pos [ 1 ] < bot : self . rectangle ( ( 0 , pos [ 1 ] + 1 , w , bot + 1 ) ) def rectangle ( self , rect , attr = None , fill = ' ' ) : x0 , y0 , x1 , y1 = rect n = c_int ( 0 ) if attr is None : attr = self . attr for y in range ( y0 , y1 ) : pos = self . fixcoord ( x0 , y ) self . FillConsoleOutputAttribute ( self . hout , attr , x1 - x0 , pos , byref ( n ) ) self . FillConsoleOutputCharacterW ( self . hout , ord ( fill [ 0 ] ) , x1 - x0 , pos , byref ( n ) ) def scroll ( self , rect , dx , dy , attr = None , fill = ' ' ) : if attr is None : attr = self . attr x0 , y0 , x1 , y1 = rect source = SMALL_RECT ( x0 , y0 , x1 - 1 , y1 - 1 ) dest = self . fixcoord ( x0 + dx , y0 + dy ) style = CHAR_INFO ( ) style . Char . AsciiChar = fill [ 0 ] style . Attributes = attr return self . ScrollConsoleScreenBufferW ( self . hout , byref ( source ) , byref ( source ) , dest , byref ( style ) ) def scroll_window ( self , lines ) : info = CONSOLE_SCREEN_BUFFER_INFO ( ) self . GetConsoleScreenBufferInfo ( self . hout , byref ( info ) ) rect = info . srWindow log ( 'sw: rtop=%d rbot=%d' % ( rect . Top , rect . Bottom ) ) top = rect . Top + lines bot = rect . Bottom + lines h = bot - top maxbot = info . dwSize . Y - 1 if top < 0 : top = 0 bot = h if bot > maxbot : bot = maxbot top = bot - h nrect = SMALL_RECT ( ) nrect . Top = top nrect . Bottom = bot nrect . Left = rect . Left nrect . Right = rect . Right log ( 'sn: top=%d bot=%d' % ( top , bot ) ) r = self . SetConsoleWindowInfo ( self . hout , True , byref ( nrect ) ) log ( 'r=%d' % r ) def get ( self ) : inputHookFunc = c_int . from_address ( self . inputHookPtr ) . value Cevent = INPUT_RECORD ( ) count = c_int ( 0 ) while 1 : if inputHookFunc : call_function ( inputHookFunc , ( ) ) status = self . ReadConsoleInputW ( self . hin , byref ( Cevent ) , 1 , byref ( count ) ) if status and count . value == 1 : e = event ( self , Cevent ) log_sock ( ensure_unicode ( e . keyinfo ) , "keypress" ) return e def getkeypress ( self ) : while 1 : e = self . get ( ) if e . type == 'KeyPress' and e . keycode not in key_modifiers : log ( e ) if e . keyinfo . keyname == 'next' : self . scroll_window ( 12 ) elif e . keyinfo . keyname == 'prior' : self . scroll_window ( - 12 ) else : return e elif e . type == 'KeyRelease' and e . keyinfo == ( True , False , False , 83 ) : log ( "getKeypress:%s,%s,%s" % ( e . keyinfo , e . keycode , e . type ) ) return e def getchar ( self ) : Cevent = INPUT_RECORD ( ) count = c_int ( 0 ) while 1 : status = self . ReadConsoleInputW ( self . hin , byref ( Cevent ) , 1 , byref ( count ) ) if ( status and count . value == 1 and Cevent . EventType == 1 and Cevent . Event . KeyEvent . bKeyDown ) : sym = keysym ( Cevent . Event . KeyEvent . wVirtualKeyCode ) if len ( sym ) == 0 : sym = Cevent . Event . KeyEvent . uChar . AsciiChar return sym def peek ( self ) : Cevent = INPUT_RECORD ( ) count = c_int ( 0 ) status = self . PeekConsoleInputW ( self . hin , byref ( Cevent ) , 1 , byref ( count ) ) if status and count == 1 : return event ( self , Cevent ) def title ( self , txt = None ) : if txt : self . SetConsoleTitleW ( txt ) else : buffer = create_unicode_buffer ( 200 ) n = self . GetConsoleTitleW ( buffer , 200 ) if n > 0 : return buffer . value [ : n ] def size ( self , width = None , height = None ) : info = CONSOLE_SCREEN_BUFFER_INFO ( ) status = self . GetConsoleScreenBufferInfo ( self . hout , byref ( info ) ) if not status : return None if width is not None and height is not None : wmin = info . srWindow . Right - info . srWindow . Left + 1 hmin = info . srWindow . Bottom - info . srWindow . Top + 1 width = max ( width , wmin ) height = max ( height , hmin ) self . SetConsoleScreenBufferSize ( self . hout , self . fixcoord ( width , height ) ) else : return ( info . dwSize . X , info . dwSize . Y ) def cursor ( self , visible = None , size = None ) : info = CONSOLE_CURSOR_INFO ( ) if self . GetConsoleCursorInfo ( self . hout , byref ( info ) ) : if visible is not None : info . bVisible = visible if size is not None : info . dwSize = size self . SetConsoleCursorInfo ( self . hout , byref ( info ) ) def bell ( self ) : self . write ( '\007' ) def next_serial ( self ) : self . serial += 1 return self . serial for func in funcs : setattr ( Console , func , getattr ( windll . kernel32 , func ) ) windll . kernel32 . SetConsoleTitleW . argtypes = [ c_wchar_p ] windll . kernel32 . GetConsoleTitleW . argtypes = [ c_wchar_p , c_short ] from event import Event VkKeyScan = windll . user32 . VkKeyScanA class event ( Event ) : def __init__ ( self , console , input ) : self . type = '??' self . serial = console . next_serial ( ) self . width = 0 self . height = 0 self . x = 0 self . y = 0 self . char = '' self . keycode = 0 self . keysym = '??' self . keyinfo = None self . width = None if input . EventType == KEY_EVENT : if input . Event . KeyEvent . bKeyDown : self . type = "KeyPress" else : self . type = "KeyRelease" self . char = input . Event . KeyEvent . uChar . UnicodeChar self . keycode = input . Event . KeyEvent . wVirtualKeyCode self . state = input . Event . KeyEvent . dwControlKeyState self . keyinfo = make_KeyPress ( self . char , self . state , self . keycode ) elif input . EventType == MOUSE_EVENT : if input . Event . MouseEvent . dwEventFlags & MOUSE_MOVED : self . type = "Motion" else : self . type = "Button" self . x = input . Event . MouseEvent . dwMousePosition . X self . y = input . Event . MouseEvent . dwMousePosition . Y self . state = input . Event . MouseEvent . dwButtonState elif input . EventType == WINDOW_BUFFER_SIZE_EVENT : self . type = "Configure" self . width = input . Event . WindowBufferSizeEvent . dwSize . X self . height = input . Event . WindowBufferSizeEvent . dwSize . Y elif input . EventType == FOCUS_EVENT : if input . Event . FocusEvent . bSetFocus : self . type = "FocusIn" else : self . type = "FocusOut" elif input . EventType == MENU_EVENT : self . type = "Menu" self . state = input . Event . MenuEvent . dwCommandId def getconsole ( buffer = 1 ) : c = Console ( buffer ) return c HOOKFUNC22 = CFUNCTYPE ( c_char_p , c_char_p ) HOOKFUNC23 = CFUNCTYPE ( c_char_p , c_void_p , c_void_p , c_char_p ) readline_hook = None readline_ref = None def hook_wrapper_23 ( stdin , stdout , prompt ) : try : res = ensure_str ( readline_hook ( prompt ) ) if res and not isinstance ( res , str ) : raise TypeError , 'readline must return a string.' except KeyboardInterrupt : return 0 except EOFError : res = '' except : print >> sys . stderr , 'Readline internal error' traceback . print_exc ( ) res = '\n' n = len ( res ) p = Console . PyMem_Malloc ( n + 1 ) cdll . msvcrt . strncpy ( p , res , n + 1 ) return p def hook_wrapper ( prompt ) : try : res = ensure_str ( readline_hook ( prompt ) ) if res and not isinstance ( res , str ) : raise TypeError , 'readline must return a string.' except KeyboardInterrupt : return 0 except EOFError : res = '' except : print >> sys . stderr , 'Readline internal error' traceback . print_exc ( ) res = '\n' p = cdll . msvcrt . _strdup ( res ) return p def install_readline ( hook ) : global readline_hook , readline_ref readline_hook = hook PyOS_RFP = c_int . from_address ( Console . GetProcAddress ( sys . dllhandle , ) ) if sys . version < '2.3' : readline_ref = HOOKFUNC22 ( hook_wrapper ) else : readline_ref = HOOKFUNC23 ( hook_wrapper_23 ) func_start = c_int . from_address ( addressof ( readline_ref ) ) . value PyOS_RFP . value = func_start if __name__ == '__main__' : import time , sys def p ( char ) : return chr ( VkKeyScan ( ord ( char ) ) & 0xff ) c = Console ( 0 ) sys . stdout = c sys . stderr = c c . page ( ) print p ( "d" ) , p ( "D" ) c . pos ( 5 , 10 ) c . write ( 'hi there' ) print 'some printed output' for i in range ( 10 ) : q = c . getkeypress ( ) print q del c

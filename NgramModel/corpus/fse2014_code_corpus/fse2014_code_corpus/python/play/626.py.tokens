"""HTTP cookie handling for web clients. This module originally developed from my port of Gisle Aas' Perl module HTTP::Cookies, from the libwww-perl library. Docstrings, comments and debug strings in this code refer to the attributes of the HTTP cookie system as cookie-attributes, to distinguish them clearly from Python attributes. CookieJar____ / \ \ FileCookieJar \ \ / | \ \ \ MozillaCookieJar | LWPCookieJar \ \ | | \ | ---MSIEBase | \ | / | | \ | / MSIEDBCookieJar BSDDBCookieJar |/ MSIECookieJar Comments to John J Lee <jjl@pobox.com>. Copyright 2002-2006 John J Lee <jjl@pobox.com> Copyright 1997-1999 Gisle Aas (original libwww-perl code) Copyright 2002-2003 Johnny Lee (original MSIE Perl code) This code is free software; you can redistribute it and/or modify it under the terms of the BSD or ZPL 2.1 licenses (see the file COPYING.txt included with the distribution). """ import sys , re , copy , time , urllib , types , logging try : import threading _threading = threading ; del threading except ImportError : import dummy_threading _threading = dummy_threading ; del dummy_threading MISSING_FILENAME_TEXT = ( "a filename was not supplied (nor was the CookieJar " ) DEFAULT_HTTP_PORT = "80" from _headersutil import split_header_words , parse_ns_headers from _util import isstringlike import _rfc3986 debug = logging . getLogger ( "mechanize.cookies" ) . debug def reraise_unmasked_exceptions ( unmasked = ( ) ) : import mechanize , warnings if not mechanize . USE_BARE_EXCEPT : raise unmasked = unmasked + ( KeyboardInterrupt , SystemExit , MemoryError ) etype = sys . exc_info ( ) [ 0 ] if issubclass ( etype , unmasked ) : raise import traceback , StringIO f = StringIO . StringIO ( ) traceback . print_exc ( None , f ) msg = f . getvalue ( ) warnings . warn ( "mechanize bug!\n%s" % msg , stacklevel = 2 ) IPV4_RE = re . compile ( r"\.\d+$" ) def is_HDN ( text ) : return not ( IPV4_RE . search ( text ) or text == "" or text [ 0 ] == "." or text [ - 1 ] == "." ) def domain_match ( A , B ) : A = A . lower ( ) B = B . lower ( ) if A == B : return True if not is_HDN ( A ) : return False i = A . rfind ( B ) has_form_nb = not ( i == - 1 or i == 0 ) return ( has_form_nb and B . startswith ( "." ) and is_HDN ( B [ 1 : ] ) ) def liberal_is_HDN ( text ) : return not IPV4_RE . search ( text ) def user_domain_match ( A , B ) : A = A . lower ( ) B = B . lower ( ) if not ( liberal_is_HDN ( A ) and liberal_is_HDN ( B ) ) : if A == B : return True return False initial_dot = B . startswith ( "." ) if initial_dot and A . endswith ( B ) : return True if not initial_dot and A == B : return True return False cut_port_re = re . compile ( r":\d+$" ) def request_host ( request ) : url = request . get_full_url ( ) host = _rfc3986 . urlsplit ( url ) [ 1 ] if host is None : host = request . get_header ( "Host" , "" ) return cut_port_re . sub ( "" , host , 1 ) def request_host_lc ( request ) : return request_host ( request ) . lower ( ) def eff_request_host ( request ) : erhn = req_host = request_host ( request ) if req_host . find ( "." ) == - 1 and not IPV4_RE . search ( req_host ) : erhn = req_host + ".local" return req_host , erhn def eff_request_host_lc ( request ) : req_host , erhn = eff_request_host ( request ) return req_host . lower ( ) , erhn . lower ( ) def effective_request_host ( request ) : return eff_request_host ( request ) [ 1 ] def request_path ( request ) : url = request . get_full_url ( ) path , query , frag = _rfc3986 . urlsplit ( url ) [ 2 : ] path = escape_path ( path ) req_path = _rfc3986 . urlunsplit ( ( None , None , path , query , frag ) ) if not req_path . startswith ( "/" ) : req_path = "/" + req_path return req_path def request_port ( request ) : host = request . get_host ( ) i = host . find ( ':' ) if i >= 0 : port = host [ i + 1 : ] try : int ( port ) except ValueError : debug ( "nonnumeric port: '%s'" , port ) return None else : port = DEFAULT_HTTP_PORT return port def request_is_unverifiable ( request ) : try : return request . is_unverifiable ( ) except AttributeError : if hasattr ( request , "unverifiable" ) : return request . unverifiable else : raise HTTP_PATH_SAFE = "%/;:@&=+$,!~*'()" ESCAPED_CHAR_RE = re . compile ( r"%([0-9a-fA-F][0-9a-fA-F])" ) def uppercase_escaped_char ( match ) : return "%%%s" % match . group ( 1 ) . upper ( ) def escape_path ( path ) : if isinstance ( path , types . UnicodeType ) : path = path . encode ( "utf-8" ) path = urllib . quote ( path , HTTP_PATH_SAFE ) path = ESCAPED_CHAR_RE . sub ( uppercase_escaped_char , path ) return path def reach ( h ) : i = h . find ( "." ) if i >= 0 : b = h [ i + 1 : ] i = b . find ( "." ) if is_HDN ( h ) and ( i >= 0 or b == "local" ) : return "." + b return h def is_third_party ( request ) : req_host = request_host_lc ( request ) return not domain_match ( req_host , reach ( request . origin_req_host ) ) class Cookie : def __init__ ( self , version , name , value , port , port_specified , domain , domain_specified , domain_initial_dot , path , path_specified , secure , expires , discard , comment , comment_url , rest , rfc2109 = False , ) : if version is not None : version = int ( version ) if expires is not None : expires = int ( expires ) if port is None and port_specified is True : raise ValueError ( "if port is None, port_specified must be false" ) self . version = version self . name = name self . value = value self . port = port self . port_specified = port_specified self . domain = domain . lower ( ) self . domain_specified = domain_specified self . domain_initial_dot = domain_initial_dot self . path = path self . path_specified = path_specified self . secure = secure self . expires = expires self . discard = discard self . comment = comment self . comment_url = comment_url self . rfc2109 = rfc2109 self . _rest = copy . copy ( rest ) def has_nonstandard_attr ( self , name ) : return self . _rest . has_key ( name ) def get_nonstandard_attr ( self , name , default = None ) : return self . _rest . get ( name , default ) def set_nonstandard_attr ( self , name , value ) : self . _rest [ name ] = value def nonstandard_attr_keys ( self ) : return self . _rest . keys ( ) def is_expired ( self , now = None ) : if now is None : now = time . time ( ) return ( self . expires is not None ) and ( self . expires <= now ) def __str__ ( self ) : if self . port is None : p = "" else : p = ":" + self . port limit = self . domain + p + self . path if self . value is not None : namevalue = "%s=%s" % ( self . name , self . value ) else : namevalue = self . name return "<Cookie %s for %s>" % ( namevalue , limit ) def __repr__ ( self ) : args = [ ] for name in [ "version" , "name" , "value" , , "port_specified" , , "domain_specified" , "domain_initial_dot" , , "path_specified" , , "expires" , "discard" , "comment" , "comment_url" , ] : attr = getattr ( self , name ) args . append ( "%s=%s" % ( name , repr ( attr ) ) ) args . append ( "rest=%s" % repr ( self . _rest ) ) args . append ( "rfc2109=%s" % repr ( self . rfc2109 ) ) return "Cookie(%s)" % ", " . join ( args ) class CookiePolicy : def set_ok ( self , cookie , request ) : raise NotImplementedError ( ) def return_ok ( self , cookie , request ) : raise NotImplementedError ( ) def domain_return_ok ( self , domain , request ) : return True def path_return_ok ( self , path , request ) : return True class DefaultCookiePolicy ( CookiePolicy ) : DomainStrictNoDots = 1 DomainStrictNonDomain = 2 DomainRFC2965Match = 4 DomainLiberal = 0 DomainStrict = DomainStrictNoDots | DomainStrictNonDomain def __init__ ( self , blocked_domains = None , allowed_domains = None , netscape = True , rfc2965 = False , rfc2109_as_netscape = None , hide_cookie2 = False , strict_domain = False , strict_rfc2965_unverifiable = True , strict_ns_unverifiable = False , strict_ns_domain = DomainLiberal , strict_ns_set_initial_dollar = False , strict_ns_set_path = False , ) : self . netscape = netscape self . rfc2965 = rfc2965 self . rfc2109_as_netscape = rfc2109_as_netscape self . hide_cookie2 = hide_cookie2 self . strict_domain = strict_domain self . strict_rfc2965_unverifiable = strict_rfc2965_unverifiable self . strict_ns_unverifiable = strict_ns_unverifiable self . strict_ns_domain = strict_ns_domain self . strict_ns_set_initial_dollar = strict_ns_set_initial_dollar self . strict_ns_set_path = strict_ns_set_path if blocked_domains is not None : self . _blocked_domains = tuple ( blocked_domains ) else : self . _blocked_domains = ( ) if allowed_domains is not None : allowed_domains = tuple ( allowed_domains ) self . _allowed_domains = allowed_domains def blocked_domains ( self ) : return self . _blocked_domains def set_blocked_domains ( self , blocked_domains ) : self . _blocked_domains = tuple ( blocked_domains ) def is_blocked ( self , domain ) : for blocked_domain in self . _blocked_domains : if user_domain_match ( domain , blocked_domain ) : return True return False def allowed_domains ( self ) : return self . _allowed_domains def set_allowed_domains ( self , allowed_domains ) : if allowed_domains is not None : allowed_domains = tuple ( allowed_domains ) self . _allowed_domains = allowed_domains def is_not_allowed ( self , domain ) : if self . _allowed_domains is None : return False for allowed_domain in self . _allowed_domains : if user_domain_match ( domain , allowed_domain ) : return False return True def set_ok ( self , cookie , request ) : debug ( " - checking cookie %s" , cookie ) assert cookie . name is not None for n in "version" , "verifiability" , "name" , "path" , "domain" , "port" : fn_name = "set_ok_" + n fn = getattr ( self , fn_name ) if not fn ( cookie , request ) : return False return True def set_ok_version ( self , cookie , request ) : if cookie . version is None : debug ( " Set-Cookie2 without version attribute (%s)" , cookie ) return False if cookie . version > 0 and not self . rfc2965 : debug ( " RFC 2965 cookies are switched off" ) return False elif cookie . version == 0 and not self . netscape : debug ( " Netscape cookies are switched off" ) return False return True def set_ok_verifiability ( self , cookie , request ) : if request_is_unverifiable ( request ) and is_third_party ( request ) : if cookie . version > 0 and self . strict_rfc2965_unverifiable : debug ( " third-party RFC 2965 cookie during " ) return False elif cookie . version == 0 and self . strict_ns_unverifiable : debug ( " third-party Netscape cookie during " ) return False return True def set_ok_name ( self , cookie , request ) : if ( cookie . version == 0 and self . strict_ns_set_initial_dollar and cookie . name . startswith ( "$" ) ) : debug ( " illegal name (starts with '$'): '%s'" , cookie . name ) return False return True def set_ok_path ( self , cookie , request ) : if cookie . path_specified : req_path = request_path ( request ) if ( ( cookie . version > 0 or ( cookie . version == 0 and self . strict_ns_set_path ) ) and not req_path . startswith ( cookie . path ) ) : debug ( " path attribute %s is not a prefix of request " , cookie . path , req_path ) return False return True def set_ok_countrycode_domain ( self , cookie , request ) : if cookie . domain_specified and self . strict_domain : domain = cookie . domain assert domain . startswith ( "." ) if domain . count ( "." ) == 2 : i = domain . rfind ( "." ) tld = domain [ i + 1 : ] sld = domain [ 1 : i ] if ( sld . lower ( ) in [ , "ac" , , "edu" , "org" , "net" , "gov" , "mil" , "int" , , "biz" , "cat" , "coop" , "info" , "jobs" , "mobi" , , "name" , "pro" , "travel" , ] and len ( tld ) == 2 ) : return False return True def set_ok_domain ( self , cookie , request ) : if self . is_blocked ( cookie . domain ) : debug ( " domain %s is in user block-list" , cookie . domain ) return False if self . is_not_allowed ( cookie . domain ) : debug ( " domain %s is not in user allow-list" , cookie . domain ) return False if not self . set_ok_countrycode_domain ( cookie , request ) : debug ( " country-code second level domain %s" , cookie . domain ) return False if cookie . domain_specified : req_host , erhn = eff_request_host_lc ( request ) domain = cookie . domain if domain . startswith ( "." ) : undotted_domain = domain [ 1 : ] else : undotted_domain = domain embedded_dots = ( undotted_domain . find ( "." ) >= 0 ) if not embedded_dots and domain != ".local" : debug ( " non-local domain %s contains no embedded dot" , domain ) return False if cookie . version == 0 : if ( not erhn . endswith ( domain ) and ( not erhn . startswith ( "." ) and not ( "." + erhn ) . endswith ( domain ) ) ) : debug ( " effective request-host %s (even with added " , erhn , domain ) return False if ( cookie . version > 0 or ( self . strict_ns_domain & self . DomainRFC2965Match ) ) : if not domain_match ( erhn , domain ) : debug ( " effective request-host %s does not domain-match " , erhn , domain ) return False if ( cookie . version > 0 or ( self . strict_ns_domain & self . DomainStrictNoDots ) ) : host_prefix = req_host [ : - len ( domain ) ] if ( host_prefix . find ( "." ) >= 0 and not IPV4_RE . search ( req_host ) ) : debug ( " host prefix %s for domain %s contains a dot" , host_prefix , domain ) return False return True def set_ok_port ( self , cookie , request ) : if cookie . port_specified : req_port = request_port ( request ) if req_port is None : req_port = "80" else : req_port = str ( req_port ) for p in cookie . port . split ( "," ) : try : int ( p ) except ValueError : debug ( " bad port %s (not numeric)" , p ) return False if p == req_port : break else : debug ( " request port (%s) not found in %s" , req_port , cookie . port ) return False return True def return_ok ( self , cookie , request ) : debug ( " - checking cookie %s" , cookie ) for n in ( "version" , "verifiability" , "secure" , "expires" , "port" , ) : fn_name = "return_ok_" + n fn = getattr ( self , fn_name ) if not fn ( cookie , request ) : return False return True def return_ok_version ( self , cookie , request ) : if cookie . version > 0 and not self . rfc2965 : debug ( " RFC 2965 cookies are switched off" ) return False elif cookie . version == 0 and not self . netscape : debug ( " Netscape cookies are switched off" ) return False return True def return_ok_verifiability ( self , cookie , request ) : if request_is_unverifiable ( request ) and is_third_party ( request ) : if cookie . version > 0 and self . strict_rfc2965_unverifiable : debug ( " third-party RFC 2965 cookie during unverifiable " ) return False elif cookie . version == 0 and self . strict_ns_unverifiable : debug ( " third-party Netscape cookie during unverifiable " ) return False return True def return_ok_secure ( self , cookie , request ) : if cookie . secure and request . get_type ( ) != "https" : debug ( " secure cookie with non-secure request" ) return False return True def return_ok_expires ( self , cookie , request ) : if cookie . is_expired ( self . _now ) : debug ( " cookie expired" ) return False return True def return_ok_port ( self , cookie , request ) : if cookie . port : req_port = request_port ( request ) if req_port is None : req_port = "80" for p in cookie . port . split ( "," ) : if p == req_port : break else : debug ( " request port %s does not match cookie port %s" , req_port , cookie . port ) return False return True def return_ok_domain ( self , cookie , request ) : req_host , erhn = eff_request_host_lc ( request ) domain = cookie . domain if ( cookie . version == 0 and ( self . strict_ns_domain & self . DomainStrictNonDomain ) and not cookie . domain_specified and domain != erhn ) : debug ( " cookie with unspecified domain does not string-compare " ) return False if cookie . version > 0 and not domain_match ( erhn , domain ) : debug ( " effective request-host name %s does not domain-match " , erhn , domain ) return False if cookie . version == 0 and not ( "." + erhn ) . endswith ( domain ) : debug ( " request-host %s does not match Netscape cookie domain " , req_host , domain ) return False return True def domain_return_ok ( self , domain , request ) : dotted_req_host , dotted_erhn = eff_request_host_lc ( request ) if not dotted_req_host . startswith ( "." ) : dotted_req_host = "." + dotted_req_host if not dotted_erhn . startswith ( "." ) : dotted_erhn = "." + dotted_erhn if not ( dotted_req_host . endswith ( domain ) or dotted_erhn . endswith ( domain ) ) : return False if self . is_blocked ( domain ) : debug ( " domain %s is in user block-list" , domain ) return False if self . is_not_allowed ( domain ) : debug ( " domain %s is not in user allow-list" , domain ) return False return True def path_return_ok ( self , path , request ) : debug ( "- checking cookie path=%s" , path ) req_path = request_path ( request ) if not req_path . startswith ( path ) : debug ( " %s does not path-match %s" , req_path , path ) return False return True def vals_sorted_by_key ( adict ) : keys = adict . keys ( ) keys . sort ( ) return map ( adict . get , keys ) class MappingIterator : def __init__ ( self , mapping ) : self . _s = [ ( vals_sorted_by_key ( mapping ) , 0 , None ) ] def __iter__ ( self ) : return self def next ( self ) : while 1 : try : vals , i , prev_item = self . _s . pop ( ) except IndexError : raise StopIteration ( ) if i < len ( vals ) : item = vals [ i ] i = i + 1 self . _s . append ( ( vals , i , prev_item ) ) try : item . items except AttributeError : break else : self . _s . append ( ( vals_sorted_by_key ( item ) , 0 , item ) ) continue return item class Absent : pass class CookieJar : non_word_re = re . compile ( r"\W" ) quote_re = re . compile ( r"([\"\\])" ) strict_domain_re = re . compile ( r"\.?[^.]*" ) domain_re = re . compile ( r"[^.]*" ) dots_re = re . compile ( r"^\.+" ) def __init__ ( self , policy = None ) : if policy is None : policy = DefaultCookiePolicy ( ) self . _policy = policy self . _cookies = { } self . _prev_getitem_index = 0 def get_policy ( self ) : return self . _policy def set_policy ( self , policy ) : self . _policy = policy def _cookies_for_domain ( self , domain , request ) : cookies = [ ] if not self . _policy . domain_return_ok ( domain , request ) : return [ ] debug ( "Checking %s for cookies to return" , domain ) cookies_by_path = self . _cookies [ domain ] for path in cookies_by_path . keys ( ) : if not self . _policy . path_return_ok ( path , request ) : continue cookies_by_name = cookies_by_path [ path ] for cookie in cookies_by_name . values ( ) : if not self . _policy . return_ok ( cookie , request ) : debug ( " not returning cookie" ) continue debug ( " it's a match" ) cookies . append ( cookie ) return cookies def cookies_for_request ( self , request ) : self . _policy . _now = self . _now = int ( time . time ( ) ) cookies = self . _cookies_for_request ( request ) def decreasing_size ( a , b ) : return cmp ( len ( b . path ) , len ( a . path ) ) cookies . sort ( decreasing_size ) return cookies def _cookies_for_request ( self , request ) : cookies = [ ] for domain in self . _cookies . keys ( ) : cookies . extend ( self . _cookies_for_domain ( domain , request ) ) return cookies def _cookie_attrs ( self , cookies ) : version_set = False attrs = [ ] for cookie in cookies : version = cookie . version if not version_set : version_set = True if version > 0 : attrs . append ( "$Version=%s" % version ) if ( ( cookie . value is not None ) and self . non_word_re . search ( cookie . value ) and version > 0 ) : value = self . quote_re . sub ( r"\\\1" , cookie . value ) else : value = cookie . value if cookie . value is None : attrs . append ( cookie . name ) else : attrs . append ( "%s=%s" % ( cookie . name , value ) ) if version > 0 : if cookie . path_specified : attrs . append ( '$Path="%s"' % cookie . path ) if cookie . domain . startswith ( "." ) : domain = cookie . domain if ( not cookie . domain_initial_dot and domain . startswith ( "." ) ) : domain = domain [ 1 : ] attrs . append ( '$Domain="%s"' % domain ) if cookie . port is not None : p = "$Port" if cookie . port_specified : p = p + ( '="%s"' % cookie . port ) attrs . append ( p ) return attrs def add_cookie_header ( self , request ) : debug ( "add_cookie_header" ) cookies = self . cookies_for_request ( request ) attrs = self . _cookie_attrs ( cookies ) if attrs : if not request . has_header ( "Cookie" ) : request . add_unredirected_header ( "Cookie" , "; " . join ( attrs ) ) if self . _policy . rfc2965 and not self . _policy . hide_cookie2 : for cookie in cookies : if cookie . version != 1 and not request . has_header ( "Cookie2" ) : request . add_unredirected_header ( "Cookie2" , '$Version="1"' ) break self . clear_expired_cookies ( ) def _normalized_cookie_tuples ( self , attrs_set ) : cookie_tuples = [ ] boolean_attrs = "discard" , "secure" value_attrs = ( "version" , , "max-age" , , "path" , "port" , , "commenturl" ) for cookie_attrs in attrs_set : name , value = cookie_attrs [ 0 ] max_age_set = False bad_cookie = False standard = { } rest = { } for k , v in cookie_attrs [ 1 : ] : lc = k . lower ( ) if lc in value_attrs or lc in boolean_attrs : k = lc if k in boolean_attrs and v is None : v = True if standard . has_key ( k ) : continue if k == "domain" : if v is None : debug ( " missing value for domain attribute" ) bad_cookie = True break v = v . lower ( ) if k == "expires" : if max_age_set : continue if v is None : debug ( " missing or invalid value for expires " ) continue if k == "max-age" : max_age_set = True if v is None : debug ( " missing value for max-age attribute" ) bad_cookie = True break try : v = int ( v ) except ValueError : debug ( " missing or invalid (non-numeric) value for " ) bad_cookie = True break k = "expires" v = self . _now + v if ( k in value_attrs ) or ( k in boolean_attrs ) : if ( v is None and k not in [ "port" , "comment" , "commenturl" ] ) : debug ( " missing value for %s attribute" % k ) bad_cookie = True break standard [ k ] = v else : rest [ k ] = v if bad_cookie : continue cookie_tuples . append ( ( name , value , standard , rest ) ) return cookie_tuples def _cookie_from_cookie_tuple ( self , tup , request ) : name , value , standard , rest = tup domain = standard . get ( "domain" , Absent ) path = standard . get ( "path" , Absent ) port = standard . get ( "port" , Absent ) expires = standard . get ( "expires" , Absent ) version = standard . get ( "version" , None ) if version is not None : try : version = int ( version ) except ValueError : return None secure = standard . get ( "secure" , False ) discard = standard . get ( "discard" , False ) comment = standard . get ( "comment" , None ) comment_url = standard . get ( "commenturl" , None ) if path is not Absent and path != "" : path_specified = True path = escape_path ( path ) else : path_specified = False path = request_path ( request ) i = path . rfind ( "/" ) if i != - 1 : if version == 0 : path = path [ : i ] else : path = path [ : i + 1 ] if len ( path ) == 0 : path = "/" domain_specified = domain is not Absent domain_initial_dot = False if domain_specified : domain_initial_dot = bool ( domain . startswith ( "." ) ) if domain is Absent : req_host , erhn = eff_request_host_lc ( request ) domain = erhn elif not domain . startswith ( "." ) : domain = "." + domain port_specified = False if port is not Absent : if port is None : port = request_port ( request ) else : port_specified = True port = re . sub ( r"\s+" , "" , port ) else : port = None if expires is Absent : expires = None discard = True return Cookie ( version , name , value , port , port_specified , domain , domain_specified , domain_initial_dot , path , path_specified , secure , expires , discard , comment , comment_url , rest ) def _cookies_from_attrs_set ( self , attrs_set , request ) : cookie_tuples = self . _normalized_cookie_tuples ( attrs_set ) cookies = [ ] for tup in cookie_tuples : cookie = self . _cookie_from_cookie_tuple ( tup , request ) if cookie : cookies . append ( cookie ) return cookies def _process_rfc2109_cookies ( self , cookies ) : if self . _policy . rfc2109_as_netscape is None : rfc2109_as_netscape = not self . _policy . rfc2965 else : rfc2109_as_netscape = self . _policy . rfc2109_as_netscape for cookie in cookies : if cookie . version == 1 : cookie . rfc2109 = True if rfc2109_as_netscape : cookie . version = 0 def _make_cookies ( self , response , request ) : headers = response . info ( ) rfc2965_hdrs = headers . getheaders ( "Set-Cookie2" ) ns_hdrs = headers . getheaders ( "Set-Cookie" ) rfc2965 = self . _policy . rfc2965 netscape = self . _policy . netscape if ( ( not rfc2965_hdrs and not ns_hdrs ) or ( not ns_hdrs and not rfc2965 ) or ( not rfc2965_hdrs and not netscape ) or ( not netscape and not rfc2965 ) ) : return [ ] try : cookies = self . _cookies_from_attrs_set ( split_header_words ( rfc2965_hdrs ) , request ) except : reraise_unmasked_exceptions ( ) cookies = [ ] if ns_hdrs and netscape : try : ns_cookies = self . _cookies_from_attrs_set ( parse_ns_headers ( ns_hdrs ) , request ) except : reraise_unmasked_exceptions ( ) ns_cookies = [ ] self . _process_rfc2109_cookies ( ns_cookies ) if rfc2965 : lookup = { } for cookie in cookies : lookup [ ( cookie . domain , cookie . path , cookie . name ) ] = None def no_matching_rfc2965 ( ns_cookie , lookup = lookup ) : key = ns_cookie . domain , ns_cookie . path , ns_cookie . name return not lookup . has_key ( key ) ns_cookies = filter ( no_matching_rfc2965 , ns_cookies ) if ns_cookies : cookies . extend ( ns_cookies ) return cookies def make_cookies ( self , response , request ) : self . _policy . _now = self . _now = int ( time . time ( ) ) return [ cookie for cookie in self . _make_cookies ( response , request ) if cookie . expires is None or not cookie . expires <= self . _now ] def set_cookie_if_ok ( self , cookie , request ) : self . _policy . _now = self . _now = int ( time . time ( ) ) if self . _policy . set_ok ( cookie , request ) : self . set_cookie ( cookie ) def set_cookie ( self , cookie ) : c = self . _cookies if not c . has_key ( cookie . domain ) : c [ cookie . domain ] = { } c2 = c [ cookie . domain ] if not c2 . has_key ( cookie . path ) : c2 [ cookie . path ] = { } c3 = c2 [ cookie . path ] c3 [ cookie . name ] = cookie def extract_cookies ( self , response , request ) : debug ( "extract_cookies: %s" , response . info ( ) ) self . _policy . _now = self . _now = int ( time . time ( ) ) for cookie in self . _make_cookies ( response , request ) : if cookie . expires is not None and cookie . expires <= self . _now : try : self . clear ( cookie . domain , cookie . path , cookie . name ) except KeyError : pass debug ( "Expiring cookie, domain='%s', path='%s', name='%s'" , cookie . domain , cookie . path , cookie . name ) elif self . _policy . set_ok ( cookie , request ) : debug ( " setting cookie: %s" , cookie ) self . set_cookie ( cookie ) def clear ( self , domain = None , path = None , name = None ) : if name is not None : if ( domain is None ) or ( path is None ) : raise ValueError ( ) del self . _cookies [ domain ] [ path ] [ name ] elif path is not None : if domain is None : raise ValueError ( ) del self . _cookies [ domain ] [ path ] elif domain is not None : del self . _cookies [ domain ] else : self . _cookies = { } def clear_session_cookies ( self ) : for cookie in self : if cookie . discard : self . clear ( cookie . domain , cookie . path , cookie . name ) def clear_expired_cookies ( self ) : now = time . time ( ) for cookie in self : if cookie . is_expired ( now ) : self . clear ( cookie . domain , cookie . path , cookie . name ) def __getitem__ ( self , i ) : if i == 0 : self . _getitem_iterator = self . __iter__ ( ) elif self . _prev_getitem_index != i - 1 : raise IndexError ( ) self . _prev_getitem_index = i try : return self . _getitem_iterator . next ( ) except StopIteration : raise IndexError ( ) def __iter__ ( self ) : return MappingIterator ( self . _cookies ) def __len__ ( self ) : i = 0 for cookie in self : i = i + 1 return i def __repr__ ( self ) : r = [ ] for cookie in self : r . append ( repr ( cookie ) ) return "<%s[%s]>" % ( self . __class__ , ", " . join ( r ) ) def __str__ ( self ) : r = [ ] for cookie in self : r . append ( str ( cookie ) ) return "<%s[%s]>" % ( self . __class__ , ", " . join ( r ) ) class LoadError ( Exception ) : pass class FileCookieJar ( CookieJar ) : def __init__ ( self , filename = None , delayload = False , policy = None ) : CookieJar . __init__ ( self , policy ) if filename is not None and not isstringlike ( filename ) : raise ValueError ( "filename must be string-like" ) self . filename = filename self . delayload = bool ( delayload ) def save ( self , filename = None , ignore_discard = False , ignore_expires = False ) : raise NotImplementedError ( ) def load ( self , filename = None , ignore_discard = False , ignore_expires = False ) : if filename is None : if self . filename is not None : filename = self . filename else : raise ValueError ( MISSING_FILENAME_TEXT ) f = open ( filename ) try : self . _really_load ( f , filename , ignore_discard , ignore_expires ) finally : f . close ( ) def revert ( self , filename = None , ignore_discard = False , ignore_expires = False ) : if filename is None : if self . filename is not None : filename = self . filename else : raise ValueError ( MISSING_FILENAME_TEXT ) old_state = copy . deepcopy ( self . _cookies ) self . _cookies = { } try : self . load ( filename , ignore_discard , ignore_expires ) except ( LoadError , IOError ) : self . _cookies = old_state raise

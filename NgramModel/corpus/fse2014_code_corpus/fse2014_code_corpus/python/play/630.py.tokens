"""Response classes. The seek_wrapper code is not used if you're using UserAgent with .set_seekable_responses(False), or if you're using the urllib2-level interface without SeekableProcessor or HTTPEquivProcessor. Class closeable_response is instantiated by some handlers (AbstractHTTPHandler), but the closeable_response interface is only depended upon by Browser-level code. Function upgrade_response is only used if you're using Browser or ResponseUpgradeProcessor. Copyright 2006 John J. Lee <jjl@pobox.com> This code is free software; you can redistribute it and/or modify it under the terms of the BSD or ZPL 2.1 licenses (see the file COPYING.txt included with the distribution). """ import copy , mimetools from cStringIO import StringIO import urllib2 def len_of_seekable ( file_ ) : pos = file_ . tell ( ) file_ . seek ( 0 , 2 ) try : return file_ . tell ( ) finally : file_ . seek ( pos ) class seek_wrapper : def __init__ ( self , wrapped ) : self . wrapped = wrapped self . __read_complete_state = [ False ] self . __is_closed_state = [ False ] self . __have_readline = hasattr ( self . wrapped , "readline" ) self . __cache = StringIO ( ) self . __pos = 0 def invariant ( self ) : return self . wrapped . tell ( ) == len ( self . __cache . getvalue ( ) ) def close ( self ) : self . wrapped . close ( ) self . is_closed = True def __getattr__ ( self , name ) : if name == "is_closed" : return self . __is_closed_state [ 0 ] elif name == "read_complete" : return self . __read_complete_state [ 0 ] wrapped = self . __dict__ . get ( "wrapped" ) if wrapped : return getattr ( wrapped , name ) return getattr ( self . __class__ , name ) def __setattr__ ( self , name , value ) : if name == "is_closed" : self . __is_closed_state [ 0 ] = bool ( value ) elif name == "read_complete" : if not self . is_closed : self . __read_complete_state [ 0 ] = bool ( value ) else : self . __dict__ [ name ] = value def seek ( self , offset , whence = 0 ) : assert whence in [ 0 , 1 , 2 ] if whence == 2 : if offset < 0 : raise ValueError ( "negative seek offset" ) to_read = None else : if whence == 0 : if offset < 0 : raise ValueError ( "negative seek offset" ) dest = offset else : pos = self . __pos if pos < offset : raise ValueError ( "seek to before start of file" ) dest = pos + offset end = len_of_seekable ( self . __cache ) to_read = dest - end if to_read < 0 : to_read = 0 if to_read != 0 : self . __cache . seek ( 0 , 2 ) if to_read is None : assert whence == 2 self . __cache . write ( self . wrapped . read ( ) ) self . read_complete = True self . __pos = self . __cache . tell ( ) - offset else : data = self . wrapped . read ( to_read ) if not data : self . read_complete = True else : self . __cache . write ( data ) self . __pos = dest else : self . __pos = dest def tell ( self ) : return self . __pos def __copy__ ( self ) : cpy = self . __class__ ( self . wrapped ) cpy . __cache = self . __cache cpy . __read_complete_state = self . __read_complete_state cpy . __is_closed_state = self . __is_closed_state return cpy def get_data ( self ) : pos = self . __pos try : self . seek ( 0 ) return self . read ( - 1 ) finally : self . __pos = pos def read ( self , size = - 1 ) : pos = self . __pos end = len_of_seekable ( self . __cache ) available = end - pos if size <= available and size != - 1 : self . __cache . seek ( pos ) self . __pos = pos + size return self . __cache . read ( size ) self . __cache . seek ( 0 , 2 ) if size == - 1 : self . __cache . write ( self . wrapped . read ( ) ) self . read_complete = True else : to_read = size - available assert to_read > 0 data = self . wrapped . read ( to_read ) if not data : self . read_complete = True else : self . __cache . write ( data ) self . __cache . seek ( pos ) data = self . __cache . read ( size ) self . __pos = self . __cache . tell ( ) assert self . __pos == pos + len ( data ) return data def readline ( self , size = - 1 ) : if not self . __have_readline : raise NotImplementedError ( "no readline method on wrapped object" ) pos = self . __pos self . __cache . seek ( 0 , 2 ) data = self . wrapped . readline ( ) if not data : self . read_complete = True else : self . __cache . write ( data ) self . __cache . seek ( pos ) data = self . __cache . readline ( ) if size != - 1 : r = data [ : size ] self . __pos = pos + size else : r = data self . __pos = pos + len ( data ) return r def readlines ( self , sizehint = - 1 ) : pos = self . __pos self . __cache . seek ( 0 , 2 ) self . __cache . write ( self . wrapped . read ( ) ) self . read_complete = True self . __cache . seek ( pos ) data = self . __cache . readlines ( sizehint ) self . __pos = self . __cache . tell ( ) return data def __iter__ ( self ) : return self def next ( self ) : line = self . readline ( ) if line == "" : raise StopIteration return line xreadlines = __iter__ def __repr__ ( self ) : return ( "<%s at %s whose wrapped object = %r>" % ( self . __class__ . __name__ , hex ( abs ( id ( self ) ) ) , self . wrapped ) ) class response_seek_wrapper ( seek_wrapper ) : def __init__ ( self , wrapped ) : seek_wrapper . __init__ ( self , wrapped ) self . _headers = self . wrapped . info ( ) def __copy__ ( self ) : cpy = seek_wrapper . __copy__ ( self ) cpy . _headers = copy . copy ( self . info ( ) ) return cpy def info ( self ) : return self . _headers def geturl ( self ) : return self . wrapped . geturl ( ) def set_data ( self , data ) : self . seek ( 0 ) self . read ( ) self . close ( ) cache = self . _seek_wrapper__cache = StringIO ( ) cache . write ( data ) self . seek ( 0 ) class eoffile : def read ( self , size = - 1 ) : return "" def readline ( self , size = - 1 ) : return "" def __iter__ ( self ) : return self def next ( self ) : return "" def close ( self ) : pass class eofresponse ( eoffile ) : def __init__ ( self , url , headers , code , msg ) : self . _url = url self . _headers = headers self . code = code self . msg = msg def geturl ( self ) : return self . _url def info ( self ) : return self . _headers class closeable_response : closeable_response = None def __init__ ( self , fp , headers , url , code , msg ) : self . _set_fp ( fp ) self . _headers = headers self . _url = url self . code = code self . msg = msg def _set_fp ( self , fp ) : self . fp = fp self . read = self . fp . read self . readline = self . fp . readline if hasattr ( self . fp , "readlines" ) : self . readlines = self . fp . readlines if hasattr ( self . fp , "fileno" ) : self . fileno = self . fp . fileno else : self . fileno = lambda : None self . __iter__ = self . fp . __iter__ self . next = self . fp . next def __repr__ ( self ) : return '<%s at %s whose fp = %r>' % ( self . __class__ . __name__ , hex ( abs ( id ( self ) ) ) , self . fp ) def info ( self ) : return self . _headers def geturl ( self ) : return self . _url def close ( self ) : wrapped = self . fp wrapped . close ( ) new_wrapped = eofresponse ( self . _url , self . _headers , self . code , self . msg ) self . _set_fp ( new_wrapped ) def __getstate__ ( self ) : state = self . __dict__ . copy ( ) new_wrapped = eofresponse ( self . _url , self . _headers , self . code , self . msg ) state [ "wrapped" ] = new_wrapped return state def test_response ( data = 'test data' , headers = [ ] , url = "http://example.com/" , code = 200 , msg = "OK" ) : return make_response ( data , headers , url , code , msg ) def test_html_response ( data = 'test data' , headers = [ ] , url = "http://example.com/" , code = 200 , msg = "OK" ) : headers += [ ( "Content-type" , "text/html" ) ] return make_response ( data , headers , url , code , msg ) def make_response ( data , headers , url , code , msg ) : mime_headers = make_headers ( headers ) r = closeable_response ( StringIO ( data ) , mime_headers , url , code , msg ) return response_seek_wrapper ( r ) def make_headers ( headers ) : hdr_text = [ ] for name_value in headers : hdr_text . append ( "%s: %s" % name_value ) return mimetools . Message ( StringIO ( "\n" . join ( hdr_text ) ) ) def get_seek_wrapper_class ( response ) : if ( isinstance ( response , urllib2 . HTTPError ) and not hasattr ( response , "seek" ) ) : if response . __class__ . __module__ == "__builtin__" : exc_class_name = response . __class__ . __name__ else : exc_class_name = "%s.%s" % ( response . __class__ . __module__ , response . __class__ . __name__ ) class httperror_seek_wrapper ( response_seek_wrapper , response . __class__ ) : _exc_class_name = exc_class_name def __init__ ( self , wrapped ) : response_seek_wrapper . __init__ ( self , wrapped ) self . hdrs = wrapped . info ( ) self . filename = wrapped . geturl ( ) def __repr__ ( self ) : return ( % ( self . __class__ . __name__ , self . _exc_class_name , hex ( abs ( id ( self ) ) ) , self . wrapped ) ) wrapper_class = httperror_seek_wrapper else : wrapper_class = response_seek_wrapper return wrapper_class def seek_wrapped_response ( response ) : if not hasattr ( response , "seek" ) : wrapper_class = get_seek_wrapper_class ( response ) response = wrapper_class ( response ) assert hasattr ( response , "get_data" ) return response def upgrade_response ( response ) : wrapper_class = get_seek_wrapper_class ( response ) if hasattr ( response , "closeable_response" ) : if not hasattr ( response , "seek" ) : response = wrapper_class ( response ) assert hasattr ( response , "get_data" ) return copy . copy ( response ) try : code = response . code except AttributeError : code = None try : msg = response . msg except AttributeError : msg = None data = None get_data = getattr ( response , "get_data" , None ) if get_data : data = get_data ( ) response = closeable_response ( response . fp , response . info ( ) , response . geturl ( ) , code , msg ) response = wrapper_class ( response ) if data : response . set_data ( data ) return response

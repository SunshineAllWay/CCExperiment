""" The io module provides the Python interfaces to stream handling. The builtin open function is defined in this module. At the top of the I/O hierarchy is the abstract base class IOBase. It defines the basic interface to a stream. Note, however, that there is no seperation between reading and writing to streams; implementations are allowed to throw an IOError if they do not support a given operation. Extending IOBase is RawIOBase which deals simply with the reading and writing of raw bytes to a stream. FileIO subclasses RawIOBase to provide an interface to OS files. BufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer streams that are readable, writable, and both respectively. BufferedRandom provides a buffered interface to random access streams. BytesIO is a simple stream of in-memory bytes. Another IOBase subclass, TextIOBase, deals with the encoding and decoding of streams into text. TextIOWrapper, which extends it, is a buffered text interface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO is a in-memory stream for text. Argument names are not part of the specification, and only the arguments of open() are intended to be used as keyword arguments. data: DEFAULT_BUFFER_SIZE An int containing the default buffer size used by the module's buffered I/O classes. open() uses the file's blksize (as obtained by os.stat) if possible. """ from __future__ import print_function from __future__ import unicode_literals __author__ = ( "Guido van Rossum <guido@python.org>, " ) __all__ = [ "BlockingIOError" , "open" , "IOBase" , "RawIOBase" , "FileIO" , , "StringIO" , "BufferedIOBase" , , "BufferedWriter" , "BufferedRWPair" , , "TextIOBase" , "TextIOWrapper" ] import os import abc import codecs import _fileio import threading DEFAULT_BUFFER_SIZE = 8 * 1024 __metaclass__ = type class BlockingIOError ( IOError ) : def __init__ ( self , errno , strerror , characters_written = 0 ) : IOError . __init__ ( self , errno , strerror ) self . characters_written = characters_written def open ( file , mode = "r" , buffering = None , encoding = None , errors = None , newline = None , closefd = True ) : if not isinstance ( file , ( basestring , int ) ) : raise TypeError ( "invalid file: %r" % file ) if not isinstance ( mode , basestring ) : raise TypeError ( "invalid mode: %r" % mode ) if buffering is not None and not isinstance ( buffering , int ) : raise TypeError ( "invalid buffering: %r" % buffering ) if encoding is not None and not isinstance ( encoding , basestring ) : raise TypeError ( "invalid encoding: %r" % encoding ) if errors is not None and not isinstance ( errors , basestring ) : raise TypeError ( "invalid errors: %r" % errors ) modes = set ( mode ) if modes - set ( "arwb+tU" ) or len ( mode ) > len ( modes ) : raise ValueError ( "invalid mode: %r" % mode ) reading = "r" in modes writing = "w" in modes appending = "a" in modes updating = "+" in modes text = "t" in modes binary = "b" in modes if "U" in modes : if writing or appending : raise ValueError ( "can't use U and writing mode at once" ) reading = True if text and binary : raise ValueError ( "can't have text and binary mode at once" ) if reading + writing + appending > 1 : raise ValueError ( "can't have read/write/append mode at once" ) if not ( reading or writing or appending ) : raise ValueError ( "must have exactly one of read/write/append mode" ) if binary and encoding is not None : raise ValueError ( "binary mode doesn't take an encoding argument" ) if binary and errors is not None : raise ValueError ( "binary mode doesn't take an errors argument" ) if binary and newline is not None : raise ValueError ( "binary mode doesn't take a newline argument" ) raw = FileIO ( file , ( reading and "r" or "" ) + ( writing and "w" or "" ) + ( appending and "a" or "" ) + ( updating and "+" or "" ) , closefd ) if buffering is None : buffering = - 1 line_buffering = False if buffering == 1 or buffering < 0 and raw . isatty ( ) : buffering = - 1 line_buffering = True if buffering < 0 : buffering = DEFAULT_BUFFER_SIZE try : bs = os . fstat ( raw . fileno ( ) ) . st_blksize except ( os . error , AttributeError ) : pass else : if bs > 1 : buffering = bs if buffering < 0 : raise ValueError ( "invalid buffering size" ) if buffering == 0 : if binary : raw . _name = file raw . _mode = mode return raw raise ValueError ( "can't have unbuffered text I/O" ) if updating : buffer = BufferedRandom ( raw , buffering ) elif writing or appending : buffer = BufferedWriter ( raw , buffering ) elif reading : buffer = BufferedReader ( raw , buffering ) else : raise ValueError ( "unknown mode: %r" % mode ) if binary : buffer . name = file buffer . mode = mode return buffer text = TextIOWrapper ( buffer , encoding , errors , newline , line_buffering ) text . name = file text . mode = mode return text class _DocDescriptor : def __get__ ( self , obj , typ ) : return ( + open . __doc__ ) class OpenWrapper : __doc__ = _DocDescriptor ( ) def __new__ ( cls , * args , ** kwargs ) : return open ( * args , ** kwargs ) class UnsupportedOperation ( ValueError , IOError ) : pass class IOBase ( object ) : __metaclass__ = abc . ABCMeta def _unsupported ( self , name ) : raise UnsupportedOperation ( "%s.%s() not supported" % ( self . __class__ . __name__ , name ) ) def seek ( self , pos , whence = 0 ) : self . _unsupported ( "seek" ) def tell ( self ) : return self . seek ( 0 , 1 ) def truncate ( self , pos = None ) : self . _unsupported ( "truncate" ) def flush ( self ) : __closed = False def close ( self ) : if not self . __closed : try : self . flush ( ) except IOError : pass self . __closed = True def __del__ ( self ) : try : self . close ( ) except : pass def seekable ( self ) : return False def _checkSeekable ( self , msg = None ) : if not self . seekable ( ) : raise IOError ( "File or stream is not seekable." if msg is None else msg ) def readable ( self ) : return False def _checkReadable ( self , msg = None ) : if not self . readable ( ) : raise IOError ( "File or stream is not readable." if msg is None else msg ) def writable ( self ) : return False def _checkWritable ( self , msg = None ) : if not self . writable ( ) : raise IOError ( "File or stream is not writable." if msg is None else msg ) @ property def closed ( self ) : return self . __closed def _checkClosed ( self , msg = None ) : if self . closed : raise ValueError ( "I/O operation on closed file." if msg is None else msg ) def __enter__ ( self ) : self . _checkClosed ( ) return self def __exit__ ( self , * args ) : self . close ( ) def fileno ( self ) : self . _unsupported ( "fileno" ) def isatty ( self ) : self . _checkClosed ( ) return False def readline ( self , limit = - 1 ) : self . _checkClosed ( ) if hasattr ( self , "peek" ) : def nreadahead ( ) : readahead = self . peek ( 1 ) if not readahead : return 1 n = ( readahead . find ( b "\n" ) + 1 ) or len ( readahead ) if limit >= 0 : n = min ( n , limit ) return n else : def nreadahead ( ) : return 1 if limit is None : limit = - 1 if not isinstance ( limit , ( int , long ) ) : raise TypeError ( "limit must be an integer" ) res = bytearray ( ) while limit < 0 or len ( res ) < limit : b = self . read ( nreadahead ( ) ) if not b : break res += b if res . endswith ( b "\n" ) : break return bytes ( res ) def __iter__ ( self ) : self . _checkClosed ( ) return self def next ( self ) : line = self . readline ( ) if not line : raise StopIteration return line def readlines ( self , hint = None ) : if hint is None : hint = - 1 if not isinstance ( hint , ( int , long ) ) : raise TypeError ( "hint must be an integer" ) if hint <= 0 : return list ( self ) n = 0 lines = [ ] for line in self : lines . append ( line ) n += len ( line ) if n >= hint : break return lines def writelines ( self , lines ) : self . _checkClosed ( ) for line in lines : self . write ( line ) class RawIOBase ( IOBase ) : def read ( self , n = - 1 ) : if n is None : n = - 1 if n < 0 : return self . readall ( ) b = bytearray ( n . __index__ ( ) ) n = self . readinto ( b ) del b [ n : ] return bytes ( b ) def readall ( self ) : res = bytearray ( ) while True : data = self . read ( DEFAULT_BUFFER_SIZE ) if not data : break res += data return bytes ( res ) def readinto ( self , b ) : self . _unsupported ( "readinto" ) def write ( self , b ) : self . _unsupported ( "write" ) class FileIO ( _fileio . _FileIO , RawIOBase ) : def close ( self ) : _fileio . _FileIO . close ( self ) RawIOBase . close ( self ) @ property def name ( self ) : return self . _name @ property def mode ( self ) : return self . _mode class BufferedIOBase ( IOBase ) : def read ( self , n = None ) : self . _unsupported ( "read" ) def readinto ( self , b ) : data = self . read ( len ( b ) ) n = len ( data ) try : b [ : n ] = data except TypeError as err : import array if not isinstance ( b , array . array ) : raise err b [ : n ] = array . array ( b 'b' , data ) return n def write ( self , b ) : self . _unsupported ( "write" ) class _BufferedIOMixin ( BufferedIOBase ) : def __init__ ( self , raw ) : self . raw = raw def seek ( self , pos , whence = 0 ) : return self . raw . seek ( pos , whence ) def tell ( self ) : return self . raw . tell ( ) def truncate ( self , pos = None ) : self . flush ( ) if pos is None : pos = self . tell ( ) return self . raw . truncate ( pos ) def flush ( self ) : self . raw . flush ( ) def close ( self ) : if not self . closed : try : self . flush ( ) except IOError : pass self . raw . close ( ) def seekable ( self ) : return self . raw . seekable ( ) def readable ( self ) : return self . raw . readable ( ) def writable ( self ) : return self . raw . writable ( ) @ property def closed ( self ) : return self . raw . closed def fileno ( self ) : return self . raw . fileno ( ) def isatty ( self ) : return self . raw . isatty ( ) class _BytesIO ( BufferedIOBase ) : def __init__ ( self , initial_bytes = None ) : buf = bytearray ( ) if initial_bytes is not None : buf += bytearray ( initial_bytes ) self . _buffer = buf self . _pos = 0 def getvalue ( self ) : if self . closed : raise ValueError ( "getvalue on closed file" ) return bytes ( self . _buffer ) def read ( self , n = None ) : if self . closed : raise ValueError ( "read from closed file" ) if n is None : n = - 1 if not isinstance ( n , ( int , long ) ) : raise TypeError ( "argument must be an integer" ) if n < 0 : n = len ( self . _buffer ) if len ( self . _buffer ) <= self . _pos : return b "" newpos = min ( len ( self . _buffer ) , self . _pos + n ) b = self . _buffer [ self . _pos : newpos ] self . _pos = newpos return bytes ( b ) def read1 ( self , n ) : return self . read ( n ) def write ( self , b ) : if self . closed : raise ValueError ( "write to closed file" ) if isinstance ( b , unicode ) : raise TypeError ( "can't write unicode to binary stream" ) n = len ( b ) if n == 0 : return 0 pos = self . _pos if pos > len ( self . _buffer ) : padding = b '\x00' * ( pos - len ( self . _buffer ) ) self . _buffer += padding self . _buffer [ pos : pos + n ] = b self . _pos += n return n def seek ( self , pos , whence = 0 ) : if self . closed : raise ValueError ( "seek on closed file" ) try : pos = pos . __index__ ( ) except AttributeError as err : raise TypeError ( "an integer is required" ) if whence == 0 : if pos < 0 : raise ValueError ( "negative seek position %r" % ( pos , ) ) self . _pos = pos elif whence == 1 : self . _pos = max ( 0 , self . _pos + pos ) elif whence == 2 : self . _pos = max ( 0 , len ( self . _buffer ) + pos ) else : raise ValueError ( "invalid whence value" ) return self . _pos def tell ( self ) : if self . closed : raise ValueError ( "tell on closed file" ) return self . _pos def truncate ( self , pos = None ) : if self . closed : raise ValueError ( "truncate on closed file" ) if pos is None : pos = self . _pos elif pos < 0 : raise ValueError ( "negative truncate position %r" % ( pos , ) ) del self . _buffer [ pos : ] return self . seek ( pos ) def readable ( self ) : return True def writable ( self ) : return True def seekable ( self ) : return True try : import _bytesio class BytesIO ( _bytesio . _BytesIO , BufferedIOBase ) : __doc__ = _bytesio . _BytesIO . __doc__ except ImportError : BytesIO = _BytesIO class BufferedReader ( _BufferedIOMixin ) : def __init__ ( self , raw , buffer_size = DEFAULT_BUFFER_SIZE ) : raw . _checkReadable ( ) _BufferedIOMixin . __init__ ( self , raw ) self . buffer_size = buffer_size self . _reset_read_buf ( ) self . _read_lock = threading . Lock ( ) def _reset_read_buf ( self ) : self . _read_buf = b "" self . _read_pos = 0 def read ( self , n = None ) : with self . _read_lock : return self . _read_unlocked ( n ) def _read_unlocked ( self , n = None ) : nodata_val = b "" empty_values = ( b "" , None ) buf = self . _read_buf pos = self . _read_pos if n is None or n == - 1 : self . _reset_read_buf ( ) chunks = [ buf [ pos : ] ] current_size = 0 while True : chunk = self . raw . read ( ) if chunk in empty_values : nodata_val = chunk break current_size += len ( chunk ) chunks . append ( chunk ) return b "" . join ( chunks ) or nodata_val avail = len ( buf ) - pos if n <= avail : self . _read_pos += n return buf [ pos : pos + n ] chunks = [ buf [ pos : ] ] wanted = max ( self . buffer_size , n ) while avail < n : chunk = self . raw . read ( wanted ) if chunk in empty_values : nodata_val = chunk break avail += len ( chunk ) chunks . append ( chunk ) n = min ( n , avail ) out = b "" . join ( chunks ) self . _read_buf = out [ n : ] self . _read_pos = 0 return out [ : n ] if out else nodata_val def peek ( self , n = 0 ) : with self . _read_lock : return self . _peek_unlocked ( n ) def _peek_unlocked ( self , n = 0 ) : want = min ( n , self . buffer_size ) have = len ( self . _read_buf ) - self . _read_pos if have < want : to_read = self . buffer_size - have current = self . raw . read ( to_read ) if current : self . _read_buf = self . _read_buf [ self . _read_pos : ] + current self . _read_pos = 0 return self . _read_buf [ self . _read_pos : ] def read1 ( self , n ) : if n <= 0 : return b "" with self . _read_lock : self . _peek_unlocked ( 1 ) return self . _read_unlocked ( min ( n , len ( self . _read_buf ) - self . _read_pos ) ) def tell ( self ) : return self . raw . tell ( ) - len ( self . _read_buf ) + self . _read_pos def seek ( self , pos , whence = 0 ) : with self . _read_lock : if whence == 1 : pos -= len ( self . _read_buf ) - self . _read_pos pos = self . raw . seek ( pos , whence ) self . _reset_read_buf ( ) return pos class BufferedWriter ( _BufferedIOMixin ) : def __init__ ( self , raw , buffer_size = DEFAULT_BUFFER_SIZE , max_buffer_size = None ) : raw . _checkWritable ( ) _BufferedIOMixin . __init__ ( self , raw ) self . buffer_size = buffer_size self . max_buffer_size = ( 2 * buffer_size if max_buffer_size is None else max_buffer_size ) self . _write_buf = bytearray ( ) self . _write_lock = threading . Lock ( ) def write ( self , b ) : if self . closed : raise ValueError ( "write to closed file" ) if isinstance ( b , unicode ) : raise TypeError ( "can't write unicode to binary stream" ) with self . _write_lock : if len ( self . _write_buf ) > self . buffer_size : try : self . _flush_unlocked ( ) except BlockingIOError as e : raise BlockingIOError ( e . errno , e . strerror , 0 ) before = len ( self . _write_buf ) self . _write_buf . extend ( b ) written = len ( self . _write_buf ) - before if len ( self . _write_buf ) > self . buffer_size : try : self . _flush_unlocked ( ) except BlockingIOError as e : if len ( self . _write_buf ) > self . max_buffer_size : overage = len ( self . _write_buf ) - self . max_buffer_size self . _write_buf = self . _write_buf [ : self . max_buffer_size ] raise BlockingIOError ( e . errno , e . strerror , overage ) return written def truncate ( self , pos = None ) : with self . _write_lock : self . _flush_unlocked ( ) if pos is None : pos = self . raw . tell ( ) return self . raw . truncate ( pos ) def flush ( self ) : with self . _write_lock : self . _flush_unlocked ( ) def _flush_unlocked ( self ) : if self . closed : raise ValueError ( "flush of closed file" ) written = 0 try : while self . _write_buf : n = self . raw . write ( self . _write_buf ) del self . _write_buf [ : n ] written += n except BlockingIOError as e : n = e . characters_written del self . _write_buf [ : n ] written += n raise BlockingIOError ( e . errno , e . strerror , written ) def tell ( self ) : return self . raw . tell ( ) + len ( self . _write_buf ) def seek ( self , pos , whence = 0 ) : with self . _write_lock : self . _flush_unlocked ( ) return self . raw . seek ( pos , whence ) class BufferedRWPair ( BufferedIOBase ) : def __init__ ( self , reader , writer , buffer_size = DEFAULT_BUFFER_SIZE , max_buffer_size = None ) : reader . _checkReadable ( ) writer . _checkWritable ( ) self . reader = BufferedReader ( reader , buffer_size ) self . writer = BufferedWriter ( writer , buffer_size , max_buffer_size ) def read ( self , n = None ) : if n is None : n = - 1 return self . reader . read ( n ) def readinto ( self , b ) : return self . reader . readinto ( b ) def write ( self , b ) : return self . writer . write ( b ) def peek ( self , n = 0 ) : return self . reader . peek ( n ) def read1 ( self , n ) : return self . reader . read1 ( n ) def readable ( self ) : return self . reader . readable ( ) def writable ( self ) : return self . writer . writable ( ) def flush ( self ) : return self . writer . flush ( ) def close ( self ) : self . writer . close ( ) self . reader . close ( ) def isatty ( self ) : return self . reader . isatty ( ) or self . writer . isatty ( ) @ property def closed ( self ) : return self . writer . closed ( ) class BufferedRandom ( BufferedWriter , BufferedReader ) : def __init__ ( self , raw , buffer_size = DEFAULT_BUFFER_SIZE , max_buffer_size = None ) : raw . _checkSeekable ( ) BufferedReader . __init__ ( self , raw , buffer_size ) BufferedWriter . __init__ ( self , raw , buffer_size , max_buffer_size ) def seek ( self , pos , whence = 0 ) : self . flush ( ) pos = self . raw . seek ( pos , whence ) with self . _read_lock : self . _reset_read_buf ( ) return pos def tell ( self ) : if self . _write_buf : return self . raw . tell ( ) + len ( self . _write_buf ) else : return BufferedReader . tell ( self ) def truncate ( self , pos = None ) : if pos is None : pos = self . tell ( ) self . seek ( pos ) return BufferedWriter . truncate ( self ) def read ( self , n = None ) : if n is None : n = - 1 self . flush ( ) return BufferedReader . read ( self , n ) def readinto ( self , b ) : self . flush ( ) return BufferedReader . readinto ( self , b ) def peek ( self , n = 0 ) : self . flush ( ) return BufferedReader . peek ( self , n ) def read1 ( self , n ) : self . flush ( ) return BufferedReader . read1 ( self , n ) def write ( self , b ) : if self . _read_buf : with self . _read_lock : self . raw . seek ( self . _read_pos - len ( self . _read_buf ) , 1 ) self . _reset_read_buf ( ) return BufferedWriter . write ( self , b ) class TextIOBase ( IOBase ) : def read ( self , n = - 1 ) : self . _unsupported ( "read" ) def write ( self , s ) : self . _unsupported ( "write" ) def truncate ( self , pos = None ) : self . _unsupported ( "truncate" ) def readline ( self ) : self . _unsupported ( "readline" ) @ property def encoding ( self ) : return None @ property def newlines ( self ) : return None class IncrementalNewlineDecoder ( codecs . IncrementalDecoder ) : def __init__ ( self , decoder , translate , errors = 'strict' ) : codecs . IncrementalDecoder . __init__ ( self , errors = errors ) self . buffer = b '' self . translate = translate self . decoder = decoder self . seennl = 0 def decode ( self , input , final = False ) : if self . buffer : input = self . buffer + input output = self . decoder . decode ( input , final = final ) if output . endswith ( "\r" ) and not final : output = output [ : - 1 ] self . buffer = b '\r' else : self . buffer = b '' crlf = output . count ( '\r\n' ) cr = output . count ( '\r' ) - crlf lf = output . count ( '\n' ) - crlf self . seennl |= ( lf and self . _LF ) | ( cr and self . _CR ) | ( crlf and self . _CRLF ) if self . translate : if crlf : output = output . replace ( "\r\n" , "\n" ) if cr : output = output . replace ( "\r" , "\n" ) return output def getstate ( self ) : buf , flag = self . decoder . getstate ( ) return buf + self . buffer , flag def setstate ( self , state ) : buf , flag = state if buf . endswith ( b '\r' ) : self . buffer = b '\r' buf = buf [ : - 1 ] else : self . buffer = b '' self . decoder . setstate ( ( buf , flag ) ) def reset ( self ) : self . seennl = 0 self . buffer = b '' self . decoder . reset ( ) _LF = 1 _CR = 2 _CRLF = 4 @ property def newlines ( self ) : return ( None , , , ( "\r" , "\n" ) , , ( "\n" , "\r\n" ) , ( "\r" , "\r\n" ) , ( "\r" , "\n" , "\r\n" ) ) [ self . seennl ] class TextIOWrapper ( TextIOBase ) : _CHUNK_SIZE = 128 def __init__ ( self , buffer , encoding = None , errors = None , newline = None , line_buffering = False ) : if newline not in ( None , "" , "\n" , "\r" , "\r\n" ) : raise ValueError ( "illegal newline value: %r" % ( newline , ) ) if encoding is None : try : encoding = os . device_encoding ( buffer . fileno ( ) ) except ( AttributeError , UnsupportedOperation ) : pass if encoding is None : try : import locale except ImportError : encoding = "ascii" else : encoding = locale . getpreferredencoding ( ) if not isinstance ( encoding , basestring ) : raise ValueError ( "invalid encoding: %r" % encoding ) if errors is None : errors = "strict" else : if not isinstance ( errors , basestring ) : raise ValueError ( "invalid errors: %r" % errors ) self . buffer = buffer self . _line_buffering = line_buffering self . _encoding = encoding self . _errors = errors self . _readuniversal = not newline self . _readtranslate = newline is None self . _readnl = newline self . _writetranslate = newline != '' self . _writenl = newline or os . linesep self . _encoder = None self . _decoder = None self . _decoded_chars = '' self . _decoded_chars_used = 0 self . _snapshot = None self . _seekable = self . _telling = self . buffer . seekable ( ) @ property def encoding ( self ) : return self . _encoding @ property def errors ( self ) : return self . _errors @ property def line_buffering ( self ) : return self . _line_buffering def seekable ( self ) : return self . _seekable def readable ( self ) : return self . buffer . readable ( ) def writable ( self ) : return self . buffer . writable ( ) def flush ( self ) : self . buffer . flush ( ) self . _telling = self . _seekable def close ( self ) : try : self . flush ( ) except : pass self . buffer . close ( ) @ property def closed ( self ) : return self . buffer . closed def fileno ( self ) : return self . buffer . fileno ( ) def isatty ( self ) : return self . buffer . isatty ( ) def write ( self , s ) : if self . closed : raise ValueError ( "write to closed file" ) if not isinstance ( s , unicode ) : raise TypeError ( "can't write %s to text stream" % s . __class__ . __name__ ) length = len ( s ) haslf = ( self . _writetranslate or self . _line_buffering ) and "\n" in s if haslf and self . _writetranslate and self . _writenl != "\n" : s = s . replace ( "\n" , self . _writenl ) encoder = self . _encoder or self . _get_encoder ( ) b = encoder . encode ( s ) self . buffer . write ( b ) if self . _line_buffering and ( haslf or "\r" in s ) : self . flush ( ) self . _snapshot = None if self . _decoder : self . _decoder . reset ( ) return length def _get_encoder ( self ) : make_encoder = codecs . getincrementalencoder ( self . _encoding ) self . _encoder = make_encoder ( self . _errors ) return self . _encoder def _get_decoder ( self ) : make_decoder = codecs . getincrementaldecoder ( self . _encoding ) decoder = make_decoder ( self . _errors ) if self . _readuniversal : decoder = IncrementalNewlineDecoder ( decoder , self . _readtranslate ) self . _decoder = decoder return decoder def _set_decoded_chars ( self , chars ) : self . _decoded_chars = chars self . _decoded_chars_used = 0 def _get_decoded_chars ( self , n = None ) : offset = self . _decoded_chars_used if n is None : chars = self . _decoded_chars [ offset : ] else : chars = self . _decoded_chars [ offset : offset + n ] self . _decoded_chars_used += len ( chars ) return chars def _rewind_decoded_chars ( self , n ) : if self . _decoded_chars_used < n : raise AssertionError ( "rewind decoded_chars out of bounds" ) self . _decoded_chars_used -= n def _read_chunk ( self ) : if self . _decoder is None : raise ValueError ( "no decoder" ) if self . _telling : dec_buffer , dec_flags = self . _decoder . getstate ( ) input_chunk = self . buffer . read1 ( self . _CHUNK_SIZE ) eof = not input_chunk self . _set_decoded_chars ( self . _decoder . decode ( input_chunk , eof ) ) if self . _telling : self . _snapshot = ( dec_flags , dec_buffer + input_chunk ) return not eof def _pack_cookie ( self , position , dec_flags = 0 , bytes_to_feed = 0 , need_eof = 0 , chars_to_skip = 0 ) : return ( position | ( dec_flags << 64 ) | ( bytes_to_feed << 128 ) | ( chars_to_skip << 192 ) | bool ( need_eof ) << 256 ) def _unpack_cookie ( self , bigint ) : rest , position = divmod ( bigint , 1 << 64 ) rest , dec_flags = divmod ( rest , 1 << 64 ) rest , bytes_to_feed = divmod ( rest , 1 << 64 ) need_eof , chars_to_skip = divmod ( rest , 1 << 64 ) return position , dec_flags , bytes_to_feed , need_eof , chars_to_skip def tell ( self ) : if not self . _seekable : raise IOError ( "underlying stream is not seekable" ) if not self . _telling : raise IOError ( "telling position disabled by next() call" ) self . flush ( ) position = self . buffer . tell ( ) decoder = self . _decoder if decoder is None or self . _snapshot is None : if self . _decoded_chars : raise AssertionError ( "pending decoded text" ) return position dec_flags , next_input = self . _snapshot position -= len ( next_input ) chars_to_skip = self . _decoded_chars_used if chars_to_skip == 0 : return self . _pack_cookie ( position , dec_flags ) saved_state = decoder . getstate ( ) try : decoder . setstate ( ( b '' , dec_flags ) ) start_pos = position start_flags , bytes_fed , chars_decoded = dec_flags , 0 , 0 need_eof = 0 for next_byte in next_input : bytes_fed += 1 chars_decoded += len ( decoder . decode ( next_byte ) ) dec_buffer , dec_flags = decoder . getstate ( ) if not dec_buffer and chars_decoded <= chars_to_skip : start_pos += bytes_fed chars_to_skip -= chars_decoded start_flags , bytes_fed , chars_decoded = dec_flags , 0 , 0 if chars_decoded >= chars_to_skip : break else : chars_decoded += len ( decoder . decode ( b '' , final = True ) ) need_eof = 1 if chars_decoded < chars_to_skip : raise IOError ( "can't reconstruct logical file position" ) return self . _pack_cookie ( start_pos , start_flags , bytes_fed , need_eof , chars_to_skip ) finally : decoder . setstate ( saved_state ) def truncate ( self , pos = None ) : self . flush ( ) if pos is None : pos = self . tell ( ) self . seek ( pos ) return self . buffer . truncate ( ) def seek ( self , cookie , whence = 0 ) : if self . closed : raise ValueError ( "tell on closed file" ) if not self . _seekable : raise IOError ( "underlying stream is not seekable" ) if whence == 1 : if cookie != 0 : raise IOError ( "can't do nonzero cur-relative seeks" ) whence = 0 cookie = self . tell ( ) if whence == 2 : if cookie != 0 : raise IOError ( "can't do nonzero end-relative seeks" ) self . flush ( ) position = self . buffer . seek ( 0 , 2 ) self . _set_decoded_chars ( '' ) self . _snapshot = None if self . _decoder : self . _decoder . reset ( ) return position if whence != 0 : raise ValueError ( "invalid whence (%r, should be 0, 1 or 2)" % ( whence , ) ) if cookie < 0 : raise ValueError ( "negative seek position %r" % ( cookie , ) ) self . flush ( ) start_pos , dec_flags , bytes_to_feed , need_eof , chars_to_skip = self . _unpack_cookie ( cookie ) self . buffer . seek ( start_pos ) self . _set_decoded_chars ( '' ) self . _snapshot = None if self . _decoder or dec_flags or chars_to_skip : self . _decoder = self . _decoder or self . _get_decoder ( ) self . _decoder . setstate ( ( b '' , dec_flags ) ) self . _snapshot = ( dec_flags , b '' ) if chars_to_skip : input_chunk = self . buffer . read ( bytes_to_feed ) self . _set_decoded_chars ( self . _decoder . decode ( input_chunk , need_eof ) ) self . _snapshot = ( dec_flags , input_chunk ) if len ( self . _decoded_chars ) < chars_to_skip : raise IOError ( "can't restore logical file position" ) self . _decoded_chars_used = chars_to_skip return cookie def read ( self , n = None ) : if n is None : n = - 1 decoder = self . _decoder or self . _get_decoder ( ) if n < 0 : result = ( self . _get_decoded_chars ( ) + decoder . decode ( self . buffer . read ( ) , final = True ) ) self . _set_decoded_chars ( '' ) self . _snapshot = None return result else : eof = False result = self . _get_decoded_chars ( n ) while len ( result ) < n and not eof : eof = not self . _read_chunk ( ) result += self . _get_decoded_chars ( n - len ( result ) ) return result def next ( self ) : self . _telling = False line = self . readline ( ) if not line : self . _snapshot = None self . _telling = self . _seekable raise StopIteration return line def readline ( self , limit = None ) : if self . closed : raise ValueError ( "read from closed file" ) if limit is None : limit = - 1 if not isinstance ( limit , ( int , long ) ) : raise TypeError ( "limit must be an integer" ) line = self . _get_decoded_chars ( ) start = 0 decoder = self . _decoder or self . _get_decoder ( ) pos = endpos = None while True : if self . _readtranslate : pos = line . find ( '\n' , start ) if pos >= 0 : endpos = pos + 1 break else : start = len ( line ) elif self . _readuniversal : nlpos = line . find ( "\n" , start ) crpos = line . find ( "\r" , start ) if crpos == - 1 : if nlpos == - 1 : start = len ( line ) else : endpos = nlpos + 1 break elif nlpos == - 1 : endpos = crpos + 1 break elif nlpos < crpos : endpos = nlpos + 1 break elif nlpos == crpos + 1 : endpos = crpos + 2 break else : endpos = crpos + 1 break else : pos = line . find ( self . _readnl ) if pos >= 0 : endpos = pos + len ( self . _readnl ) break if limit >= 0 and len ( line ) >= limit : endpos = limit break more_line = '' while self . _read_chunk ( ) : if self . _decoded_chars : break if self . _decoded_chars : line += self . _get_decoded_chars ( ) else : self . _set_decoded_chars ( '' ) self . _snapshot = None return line if limit >= 0 and endpos > limit : endpos = limit self . _rewind_decoded_chars ( len ( line ) - endpos ) return line [ : endpos ] @ property def newlines ( self ) : return self . _decoder . newlines if self . _decoder else None class StringIO ( TextIOWrapper ) : def __init__ ( self , initial_value = "" , encoding = "utf-8" , errors = "strict" , newline = "\n" ) : super ( StringIO , self ) . __init__ ( BytesIO ( ) , encoding = encoding , errors = errors , newline = newline ) if initial_value : if not isinstance ( initial_value , unicode ) : initial_value = unicode ( initial_value ) self . write ( initial_value ) self . seek ( 0 ) def getvalue ( self ) : self . flush ( ) return self . buffer . getvalue ( ) . decode ( self . _encoding , self . _errors )

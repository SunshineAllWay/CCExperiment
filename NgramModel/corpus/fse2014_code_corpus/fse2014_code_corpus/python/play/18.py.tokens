"""A generally useful event scheduler class. Each instance of this class manages its own queue. No multi-threading is implied; you are supposed to hack that yourself, or use a single instance per application. Each instance is parametrized with two functions, one that is supposed to return the current time, one that is supposed to implement a delay. You can implement real-time scheduling by substituting time and sleep from built-in module time, or you can implement simulated time by writing your own functions. This can also be used to integrate scheduling with STDWIN events; the delay function is allowed to modify the queue. Time can be expressed as integers or floating point numbers, as long as it is consistent. Events are specified by tuples (time, priority, action, argument). As in UNIX, lower priority numbers mean higher priority; in this way the queue can be maintained as a priority queue. Execution of the event means calling the action function, passing it the argument sequence in "argument" (remember that in Python, multiple function arguments are be packed in a sequence). The action function may be an instance method so it has another way to reference private data (besides global variables). """ import heapq from collections import namedtuple __all__ = [ "scheduler" ] Event = namedtuple ( 'Event' , 'time, priority, action, argument' ) class scheduler : def __init__ ( self , timefunc , delayfunc ) : self . _queue = [ ] self . timefunc = timefunc self . delayfunc = delayfunc def enterabs ( self , time , priority , action , argument ) : event = Event ( time , priority , action , argument ) heapq . heappush ( self . _queue , event ) return event def enter ( self , delay , priority , action , argument ) : time = self . timefunc ( ) + delay return self . enterabs ( time , priority , action , argument ) def cancel ( self , event ) : self . _queue . remove ( event ) heapq . heapify ( self . _queue ) def empty ( self ) : return not self . _queue def run ( self ) : q = self . _queue delayfunc = self . delayfunc timefunc = self . timefunc pop = heapq . heappop while q : time , priority , action , argument = checked_event = q [ 0 ] now = timefunc ( ) if now < time : delayfunc ( time - now ) else : event = pop ( q ) if event is checked_event : action ( * argument ) delayfunc ( 0 ) else : heapq . heappush ( q , event ) @ property def queue ( self ) : events = self . _queue [ : ] return map ( heapq . heappop , [ events ] * len ( events ) )

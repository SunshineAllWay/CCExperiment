__all__ = [ , , , , ] import email . base64mime import email . quoprimime from email import errors from email . encoders import encode_7or8bit QP = 1 BASE64 = 2 SHORTEST = 3 MISC_LEN = 7 DEFAULT_CHARSET = 'us-ascii' CHARSETS = { : ( QP , QP , None ) , : ( QP , QP , None ) , : ( QP , QP , None ) , : ( QP , QP , None ) , : ( QP , QP , None ) , : ( QP , QP , None ) , : ( QP , QP , None ) , : ( QP , QP , None ) , : ( QP , QP , None ) , : ( QP , QP , None ) , : ( QP , QP , None ) , : ( QP , QP , None ) , : ( None , None , None ) , : ( BASE64 , BASE64 , None ) , : ( BASE64 , BASE64 , None ) , : ( BASE64 , None , 'iso-2022-jp' ) , : ( BASE64 , None , 'iso-2022-jp' ) , : ( BASE64 , None , None ) , : ( BASE64 , BASE64 , None ) , : ( SHORTEST , BASE64 , 'utf-8' ) , : ( None , BASE64 , 'utf-8' ) , } ALIASES = { : 'iso-8859-1' , : 'iso-8859-1' , : 'iso-8859-2' , : 'iso-8859-2' , : 'iso-8859-3' , : 'iso-8859-3' , : 'iso-8859-4' , : 'iso-8859-4' , : 'iso-8859-9' , : 'iso-8859-9' , : 'iso-8859-10' , : 'iso-8859-10' , : 'iso-8859-13' , : 'iso-8859-13' , : 'iso-8859-14' , : 'iso-8859-14' , : 'iso-8859-15' , : 'iso-8859-15' , : 'iso-8859-16' , : 'iso-8859-16' , : 'ks_c_5601-1987' , : 'euc-jp' , : 'euc-kr' , : 'us-ascii' , } CODEC_MAP = { : 'eucgb2312_cn' , : 'big5_tw' , : None , } def add_charset ( charset , header_enc = None , body_enc = None , output_charset = None ) : if body_enc == SHORTEST : raise ValueError ( 'SHORTEST not allowed for body_enc' ) CHARSETS [ charset ] = ( header_enc , body_enc , output_charset ) def add_alias ( alias , canonical ) : ALIASES [ alias ] = canonical def add_codec ( charset , codecname ) : CODEC_MAP [ charset ] = codecname class Charset : def __init__ ( self , input_charset = DEFAULT_CHARSET ) : try : if isinstance ( input_charset , unicode ) : input_charset . encode ( 'ascii' ) else : input_charset = unicode ( input_charset , 'ascii' ) except UnicodeError : raise errors . CharsetError ( input_charset ) input_charset = input_charset . lower ( ) self . input_charset = ALIASES . get ( input_charset , input_charset ) henc , benc , conv = CHARSETS . get ( self . input_charset , ( SHORTEST , BASE64 , None ) ) if not conv : conv = self . input_charset self . header_encoding = henc self . body_encoding = benc self . output_charset = ALIASES . get ( conv , conv ) self . input_codec = CODEC_MAP . get ( self . input_charset , self . input_charset ) self . output_codec = CODEC_MAP . get ( self . output_charset , self . output_charset ) def __str__ ( self ) : return self . input_charset . lower ( ) __repr__ = __str__ def __eq__ ( self , other ) : return str ( self ) == str ( other ) . lower ( ) def __ne__ ( self , other ) : return not self . __eq__ ( other ) def get_body_encoding ( self ) : assert self . body_encoding != SHORTEST if self . body_encoding == QP : return 'quoted-printable' elif self . body_encoding == BASE64 : return 'base64' else : return encode_7or8bit def convert ( self , s ) : if self . input_codec != self . output_codec : return unicode ( s , self . input_codec ) . encode ( self . output_codec ) else : return s def to_splittable ( self , s ) : if isinstance ( s , unicode ) or self . input_codec is None : return s try : return unicode ( s , self . input_codec , 'replace' ) except LookupError : return s def from_splittable ( self , ustr , to_output = True ) : if to_output : codec = self . output_codec else : codec = self . input_codec if not isinstance ( ustr , unicode ) or codec is None : return ustr try : return ustr . encode ( codec , 'replace' ) except LookupError : return ustr def get_output_charset ( self ) : return self . output_charset or self . input_charset def encoded_header_len ( self , s ) : cset = self . get_output_charset ( ) if self . header_encoding == BASE64 : return email . base64mime . base64_len ( s ) + len ( cset ) + MISC_LEN elif self . header_encoding == QP : return email . quoprimime . header_quopri_len ( s ) + len ( cset ) + MISC_LEN elif self . header_encoding == SHORTEST : lenb64 = email . base64mime . base64_len ( s ) lenqp = email . quoprimime . header_quopri_len ( s ) return min ( lenb64 , lenqp ) + len ( cset ) + MISC_LEN else : return len ( s ) def header_encode ( self , s , convert = False ) : cset = self . get_output_charset ( ) if convert : s = self . convert ( s ) if self . header_encoding == BASE64 : return email . base64mime . header_encode ( s , cset ) elif self . header_encoding == QP : return email . quoprimime . header_encode ( s , cset , maxlinelen = None ) elif self . header_encoding == SHORTEST : lenb64 = email . base64mime . base64_len ( s ) lenqp = email . quoprimime . header_quopri_len ( s ) if lenb64 < lenqp : return email . base64mime . header_encode ( s , cset ) else : return email . quoprimime . header_encode ( s , cset , maxlinelen = None ) else : return s def body_encode ( self , s , convert = True ) : if convert : s = self . convert ( s ) if self . body_encoding is BASE64 : return email . base64mime . body_encode ( s ) elif self . body_encoding is QP : return email . quoprimime . body_encode ( s ) else : return s

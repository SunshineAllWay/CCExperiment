"""Utility functions for copying files and directory trees. XXX The functions here don't copy the resource fork or other metadata on Mac. """ import os import sys import stat from os . path import abspath import fnmatch __all__ = [ "copyfileobj" , "copyfile" , "copymode" , "copystat" , "copy" , "copy2" , , "move" , "rmtree" , "Error" ] class Error ( EnvironmentError ) : pass try : WindowsError except NameError : WindowsError = None def copyfileobj ( fsrc , fdst , length = 16 * 1024 ) : while 1 : buf = fsrc . read ( length ) if not buf : break fdst . write ( buf ) def _samefile ( src , dst ) : if hasattr ( os . path , 'samefile' ) : try : return os . path . samefile ( src , dst ) except OSError : return False return ( os . path . normcase ( os . path . abspath ( src ) ) == os . path . normcase ( os . path . abspath ( dst ) ) ) def copyfile ( src , dst ) : if _samefile ( src , dst ) : raise Error , "`%s` and `%s` are the same file" % ( src , dst ) fsrc = None fdst = None try : fsrc = open ( src , 'rb' ) fdst = open ( dst , 'wb' ) copyfileobj ( fsrc , fdst ) finally : if fdst : fdst . close ( ) if fsrc : fsrc . close ( ) def copymode ( src , dst ) : if hasattr ( os , 'chmod' ) : st = os . stat ( src ) mode = stat . S_IMODE ( st . st_mode ) os . chmod ( dst , mode ) def copystat ( src , dst ) : st = os . stat ( src ) mode = stat . S_IMODE ( st . st_mode ) if hasattr ( os , 'utime' ) : os . utime ( dst , ( st . st_atime , st . st_mtime ) ) if hasattr ( os , 'chmod' ) : os . chmod ( dst , mode ) if hasattr ( os , 'chflags' ) and hasattr ( st , 'st_flags' ) : os . chflags ( dst , st . st_flags ) def copy ( src , dst ) : if os . path . isdir ( dst ) : dst = os . path . join ( dst , os . path . basename ( src ) ) copyfile ( src , dst ) copymode ( src , dst ) def copy2 ( src , dst ) : if os . path . isdir ( dst ) : dst = os . path . join ( dst , os . path . basename ( src ) ) copyfile ( src , dst ) copystat ( src , dst ) def ignore_patterns ( * patterns ) : def _ignore_patterns ( path , names ) : ignored_names = [ ] for pattern in patterns : ignored_names . extend ( fnmatch . filter ( names , pattern ) ) return set ( ignored_names ) return _ignore_patterns def copytree ( src , dst , symlinks = False , ignore = None ) : names = os . listdir ( src ) if ignore is not None : ignored_names = ignore ( src , names ) else : ignored_names = set ( ) os . makedirs ( dst ) errors = [ ] for name in names : if name in ignored_names : continue srcname = os . path . join ( src , name ) dstname = os . path . join ( dst , name ) try : if symlinks and os . path . islink ( srcname ) : linkto = os . readlink ( srcname ) os . symlink ( linkto , dstname ) elif os . path . isdir ( srcname ) : copytree ( srcname , dstname , symlinks , ignore ) else : copy2 ( srcname , dstname ) except ( IOError , os . error ) , why : errors . append ( ( srcname , dstname , str ( why ) ) ) except Error , err : errors . extend ( err . args [ 0 ] ) try : copystat ( src , dst ) except OSError , why : if WindowsError is not None and isinstance ( why , WindowsError ) : pass else : errors . extend ( ( src , dst , str ( why ) ) ) if errors : raise Error , errors def rmtree ( path , ignore_errors = False , onerror = None ) : if ignore_errors : def onerror ( * args ) : pass elif onerror is None : def onerror ( * args ) : raise try : if os . path . islink ( path ) : raise OSError ( "Cannot call rmtree on a symbolic link" ) except OSError : onerror ( os . path . islink , path , sys . exc_info ( ) ) return names = [ ] try : names = os . listdir ( path ) except os . error , err : onerror ( os . listdir , path , sys . exc_info ( ) ) for name in names : fullname = os . path . join ( path , name ) try : mode = os . lstat ( fullname ) . st_mode except os . error : mode = 0 if stat . S_ISDIR ( mode ) : rmtree ( fullname , ignore_errors , onerror ) else : try : os . remove ( fullname ) except os . error , err : onerror ( os . remove , fullname , sys . exc_info ( ) ) try : os . rmdir ( path ) except os . error : onerror ( os . rmdir , path , sys . exc_info ( ) ) def _basename ( path ) : return os . path . basename ( path . rstrip ( os . path . sep ) ) def move ( src , dst ) : real_dst = dst if os . path . isdir ( dst ) : real_dst = os . path . join ( dst , _basename ( src ) ) if os . path . exists ( real_dst ) : raise Error , "Destination path '%s' already exists" % real_dst try : os . rename ( src , real_dst ) except OSError : if os . path . isdir ( src ) : if destinsrc ( src , dst ) : raise Error , "Cannot move a directory '%s' into itself '%s'." % ( src , dst ) copytree ( src , real_dst , symlinks = True ) rmtree ( src ) else : copy2 ( src , real_dst ) os . unlink ( src ) def destinsrc ( src , dst ) : return abspath ( dst ) . startswith ( abspath ( src ) )

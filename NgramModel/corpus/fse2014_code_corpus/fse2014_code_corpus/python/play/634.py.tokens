"""RFC 3986 URI parsing and relative reference resolution / absolutization. (aka splitting and joining) Copyright 2006 John J. Lee <jjl@pobox.com> This code is free software; you can redistribute it and/or modify it under the terms of the BSD or ZPL 2.1 licenses (see the file COPYING.txt included with the distribution). """ import re , urllib BAD_URI_CHARS_RE = re . compile ( "[^A-Za-z0-9\-_.~!*'();:@&=+$,/?%#[\]]" ) def clean_url ( url , encoding ) : if type ( url ) == type ( "" ) : url = url . decode ( encoding , "replace" ) url = url . strip ( ) return urllib . quote ( url . encode ( encoding ) , "!*'();:@&=+$,/?%#[]~" ) def is_clean_uri ( uri ) : return not bool ( BAD_URI_CHARS_RE . search ( uri ) ) SPLIT_MATCH = re . compile ( ) . match def urlsplit ( absolute_uri ) : match = SPLIT_MATCH ( absolute_uri ) if match : g = match . groups ( ) return g [ 1 ] , g [ 3 ] , g [ 4 ] , g [ 6 ] , g [ 8 ] def urlunsplit ( parts ) : scheme , authority , path , query , fragment = parts r = [ ] append = r . append if scheme is not None : append ( scheme ) append ( ":" ) if authority is not None : append ( "//" ) append ( authority ) append ( path ) if query is not None : append ( "?" ) append ( query ) if fragment is not None : append ( "#" ) append ( fragment ) return "" . join ( r ) def urljoin ( base_uri , uri_reference ) : return urlunsplit ( urljoin_parts ( urlsplit ( base_uri ) , urlsplit ( uri_reference ) ) ) def urljoin_parts ( base_parts , reference_parts ) : scheme , authority , path , query , fragment = base_parts rscheme , rauthority , rpath , rquery , rfragment = reference_parts if rscheme == scheme : rscheme = None if rscheme is not None : tscheme , tauthority , tpath , tquery = ( rscheme , rauthority , remove_dot_segments ( rpath ) , rquery ) else : if rauthority is not None : tauthority , tpath , tquery = ( rauthority , remove_dot_segments ( rpath ) , rquery ) else : if rpath == "" : tpath = path if rquery is not None : tquery = rquery else : tquery = query else : if rpath . startswith ( "/" ) : tpath = remove_dot_segments ( rpath ) else : tpath = merge ( authority , path , rpath ) tpath = remove_dot_segments ( tpath ) tquery = rquery tauthority = authority tscheme = scheme tfragment = rfragment return ( tscheme , tauthority , tpath , tquery , tfragment ) def remove_dot_segments ( path ) : r = [ ] while path : if path . startswith ( "../" ) : path = path [ 3 : ] continue if path . startswith ( "./" ) : path = path [ 2 : ] continue if path . startswith ( "/./" ) : path = path [ 2 : ] continue if path == "/." : path = "/" continue if path . startswith ( "/../" ) : path = path [ 3 : ] if r : r . pop ( ) continue if path == "/.." : path = "/" if r : r . pop ( ) continue if path == "." : path = path [ 1 : ] continue if path == ".." : path = path [ 2 : ] continue start = 0 if path . startswith ( "/" ) : start = 1 ii = path . find ( "/" , start ) if ii < 0 : ii = None r . append ( path [ : ii ] ) if ii is None : break path = path [ ii : ] return "" . join ( r ) def merge ( base_authority , base_path , ref_path ) : if base_path == "" : return "/" + ref_path ii = base_path . rfind ( "/" ) if ii >= 0 : return base_path [ : ii + 1 ] + ref_path return ref_path if __name__ == "__main__" : import doctest doctest . testmod ( )

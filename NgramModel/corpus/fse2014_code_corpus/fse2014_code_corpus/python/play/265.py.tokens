''' an attempt to implement readline for Python in Python using ctypes''' import sys , os , re from glob import glob import clipboard , logger , console from logger import log , log_sock from error import ReadlineError , GetSetError from pyreadline . keysyms . common import make_KeyPress_from_keydescr import pyreadline . lineeditor . lineobj as lineobj import pyreadline . lineeditor . history as history import release from modes import editingmodes in_ironpython = "IronPython" in sys . version if in_ironpython : import System default_prompt = ">>> " else : default_prompt = "" import pdb def quote_char ( c ) : if ord ( c ) > 0 : return c def inword ( buffer , point ) : return buffer [ point : point + 1 ] in [ A - Za - z0 - 9 ] class Readline ( object ) : def __init__ ( self ) : self . startup_hook = None self . pre_input_hook = None self . completer = None self . completer_delims = " \t\n\"\\'`@$><=;|&{(" self . console = console . Console ( ) self . size = self . console . size ( ) self . prompt_color = None self . command_color = None self . selection_color = self . console . saveattr << 4 self . key_dispatch = { } self . previous_func = None self . first_prompt = True self . next_meta = False self . tabstop = 4 self . allow_ctrl_c = False self . ctrl_c_tap_time_interval = 0.3 self . debug = False self . begidx = 0 self . endidx = 0 self . show_all_if_ambiguous = 'off' self . mark_directories = 'on' self . bell_style = 'none' self . mark = - 1 self . l_buffer = lineobj . ReadLineTextBuffer ( "" ) self . _history = history . LineHistory ( ) self . editingmodes = [ mode ( self ) for mode in editingmodes ] for mode in self . editingmodes : mode . init_editing_mode ( None ) self . mode = self . editingmodes [ 0 ] self . read_inputrc ( ) log ( "\n" . join ( self . rl_settings_to_string ( ) ) ) self . enable_ipython_paste_for_paths = True self . enable_ipython_paste_list_of_lists = True self . enable_win32_clipboard = True self . paste_line_buffer = [ ] def _g ( x ) : def g ( self ) : raise GetSetError ( "GET %s" % x ) def s ( self , q ) : raise GetSetError ( "SET %s" % x ) return g , s line_buffer = property ( * _g ( "line_buffer" ) ) line_cursor = property ( * _g ( "line_buffer" ) ) undo_stack = property ( * _g ( "undo_stack" ) ) history_length = property ( * _g ( "history_length" ) ) history = property ( * _g ( "history" ) ) history_cursor = property ( * _g ( "history_cursor" ) ) def parse_and_bind ( self , string ) : try : log ( 'parse_and_bind("%s")' % string ) if string . startswith ( '#' ) : return if string . startswith ( 'set' ) : m = re . compile ( r'set\s+([-a-zA-Z0-9]+)\s+(.+)\s*$' ) . match ( string ) if m : var_name = m . group ( 1 ) val = m . group ( 2 ) try : setattr ( self , var_name . replace ( '-' , '_' ) , val ) except AttributeError : log ( 'unknown var="%s" val="%s"' % ( var_name , val ) ) else : log ( 'bad set "%s"' % string ) return m = re . compile ( r'\s*(.+)\s*:\s*([-a-zA-Z]+)\s*$' ) . match ( string ) if m : key = m . group ( 1 ) func_name = m . group ( 2 ) py_name = func_name . replace ( '-' , '_' ) try : func = getattr ( self . mode , py_name ) except AttributeError : log ( 'unknown func key="%s" func="%s"' % ( key , func_name ) ) if self . debug : print 'pyreadline parse_and_bind error, unknown function to bind: "%s"' % func_name return self . mode . _bind_key ( key , func ) except : log ( 'error' ) raise def get_line_buffer ( self ) : return self . l_buffer . get_line_text ( ) def insert_text ( self , string ) : self . l_buffer . insert_text ( string ) def read_init_file ( self , filename = None ) : log ( 'read_init_file("%s")' % filename ) def add_history ( self , line ) : self . _history . add_history ( line ) def get_history_length ( self ) : return self . _history . get_history_length ( ) def set_history_length ( self , length ) : self . _history . set_history_length ( length ) def clear_history ( self ) : self . _history . clear_history ( ) def read_history_file ( self , filename = None ) : self . _history . read_history_file ( filename ) def write_history_file ( self , filename = None ) : self . _history . write_history_file ( filename ) def set_completer ( self , function = None ) : log ( 'set_completer' ) self . completer = function def get_completer ( self ) : log ( 'get_completer' ) return self . completer def get_begidx ( self ) : return self . begidx def get_endidx ( self ) : return self . endidx def set_completer_delims ( self , string ) : self . completer_delims = string def get_completer_delims ( self ) : return self . completer_delims def set_startup_hook ( self , function = None ) : self . startup_hook = function def set_pre_input_hook ( self , function = None ) : self . pre_input_hook = function def rl_settings_to_string ( self ) : out = [ "%-20s: %s" % ( "show all if ambigous" , self . show_all_if_ambiguous ) ] out . append ( "%-20s: %s" % ( "mark_directories" , self . mark_directories ) ) out . append ( "%-20s: %s" % ( "bell_style" , self . bell_style ) ) out . append ( "%-20s: %s" % ( "mark_directories" , self . mark_directories ) ) out . append ( "------------- key bindings ------------" ) tablepat = "%-7s %-7s %-7s %-15s %-15s " out . append ( tablepat % ( "Control" , "Meta" , "Shift" , "Keycode/char" , "Function" ) ) bindings = [ ( k [ 0 ] , k [ 1 ] , k [ 2 ] , k [ 3 ] , v . __name__ ) for k , v in self . mode . key_dispatch . iteritems ( ) ] bindings . sort ( ) for key in bindings : out . append ( tablepat % ( key ) ) return out def _bell ( self ) : if self . bell_style == 'none' : pass elif self . bell_style == 'visible' : raise NotImplementedError ( "Bellstyle visible is not implemented yet." ) elif self . bell_style == 'audible' : self . console . bell ( ) else : raise ReadlineError ( "Bellstyle %s unknown." % self . bell_style ) def _clear_after ( self ) : c = self . console x , y = c . pos ( ) w , h = c . size ( ) c . rectangle ( ( x , y , w + 1 , y + 1 ) ) c . rectangle ( ( 0 , y + 1 , w , min ( y + 3 , h ) ) ) def _set_cursor ( self ) : c = self . console xc , yc = self . prompt_end_pos w , h = c . size ( ) xc += self . l_buffer . visible_line_width ( ) while ( xc >= w ) : xc -= w yc += 1 c . pos ( xc , yc ) def _print_prompt ( self ) : c = self . console x , y = c . pos ( ) n = c . write_scrolling ( self . prompt , self . prompt_color ) self . prompt_begin_pos = ( x , y - n ) self . prompt_end_pos = c . pos ( ) self . size = c . size ( ) def _update_prompt_pos ( self , n ) : if n != 0 : bx , by = self . prompt_begin_pos ex , ey = self . prompt_end_pos self . prompt_begin_pos = ( bx , by - n ) self . prompt_end_pos = ( ex , ey - n ) def _update_line ( self ) : c = self . console c . cursor ( 0 ) c . pos ( * self . prompt_end_pos ) ltext = self . l_buffer . quoted_text ( ) if self . l_buffer . enable_selection and self . l_buffer . selection_mark >= 0 : start = len ( self . l_buffer [ : self . l_buffer . selection_mark ] . quoted_text ( ) ) stop = len ( self . l_buffer [ : self . l_buffer . point ] . quoted_text ( ) ) if start > stop : stop , start = start , stop n = c . write_scrolling ( ltext [ : start ] , self . command_color ) n = c . write_scrolling ( ltext [ start : stop ] , self . selection_color ) n = c . write_scrolling ( ltext [ stop : ] , self . command_color ) else : n = c . write_scrolling ( ltext , self . command_color ) x , y = c . pos ( ) w , h = c . size ( ) if y >= h - 1 or n > 0 : c . scroll_window ( - 1 ) c . scroll ( ( 0 , 0 , w , h ) , 0 , - 1 ) n += 1 self . _update_prompt_pos ( n ) if hasattr ( c , "clear_to_end_of_window" ) : c . clear_to_end_of_window ( ) else : self . _clear_after ( ) c . cursor ( 1 ) self . _set_cursor ( ) def readline ( self , prompt = '' ) : return self . mode . readline ( prompt ) def read_inputrc ( self , inputrcpath = os . path . expanduser ( "~/pyreadlineconfig.ini" ) ) : modes = dict ( [ ( x . mode , x ) for x in self . editingmodes ] ) mode = self . editingmodes [ 0 ] . mode def setmode ( name ) : self . mode = modes [ name ] def bind_key ( key , name ) : log ( "bind %s %s" % ( key , name ) ) if hasattr ( modes [ mode ] , name ) : modes [ mode ] . _bind_key ( key , getattr ( modes [ mode ] , name ) ) else : print "Trying to bind unknown command '%s' to key '%s'" % ( name , key ) def un_bind_key ( key ) : keyinfo = make_KeyPress_from_keydescr ( key ) . tuple ( ) if keyinfo in modes [ mode ] . key_dispatch : del modes [ mode ] . key_dispatch [ keyinfo ] def bind_exit_key ( key ) : modes [ mode ] . _bind_exit_key ( key ) def un_bind_exit_key ( key ) : keyinfo = make_KeyPress_from_keydescr ( key ) . tuple ( ) if keyinfo in modes [ mode ] . exit_dispatch : del modes [ mode ] . exit_dispatch [ keyinfo ] def setkill_ring_to_clipboard ( killring ) : import pyreadline . lineeditor . lineobj pyreadline . lineeditor . lineobj . kill_ring_to_clipboard = killring def sethistoryfilename ( filename ) : self . _history . history_filename = os . path . expanduser ( filename ) def setbellstyle ( mode ) : self . bell_style = mode def sethistorylength ( length ) : self . _history . history_length = int ( length ) def allow_ctrl_c ( mode ) : log_sock ( "allow_ctrl_c:%s:%s" % ( self . allow_ctrl_c , mode ) ) self . allow_ctrl_c = mode def setbellstyle ( mode ) : self . bell_style = mode def show_all_if_ambiguous ( mode ) : self . show_all_if_ambiguous = mode def ctrl_c_tap_time_interval ( mode ) : self . ctrl_c_tap_time_interval = mode def mark_directories ( mode ) : self . mark_directories = mode def completer_delims ( mode ) : self . completer_delims = mode def debug_output ( on , filename = "pyreadline_debug_log.txt" ) : if on in [ "on" , "on_nologfile" ] : self . debug = True logger . start_log ( on , filename ) logger . log ( "STARTING LOG" ) def set_prompt_color ( color ) : trtable = { "black" : 0 , "darkred" : 4 , "darkgreen" : 2 , "darkyellow" : 6 , "darkblue" : 1 , "darkmagenta" : 5 , "darkcyan" : 3 , "gray" : 7 , : 4 + 8 , "green" : 2 + 8 , "yellow" : 6 + 8 , "blue" : 1 + 8 , "magenta" : 5 + 8 , "cyan" : 3 + 8 , "white" : 7 + 8 } self . prompt_color = trtable . get ( color . lower ( ) , 7 ) def set_input_color ( color ) : trtable = { "black" : 0 , "darkred" : 4 , "darkgreen" : 2 , "darkyellow" : 6 , "darkblue" : 1 , "darkmagenta" : 5 , "darkcyan" : 3 , "gray" : 7 , : 4 + 8 , "green" : 2 + 8 , "yellow" : 6 + 8 , "blue" : 1 + 8 , "magenta" : 5 + 8 , "cyan" : 3 + 8 , "white" : 7 + 8 } self . command_color = trtable . get ( color . lower ( ) , 7 ) loc = { "branch" : release . branch , : release . version , : mode , : modes , : setmode , : bind_key , : bind_exit_key , : un_bind_key , : un_bind_exit_key , : setbellstyle , : mark_directories , : show_all_if_ambiguous , : completer_delims , : debug_output , : sethistoryfilename , : sethistorylength , : set_prompt_color , : set_input_color , : allow_ctrl_c , : ctrl_c_tap_time_interval , : setkill_ring_to_clipboard , } if os . path . isfile ( inputrcpath ) : try : execfile ( inputrcpath , loc , loc ) except Exception , x : raise import traceback print >> sys . stderr , "Error reading .pyinputrc" filepath , lineno = traceback . extract_tb ( sys . exc_traceback ) [ 1 ] [ : 2 ] print >> sys . stderr , "Line: %s in file %s" % ( lineno , filepath ) print >> sys . stderr , x raise ReadlineError ( "Error reading .pyinputrc" ) def CTRL ( c ) : assert '@' <= c <= '_' return chr ( ord ( c ) - ord ( '@' ) ) rl = Readline ( ) def GetOutputFile ( ) : return rl . console parse_and_bind = rl . parse_and_bind get_line_buffer = rl . get_line_buffer insert_text = rl . insert_text read_init_file = rl . read_init_file add_history = rl . add_history get_history_length = rl . get_history_length set_history_length = rl . set_history_length clear_history = rl . clear_history read_history_file = rl . read_history_file write_history_file = rl . write_history_file set_completer = rl . set_completer get_completer = rl . get_completer get_begidx = rl . get_begidx get_endidx = rl . get_endidx set_completer_delims = rl . set_completer_delims get_completer_delims = rl . get_completer_delims set_startup_hook = rl . set_startup_hook set_pre_input_hook = rl . set_pre_input_hook if __name__ == '__main__' : res = [ rl . readline ( 'In[%d] ' % i ) for i in range ( 3 ) ] print res else : console . install_readline ( rl . readline ) pass

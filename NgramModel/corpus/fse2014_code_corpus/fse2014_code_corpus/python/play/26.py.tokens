"""runpy.py - locating and running Python code using the module namespace Provides support for locating and running Python scripts using the Python module namespace instead of the native filesystem. This allows Python code to play nicely with non-filesystem based PEP 302 importers when locating support scripts as well as when importing modules. """ import sys import imp try : from imp import get_loader except ImportError : from pkgutil import get_loader __all__ = [ , ] def _run_code ( code , run_globals , init_globals = None , mod_name = None , mod_fname = None , mod_loader = None , pkg_name = None ) : if init_globals is not None : run_globals . update ( init_globals ) run_globals . update ( __name__ = mod_name , __file__ = mod_fname , __loader__ = mod_loader , __package__ = pkg_name ) exec code in run_globals return run_globals def _run_module_code ( code , init_globals = None , mod_name = None , mod_fname = None , mod_loader = None , pkg_name = None ) : temp_module = imp . new_module ( mod_name ) mod_globals = temp_module . __dict__ saved_argv0 = sys . argv [ 0 ] restore_module = mod_name in sys . modules if restore_module : saved_module = sys . modules [ mod_name ] sys . argv [ 0 ] = mod_fname sys . modules [ mod_name ] = temp_module try : _run_code ( code , mod_globals , init_globals , mod_name , mod_fname , mod_loader , pkg_name ) finally : sys . argv [ 0 ] = saved_argv0 if restore_module : sys . modules [ mod_name ] = saved_module else : del sys . modules [ mod_name ] return mod_globals . copy ( ) def _get_filename ( loader , mod_name ) : try : get_filename = loader . get_filename except AttributeError : return None else : return get_filename ( mod_name ) def _get_module_details ( mod_name ) : loader = get_loader ( mod_name ) if loader is None : raise ImportError ( "No module named %s" % mod_name ) if loader . is_package ( mod_name ) : raise ImportError ( ( "%s is a package and cannot " + ) % mod_name ) code = loader . get_code ( mod_name ) if code is None : raise ImportError ( "No code object available for %s" % mod_name ) filename = _get_filename ( loader , mod_name ) return loader , code , filename def _run_module_as_main ( mod_name , set_argv0 = True ) : try : loader , code , fname = _get_module_details ( mod_name ) except ImportError as exc : if set_argv0 : info = str ( exc ) else : info = "can't find '__main__.py' in %r" % sys . argv [ 0 ] msg = "%s: %s" % ( sys . executable , info ) sys . exit ( msg ) pkg_name = mod_name . rpartition ( '.' ) [ 0 ] main_globals = sys . modules [ "__main__" ] . __dict__ if set_argv0 : sys . argv [ 0 ] = fname return _run_code ( code , main_globals , None , , fname , loader , pkg_name ) def run_module ( mod_name , init_globals = None , run_name = None , alter_sys = False ) : loader , code , fname = _get_module_details ( mod_name ) if run_name is None : run_name = mod_name pkg_name = mod_name . rpartition ( '.' ) [ 0 ] if alter_sys : return _run_module_code ( code , init_globals , run_name , fname , loader , pkg_name ) else : return _run_code ( code , { } , init_globals , run_name , fname , loader , pkg_name ) if __name__ == "__main__" : if len ( sys . argv ) < 2 : print >> sys . stderr , "No module specified for execution" else : del sys . argv [ 0 ] _run_module_as_main ( sys . argv [ 0 ] )

"""Package resource API -------------------- A resource is a logical file contained within a package, or a logical subdirectory thereof. The package resource API expects resource names to have their path parts separated with ``/``, *not* whatever the local path separator is. Do not use os.path operations to manipulate resource names being passed into the API. The package resource API is designed to work with normal filesystem packages, .egg files, and unpacked .egg files. It can also work in a limited way with .zip files and with custom PEP 302 loaders that support the ``get_data()`` method. """ import sys , os , zipimport , time , re , imp , new try : frozenset except NameError : from sets import ImmutableSet as frozenset from os import utime , rename , unlink from os import open as os_open def get_supported_platform ( ) : plat = get_build_platform ( ) ; m = macosVersionString . match ( plat ) if m is not None and sys . platform == "darwin" : try : plat = 'macosx-%s-%s' % ( '.' . join ( _macosx_vers ( ) [ : 2 ] ) , m . group ( 3 ) ) except ValueError : pass return plat __all__ = [ , 'run_script' , 'get_provider' , 'get_distribution' , , 'get_entry_map' , 'get_entry_info' , 'iter_entry_points' , , 'resource_stream' , 'resource_filename' , , 'resource_exists' , 'resource_isdir' , , 'working_set' , 'add_activation_listener' , , 'set_extraction_path' , 'cleanup_resources' , , , 'WorkingSet' , 'ResourceManager' , , 'Requirement' , 'EntryPoint' , , 'VersionConflict' , 'DistributionNotFound' , 'UnknownExtra' , , , 'parse_version' , 'safe_name' , 'safe_version' , , 'compatible_platforms' , 'yield_lines' , 'split_sections' , , 'to_filename' , , 'normalize_path' , , 'BINARY_DIST' , 'SOURCE_DIST' , 'CHECKOUT_DIST' , 'DEVELOP_DIST' , , 'IResourceProvider' , 'FileMetadata' , , 'EggMetadata' , 'EmptyProvider' , 'empty_provider' , , 'EggProvider' , 'DefaultProvider' , 'ZipProvider' , , 'register_namespace_handler' , 'register_loader_type' , , 'get_importer' , , 'AvailableDistributions' , ] class ResolutionError ( Exception ) : def __repr__ ( self ) : return self . __class__ . __name__ + repr ( self . args ) class VersionConflict ( ResolutionError ) : class DistributionNotFound ( ResolutionError ) : class UnknownExtra ( ResolutionError ) : _provider_factories = { } PY_MAJOR = sys . version [ : 3 ] EGG_DIST = 3 BINARY_DIST = 2 SOURCE_DIST = 1 CHECKOUT_DIST = 0 DEVELOP_DIST = - 1 def register_loader_type ( loader_type , provider_factory ) : _provider_factories [ loader_type ] = provider_factory def get_provider ( moduleOrReq ) : if isinstance ( moduleOrReq , Requirement ) : return working_set . find ( moduleOrReq ) or require ( str ( moduleOrReq ) ) [ 0 ] try : module = sys . modules [ moduleOrReq ] except KeyError : __import__ ( moduleOrReq ) module = sys . modules [ moduleOrReq ] loader = getattr ( module , '__loader__' , None ) return _find_adapter ( _provider_factories , loader ) ( module ) def _macosx_vers ( _cache = [ ] ) : if not _cache : info = os . popen ( '/usr/bin/sw_vers' ) . read ( ) . splitlines ( ) for line in info : key , value = line . split ( None , 1 ) if key == 'ProductVersion:' : _cache . append ( value . strip ( ) . split ( "." ) ) break else : raise ValueError , "What?!" return _cache [ 0 ] def _macosx_arch ( machine ) : return { 'PowerPC' : 'ppc' , 'Power_Macintosh' : 'ppc' } . get ( machine , machine ) def get_build_platform ( ) : from distutils . util import get_platform plat = get_platform ( ) if sys . platform == "darwin" and not plat . startswith ( 'macosx-' ) : try : version = _macosx_vers ( ) machine = os . uname ( ) [ 4 ] . replace ( " " , "_" ) return "macosx-%d.%d-%s" % ( int ( version [ 0 ] ) , int ( version [ 1 ] ) , _macosx_arch ( machine ) ) except ValueError : pass return plat macosVersionString = re . compile ( r"macosx-(\d+)\.(\d+)-(.*)" ) darwinVersionString = re . compile ( r"darwin-(\d+)\.(\d+)\.(\d+)-(.*)" ) get_platform = get_build_platform def compatible_platforms ( provided , required ) : if provided is None or required is None or provided == required : return True reqMac = macosVersionString . match ( required ) if reqMac : provMac = macosVersionString . match ( provided ) if not provMac : provDarwin = darwinVersionString . match ( provided ) if provDarwin : dversion = int ( provDarwin . group ( 1 ) ) macosversion = "%s.%s" % ( reqMac . group ( 1 ) , reqMac . group ( 2 ) ) if dversion == 7 and macosversion >= "10.3" or dversion == 8 and macosversion >= "10.4" : return True return False if provMac . group ( 1 ) != reqMac . group ( 1 ) or provMac . group ( 3 ) != reqMac . group ( 3 ) : return False if int ( provMac . group ( 2 ) ) > int ( reqMac . group ( 2 ) ) : return False return True return False def run_script ( dist_spec , script_name ) : ns = sys . _getframe ( 1 ) . f_globals name = ns [ '__name__' ] ns . clear ( ) ns [ '__name__' ] = name require ( dist_spec ) [ 0 ] . run_script ( script_name , ns ) run_main = run_script def get_distribution ( dist ) : if isinstance ( dist , basestring ) : dist = Requirement . parse ( dist ) if isinstance ( dist , Requirement ) : dist = get_provider ( dist ) if not isinstance ( dist , Distribution ) : raise TypeError ( "Expected string, Requirement, or Distribution" , dist ) return dist def load_entry_point ( dist , group , name ) : return get_distribution ( dist ) . load_entry_point ( group , name ) def get_entry_map ( dist , group = None ) : return get_distribution ( dist ) . get_entry_map ( group ) def get_entry_info ( dist , group , name ) : return get_distribution ( dist ) . get_entry_info ( group , name ) class IMetadataProvider : def has_metadata ( name ) : def get_metadata ( name ) : def get_metadata_lines ( name ) : def metadata_isdir ( name ) : def metadata_listdir ( name ) : def run_script ( script_name , namespace ) : class IResourceProvider ( IMetadataProvider ) : def get_resource_filename ( manager , resource_name ) : def get_resource_stream ( manager , resource_name ) : def get_resource_string ( manager , resource_name ) : def has_resource ( resource_name ) : def resource_isdir ( resource_name ) : def resource_listdir ( resource_name ) : class WorkingSet ( object ) : def __init__ ( self , entries = None ) : self . entries = [ ] self . entry_keys = { } self . by_key = { } self . callbacks = [ ] if entries is None : entries = sys . path for entry in entries : self . add_entry ( entry ) def add_entry ( self , entry ) : self . entry_keys . setdefault ( entry , [ ] ) self . entries . append ( entry ) for dist in find_distributions ( entry , True ) : self . add ( dist , entry , False ) def __contains__ ( self , dist ) : return self . by_key . get ( dist . key ) == dist def find ( self , req ) : dist = self . by_key . get ( req . key ) if dist is not None and dist not in req : raise VersionConflict ( dist , req ) else : return dist def iter_entry_points ( self , group , name = None ) : for dist in self : entries = dist . get_entry_map ( group ) if name is None : for ep in entries . values ( ) : yield ep elif name in entries : yield entries [ name ] def run_script ( self , requires , script_name ) : ns = sys . _getframe ( 1 ) . f_globals name = ns [ '__name__' ] ns . clear ( ) ns [ '__name__' ] = name self . require ( requires ) [ 0 ] . run_script ( script_name , ns ) def __iter__ ( self ) : seen = { } for item in self . entries : for key in self . entry_keys [ item ] : if key not in seen : seen [ key ] = 1 yield self . by_key [ key ] def add ( self , dist , entry = None , insert = True ) : if insert : dist . insert_on ( self . entries , entry ) if entry is None : entry = dist . location keys = self . entry_keys . setdefault ( entry , [ ] ) keys2 = self . entry_keys . setdefault ( dist . location , [ ] ) if dist . key in self . by_key : return self . by_key [ dist . key ] = dist if dist . key not in keys : keys . append ( dist . key ) if dist . key not in keys2 : keys2 . append ( dist . key ) self . _added_new ( dist ) def resolve ( self , requirements , env = None , installer = None ) : requirements = list ( requirements ) [ : : - 1 ] processed = { } best = { } to_activate = [ ] while requirements : req = requirements . pop ( 0 ) if req in processed : continue dist = best . get ( req . key ) if dist is None : dist = self . by_key . get ( req . key ) if dist is None : if env is None : env = Environment ( self . entries ) dist = best [ req . key ] = env . best_match ( req , self , installer ) if dist is None : raise DistributionNotFound ( req ) to_activate . append ( dist ) if dist not in req : raise VersionConflict ( dist , req ) requirements . extend ( dist . requires ( req . extras ) [ : : - 1 ] ) processed [ req ] = True return to_activate def find_plugins ( self , plugin_env , full_env = None , installer = None , fallback = True ) : plugin_projects = list ( plugin_env ) plugin_projects . sort ( ) error_info = { } distributions = { } if full_env is None : env = Environment ( self . entries ) env += plugin_env else : env = full_env + plugin_env shadow_set = self . __class__ ( [ ] ) map ( shadow_set . add , self ) for project_name in plugin_projects : for dist in plugin_env [ project_name ] : req = [ dist . as_requirement ( ) ] try : resolvees = shadow_set . resolve ( req , env , installer ) except ResolutionError , v : error_info [ dist ] = v if fallback : continue else : break else : map ( shadow_set . add , resolvees ) distributions . update ( dict . fromkeys ( resolvees ) ) break distributions = list ( distributions ) distributions . sort ( ) return distributions , error_info def require ( self , * requirements ) : needed = self . resolve ( parse_requirements ( requirements ) ) for dist in needed : self . add ( dist ) return needed def subscribe ( self , callback ) : if callback in self . callbacks : return self . callbacks . append ( callback ) for dist in self : callback ( dist ) def _added_new ( self , dist ) : for callback in self . callbacks : callback ( dist ) class Environment ( object ) : def __init__ ( self , search_path = None , platform = get_supported_platform ( ) , python = PY_MAJOR ) : self . _distmap = { } self . _cache = { } self . platform = platform self . python = python self . scan ( search_path ) def can_add ( self , dist ) : return ( self . python is None or dist . py_version is None or dist . py_version == self . python ) and compatible_platforms ( dist . platform , self . platform ) def remove ( self , dist ) : self . _distmap [ dist . key ] . remove ( dist ) def scan ( self , search_path = None ) : if search_path is None : search_path = sys . path for item in search_path : for dist in find_distributions ( item ) : self . add ( dist ) def __getitem__ ( self , project_name ) : try : return self . _cache [ project_name ] except KeyError : project_name = project_name . lower ( ) if project_name not in self . _distmap : return [ ] if project_name not in self . _cache : dists = self . _cache [ project_name ] = self . _distmap [ project_name ] _sort_dists ( dists ) return self . _cache [ project_name ] def add ( self , dist ) : if self . can_add ( dist ) and dist . has_version ( ) : dists = self . _distmap . setdefault ( dist . key , [ ] ) if dist not in dists : dists . append ( dist ) if dist . key in self . _cache : _sort_dists ( self . _cache [ dist . key ] ) def best_match ( self , req , working_set , installer = None ) : dist = working_set . find ( req ) if dist is not None : return dist for dist in self [ req . key ] : if dist in req : return dist return self . obtain ( req , installer ) def obtain ( self , requirement , installer = None ) : if installer is not None : return installer ( requirement ) def __iter__ ( self ) : for key in self . _distmap . keys ( ) : if self [ key ] : yield key def __iadd__ ( self , other ) : if isinstance ( other , Distribution ) : self . add ( other ) elif isinstance ( other , Environment ) : for project in other : for dist in other [ project ] : self . add ( dist ) else : raise TypeError ( "Can't add %r to environment" % ( other , ) ) return self def __add__ ( self , other ) : new = self . __class__ ( [ ] , platform = None , python = None ) for env in self , other : new += env return new AvailableDistributions = Environment class ExtractionError ( RuntimeError ) : class ResourceManager : extraction_path = None def __init__ ( self ) : self . cached_files = { } def resource_exists ( self , package_or_requirement , resource_name ) : return get_provider ( package_or_requirement ) . has_resource ( resource_name ) def resource_isdir ( self , package_or_requirement , resource_name ) : return get_provider ( package_or_requirement ) . resource_isdir ( resource_name ) def resource_filename ( self , package_or_requirement , resource_name ) : return get_provider ( package_or_requirement ) . get_resource_filename ( self , resource_name ) def resource_stream ( self , package_or_requirement , resource_name ) : return get_provider ( package_or_requirement ) . get_resource_stream ( self , resource_name ) def resource_string ( self , package_or_requirement , resource_name ) : return get_provider ( package_or_requirement ) . get_resource_string ( self , resource_name ) def resource_listdir ( self , package_or_requirement , resource_name ) : return get_provider ( package_or_requirement ) . resource_listdir ( resource_name ) def extraction_error ( self ) : old_exc = sys . exc_info ( ) [ 1 ] cache_path = self . extraction_path or get_default_cache ( ) err = ExtractionError ( """Can't extract file(s) to egg cache The following error occurred while trying to extract file(s) to the Python egg cache: %s The Python egg cache directory is currently set to: %s Perhaps your account does not have write access to this directory? You can change the cache directory by setting the PYTHON_EGG_CACHE environment variable to point to an accessible directory. """ % ( old_exc , cache_path ) ) err . manager = self err . cache_path = cache_path err . original_error = old_exc raise err def get_cache_path ( self , archive_name , names = ( ) ) : extract_path = self . extraction_path or get_default_cache ( ) target_path = os . path . join ( extract_path , archive_name + '-tmp' , * names ) try : ensure_directory ( target_path ) except : self . extraction_error ( ) self . cached_files [ target_path ] = 1 return target_path def postprocess ( self , tempname , filename ) : if os . name == 'posix' : mode = ( ( os . stat ( tempname ) . st_mode ) | 0555 ) & 07777 os . chmod ( tempname , mode ) def set_extraction_path ( self , path ) : if self . cached_files : raise ValueError ( ) self . extraction_path = path def cleanup_resources ( self , force = False ) : def get_default_cache ( ) : try : return os . environ [ 'PYTHON_EGG_CACHE' ] except KeyError : pass if os . name != 'nt' : return os . path . expanduser ( '~/.python-eggs' ) app_data = 'Application Data' app_homes = [ ( ( 'APPDATA' , ) , None ) , ( ( 'USERPROFILE' , ) , app_data ) , ( ( 'HOMEDRIVE' , 'HOMEPATH' ) , app_data ) , ( ( 'HOMEPATH' , ) , app_data ) , ( ( 'HOME' , ) , None ) , ( ( 'WINDIR' , ) , app_data ) , ] for keys , subdir in app_homes : dirname = '' for key in keys : if key in os . environ : dirname = os . path . join ( dirname , os . environ [ key ] ) else : break else : if subdir : dirname = os . path . join ( dirname , subdir ) return os . path . join ( dirname , 'Python-Eggs' ) else : raise RuntimeError ( ) def safe_name ( name ) : return re . sub ( '[^A-Za-z0-9.]+' , '-' , name ) def safe_version ( version ) : version = version . replace ( ' ' , '.' ) return re . sub ( '[^A-Za-z0-9.]+' , '-' , version ) def safe_extra ( extra ) : return re . sub ( '[^A-Za-z0-9.]+' , '_' , extra ) . lower ( ) def to_filename ( name ) : return name . replace ( '-' , '_' ) class NullProvider : egg_name = None egg_info = None loader = None def __init__ ( self , module ) : self . loader = getattr ( module , '__loader__' , None ) self . module_path = os . path . dirname ( getattr ( module , '__file__' , '' ) ) def get_resource_filename ( self , manager , resource_name ) : return self . _fn ( self . module_path , resource_name ) def get_resource_stream ( self , manager , resource_name ) : return StringIO ( self . get_resource_string ( manager , resource_name ) ) def get_resource_string ( self , manager , resource_name ) : return self . _get ( self . _fn ( self . module_path , resource_name ) ) def has_resource ( self , resource_name ) : return self . _has ( self . _fn ( self . module_path , resource_name ) ) def has_metadata ( self , name ) : return self . egg_info and self . _has ( self . _fn ( self . egg_info , name ) ) def get_metadata ( self , name ) : if not self . egg_info : return "" return self . _get ( self . _fn ( self . egg_info , name ) ) def get_metadata_lines ( self , name ) : return yield_lines ( self . get_metadata ( name ) ) def resource_isdir ( self , resource_name ) : return self . _isdir ( self . _fn ( self . module_path , resource_name ) ) def metadata_isdir ( self , name ) : return self . egg_info and self . _isdir ( self . _fn ( self . egg_info , name ) ) def resource_listdir ( self , resource_name ) : return self . _listdir ( self . _fn ( self . module_path , resource_name ) ) def metadata_listdir ( self , name ) : if self . egg_info : return self . _listdir ( self . _fn ( self . egg_info , name ) ) return [ ] def run_script ( self , script_name , namespace ) : script = 'scripts/' + script_name if not self . has_metadata ( script ) : raise ResolutionError ( "No script named %r" % script_name ) script_text = self . get_metadata ( script ) . replace ( '\r\n' , '\n' ) script_text = script_text . replace ( '\r' , '\n' ) script_filename = self . _fn ( self . egg_info , script ) namespace [ '__file__' ] = script_filename if os . path . exists ( script_filename ) : execfile ( script_filename , namespace , namespace ) else : from linecache import cache cache [ script_filename ] = ( len ( script_text ) , 0 , script_text . split ( '\n' ) , script_filename ) script_code = compile ( script_text , script_filename , 'exec' ) exec script_code in namespace , namespace def _has ( self , path ) : raise NotImplementedError ( ) def _isdir ( self , path ) : raise NotImplementedError ( ) def _listdir ( self , path ) : raise NotImplementedError ( ) def _fn ( self , base , resource_name ) : if resource_name : return os . path . join ( base , * resource_name . split ( '/' ) ) return base def _get ( self , path ) : if hasattr ( self . loader , 'get_data' ) : return self . loader . get_data ( path ) raise NotImplementedError ( ) register_loader_type ( object , NullProvider ) class EggProvider ( NullProvider ) : def __init__ ( self , module ) : NullProvider . __init__ ( self , module ) self . _setup_prefix ( ) def _setup_prefix ( self ) : path = self . module_path old = None while path != old : if path . lower ( ) . endswith ( '.egg' ) : self . egg_name = os . path . basename ( path ) self . egg_info = os . path . join ( path , 'EGG-INFO' ) self . egg_root = path break old = path path , base = os . path . split ( path ) class DefaultProvider ( EggProvider ) : def _has ( self , path ) : return os . path . exists ( path ) def _isdir ( self , path ) : return os . path . isdir ( path ) def _listdir ( self , path ) : return os . listdir ( path ) def get_resource_stream ( self , manager , resource_name ) : return open ( self . _fn ( self . module_path , resource_name ) , 'rb' ) def _get ( self , path ) : stream = open ( path , 'rb' ) try : return stream . read ( ) finally : stream . close ( ) register_loader_type ( type ( None ) , DefaultProvider ) class EmptyProvider ( NullProvider ) : _isdir = _has = lambda self , path : False _get = lambda self , path : '' _listdir = lambda self , path : [ ] module_path = None def __init__ ( self ) : pass empty_provider = EmptyProvider ( ) class ZipProvider ( EggProvider ) : eagers = None def __init__ ( self , module ) : EggProvider . __init__ ( self , module ) self . zipinfo = zipimport . _zip_directory_cache [ self . loader . archive ] self . zip_pre = self . loader . archive + os . sep def _zipinfo_name ( self , fspath ) : if fspath . startswith ( self . zip_pre ) : return fspath [ len ( self . zip_pre ) : ] raise AssertionError ( % ( fspath , self . zip_pre ) ) def _parts ( self , zip_path ) : fspath = self . zip_pre + zip_path if fspath . startswith ( self . egg_root + os . sep ) : return fspath [ len ( self . egg_root ) + 1 : ] . split ( os . sep ) raise AssertionError ( % ( fspath , self . egg_root ) ) def get_resource_filename ( self , manager , resource_name ) : if not self . egg_name : raise NotImplementedError ( ) zip_path = self . _resource_to_zip ( resource_name ) eagers = self . _get_eager_resources ( ) if '/' . join ( self . _parts ( zip_path ) ) in eagers : for name in eagers : self . _extract_resource ( manager , self . _eager_to_zip ( name ) ) return self . _extract_resource ( manager , zip_path ) def _extract_resource ( self , manager , zip_path ) : if zip_path in self . _index ( ) : for name in self . _index ( ) [ zip_path ] : last = self . _extract_resource ( manager , os . path . join ( zip_path , name ) ) return os . path . dirname ( last ) zip_stat = self . zipinfo [ zip_path ] t , d , size = zip_stat [ 5 ] , zip_stat [ 6 ] , zip_stat [ 3 ] date_time = ( ( d >> 9 ) + 1980 , ( d >> 5 ) & 0xF , d & 0x1F , ( t & 0xFFFF ) >> 11 , ( t >> 5 ) & 0x3F , ( t & 0x1F ) * 2 , 0 , 0 , - 1 ) timestamp = time . mktime ( date_time ) try : real_path = manager . get_cache_path ( self . egg_name , self . _parts ( zip_path ) ) if os . path . isfile ( real_path ) : stat = os . stat ( real_path ) if stat . st_size == size and stat . st_mtime == timestamp : return real_path outf , tmpnam = _mkstemp ( ".$extract" , dir = os . path . dirname ( real_path ) ) os . write ( outf , self . loader . get_data ( zip_path ) ) os . close ( outf ) utime ( tmpnam , ( timestamp , timestamp ) ) manager . postprocess ( tmpnam , real_path ) try : rename ( tmpnam , real_path ) except os . error : if os . path . isfile ( real_path ) : stat = os . stat ( real_path ) if stat . st_size == size and stat . st_mtime == timestamp : return real_path elif os . name == 'nt' : unlink ( real_path ) rename ( tmpnam , real_path ) return real_path raise except os . error : manager . extraction_error ( ) return real_path def _get_eager_resources ( self ) : if self . eagers is None : eagers = [ ] for name in ( 'native_libs.txt' , 'eager_resources.txt' ) : if self . has_metadata ( name ) : eagers . extend ( self . get_metadata_lines ( name ) ) self . eagers = eagers return self . eagers def _index ( self ) : try : return self . _dirindex except AttributeError : ind = { } for path in self . zipinfo : parts = path . split ( os . sep ) while parts : parent = os . sep . join ( parts [ : - 1 ] ) if parent in ind : ind [ parent ] . append ( parts [ - 1 ] ) break else : ind [ parent ] = [ parts . pop ( ) ] self . _dirindex = ind return ind def _has ( self , fspath ) : zip_path = self . _zipinfo_name ( fspath ) return zip_path in self . zipinfo or zip_path in self . _index ( ) def _isdir ( self , fspath ) : return self . _zipinfo_name ( fspath ) in self . _index ( ) def _listdir ( self , fspath ) : return list ( self . _index ( ) . get ( self . _zipinfo_name ( fspath ) , ( ) ) ) def _eager_to_zip ( self , resource_name ) : return self . _zipinfo_name ( self . _fn ( self . egg_root , resource_name ) ) def _resource_to_zip ( self , resource_name ) : return self . _zipinfo_name ( self . _fn ( self . module_path , resource_name ) ) register_loader_type ( zipimport . zipimporter , ZipProvider ) class FileMetadata ( EmptyProvider ) : def __init__ ( self , path ) : self . path = path def has_metadata ( self , name ) : return name == 'PKG-INFO' def get_metadata ( self , name ) : if name == 'PKG-INFO' : return open ( self . path , 'rU' ) . read ( ) raise KeyError ( "No metadata except PKG-INFO is available" ) def get_metadata_lines ( self , name ) : return yield_lines ( self . get_metadata ( name ) ) class PathMetadata ( DefaultProvider ) : def __init__ ( self , path , egg_info ) : self . module_path = path self . egg_info = egg_info class EggMetadata ( ZipProvider ) : def __init__ ( self , importer ) : self . zipinfo = zipimport . _zip_directory_cache [ importer . archive ] self . zip_pre = importer . archive + os . sep self . loader = importer if importer . prefix : self . module_path = os . path . join ( importer . archive , importer . prefix ) else : self . module_path = importer . archive self . _setup_prefix ( ) class ImpWrapper : def __init__ ( self , path = None ) : self . path = path def find_module ( self , fullname , path = None ) : subname = fullname . split ( "." ) [ - 1 ] if subname != fullname and self . path is None : return None if self . path is None : path = None else : path = [ self . path ] try : file , filename , etc = imp . find_module ( subname , path ) except ImportError : return None return ImpLoader ( file , filename , etc ) class ImpLoader : def __init__ ( self , file , filename , etc ) : self . file = file self . filename = filename self . etc = etc def load_module ( self , fullname ) : try : mod = imp . load_module ( fullname , self . file , self . filename , self . etc ) finally : if self . file : self . file . close ( ) return mod def get_importer ( path_item ) : try : importer = sys . path_importer_cache [ path_item ] except KeyError : for hook in sys . path_hooks : try : importer = hook ( path_item ) except ImportError : pass else : break else : importer = None sys . path_importer_cache . setdefault ( path_item , importer ) if importer is None : try : importer = ImpWrapper ( path_item ) except ImportError : pass return importer try : from pkgutil import get_importer , ImpImporter except ImportError : pass else : ImpWrapper = ImpImporter del ImpLoader , ImpImporter _distribution_finders = { } def register_finder ( importer_type , distribution_finder ) : _distribution_finders [ importer_type ] = distribution_finder def find_distributions ( path_item , only = False ) : importer = get_importer ( path_item ) finder = _find_adapter ( _distribution_finders , importer ) return finder ( importer , path_item , only ) def find_in_zip ( importer , path_item , only = False ) : metadata = EggMetadata ( importer ) if metadata . has_metadata ( 'PKG-INFO' ) : yield Distribution . from_filename ( path_item , metadata = metadata ) if only : return for subitem in metadata . resource_listdir ( '/' ) : if subitem . endswith ( '.egg' ) : subpath = os . path . join ( path_item , subitem ) for dist in find_in_zip ( zipimport . zipimporter ( subpath ) , subpath ) : yield dist register_finder ( zipimport . zipimporter , find_in_zip ) def StringIO ( * args , ** kw ) : global StringIO try : from cStringIO import StringIO except ImportError : from StringIO import StringIO return StringIO ( * args , ** kw ) def find_nothing ( importer , path_item , only = False ) : return ( ) register_finder ( object , find_nothing ) def find_on_path ( importer , path_item , only = False ) : path_item = _normalize_cached ( path_item ) if os . path . isdir ( path_item ) : if path_item . lower ( ) . endswith ( '.egg' ) : yield Distribution . from_filename ( path_item , metadata = PathMetadata ( path_item , os . path . join ( path_item , 'EGG-INFO' ) ) ) else : for entry in os . listdir ( path_item ) : lower = entry . lower ( ) if lower . endswith ( '.egg-info' ) : fullpath = os . path . join ( path_item , entry ) if os . path . isdir ( fullpath ) : metadata = PathMetadata ( path_item , fullpath ) else : metadata = FileMetadata ( fullpath ) yield Distribution . from_location ( path_item , entry , metadata , precedence = DEVELOP_DIST ) elif not only and lower . endswith ( '.egg' ) : for dist in find_distributions ( os . path . join ( path_item , entry ) ) : yield dist elif not only and lower . endswith ( '.egg-link' ) : for line in file ( os . path . join ( path_item , entry ) ) : if not line . strip ( ) : continue for item in find_distributions ( os . path . join ( path_item , line . rstrip ( ) ) ) : yield item break register_finder ( ImpWrapper , find_on_path ) _namespace_handlers = { } _namespace_packages = { } def register_namespace_handler ( importer_type , namespace_handler ) : _namespace_handlers [ importer_type ] = namespace_handler def _handle_ns ( packageName , path_item ) : importer = get_importer ( path_item ) if importer is None : return None loader = importer . find_module ( packageName ) if loader is None : return None module = sys . modules . get ( packageName ) if module is None : module = sys . modules [ packageName ] = new . module ( packageName ) module . __path__ = [ ] ; _set_parent_ns ( packageName ) elif not hasattr ( module , '__path__' ) : raise TypeError ( "Not a package:" , packageName ) handler = _find_adapter ( _namespace_handlers , importer ) subpath = handler ( importer , path_item , packageName , module ) if subpath is not None : path = module . __path__ ; path . append ( subpath ) loader . load_module ( packageName ) ; module . __path__ = path return subpath def declare_namespace ( packageName ) : imp . acquire_lock ( ) try : if packageName in _namespace_packages : return path , parent = sys . path , None if '.' in packageName : parent = '.' . join ( packageName . split ( '.' ) [ : - 1 ] ) declare_namespace ( parent ) __import__ ( parent ) try : path = sys . modules [ parent ] . __path__ except AttributeError : raise TypeError ( "Not a package:" , parent ) _namespace_packages . setdefault ( parent , [ ] ) . append ( packageName ) _namespace_packages . setdefault ( packageName , [ ] ) for path_item in path : _handle_ns ( packageName , path_item ) finally : imp . release_lock ( ) def fixup_namespace_packages ( path_item , parent = None ) : imp . acquire_lock ( ) try : for package in _namespace_packages . get ( parent , ( ) ) : subpath = _handle_ns ( package , path_item ) if subpath : fixup_namespace_packages ( subpath , package ) finally : imp . release_lock ( ) def file_ns_handler ( importer , path_item , packageName , module ) : subpath = os . path . join ( path_item , packageName . split ( '.' ) [ - 1 ] ) normalized = _normalize_cached ( subpath ) for item in module . __path__ : if _normalize_cached ( item ) == normalized : break else : return subpath register_namespace_handler ( ImpWrapper , file_ns_handler ) register_namespace_handler ( zipimport . zipimporter , file_ns_handler ) def null_ns_handler ( importer , path_item , packageName , module ) : return None register_namespace_handler ( object , null_ns_handler ) def normalize_path ( filename ) : return os . path . normcase ( os . path . realpath ( filename ) ) def _normalize_cached ( filename , _cache = { } ) : try : return _cache [ filename ] except KeyError : _cache [ filename ] = result = normalize_path ( filename ) return result def _set_parent_ns ( packageName ) : parts = packageName . split ( '.' ) name = parts . pop ( ) if parts : parent = '.' . join ( parts ) setattr ( sys . modules [ parent ] , name , sys . modules [ packageName ] ) def yield_lines ( strs ) : if isinstance ( strs , basestring ) : for s in strs . splitlines ( ) : s = s . strip ( ) if s and not s . startswith ( '#' ) : yield s else : for ss in strs : for s in yield_lines ( ss ) : yield s LINE_END = re . compile ( r"\s*(#.*)?$" ) . match CONTINUE = re . compile ( r"\s*\\\s*(#.*)?$" ) . match DISTRO = re . compile ( r"\s*((\w|[-.])+)" ) . match VERSION = re . compile ( r"\s*(<=?|>=?|==|!=)\s*((\w|[-.])+)" ) . match COMMA = re . compile ( r"\s*," ) . match OBRACKET = re . compile ( r"\s*\[" ) . match CBRACKET = re . compile ( r"\s*\]" ) . match MODULE = re . compile ( r"\w+(\.\w+)*$" ) . match EGG_NAME = re . compile ( , re . VERBOSE | re . IGNORECASE ) . match component_re = re . compile ( r'(\d+ | [a-z]+ | \.| -)' , re . VERBOSE ) replace = { 'pre' : 'c' , 'preview' : 'c' , '-' : 'final-' , 'rc' : 'c' , 'dev' : '@' } . get def _parse_version_parts ( s ) : for part in component_re . split ( s ) : part = replace ( part , part ) if not part or part == '.' : continue if part [ : 1 ] in '0123456789' : yield part . zfill ( 8 ) else : yield '*' + part yield '*final' def parse_version ( s ) : parts = [ ] for part in _parse_version_parts ( s . lower ( ) ) : if part . startswith ( '*' ) : if part < '*final' : while parts and parts [ - 1 ] == '*final-' : parts . pop ( ) while parts and parts [ - 1 ] == '00000000' : parts . pop ( ) parts . append ( part ) return tuple ( parts ) class EntryPoint ( object ) : def __init__ ( self , name , module_name , attrs = ( ) , extras = ( ) , dist = None ) : if not MODULE ( module_name ) : raise ValueError ( "Invalid module name" , module_name ) self . name = name self . module_name = module_name self . attrs = tuple ( attrs ) self . extras = Requirement . parse ( ( "x[%s]" % ',' . join ( extras ) ) ) . extras self . dist = dist def __str__ ( self ) : s = "%s = %s" % ( self . name , self . module_name ) if self . attrs : s += ':' + '.' . join ( self . attrs ) if self . extras : s += ' [%s]' % ',' . join ( self . extras ) return s def __repr__ ( self ) : return "EntryPoint.parse(%r)" % str ( self ) def load ( self , require = True , env = None , installer = None ) : if require : self . require ( env , installer ) entry = __import__ ( self . module_name , globals ( ) , globals ( ) , [ '__name__' ] ) for attr in self . attrs : try : entry = getattr ( entry , attr ) except AttributeError : raise ImportError ( "%r has no %r attribute" % ( entry , attr ) ) return entry def require ( self , env = None , installer = None ) : if self . extras and not self . dist : raise UnknownExtra ( "Can't require() without a distribution" , self ) map ( working_set . add , working_set . resolve ( self . dist . requires ( self . extras ) , env , installer ) ) def parse ( cls , src , dist = None ) : try : attrs = extras = ( ) name , value = src . split ( '=' , 1 ) if '[' in value : value , extras = value . split ( '[' , 1 ) req = Requirement . parse ( "x[" + extras ) if req . specs : raise ValueError extras = req . extras if ':' in value : value , attrs = value . split ( ':' , 1 ) if not MODULE ( attrs . rstrip ( ) ) : raise ValueError attrs = attrs . rstrip ( ) . split ( '.' ) except ValueError : raise ValueError ( , src ) else : return cls ( name . strip ( ) , value . strip ( ) , attrs , extras , dist ) parse = classmethod ( parse ) def parse_group ( cls , group , lines , dist = None ) : if not MODULE ( group ) : raise ValueError ( "Invalid group name" , group ) this = { } for line in yield_lines ( lines ) : ep = cls . parse ( line , dist ) if ep . name in this : raise ValueError ( "Duplicate entry point" , group , ep . name ) this [ ep . name ] = ep return this parse_group = classmethod ( parse_group ) def parse_map ( cls , data , dist = None ) : if isinstance ( data , dict ) : data = data . items ( ) else : data = split_sections ( data ) maps = { } for group , lines in data : if group is None : if not lines : continue raise ValueError ( "Entry points must be listed in groups" ) group = group . strip ( ) if group in maps : raise ValueError ( "Duplicate group name" , group ) maps [ group ] = cls . parse_group ( group , lines , dist ) return maps parse_map = classmethod ( parse_map ) class Distribution ( object ) : def __init__ ( self , location = None , metadata = None , project_name = None , version = None , py_version = PY_MAJOR , platform = None , precedence = EGG_DIST ) : self . project_name = safe_name ( project_name or 'Unknown' ) if version is not None : self . _version = safe_version ( version ) self . py_version = py_version self . platform = platform self . location = location self . precedence = precedence self . _provider = metadata or empty_provider def from_location ( cls , location , basename , metadata = None , ** kw ) : project_name , version , py_version , platform = [ None ] * 4 basename , ext = os . path . splitext ( basename ) if ext . lower ( ) in ( ".egg" , ".egg-info" ) : match = EGG_NAME ( basename ) if match : project_name , version , py_version , platform = match . group ( , 'ver' , 'pyver' , 'plat' ) return cls ( location , metadata , project_name = project_name , version = version , py_version = py_version , platform = platform , ** kw ) from_location = classmethod ( from_location ) hashcmp = property ( lambda self : ( getattr ( self , 'parsed_version' , ( ) ) , self . precedence , self . key , - len ( self . location or '' ) , self . location , self . py_version , self . platform ) ) def __cmp__ ( self , other ) : return cmp ( self . hashcmp , other ) def __hash__ ( self ) : return hash ( self . hashcmp ) def key ( self ) : try : return self . _key except AttributeError : self . _key = key = self . project_name . lower ( ) return key key = property ( key ) def parsed_version ( self ) : try : return self . _parsed_version except AttributeError : self . _parsed_version = pv = parse_version ( self . version ) return pv parsed_version = property ( parsed_version ) def version ( self ) : try : return self . _version except AttributeError : for line in self . _get_metadata ( 'PKG-INFO' ) : if line . lower ( ) . startswith ( 'version:' ) : self . _version = safe_version ( line . split ( ':' , 1 ) [ 1 ] . strip ( ) ) return self . _version else : raise ValueError ( , self ) version = property ( version ) def _dep_map ( self ) : try : return self . __dep_map except AttributeError : dm = self . __dep_map = { None : [ ] } for name in 'requires.txt' , 'depends.txt' : for extra , reqs in split_sections ( self . _get_metadata ( name ) ) : if extra : extra = safe_extra ( extra ) dm . setdefault ( extra , [ ] ) . extend ( parse_requirements ( reqs ) ) return dm _dep_map = property ( _dep_map ) def requires ( self , extras = ( ) ) : dm = self . _dep_map deps = [ ] deps . extend ( dm . get ( None , ( ) ) ) for ext in extras : try : deps . extend ( dm [ safe_extra ( ext ) ] ) except KeyError : raise UnknownExtra ( % ( self , ext ) ) return deps def _get_metadata ( self , name ) : if self . has_metadata ( name ) : for line in self . get_metadata_lines ( name ) : yield line def activate ( self , path = None ) : if path is None : path = sys . path self . insert_on ( path ) if path is sys . path : fixup_namespace_packages ( self . location ) map ( declare_namespace , self . _get_metadata ( 'namespace_packages.txt' ) ) def egg_name ( self ) : filename = "%s-%s-py%s" % ( to_filename ( self . project_name ) , to_filename ( self . version ) , self . py_version or PY_MAJOR ) if self . platform : filename += '-' + self . platform return filename def __repr__ ( self ) : if self . location : return "%s (%s)" % ( self , self . location ) else : return str ( self ) def __str__ ( self ) : try : version = getattr ( self , 'version' , None ) except ValueError : version = None version = version or "[unknown version]" return "%s %s" % ( self . project_name , version ) def __getattr__ ( self , attr ) : if attr . startswith ( '_' ) : raise AttributeError , attr return getattr ( self . _provider , attr ) def from_filename ( cls , filename , metadata = None , ** kw ) : return cls . from_location ( _normalize_cached ( filename ) , os . path . basename ( filename ) , metadata , ** kw ) from_filename = classmethod ( from_filename ) def as_requirement ( self ) : return Requirement . parse ( '%s==%s' % ( self . project_name , self . version ) ) def load_entry_point ( self , group , name ) : ep = self . get_entry_info ( group , name ) if ep is None : raise ImportError ( "Entry point %r not found" % ( ( group , name ) , ) ) return ep . load ( ) def get_entry_map ( self , group = None ) : try : ep_map = self . _ep_map except AttributeError : ep_map = self . _ep_map = EntryPoint . parse_map ( self . _get_metadata ( 'entry_points.txt' ) , self ) if group is not None : return ep_map . get ( group , { } ) return ep_map def get_entry_info ( self , group , name ) : return self . get_entry_map ( group ) . get ( name ) def insert_on ( self , path , loc = None ) : loc = loc or self . location if not loc : return if path is sys . path : self . check_version_conflict ( ) nloc = _normalize_cached ( loc ) bdir = os . path . dirname ( nloc ) npath = map ( _normalize_cached , path ) bp = None for p , item in enumerate ( npath ) : if item == nloc : break elif item == bdir and self . precedence == EGG_DIST : path . insert ( p , loc ) npath . insert ( p , nloc ) break else : path . append ( loc ) return while 1 : try : np = npath . index ( nloc , p + 1 ) except ValueError : break else : del npath [ np ] , path [ np ] p = np return def check_version_conflict ( self ) : if self . key == 'setuptools' : return nsp = dict . fromkeys ( self . _get_metadata ( 'namespace_packages.txt' ) ) loc = normalize_path ( self . location ) for modname in self . _get_metadata ( 'top_level.txt' ) : if ( modname not in sys . modules or modname in nsp or modname in _namespace_packages ) : continue fn = getattr ( sys . modules [ modname ] , '__file__' , None ) if fn and normalize_path ( fn ) . startswith ( loc ) : continue issue_warning ( % ( modname , fn , self . location ) , ) def has_version ( self ) : try : self . version except ValueError : issue_warning ( "Unbuilt egg for " + repr ( self ) ) return False return True def clone ( self , ** kw ) : for attr in ( , 'version' , 'py_version' , 'platform' , 'location' , ) : kw . setdefault ( attr , getattr ( self , attr , None ) ) kw . setdefault ( 'metadata' , self . _provider ) return self . __class__ ( ** kw ) def extras ( self ) : return [ dep for dep in self . _dep_map if dep ] extras = property ( extras ) def issue_warning ( * args , ** kw ) : level = 1 g = globals ( ) try : while sys . _getframe ( level ) . f_globals is g : level += 1 except ValueError : pass from warnings import warn warn ( stacklevel = level + 1 , * args , ** kw ) def parse_requirements ( strs ) : lines = iter ( yield_lines ( strs ) ) def scan_list ( ITEM , TERMINATOR , line , p , groups , item_name ) : items = [ ] while not TERMINATOR ( line , p ) : if CONTINUE ( line , p ) : try : line = lines . next ( ) ; p = 0 except StopIteration : raise ValueError ( ) match = ITEM ( line , p ) if not match : raise ValueError ( "Expected " + item_name + " in" , line , "at" , line [ p : ] ) items . append ( match . group ( * groups ) ) p = match . end ( ) match = COMMA ( line , p ) if match : p = match . end ( ) elif not TERMINATOR ( line , p ) : raise ValueError ( , line , "at" , line [ p : ] ) match = TERMINATOR ( line , p ) if match : p = match . end ( ) return line , p , items for line in lines : match = DISTRO ( line ) if not match : raise ValueError ( "Missing distribution spec" , line ) project_name = match . group ( 1 ) p = match . end ( ) extras = [ ] match = OBRACKET ( line , p ) if match : p = match . end ( ) line , p , extras = scan_list ( DISTRO , CBRACKET , line , p , ( 1 , ) , "'extra' name" ) line , p , specs = scan_list ( VERSION , LINE_END , line , p , ( 1 , 2 ) , "version spec" ) specs = [ ( op , safe_version ( val ) ) for op , val in specs ] yield Requirement ( project_name , specs , extras ) def _sort_dists ( dists ) : tmp = [ ( dist . hashcmp , dist ) for dist in dists ] tmp . sort ( ) dists [ : : - 1 ] = [ d for hc , d in tmp ] class Requirement : def __init__ ( self , project_name , specs , extras ) : self . unsafe_name , project_name = project_name , safe_name ( project_name ) self . project_name , self . key = project_name , project_name . lower ( ) index = [ ( parse_version ( v ) , state_machine [ op ] , op , v ) for op , v in specs ] index . sort ( ) self . specs = [ ( op , ver ) for parsed , trans , op , ver in index ] self . index , self . extras = index , tuple ( map ( safe_extra , extras ) ) self . hashCmp = ( self . key , tuple ( [ ( op , parsed ) for parsed , trans , op , ver in index ] ) , frozenset ( self . extras ) ) self . __hash = hash ( self . hashCmp ) def __str__ ( self ) : specs = ',' . join ( [ '' . join ( s ) for s in self . specs ] ) extras = ',' . join ( self . extras ) if extras : extras = '[%s]' % extras return '%s%s%s' % ( self . project_name , extras , specs ) def __eq__ ( self , other ) : return isinstance ( other , Requirement ) and self . hashCmp == other . hashCmp def __contains__ ( self , item ) : if isinstance ( item , Distribution ) : if item . key <> self . key : return False if self . index : item = item . parsed_version elif isinstance ( item , basestring ) : item = parse_version ( item ) last = None for parsed , trans , op , ver in self . index : action = trans [ cmp ( item , parsed ) ] if action == 'F' : return False elif action == 'T' : return True elif action == '+' : last = True elif action == '-' or last is None : last = False if last is None : last = True return last def __hash__ ( self ) : return self . __hash def __repr__ ( self ) : return "Requirement.parse(%r)" % str ( self ) def parse ( s ) : reqs = list ( parse_requirements ( s ) ) if reqs : if len ( reqs ) == 1 : return reqs [ 0 ] raise ValueError ( "Expected only one requirement" , s ) raise ValueError ( "No requirements found" , s ) parse = staticmethod ( parse ) state_machine = { : '--T' , : 'T-T' , : 'F+F' , : 'T+F' , : 'T..' , : 'F++' , } def _get_mro ( cls ) : if not isinstance ( cls , type ) : class cls ( cls , object ) : pass return cls . __mro__ [ 1 : ] return cls . __mro__ def _find_adapter ( registry , ob ) : for t in _get_mro ( getattr ( ob , '__class__' , type ( ob ) ) ) : if t in registry : return registry [ t ] def ensure_directory ( path ) : dirname = os . path . dirname ( path ) if not os . path . isdir ( dirname ) : os . makedirs ( dirname ) def split_sections ( s ) : section = None content = [ ] for line in yield_lines ( s ) : if line . startswith ( "[" ) : if line . endswith ( "]" ) : if section or content : yield section , content section = line [ 1 : - 1 ] . strip ( ) content = [ ] else : raise ValueError ( "Invalid section heading" , line ) else : content . append ( line ) yield section , content def _mkstemp ( * args , ** kw ) : from tempfile import mkstemp old_open = os . open try : os . open = os_open return mkstemp ( * args , ** kw ) finally : os . open = old_open _manager = ResourceManager ( ) def _initialize ( g ) : for name in dir ( _manager ) : if not name . startswith ( '_' ) : g [ name ] = getattr ( _manager , name ) _initialize ( globals ( ) ) working_set = WorkingSet ( ) try : from __main__ import __requires__ except ImportError : pass else : try : working_set . require ( __requires__ ) except VersionConflict : working_set = WorkingSet ( [ ] ) for dist in working_set . resolve ( parse_requirements ( __requires__ ) , Environment ( ) ) : working_set . add ( dist ) for entry in sys . path : if entry not in working_set . entries : working_set . add_entry ( entry ) sys . path [ : ] = working_set . entries require = working_set . require iter_entry_points = working_set . iter_entry_points add_activation_listener = working_set . subscribe run_script = working_set . run_script run_main = run_script add_activation_listener ( lambda dist : dist . activate ( ) ) working_set . entries = [ ] ; map ( working_set . add_entry , sys . path )

class error ( Exception ) : pass import sys def FileExists ( fname ) : import os try : os . stat ( fname ) return 1 except os . error , details : return 0 def IsPackageDir ( path , packageName , knownFileName ) : import os if knownFileName is None : knownFileName = "." return FileExists ( os . path . join ( os . path . join ( path , packageName ) , knownFileName ) ) def IsDebug ( ) : import imp for suffix_item in imp . get_suffixes ( ) : if suffix_item [ 0 ] == '_d.pyd' : return '_d' return '' def FindPackagePath ( packageName , knownFileName , searchPaths ) : import regutil , os pathLook = regutil . GetRegisteredNamedPath ( packageName ) if pathLook and IsPackageDir ( pathLook , packageName , knownFileName ) : return pathLook , None for pathLook in searchPaths : if IsPackageDir ( pathLook , packageName , knownFileName ) : ret = os . path . abspath ( pathLook ) return ret , ret raise error , "The package %s can not be located" % packageName def FindHelpPath ( helpFile , helpDesc , searchPaths ) : import os , win32api , win32con try : key = win32api . RegOpenKey ( win32con . HKEY_LOCAL_MACHINE , "Software\\Microsoft\\Windows\\Help" , 0 , win32con . KEY_ALL_ACCESS ) try : try : path = win32api . RegQueryValueEx ( key , helpDesc ) [ 0 ] if FileExists ( os . path . join ( path , helpFile ) ) : return os . path . abspath ( path ) except win32api . error : pass finally : key . Close ( ) except win32api . error : pass for pathLook in searchPaths : if FileExists ( os . path . join ( pathLook , helpFile ) ) : return os . path . abspath ( pathLook ) pathLook = os . path . join ( pathLook , "Help" ) if FileExists ( os . path . join ( pathLook , helpFile ) ) : return os . path . abspath ( pathLook ) raise error , "The help file %s can not be located" % helpFile def FindAppPath ( appName , knownFileName , searchPaths ) : import regutil , string , os regPath = regutil . GetRegisteredNamedPath ( appName ) if regPath : pathLook = string . split ( regPath , ";" ) [ 0 ] if regPath and FileExists ( os . path . join ( pathLook , knownFileName ) ) : return None for pathLook in searchPaths : if FileExists ( os . path . join ( pathLook , knownFileName ) ) : return os . path . abspath ( pathLook ) raise error , "The file %s can not be located for application %s" % ( knownFileName , appName ) def FindPythonExe ( exeAlias , possibleRealNames , searchPaths ) : import win32api , regutil , string , os , sys if possibleRealNames is None : possibleRealNames = exeAlias found = os . path . join ( sys . prefix , possibleRealNames ) if not FileExists ( found ) : found = os . path . join ( sys . prefix , "PCBuild" , possibleRealNames ) if not FileExists ( found ) : found = LocateFileName ( possibleRealNames , searchPaths ) registered_ok = 0 try : registered = win32api . RegQueryValue ( regutil . GetRootKey ( ) , regutil . GetAppPathsKey ( ) + "\\" + exeAlias ) registered_ok = found == registered except win32api . error : pass return found , registered_ok def QuotedFileName ( fname ) : import regutil , string try : string . index ( fname , " " ) return '"%s"' % fname except ValueError : return fname def LocateFileName ( fileNamesString , searchPaths ) : import regutil , string , os fileNames = string . split ( fileNamesString , ";" ) for path in searchPaths : for fileName in fileNames : try : retPath = os . path . join ( path , fileName ) os . stat ( retPath ) break except os . error : retPath = None if retPath : break else : fileName = fileNames [ 0 ] try : import win32ui , win32con except ImportError : raise error , "Need to locate the file %s, but the win32ui module is not available\nPlease run the program again, passing as a parameter the path to this file." % fileName flags = win32con . OFN_FILEMUSTEXIST ext = os . path . splitext ( fileName ) [ 1 ] filter = "Files of requested type (*%s)|*%s||" % ( ext , ext ) dlg = win32ui . CreateFileDialog ( 1 , None , fileName , flags , filter , None ) dlg . SetOFNTitle ( "Locate " + fileName ) if dlg . DoModal ( ) <> win32con . IDOK : raise KeyboardInterrupt , "User cancelled the process" retPath = dlg . GetPathName ( ) return os . path . abspath ( retPath ) def LocatePath ( fileName , searchPaths ) : import os return os . path . abspath ( os . path . split ( LocateFileName ( fileName , searchPaths ) ) [ 0 ] ) def LocateOptionalPath ( fileName , searchPaths ) : try : return LocatePath ( fileName , searchPaths ) except KeyboardInterrupt : return None def LocateOptionalFileName ( fileName , searchPaths = None ) : try : return LocateFileName ( fileName , searchPaths ) except KeyboardInterrupt : return None def LocatePythonCore ( searchPaths ) : import string , os , regutil currentPath = regutil . GetRegisteredNamedPath ( None ) if currentPath : presearchPaths = string . split ( currentPath , ";" ) else : presearchPaths = [ os . path . abspath ( "." ) ] libPath = None for path in presearchPaths : if FileExists ( os . path . join ( path , "os.py" ) ) : libPath = path break if libPath is None and searchPaths is not None : libPath = LocatePath ( "os.py" , searchPaths ) if libPath is None : raise error , "The core Python library could not be located." corePath = None suffix = IsDebug ( ) for path in presearchPaths : if FileExists ( os . path . join ( path , "unicodedata%s.pyd" % suffix ) ) : corePath = path break if corePath is None and searchPaths is not None : corePath = LocatePath ( "unicodedata%s.pyd" % suffix , searchPaths ) if corePath is None : raise error , "The core Python path could not be located." installPath = os . path . abspath ( os . path . join ( libPath , ".." ) ) return installPath , [ libPath , corePath ] def FindRegisterPackage ( packageName , knownFile , searchPaths , registryAppName = None ) : import regutil , string if not packageName : raise error , "A package name must be supplied" corePaths = string . split ( regutil . GetRegisteredNamedPath ( None ) , ";" ) if not searchPaths : searchPaths = corePaths registryAppName = registryAppName or packageName try : pathLook , pathAdd = FindPackagePath ( packageName , knownFile , searchPaths ) if pathAdd is not None : if pathAdd in corePaths : pathAdd = "" regutil . RegisterNamedPath ( registryAppName , pathAdd ) return pathLook except error , details : print "*** The %s package could not be registered - %s" % ( packageName , details ) print "*** Please ensure you have passed the correct paths on the command line." print "*** - For packages, you should pass a path to the packages parent directory," print "*** - and not the package directory itself..." def FindRegisterApp ( appName , knownFiles , searchPaths ) : import regutil , string if type ( knownFiles ) == type ( '' ) : knownFiles = [ knownFiles ] paths = [ ] try : for knownFile in knownFiles : pathLook = FindAppPath ( appName , knownFile , searchPaths ) if pathLook : paths . append ( pathLook ) except error , details : print "*** " , details return regutil . RegisterNamedPath ( appName , string . join ( paths , ";" ) ) def FindRegisterPythonExe ( exeAlias , searchPaths , actualFileNames = None ) : import regutil , string fname , ok = FindPythonExe ( exeAlias , actualFileNames , searchPaths ) if not ok : regutil . RegisterPythonExe ( fname , exeAlias ) return fname def FindRegisterHelpFile ( helpFile , searchPaths , helpDesc = None ) : import regutil try : pathLook = FindHelpPath ( helpFile , helpDesc , searchPaths ) except error , details : print "*** " , details return regutil . RegisterHelpFile ( helpFile , pathLook , helpDesc ) def SetupCore ( searchPaths ) : import sys for path in searchPaths : sys . path . append ( path ) import string , os import regutil , win32api , win32con installPath , corePaths = LocatePythonCore ( searchPaths ) print corePaths regutil . RegisterNamedPath ( None , string . join ( corePaths , ";" ) ) hKey = win32api . RegCreateKey ( regutil . GetRootKey ( ) , regutil . BuildDefaultPythonKey ( ) ) try : win32api . RegSetValue ( hKey , "InstallPath" , win32con . REG_SZ , installPath ) finally : win32api . RegCloseKey ( hKey ) win32paths = os . path . abspath ( os . path . split ( win32api . __file__ ) [ 0 ] ) + ";" + os . path . abspath ( os . path . split ( LocateFileName ( "win32con.py;win32con.pyc" , sys . path ) ) [ 0 ] ) check = os . path . join ( sys . prefix , "PCBuild" ) if os . path . isdir ( check ) : regutil . RegisterNamedPath ( "PCBuild" , check ) def RegisterShellInfo ( searchPaths ) : import regutil , win32con suffix = IsDebug ( ) exePath = FindRegisterPythonExe ( "Python%s.exe" % suffix , searchPaths ) regutil . SetRegistryDefaultValue ( ".py" , "Python.File" , win32con . HKEY_CLASSES_ROOT ) regutil . RegisterShellCommand ( "Open" , QuotedFileName ( exePath ) + " \"%1\" %*" , "&Run" ) regutil . SetRegistryDefaultValue ( "Python.File\\DefaultIcon" , "%s,0" % exePath , win32con . HKEY_CLASSES_ROOT ) FindRegisterHelpFile ( "Python.hlp" , searchPaths , "Main Python Documentation" ) FindRegisterHelpFile ( "ActivePython.chm" , searchPaths , "Main Python Documentation" ) usage = """\ regsetup.py - Setup/maintain the registry for Python apps. Run without options, (but possibly search paths) to repair a totally broken python registry setup. This should allow other options to work. Usage: %s [options ...] paths ... -p packageName -- Find and register a package. Looks in the paths for a sub-directory with the name of the package, and adds a path entry for the package. -a appName -- Unconditionally add an application name to the path. A new path entry is create with the app name, and the paths specified are added to the registry. -c -- Add the specified paths to the core Pythonpath. If a path appears on the core path, and a package also needs that same path, the package will not bother registering it. Therefore, By adding paths to the core path, you can avoid packages re-registering the same path. -m filename -- Find and register the specific file name as a module. Do not include a path on the filename! --shell -- Register everything with the Win95/NT shell. --upackage name -- Unregister the package --uapp name -- Unregister the app (identical to --upackage) --umodule name -- Unregister the module --description -- Print a description of the usage. --examples -- Print examples of usage. """ % sys . argv [ 0 ] description = """\ If no options are processed, the program attempts to validate and set the standard Python path to the point where the standard library is available. This can be handy if you move Python to a new drive/sub-directory, in which case most of the options would fail (as they need at least string.py, os.py etc to function.) Running without options should repair Python well enough to run with the other options. paths are search paths that the program will use to seek out a file. For example, when registering the core Python, you may wish to provide paths to non-standard places to look for the Python help files, library files, etc. See also the "regcheck.py" utility which will check and dump the contents of the registry. """ examples = """\ Examples: "regsetup c:\\wierd\\spot\\1 c:\\wierd\\spot\\2" Attempts to setup the core Python. Looks in some standard places, as well as the 2 wierd spots to locate the core Python files (eg, Python.exe, python14.dll, the standard library and Win32 Extensions. "regsetup -a myappname . .\subdir" Registers a new Pythonpath entry named myappname, with "C:\\I\\AM\\HERE" and "C:\\I\\AM\\HERE\subdir" added to the path (ie, all args are converted to absolute paths) "regsetup -c c:\\my\\python\\files" Unconditionally add "c:\\my\\python\\files" to the 'core' Python path. "regsetup -m some.pyd \\windows\\system" Register the module some.pyd in \\windows\\system as a registered module. This will allow some.pyd to be imported, even though the windows system directory is not (usually!) on the Python Path. "regsetup --umodule some" Unregister the module "some". This means normal import rules then apply for that module. """ if __name__ == '__main__' : if len ( sys . argv ) > 1 and sys . argv [ 1 ] in [ '/?' , '-?' , '-help' , '-h' ] : print usage elif len ( sys . argv ) == 1 or not sys . argv [ 1 ] [ 0 ] in [ '/' , '-' ] : searchPath = sys . path [ : ] for arg in sys . argv [ 1 : ] : searchPath . append ( arg ) searchPath . append ( "..\\Build" ) searchPath . append ( "..\\Lib" ) searchPath . append ( ".." ) searchPath . append ( "..\\.." ) searchPath . append ( "..\\..\\lib" ) searchPath . append ( "..\\build" ) searchPath . append ( "..\\..\\pcbuild" ) print "Attempting to setup/repair the Python core" SetupCore ( searchPath ) RegisterShellInfo ( searchPath ) FindRegisterHelpFile ( "PyWin32.chm" , searchPath , "Pythonwin Reference" ) print "Registration complete - checking the registry..." import regcheck regcheck . CheckRegistry ( ) else : searchPaths = [ ] import getopt , string opts , args = getopt . getopt ( sys . argv [ 1 : ] , 'p:a:m:c' , [ 'shell' , 'upackage=' , 'uapp=' , 'umodule=' , 'description' , 'examples' ] ) for arg in args : searchPaths . append ( arg ) for o , a in opts : if o == '--description' : print description if o == '--examples' : print examples if o == '--shell' : print "Registering the Python core." RegisterShellInfo ( searchPaths ) if o == '-p' : print "Registering package" , a FindRegisterPackage ( a , None , searchPaths ) if o in [ '--upackage' , '--uapp' ] : import regutil print "Unregistering application/package" , a regutil . UnregisterNamedPath ( a ) if o == '-a' : import regutil path = string . join ( searchPaths , ";" ) print "Registering application" , a , "to path" , path regutil . RegisterNamedPath ( a , path ) if o == '-c' : if not len ( searchPaths ) : raise error , "-c option must provide at least one additional path" import win32api , regutil currentPaths = string . split ( regutil . GetRegisteredNamedPath ( None ) , ";" ) oldLen = len ( currentPaths ) for newPath in searchPaths : if newPath not in currentPaths : currentPaths . append ( newPath ) if len ( currentPaths ) <> oldLen : print "Registering %d new core paths" % ( len ( currentPaths ) - oldLen ) regutil . RegisterNamedPath ( None , string . join ( currentPaths , ";" ) ) else : print "All specified paths are already registered."

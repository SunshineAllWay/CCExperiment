import errno import string class DBRecIO : def __init__ ( self , db , key , txn = None ) : self . db = db self . key = key self . txn = txn self . len = None self . pos = 0 self . closed = 0 self . softspace = 0 def close ( self ) : if not self . closed : self . closed = 1 del self . db , self . txn def isatty ( self ) : if self . closed : raise ValueError , "I/O operation on closed file" return 0 def seek ( self , pos , mode = 0 ) : if self . closed : raise ValueError , "I/O operation on closed file" if mode == 1 : pos = pos + self . pos elif mode == 2 : pos = pos + self . len self . pos = max ( 0 , pos ) def tell ( self ) : if self . closed : raise ValueError , "I/O operation on closed file" return self . pos def read ( self , n = - 1 ) : if self . closed : raise ValueError , "I/O operation on closed file" if n < 0 : newpos = self . len else : newpos = min ( self . pos + n , self . len ) dlen = newpos - self . pos r = self . db . get ( self . key , txn = self . txn , dlen = dlen , doff = self . pos ) self . pos = newpos return r __fixme = """ def readline(self, length=None): if self.closed: raise ValueError, "I/O operation on closed file" if self.buflist: self.buf = self.buf + string.joinfields(self.buflist, '') self.buflist = [] i = string.find(self.buf, '\n', self.pos) if i < 0: newpos = self.len else: newpos = i+1 if length is not None: if self.pos + length < newpos: newpos = self.pos + length r = self.buf[self.pos:newpos] self.pos = newpos return r def readlines(self, sizehint = 0): total = 0 lines = [] line = self.readline() while line: lines.append(line) total += len(line) if 0 < sizehint <= total: break line = self.readline() return lines """ def truncate ( self , size = None ) : if self . closed : raise ValueError , "I/O operation on closed file" if size is None : size = self . pos elif size < 0 : raise IOError ( errno . EINVAL , ) elif size < self . pos : self . pos = size self . db . put ( self . key , "" , txn = self . txn , dlen = self . len - size , doff = size ) def write ( self , s ) : if self . closed : raise ValueError , "I/O operation on closed file" if not s : return if self . pos > self . len : self . buflist . append ( '\0' * ( self . pos - self . len ) ) self . len = self . pos newpos = self . pos + len ( s ) self . db . put ( self . key , s , txn = self . txn , dlen = len ( s ) , doff = self . pos ) self . pos = newpos def writelines ( self , list ) : self . write ( string . joinfields ( list , '' ) ) def flush ( self ) : if self . closed : raise ValueError , "I/O operation on closed file"

"""Microsoft Internet Explorer cookie loading on Windows. Copyright 2002-2003 Johnny Lee <typo_pl@hotmail.com> (MSIE Perl code) Copyright 2002-2006 John J Lee <jjl@pobox.com> (The Python port) This code is free software; you can redistribute it and/or modify it under the terms of the BSD or ZPL 2.1 licenses (see the file COPYING.txt included with the distribution). """ import os , re , time , struct , logging if os . name == "nt" : import _winreg from _clientcookie import FileCookieJar , CookieJar , Cookie , MISSING_FILENAME_TEXT , LoadError debug = logging . getLogger ( "mechanize" ) . debug def regload ( path , leaf ) : key = _winreg . OpenKey ( _winreg . HKEY_CURRENT_USER , path , 0 , _winreg . KEY_ALL_ACCESS ) try : value = _winreg . QueryValueEx ( key , leaf ) [ 0 ] except WindowsError : value = None return value WIN32_EPOCH = 0x019db1ded53e8000L def epoch_time_offset_from_win32_filetime ( filetime ) : if filetime < WIN32_EPOCH : raise ValueError ( "filetime (%d) is before epoch (%d)" % ( filetime , WIN32_EPOCH ) ) return divmod ( ( filetime - WIN32_EPOCH ) , 10000000L ) [ 0 ] def binary_to_char ( c ) : return "%02X" % ord ( c ) def binary_to_str ( d ) : return "" . join ( map ( binary_to_char , list ( d ) ) ) class MSIEBase : magic_re = re . compile ( r"Client UrlCache MMF Ver \d\.\d.*" ) padding = "\x0d\xf0\xad\x0b" msie_domain_re = re . compile ( r"^([^/]+)(/.*)$" ) cookie_re = re . compile ( "Cookie\:.+\@([\x21-\xFF]+).*?" ) reg_path = r"software\microsoft\windows" r"\currentversion\explorer\shell folders" reg_key = "Cookies" def __init__ ( self ) : self . _delayload_domains = { } def _delayload_domain ( self , domain ) : delayload_info = self . _delayload_domains . get ( domain ) if delayload_info is not None : cookie_file , ignore_discard , ignore_expires = delayload_info try : self . load_cookie_data ( cookie_file , ignore_discard , ignore_expires ) except ( LoadError , IOError ) : debug ( "error reading cookie file, skipping: %s" , cookie_file ) else : del self . _delayload_domains [ domain ] def _load_cookies_from_file ( self , filename ) : debug ( "Loading MSIE cookies file: %s" , filename ) cookies = [ ] cookies_fh = open ( filename ) try : while 1 : key = cookies_fh . readline ( ) if key == "" : break rl = cookies_fh . readline def getlong ( rl = rl ) : return long ( rl ( ) . rstrip ( ) ) def getstr ( rl = rl ) : return rl ( ) . rstrip ( ) key = key . rstrip ( ) value = getstr ( ) domain_path = getstr ( ) flags = getlong ( ) lo_expire = getlong ( ) hi_expire = getlong ( ) lo_create = getlong ( ) hi_create = getlong ( ) sep = getstr ( ) if "" in ( key , value , domain_path , flags , hi_expire , lo_expire , hi_create , lo_create , sep ) or ( sep != "*" ) : break m = self . msie_domain_re . search ( domain_path ) if m : domain = m . group ( 1 ) path = m . group ( 2 ) cookies . append ( { "KEY" : key , "VALUE" : value , : domain , "PATH" : path , : flags , "HIXP" : hi_expire , : lo_expire , "HICREATE" : hi_create , : lo_create } ) finally : cookies_fh . close ( ) return cookies def load_cookie_data ( self , filename , ignore_discard = False , ignore_expires = False ) : now = int ( time . time ( ) ) cookie_data = self . _load_cookies_from_file ( filename ) for cookie in cookie_data : flags = cookie [ "FLAGS" ] secure = ( ( flags & 0x2000 ) != 0 ) filetime = ( cookie [ "HIXP" ] << 32 ) + cookie [ "LOXP" ] expires = epoch_time_offset_from_win32_filetime ( filetime ) if expires < now : discard = True else : discard = False domain = cookie [ "DOMAIN" ] initial_dot = domain . startswith ( "." ) if initial_dot : domain_specified = True else : domain_specified = False c = Cookie ( 0 , cookie [ "KEY" ] , cookie [ "VALUE" ] , None , False , domain , domain_specified , initial_dot , cookie [ "PATH" ] , False , secure , expires , discard , None , None , { "flags" : flags } ) if not ignore_discard and c . discard : continue if not ignore_expires and c . is_expired ( now ) : continue CookieJar . set_cookie ( self , c ) def load_from_registry ( self , ignore_discard = False , ignore_expires = False , username = None ) : cookies_dir = regload ( self . reg_path , self . reg_key ) filename = os . path . normpath ( os . path . join ( cookies_dir , "INDEX.DAT" ) ) self . load ( filename , ignore_discard , ignore_expires , username ) def _really_load ( self , index , filename , ignore_discard , ignore_expires , username ) : now = int ( time . time ( ) ) if username is None : username = os . environ [ 'USERNAME' ] . lower ( ) cookie_dir = os . path . dirname ( filename ) data = index . read ( 256 ) if len ( data ) != 256 : raise LoadError ( "%s file is too short" % filename ) sig , size , data = data [ : 32 ] , data [ 32 : 36 ] , data [ 36 : ] size = struct . unpack ( "<L" , size ) [ 0 ] if not self . magic_re . match ( sig ) or size != 0x4000 : raise LoadError ( "%s ['%s' %s] does not seem to contain cookies" % ( str ( filename ) , sig , size ) ) index . seek ( size , 0 ) sector = 128 while 1 : data = "" to_read = 2 * sector d = index . read ( to_read ) if len ( d ) != to_read : break data = data + d sig , size , data = data [ : 4 ] , data [ 4 : 8 ] , data [ 8 : ] size = struct . unpack ( "<L" , size ) [ 0 ] to_read = ( size - 2 ) * sector if sig != "URL " : assert sig in ( "HASH" , "LEAK" , self . padding , "\x00\x00\x00\x00" ) , "unrecognized MSIE index.dat record: %s" % binary_to_str ( sig ) if sig == "\x00\x00\x00\x00" : break if sig == self . padding : continue assert to_read >= 0 if size != 2 : assert to_read != 0 index . seek ( to_read , 1 ) continue if size > 2 : more_data = index . read ( to_read ) if len ( more_data ) != to_read : break data = data + more_data cookie_re = ( "Cookie\:%s\@([\x21-\xFF]+).*?" % username + % username ) m = re . search ( cookie_re , data , re . I ) if m : cookie_file = os . path . join ( cookie_dir , m . group ( 2 ) ) if not self . delayload : try : self . load_cookie_data ( cookie_file , ignore_discard , ignore_expires ) except ( LoadError , IOError ) : debug ( "error reading cookie file, skipping: %s" , cookie_file ) else : domain = m . group ( 1 ) i = domain . find ( "/" ) if i != - 1 : domain = domain [ : i ] self . _delayload_domains [ domain ] = ( cookie_file , ignore_discard , ignore_expires ) class MSIECookieJar ( MSIEBase , FileCookieJar ) : def __init__ ( self , filename = None , delayload = False , policy = None ) : MSIEBase . __init__ ( self ) FileCookieJar . __init__ ( self , filename , delayload , policy ) def set_cookie ( self , cookie ) : if self . delayload : self . _delayload_domain ( cookie . domain ) CookieJar . set_cookie ( self , cookie ) def _cookies_for_request ( self , request ) : domains = self . _cookies . copy ( ) domains . update ( self . _delayload_domains ) domains = domains . keys ( ) cookies = [ ] for domain in domains : cookies . extend ( self . _cookies_for_domain ( domain , request ) ) return cookies def _cookies_for_domain ( self , domain , request ) : if not self . _policy . domain_return_ok ( domain , request ) : return [ ] debug ( "Checking %s for cookies to return" , domain ) if self . delayload : self . _delayload_domain ( domain ) return CookieJar . _cookies_for_domain ( self , domain , request ) def read_all_cookies ( self ) : if self . delayload : for domain in self . _delayload_domains . keys ( ) : self . _delayload_domain ( domain ) def load ( self , filename , ignore_discard = False , ignore_expires = False , username = None ) : if filename is None : if self . filename is not None : filename = self . filename else : raise ValueError ( MISSING_FILENAME_TEXT ) index = open ( filename , "rb" ) try : self . _really_load ( index , filename , ignore_discard , ignore_expires , username ) finally : index . close ( )

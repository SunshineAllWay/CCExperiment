__doc__ = """\ logging.py - A plugin for Gate One that provides logging-related functionality. """ __version__ = '1.0rc1' __license__ = "GNU AGPLv3 or Proprietary (see LICENSE.txt)" __version_info__ = ( 1 , 0 ) __author__ = 'Dan McDougall <daniel.mcdougall@liftoffsoftware.com>' import os import logging import gzip import re import time from multiprocessing import Process , Queue from functools import partial from gateone import BaseHandler , PLUGINS , COLORS_256 from logviewer import flatten_log , playback_log from utils import get_translation , json_encode , get_or_update_metadata _ = get_translation ( ) import tornado . web import tornado . template import tornado . ioloop from tornado . escape import json_decode SEPARATOR = u"\U000f0f0f" PROCS = { } def retrieve_log_frames ( golog_path , rows , cols , limit = None ) : out_frames = [ ] from terminal import Terminal terminal_emulator = Terminal term = terminal_emulator ( rows = rows , cols = cols , em_dimensions = { 'height' : 14 , 'width' : 7 } ) frames = gzip . open ( golog_path ) . read ( ) . split ( SEPARATOR . encode ( 'UTF-8' ) ) [ 1 : ] if not limit : limit = len ( frames ) for frame in frames [ : limit ] : if len ( frame ) > 14 : frame_time = int ( float ( frame [ : 13 ] ) ) frame_screen = frame [ 14 : ] term . write ( frame_screen ) scrollback , screen = term . dump_html ( ) out_frames . append ( { 'screen' : screen , 'time' : frame_time } ) return out_frames def enumerate_logs ( limit = None , tws = None ) : results = [ ] user = tws . get_current_user ( ) [ 'upn' ] users_dir = os . path . join ( tws . settings [ 'user_dir' ] , user ) io_loop = tornado . ioloop . IOLoop . instance ( ) global PROCS if user not in PROCS : PROCS [ user ] = { } else : fd = PROCS [ user ] [ 'queue' ] . _reader . fileno ( ) if fd in io_loop . _handlers : io_loop . remove_handler ( fd ) if PROCS [ user ] [ 'process' ] : try : PROCS [ user ] [ 'process' ] . terminate ( ) except OSError : pass PROCS [ user ] [ 'queue' ] = q = Queue ( ) PROCS [ user ] [ 'process' ] = Process ( target = _enumerate_logs , args = ( q , user , users_dir , limit ) ) def send_message ( fd , event ) : message = q . get ( ) if message == 'complete' : io_loop . remove_handler ( fd ) logs_dir = os . path . join ( users_dir , "logs" ) log_files = os . listdir ( logs_dir ) total_bytes = 0 for log in log_files : log_path = os . path . join ( logs_dir , log ) total_bytes += os . stat ( log_path ) . st_size out_dict = { : len ( log_files ) , : total_bytes } message = { 'logging_logs_complete' : out_dict } tws . write_message ( message ) return message = json_encode ( message ) if message not in results : if results : results . pop ( ) results . append ( message ) tws . write_message ( message ) io_loop . add_handler ( q . _reader . fileno ( ) , send_message , io_loop . READ ) PROCS [ user ] [ 'process' ] . start ( ) def _enumerate_logs ( queue , user , users_dir , limit = None ) : logs_dir = os . path . join ( users_dir , "logs" ) log_files = os . listdir ( logs_dir ) log_files = [ a for a in log_files if a . endswith ( '.golog' ) ] log_files . sort ( ) log_files . reverse ( ) out_dict = { } for log in log_files : metadata = { } log_path = os . path . join ( logs_dir , log ) logfile = gzip . open ( log_path ) metadata = get_or_update_metadata ( log_path , user ) metadata [ 'size' ] = os . stat ( log_path ) . st_size out_dict [ 'log' ] = metadata message = { 'logging_log' : out_dict } queue . put ( message ) time . sleep ( 0.01 ) queue . put ( 'complete' ) def retrieve_log_flat ( settings , tws = None ) : settings [ 'container' ] = tws . container settings [ 'prefix' ] = tws . prefix settings [ 'user' ] = user = tws . get_current_user ( ) [ 'upn' ] settings [ 'users_dir' ] = os . path . join ( tws . settings [ 'user_dir' ] , user ) settings [ 'gateone_dir' ] = tws . settings [ 'gateone_dir' ] io_loop = tornado . ioloop . IOLoop . instance ( ) global PROCS if user not in PROCS : PROCS [ user ] = { } else : fd = PROCS [ user ] [ 'queue' ] . _reader . fileno ( ) if fd in io_loop . _handlers : io_loop . remove_handler ( fd ) if PROCS [ user ] [ 'process' ] : try : PROCS [ user ] [ 'process' ] . terminate ( ) except OSError : pass PROCS [ user ] [ 'queue' ] = q = Queue ( ) PROCS [ user ] [ 'process' ] = Process ( target = _retrieve_log_flat , args = ( q , settings ) ) def send_message ( fd , event ) : io_loop . remove_handler ( fd ) message = q . get ( ) tws . write_message ( message ) io_loop . add_handler ( q . _reader . fileno ( ) , send_message , io_loop . READ ) PROCS [ user ] [ 'process' ] . start ( ) def _retrieve_log_flat ( queue , settings ) : out_dict = { : "" , : "" , : { } , } gateone_dir = settings [ 'gateone_dir' ] user = settings [ 'user' ] users_dir = settings [ 'users_dir' ] container = settings [ 'container' ] prefix = settings [ 'prefix' ] log_filename = settings [ 'log_filename' ] theme = "%s.css" % settings [ 'theme' ] colors = "%s.css" % settings [ 'colors' ] logs_dir = os . path . join ( users_dir , "logs" ) log_path = os . path . join ( logs_dir , log_filename ) if os . path . exists ( log_path ) : out_dict [ 'metadata' ] = get_or_update_metadata ( log_path , user ) out_dict [ 'metadata' ] [ 'filename' ] = log_filename out_dict [ 'result' ] = "Success" from terminal import Terminal terminal_emulator = Terminal term = terminal_emulator ( rows = 100 , cols = 300 ) flattened_log = flatten_log ( log_path ) flattened_log . replace ( '\n' , '\r\n' ) term . write ( flattened_log ) scrollback , screen = term . dump_html ( ) log_lines = scrollback + screen out_dict [ 'log' ] = log_lines else : out_dict [ 'result' ] = "ERROR: Log not found" message = { 'logging_log_flat' : out_dict } queue . put ( message ) def retrieve_log_playback ( settings , tws = None ) : settings [ 'container' ] = tws . container settings [ 'prefix' ] = tws . prefix settings [ 'user' ] = user = tws . get_current_user ( ) [ 'upn' ] settings [ 'users_dir' ] = os . path . join ( tws . settings [ 'user_dir' ] , user ) settings [ 'gateone_dir' ] = tws . settings [ 'gateone_dir' ] settings [ 'url_prefix' ] = tws . settings [ 'url_prefix' ] io_loop = tornado . ioloop . IOLoop . instance ( ) global PROCS if user not in PROCS : PROCS [ user ] = { } else : fd = PROCS [ user ] [ 'queue' ] . _reader . fileno ( ) if fd in io_loop . _handlers : io_loop . remove_handler ( fd ) if PROCS [ user ] [ 'process' ] : try : PROCS [ user ] [ 'process' ] . terminate ( ) except OSError : pass PROCS [ user ] [ 'queue' ] = q = Queue ( ) PROCS [ user ] [ 'queue' ] = q = Queue ( ) PROCS [ user ] [ 'process' ] = Process ( target = _retrieve_log_playback , args = ( q , settings ) ) def send_message ( fd , event ) : io_loop . remove_handler ( fd ) message = q . get ( ) tws . write_message ( message ) io_loop . add_handler ( q . _reader . fileno ( ) , send_message , io_loop . READ ) PROCS [ user ] [ 'process' ] . start ( ) def _retrieve_log_playback ( queue , settings ) : if 'where' not in settings : settings [ 'where' ] = None out_dict = { : "" , : "" , : { } , : settings [ 'where' ] } gateone_dir = settings [ 'gateone_dir' ] user = settings [ 'user' ] users_dir = settings [ 'users_dir' ] container = settings [ 'container' ] prefix = settings [ 'prefix' ] url_prefix = settings [ 'url_prefix' ] log_filename = settings [ 'log_filename' ] theme = "%s.css" % settings [ 'theme' ] colors = "%s.css" % settings [ 'colors' ] logs_dir = os . path . join ( users_dir , "logs" ) log_path = os . path . join ( logs_dir , log_filename ) templates_path = os . path . join ( gateone_dir , 'templates' ) colors_path = os . path . join ( templates_path , 'term_colors' ) themes_path = os . path . join ( templates_path , 'themes' ) plugins_path = os . path . join ( gateone_dir , 'plugins' ) logging_plugin_path = os . path . join ( plugins_path , 'logging' ) template_path = os . path . join ( logging_plugin_path , 'templates' ) if os . path . exists ( log_path ) : out_dict [ 'metadata' ] = get_or_update_metadata ( log_path , user ) out_dict [ 'metadata' ] [ 'filename' ] = log_filename try : rows = out_dict [ 'metadata' ] [ 'rows' ] cols = out_dict [ 'metadata' ] [ 'cols' ] except KeyError : rows = 40 cols = 500 out_dict [ 'result' ] = "Success" with open ( os . path . join ( colors_path , colors ) ) as f : colors_file = f . read ( ) colors_template = tornado . template . Template ( colors_file ) rendered_colors = colors_template . generate ( container = container , prefix = prefix , url_prefix = url_prefix ) with open ( os . path . join ( themes_path , theme ) ) as f : theme_file = f . read ( ) theme_template = tornado . template . Template ( theme_file ) colors_256 = "" for i in xrange ( 256 ) : fg = "#%s span.fx%s {color: #%s;}" % ( container , i , COLORS_256 [ i ] ) bg = "#%s span.bx%s {background-color: #%s;} " % ( container , i , COLORS_256 [ i ] ) colors_256 += "%s %s" % ( fg , bg ) colors_256 += "\n" rendered_theme = theme_template . generate ( container = container , prefix = prefix , colors_256 = colors_256 , url_prefix = url_prefix ) loader = tornado . template . Loader ( template_path ) playback_template = loader . load ( 'playback_log.html' ) preview = 'false' if settings [ 'where' ] : preview = 'true' recording = retrieve_log_frames ( log_path , rows , cols , limit = 50 ) else : recording = retrieve_log_frames ( log_path , rows , cols ) playback_html = playback_template . generate ( prefix = prefix , container = container , theme = rendered_theme , colors = rendered_colors , preview = preview , recording = json_encode ( recording ) , url_prefix = url_prefix ) out_dict [ 'html' ] = playback_html else : out_dict [ 'result' ] = "ERROR: Log not found" message = { 'logging_log_playback' : out_dict } queue . put ( message ) def save_log_playback ( settings , tws = None ) : settings [ 'container' ] = tws . container settings [ 'prefix' ] = tws . prefix settings [ 'user' ] = user = tws . get_current_user ( ) [ 'upn' ] settings [ 'users_dir' ] = os . path . join ( tws . settings [ 'user_dir' ] , user ) settings [ 'gateone_dir' ] = tws . settings [ 'gateone_dir' ] settings [ 'url_prefix' ] = tws . settings [ 'url_prefix' ] q = Queue ( ) global PROC PROC = Process ( target = _save_log_playback , args = ( q , settings ) ) PROC . daemon = True io_loop = tornado . ioloop . IOLoop . instance ( ) def send_message ( fd , event ) : io_loop . remove_handler ( fd ) message = q . get ( ) tws . write_message ( message ) io_loop . add_handler ( q . _reader . fileno ( ) , send_message , io_loop . READ ) PROC . start ( ) return def _save_log_playback ( queue , settings ) : out_dict = { : "Success" , : 'text/html' , : "" , } gateone_dir = settings [ 'gateone_dir' ] user = settings [ 'user' ] users_dir = settings [ 'users_dir' ] container = settings [ 'container' ] prefix = settings [ 'prefix' ] url_prefix = settings [ 'url_prefix' ] log_filename = settings [ 'log_filename' ] short_logname = log_filename . split ( '.golog' ) [ 0 ] out_dict [ 'filename' ] = "%s.html" % short_logname theme = "%s.css" % settings [ 'theme' ] colors = "%s.css" % settings [ 'colors' ] logs_dir = os . path . join ( users_dir , "logs" ) log_path = os . path . join ( logs_dir , log_filename ) templates_path = os . path . join ( gateone_dir , 'templates' ) colors_path = os . path . join ( templates_path , 'term_colors' ) themes_path = os . path . join ( templates_path , 'themes' ) plugins_path = os . path . join ( gateone_dir , 'plugins' ) logging_plugin_path = os . path . join ( plugins_path , 'logging' ) template_path = os . path . join ( logging_plugin_path , 'templates' ) if os . path . exists ( log_path ) : out_dict [ 'metadata' ] = get_or_update_metadata ( log_path , user ) try : rows = out_dict [ 'metadata' ] [ 'rows' ] cols = out_dict [ 'metadata' ] [ 'cols' ] except KeyError : rows = 40 cols = 500 with open ( os . path . join ( colors_path , colors ) ) as f : colors_file = f . read ( ) colors_template = tornado . template . Template ( colors_file ) rendered_colors = colors_template . generate ( container = container , prefix = prefix , url_prefix = url_prefix ) with open ( os . path . join ( themes_path , theme ) ) as f : theme_file = f . read ( ) theme_template = tornado . template . Template ( theme_file ) colors_256 = "" for i in xrange ( 256 ) : fg = "#%s span.fx%s {color: #%s;}" % ( container , i , COLORS_256 [ i ] ) bg = "#%s span.bx%s {background-color: #%s;} " % ( container , i , COLORS_256 [ i ] ) colors_256 += "%s %s" % ( fg , bg ) colors_256 += "\n" rendered_theme = theme_template . generate ( container = container , prefix = prefix , colors_256 = colors_256 , url_prefix = url_prefix ) loader = tornado . template . Loader ( template_path ) playback_template = loader . load ( 'playback_log.html' ) recording = retrieve_log_frames ( log_path , rows , cols ) preview = 'false' playback_html = playback_template . generate ( prefix = prefix , container = container , theme = rendered_theme , colors = rendered_colors , preview = preview , recording = json_encode ( recording ) , url_prefix = url_prefix ) out_dict [ 'data' ] = playback_html else : out_dict [ 'result' ] = "ERROR: Log not found" message = { 'save_file' : out_dict } queue . put ( message ) hooks = { : { : enumerate_logs , : retrieve_log_flat , : retrieve_log_playback , : save_log_playback , }

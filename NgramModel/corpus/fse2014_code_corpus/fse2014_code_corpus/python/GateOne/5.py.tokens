__version__ = '1.0rc1' __license__ = "AGPLv3 or Proprietary (see LICENSE.txt)" __version_info__ = ( 1 , 0 ) __author__ = 'Dan McDougall <daniel.mcdougall@liftoffsoftware.com>' __doc__ = """\ About This Module ================= This crux of this module is the Terminal class which is a pure-Python implementation of the quintessential Unix terminal emulator. It does its best to emulate an xterm and along with that comes support for the majority of the relevant portions of ECMA-48. This includes support for emulating varous VT-* terminal types as well as the "linux" terminal type. The Terminal class's VT-* emulation support is not complete but it should suffice for most terminal emulation needs (e.g. all your typical command line programs should work wonderfully). If something doesn't look quite right or you need support for certain modes added please feel free to open a ticket on Gate One's issue tracker: https://github.com/liftoff/GateOne/issues Note that Terminal was written from scratch in order to be as fast as possible. It is extensively commented and implements some interesting patterns in order to maximize execution speed (most notably for things that loop). Some bits of code may seem "un-Pythonic" and/or difficult to grok but understand that this is probably due to optimizations. If you know "a better way" please feel free to submit a patch, open a ticket, or send us an email. There's a reason why open source software is a superior development model! Supported Emulation Types ------------------------- Without any special mode settings or parameters Terminal should effectively emulate the following terminal types: * xterm (the most important one) * ECMA-48/ANSI X3.64 * Nearly all the VT-* types: VT-52, VT-100, VT-220, VT-320, VT-420, and VT-520 * Linux console ("linux") If you want Terminal to support something else or it's missing a feature from any given terminal type please let us know. We'll implement it! What Terminal Doesn't Do ------------------------ The Terminal class is meant to emulate the display portion of a given terminal. It does not translate keystrokes into escape sequences or special control codes--you'll have to take care of that in your application (or at the client-side like Gate One). It does, however, keep track of many keystroke-specific modes of operation such as Application Cursor Keys and the G0 and G1 charset modes *with* callbacks that can be used to notify your application when such things change. Special Considerations ---------------------- Many methods inside Terminal start with an underscore. This was done to indicate that such methods shouldn't be called directly (from a program that imported the module). If it was thought that a situation might arise where a method could be used externally by a controlling program, the underscore was omitted. Asynchronous Use ---------------- To support asynchronous usage (and make everything faster), Terminal was written to support extensive callbacks that are called when certain events are encountered. Here are the events and their callbacks: .. _callback_constants: ==================================== ======================================================================== Callback Constant (ID) Called when... ==================================== ======================================================================== :attr:`terminal.CALLBACK_SCROLL_UP` The terminal is scrolled up (back). :attr:`terminal.CALLBACK_CHANGED` The screen is changed/updated. :attr:`terminal.CALLBACK_CURSOR_POS` The cursor position changes. :attr:`terminal.CALLBACK_DSR` A Device Status Report (DSR) is requested (via the DSR escape sequence). :attr:`terminal.CALLBACK_TITLE` The terminal title changes (xterm-style) :attr:`terminal.CALLBACK_BELL` The bell character (^G) is encountered. :attr:`terminal.CALLBACK_OPT` The special optional escape sequence is encountered. :attr:`terminal.CALLBACK_MODE` The terminal mode setting changes (e.g. use alternate screen buffer). ==================================== ======================================================================== Note that CALLBACK_DSR is special in that it in most cases it will be called with arguments. See the code for examples of how and when this happens. Also, in most cases it is unwise to override CALLBACK_MODE since this method is primarily meant for internal use within the Terminal class. Using Terminal -------------- Gate One makes extensive use of the Terminal class and its callbacks. So that's a great place to look for specific examples (gateone.py and termio.py, specifically). Having said that, implementing Terminal is pretty straightforward:: >>> import terminal >>> term = terminal.Terminal(24, 80) >>> term.write("This text will be written to the terminal screen.") >>> term.dump() [u'This text will be written to the terminal screen. ', <snip> u' '] Here's an example with some basic callbacks: >>> def mycallback(): ... "This will be called whenever the screen changes." ... print("Screen update! Perfect time to dump the terminal screen.") ... print(term.dump()[0]) # Only need to see the top line for this demo =) ... print("Just dumped the screen.") >>> import terminal >>> term = terminal.Terminal(24, 80) >>> term.callbacks[term.CALLBACK_CHANGED] = mycallback >>> term.write("This should result in mycallback() being called") Screen update! Perfect time to dump the terminal screen. This should result in mycallback() being called Just dumped the screen. .. note:: In testing Gate One it was determined that it is faster to perform the conversion of a terminal screen to HTML on the server side than it is on the client side (via JavaScript anyway). About The Scrollback Bufffer ---------------------------- The Terminal class implements a scrollback buffer. Here's how it works: Whenever a :meth:`Terminal.scroll_up` event occurs, the line (or lines) that will be removed from the top of the screen will be placed into :attr:`Terminal.scrollback_buf`. Then whenever :meth:`Terminal.dump_html` is called the scrollback buffer will be returned along with the screen output and reset to an empty state. Why do this? In the event that a very large :meth:`Terminal.write` occurs (e.g. 'ps aux'), it gives the controlling program the ability to capture what went past the screen without some fancy tracking logic surrounding :meth:`Terminal.write`. More information about how this works can be had by looking at the :meth:`Terminal.dump_html` function itself. .. note:: There's more than one function that empties :attr:`Terminal.scrollback_buf` when called. You'll just have to have a look around =) Class Docstrings ================ """ import re , logging , base64 , copy , StringIO , codecs from datetime import datetime , timedelta from collections import defaultdict from itertools import imap , izip from utils import get_translation try : from PIL import Image except ImportError : Image = None logging . warning ( ) _ = get_translation ( ) CALLBACK_SCROLL_UP = 1 CALLBACK_CHANGED = 2 CALLBACK_CURSOR_POS = 3 CALLBACK_DSR = 5 CALLBACK_TITLE = 6 CALLBACK_BELL = 7 CALLBACK_OPT = 8 CALLBACK_MODE = 9 CALLBACK_RESET = 10 CALLBACK_LEDS = 11 RENDITION_CLASSES = defaultdict ( lambda : None , { 0 : 'reset' , 1 : 'bold' , 2 : 'dim' , 3 : 'italic' , 4 : 'underline' , 5 : 'blink' , 6 : 'fastblink' , 7 : 'reverse' , 8 : 'hidden' , 9 : 'strike' , 10 : 'resetfont' , 11 : 'font11' , 12 : 'font12' , 13 : 'font13' , 14 : 'font14' , 15 : 'font15' , 16 : 'font16' , 17 : 'font17' , 18 : 'font18' , 19 : 'font19' , 20 : 'fraktur' , 21 : 'boldreset' , 22 : 'dimreset' , 23 : 'italicreset' , 24 : 'underlinereset' , 27 : 'reversereset' , 28 : 'hiddenreset' , 29 : 'strikereset' , 30 : 'f0' , 31 : 'f1' , 32 : 'f2' , 33 : 'f3' , 34 : 'f4' , 35 : 'f5' , 36 : 'f6' , 37 : 'f7' , 38 : '' , 40 : 'b0' , 41 : 'b1' , 42 : 'b2' , 43 : 'b3' , 44 : 'b4' , 45 : 'b5' , 46 : 'b6' , 47 : 'b7' , 48 : '' , 49 : 'backgroundreset' , 51 : 'frame' , 52 : 'encircle' , 53 : 'overline' , 60 : 'rightline' , 61 : 'rightdoubleline' , 62 : 'leftline' , 63 : 'leftdoubleline' , 90 : 'bf0' , 91 : 'bf1' , 92 : 'bf2' , 93 : 'bf3' , 94 : 'bf4' , 95 : 'bf5' , 96 : 'bf6' , 97 : 'bf7' , 100 : 'bb0' , 101 : 'bb1' , 102 : 'bb2' , 103 : 'bb3' , 104 : 'bb4' , 105 : 'bb5' , 106 : 'bb6' , 107 : 'bb7' } ) for i in xrange ( 256 ) : RENDITION_CLASSES [ ( i + 1000 ) ] = "fx%s" % i RENDITION_CLASSES [ ( i + 10000 ) ] = "bx%s" % i del i def handle_special ( e ) : curses_specials = { 0xda : u'┌' , 0xc0 : u'└' , 0xbf : u'┐' , 0xd9 : u'┘' , 0xb4 : u'├' , 0xc3 : u'┤' , 0xc1 : u'┴' , 0xc2 : u'┬' , 0xc4 : u'─' , 0xb3 : u'│' , 0xc5 : u'┼' , 0x2d : u'' , 0x5f : u'' , 0x60 : u'◆' , 0xb2 : u'▒' , 0xf8 : u'°' , 0xf1 : u'±' , 0xf9 : u'•' , 0x3c : u'←' , 0x3e : u'→' , 0x76 : u'↓' , 0x5e : u'↑' , 0xb0 : u'⊞' , 0x0f : u'⨂' , 0xdb : u'█' , } specials = { 128 : u'€' , 129 : u' ' , 130 : u'‚' , 131 : u'ƒ' , 132 : u'„' , 133 : u'…' , 134 : u'†' , 135 : u'‡' , 136 : u'ˆ' , 137 : u'‰' , 138 : u'Š' , 139 : u'‹' , 140 : u'Œ' , 141 : u' ' , 142 : u'Ž' , 143 : u' ' , 144 : u' ' , 145 : u'‘' , 146 : u'’' , 147 : u'“' , 148 : u'”' , 149 : u'•' , 150 : u'–' , 151 : u'—' , 152 : u'˜' , 153 : u'™' , 154 : u'š' , 155 : u'›' , 156 : u'œ' , 157 : u'Ø' , 158 : u'ž' , 159 : u'Ÿ' , 160 : u' ' , 161 : u'¡' , 162 : u'¢' , 163 : u'£' , 164 : u'¤' , 165 : u'¥' , 166 : u'¦' , 167 : u'§' , 168 : u'¨' , 169 : u'©' , 170 : u'ª' , 171 : u'«' , 172 : u'¬' , 173 : u"\u00AD" , 174 : u'®' , 175 : u'¯' , 176 : u'°' , 177 : u'±' , 178 : u'²' , 179 : u'³' , 180 : u'´' , 181 : u'µ' , 182 : u'¶' , 183 : u'·' , 184 : u'¸' , 185 : u'¹' , 186 : u'º' , 187 : u'»' , 188 : u'¼' , 189 : u'½' , 190 : u'¾' , 191 : u'¿' , 192 : u'À' , 193 : u'Á' , 194 : u'Â' , 195 : u'Ã' , 196 : u'Ä' , 197 : u'Å' , 198 : u'Æ' , 199 : u'Ç' , 200 : u'È' , 201 : u'É' , 202 : u'Ê' , 203 : u'Ë' , 204 : u'Ì' , 205 : u'Í' , 206 : u'Î' , 207 : u'Ï' , 208 : u'Ð' , 209 : u'Ñ' , 210 : u'Ò' , 211 : u'Ó' , 212 : u'Ô' , 213 : u'Õ' , 214 : u'Ö' , 215 : u'×' , 216 : u'Ø' , 217 : u'Ù' , 218 : u'Ú' , 219 : u'Û' , 220 : u'Ü' , 221 : u'Ý' , 222 : u'Þ' , 223 : u'ß' , 224 : u'à' , 225 : u'á' , 226 : u'â' , 227 : u'ã' , 228 : u'ä' , 229 : u'å' , 230 : u'æ' , 231 : u'ç' , 232 : u'è' , 233 : u'é' , 234 : u'ê' , 235 : u'ë' , 236 : u'ì' , 237 : u'í' , 238 : u'î' , 239 : u'ï' , 240 : u'ð' , 241 : u'ñ' , 242 : u'ò' , 243 : u'ó' , 244 : u'ô' , 245 : u'õ' , 246 : u'ö' , 247 : u'÷' , 248 : u'ø' , 249 : u'ù' , 250 : u'ú' , 251 : u'û' , 252 : u'ü' , 253 : u'ý' , 254 : u'þ' , 255 : u'ÿ' , } if isinstance ( e , ( UnicodeEncodeError , UnicodeTranslateError ) ) : s = [ u'%s' % specials [ ord ( c ) ] for c in e . object [ e . start : e . end ] ] return '' . join ( s ) , e . end else : s = [ u'%s' % specials [ ord ( c ) ] for c in e . object [ e . start : e . end ] ] return '' . join ( s ) , e . end codecs . register_error ( 'handle_special' , handle_special ) def _reduce_renditions ( renditions ) : out_renditions = [ ] foreground = None background = None for i , rend in enumerate ( renditions ) : if rend < 29 : if rend not in out_renditions : out_renditions . append ( rend ) elif rend > 29 and rend < 40 : foreground = rend elif rend > 39 and rend < 50 : background = rend elif rend > 91 and rend < 98 : foreground = rend elif rend > 99 and rend < 108 : background = rend elif rend > 1000 and rend < 10000 : foreground = rend elif rend > 10000 and rend < 20000 : background = rend else : out_renditions . append ( rend ) if foreground : out_renditions . append ( foreground ) if background : out_renditions . append ( background ) return out_renditions class Terminal ( object ) : ASCII_NUL = 0 ASCII_BEL = 7 ASCII_BS = 8 ASCII_HT = 9 ASCII_LF = 10 ASCII_VT = 11 ASCII_FF = 12 ASCII_CR = 13 ASCII_SO = 14 ASCII_SI = 15 ASCII_XON = 17 ASCII_XOFF = 19 ASCII_CAN = 24 ASCII_SUB = 26 ASCII_ESC = 27 ASCII_CSI = 155 ASCII_HTS = 210 charsets = { : { } , : { 95 : u' ' , 96 : u'◆' , 97 : u'▒' , 98 : u'\t' , 99 : u'\x0c' , 100 : u'\r' , 101 : u'\n' , 102 : u'°' , 103 : u'±' , 104 : u'\n' , 105 : u'\x0b' , 106 : u'┘' , 107 : u'┐' , 108 : u'┌' , 109 : u'└' , 110 : u'┼' , 111 : u'⎺' , 112 : u'⎻' , 113 : u'─' , 114 : u'⎼' , 115 : u'⎽' , 116 : u'├' , 117 : u'┤' , 118 : u'┴' , 119 : u'┬' , 120 : u'│' , 121 : u'≤' , 122 : u'≥' , 123 : u'π' , 124 : u'≠' , 125 : u'£' , 126 : u'·' } } RE_CSI_ESC_SEQ = re . compile ( r'\x1B\[([?A-Za-z0-9;@:\!]*)([A-Za-z@_])' ) RE_ESC_SEQ = re . compile ( r'\x1b(.*\x1b\\|[ABCDEFGHIJKLMNOQRSTUVWXYZa-z0-9=<>]|[()# %*+].)' ) RE_TITLE_SEQ = re . compile ( r'\x1b\][0-2]\;(.*?)(\x07|\x1b\\)' ) RE_OPT_SEQ = re . compile ( r'\x1b\]_\;(.+?)(\x07|\x1b\\)' ) RE_NUMBERS = re . compile ( '\d*' ) def __init__ ( self , rows = 24 , cols = 80 , em_dimensions = None ) : self . initialize ( rows , cols , em_dimensions ) def initialize ( self , rows = 24 , cols = 80 , em_dimensions = None ) : self . cols = cols self . rows = rows self . em_dimensions = em_dimensions self . scrollback_buf = [ ] self . scrollback_renditions = [ ] self . title = "Gate One" self . modified = False self . local_echo = True self . esc_buffer = '' self . show_cursor = True self . cursor_home = 0 self . cur_rendition = [ 0 ] self . init_screen ( ) self . init_renditions ( ) self . G0_charset = self . charsets [ 'B' ] self . G1_charset = self . charsets [ 'B' ] self . current_charset = 0 self . charset = self . G0_charset self . set_G0_charset ( 'B' ) self . set_G1_charset ( 'B' ) self . use_g0_charset ( ) self . top_margin = 0 self . bottom_margin = self . rows - 1 self . timeout_image = None self . specials = { self . ASCII_NUL : self . __ignore , self . ASCII_BEL : self . bell , self . ASCII_BS : self . backspace , self . ASCII_HT : self . horizontal_tab , self . ASCII_LF : self . linefeed , self . ASCII_VT : self . linefeed , self . ASCII_FF : self . linefeed , self . ASCII_CR : self . _carriage_return , self . ASCII_SO : self . use_g1_charset , self . ASCII_SI : self . use_g0_charset , self . ASCII_XON : self . _xon , self . ASCII_CAN : self . _cancel_esc_sequence , self . ASCII_XOFF : self . _xoff , self . ASCII_ESC : self . _escape , self . ASCII_CSI : self . _csi , } self . esc_handlers = { : self . _set_line_params , : self . _string_terminator , : self . clear_screen , : self . __ignore , : self . reverse_linefeed , : self . next_line , : self . __ignore , : self . next_line , : self . _dsr_get_cursor_position , : self . save_cursor_position , : self . restore_cursor_position , : self . _set_tabstop , : self . reverse_linefeed , : self . set_G0_charset , : self . set_G1_charset , : self . __ignore , : self . __ignore , : self . _device_status_report , : self . __ignore , : self . _dcs_handler , : self . __ignore , : self . __ignore , : self . __ignore , } self . csi_handlers = { : self . cursor_up , : self . cursor_down , : self . cursor_right , : self . cursor_left , : self . cursor_next_line , : self . cursor_previous_line , : self . cursor_horizontal_absolute , : self . cursor_position , : self . insert_line , : self . delete_line , : self . _csi_device_status_report , : self . __ignore , : self . set_expanded_mode , : self . reset_expanded_mode , : self . cursor_position , : self . cursor_position_vertical , : self . clear_screen_from_cursor , : self . clear_line_from_cursor , : self . scroll_up , : self . scroll_down , : self . save_cursor_position , : self . restore_cursor_position , : self . _set_rendition , : self . __ignore , : self . reset , : self . _set_top_bottom , : self . set_led_state , : self . delete_characters , : self . _erase_characters , : self . insert_characters , : self . insert_characters , } self . expanded_modes = { : self . set_application_mode , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . send_receive_mode , : self . __ignore , : self . __ignore , : self . show_hide_cursor , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . toggle_alternate_screen_buffer , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , : self . toggle_alternate_screen_buffer_cursor , : self . __ignore , : self . __ignore , : self . __ignore , : self . __ignore , } self . callbacks = { CALLBACK_SCROLL_UP : { } , CALLBACK_CHANGED : { } , CALLBACK_CURSOR_POS : { } , CALLBACK_DSR : { } , CALLBACK_TITLE : { } , CALLBACK_BELL : { } , CALLBACK_OPT : { } , CALLBACK_MODE : { } , CALLBACK_RESET : { } , CALLBACK_LEDS : { } , } self . leds = { 1 : False , 2 : False , 3 : False , 4 : False } png_header = re . compile ( '.*\x89PNG\r' ) png_whole = re . compile ( '\x89PNG\r.+IEND\xaeB`\x82' , re . DOTALL ) jpeg_header = re . compile ( '.*\xff\xd8\xff.+JFIF\x00|.*\xff\xd8\xff.+Exif\x00' , re . DOTALL ) jpeg_whole = re . compile ( , re . DOTALL ) self . magic = { png_header : png_whole , jpeg_header : jpeg_whole , } self . matched_header = None self . alt_screen = None self . alt_renditions = None self . alt_cursorX = 0 self . alt_cursorY = 0 self . saved_cursorX = 0 self . saved_cursorY = 0 self . saved_rendition = [ None ] self . application_keys = False self . image = bytearray ( ) def init_screen ( self ) : self . screen = [ [ u' ' for a in xrange ( self . cols ) ] for b in xrange ( self . rows ) ] tabs , remainder = divmod ( self . cols , 8 ) self . tabstops = [ ( a * 8 ) - 1 for a in xrange ( tabs ) ] self . tabstops [ 0 ] = 0 self . cursorX = 0 self . cursorY = 0 self . rendition_set = False def init_renditions ( self ) : self . renditions = [ [ [ 0 ] for a in xrange ( self . cols ) ] for b in xrange ( self . rows ) ] def init_scrollback ( self ) : self . scrollback_buf = [ ] self . scrollback_renditions = [ ] def add_callback ( self , event , callback , identifier = None ) : if not identifier : identifier = callback . __hash__ ( ) self . callbacks [ event ] [ identifier ] = callback return identifier def remove_callback ( self , event , identifier ) : del self . callbacks [ event ] [ identifier ] def remove_all_callbacks ( self , identifier ) : for event , identifiers in self . callbacks . items ( ) : try : del self . callbacks [ event ] [ identifier ] except KeyError : pass def reset ( self , * args , ** kwargs ) : self . leds = { 1 : False , 2 : False , 3 : False , 4 : False } self . local_echo = True self . title = "Gate One" self . esc_buffer = '' self . show_cursor = True self . rendition_set = False self . G0_charset = 'B' self . current_charset = self . charsets [ 'B' ] self . top_margin = 0 self . bottom_margin = self . rows - 1 self . alt_screen = None self . alt_renditions = None self . alt_cursorX = 0 self . alt_cursorY = 0 self . saved_cursorX = 0 self . saved_cursorY = 0 self . saved_rendition = [ None ] self . application_keys = False self . init_screen ( ) self . init_renditions ( ) self . init_scrollback ( ) try : self . callbacks [ CALLBACK_RESET ] ( ) except TypeError : pass def __ignore ( self , * args , ** kwargs ) : pass def resize ( self , rows , cols , em_dimensions = None ) : logging . debug ( "resize(%s, %s)" % ( rows , cols ) ) if rows < self . rows : for i in xrange ( self . rows - rows ) : self . screen . pop ( 0 ) self . renditions . pop ( 0 ) elif rows > self . rows : for i in xrange ( rows - self . rows ) : line = [ u' ' for a in xrange ( cols ) ] renditions = [ [ 0 ] for a in xrange ( self . cols ) ] self . screen . append ( line ) self . renditions . append ( renditions ) self . rows = rows self . top_margin = 0 self . bottom_margin = self . rows - 1 if self . cursorY >= self . rows : self . cursorY = self . rows - 1 if cols < self . cols : for i in xrange ( self . rows ) : self . screen [ i ] = self . screen [ i ] [ : cols - self . cols ] self . renditions [ i ] = self . renditions [ i ] [ : cols - self . cols ] elif cols > self . cols : for i in xrange ( self . rows ) : for j in xrange ( cols - self . cols ) : self . screen [ i ] . append ( u' ' ) self . renditions [ i ] . append ( [ 0 ] ) self . cols = cols if self . cursorX >= self . cols : self . cursorX = self . cols - 1 self . rendition_set = False def _set_top_bottom ( self , settings ) : if len ( settings ) : if settings . startswith ( '?' ) : return top , bottom = settings . split ( ';' ) self . top_margin = max ( 0 , int ( top ) - 1 ) if bottom : self . bottom_margin = min ( self . rows - 1 , int ( bottom ) - 1 ) else : self . top_margin , self . bottom_margin = 0 , self . rows - 1 def get_cursor_position ( self ) : return ( self . cursorY , self . cursorX ) def set_title ( self , title ) : self . title = title try : for callback in self . callbacks [ CALLBACK_TITLE ] . values ( ) : callback ( ) except TypeError as e : logging . error ( _ ( "Got TypeError on CALLBACK_TITLE..." ) ) logging . error ( repr ( self . callbacks [ CALLBACK_TITLE ] ) ) logging . error ( e ) def get_title ( self ) : return self . title def save_cursor_position ( self , mode = None ) : if mode : self . set_expanded_mode ( mode ) self . saved_cursorX = self . cursorX self . saved_cursorY = self . cursorY self . saved_rendition = self . renditions [ self . cursorY ] [ self . cursorX ] def restore_cursor_position ( self , * args , ** kwargs ) : if self . saved_cursorX and self . saved_cursorY : self . cursorX = self . saved_cursorX self . cursorY = self . saved_cursorY self . renditions [ self . cursorY ] [ self . cursorX ] = self . saved_rendition def _dsr_get_cursor_position ( self ) : esc_cursor_pos = '\x1b%s;%sR' % ( self . cursorY , self . cursorX ) try : for callback in self . callbacks [ CALLBACK_DSR ] . values ( ) : callback ( esc_cursor_pos ) except TypeError : pass return esc_cursor_pos def _dcs_handler ( self , string = None ) : pass def _set_line_params ( self , param ) : try : param = int ( param ) except ValueError : logging . warning ( "Couldn't handle escape sequence #%s" % repr ( param ) ) if param == 8 : self . init_renditions ( ) self . screen = [ [ u'E' for a in xrange ( self . cols ) ] for b in xrange ( self . rows ) ] def set_G0_charset ( self , char ) : try : self . G0_charset = self . charsets [ char ] except KeyError : self . G0_charset = self . charsets [ 'B' ] if self . current_charset == 0 : self . charset = self . G0_charset def set_G1_charset ( self , char ) : try : self . G1_charset = self . charsets [ char ] except KeyError : self . G1_charset = self . charsets [ 'B' ] if self . current_charset == 1 : self . charset = self . G1_charset def use_g0_charset ( self ) : self . current_charset = 0 def use_g1_charset ( self ) : self . current_charset = 1 def write ( self , chars , special_checks = True ) : specials = self . specials esc_handlers = self . esc_handlers csi_handlers = self . csi_handlers RE_ESC_SEQ = self . RE_ESC_SEQ RE_CSI_ESC_SEQ = self . RE_CSI_ESC_SEQ cursor_right = self . cursor_right magic = self . magic changed = False if special_checks : before_chars = "" after_chars = "" for magic_header in magic . keys ( ) : if magic_header . match ( chars ) : self . matched_header = magic_header self . timeout_image = datetime . now ( ) if self . image or self . matched_header : self . image . extend ( chars ) match = magic [ self . matched_header ] . match ( self . image ) if match : before_chars , after_chars = magic [ self . matched_header ] . split ( self . image ) self . image = match . group ( ) self . _capture_image ( ) self . image = bytearray ( ) self . matched_header = None if before_chars : self . write ( before_chars , special_checks = False ) if after_chars : self . write ( after_chars , special_checks = False ) one_second = timedelta ( seconds = 1 ) if datetime . now ( ) - self . timeout_image > one_second : self . image = bytearray ( ) self . matched_header = None chars = _ ( "Failed to decode image. Buffer discarded." ) else : return try : chars = unicode ( chars . decode ( 'utf-8' , "handle_special" ) ) except UnicodeEncodeError : try : chars = unicode ( chars . decode ( 'utf-8' , "ignore" ) ) except UnicodeEncodeError : logging . error ( _ ( "Double UnicodeEncodeError in Terminal.terminal." ) ) return for char in chars : charnum = ord ( char ) if charnum in specials : specials [ charnum ] ( ) else : if self . esc_buffer : try : self . esc_buffer += char match_obj = RE_ESC_SEQ . match ( self . esc_buffer ) if match_obj : seq_type = match_obj . group ( 1 ) if len ( seq_type ) == 1 : esc_handlers [ seq_type ] ( ) else : esc_handlers [ seq_type [ 0 ] ] ( seq_type [ 1 : ] ) self . esc_buffer = '' continue match_obj = RE_CSI_ESC_SEQ . match ( self . esc_buffer ) if match_obj : csi_values = match_obj . group ( 1 ) csi_type = match_obj . group ( 2 ) try : csi_handlers [ csi_type ] ( csi_values ) except ValueError : pass self . esc_buffer = '' continue except KeyError : if self . esc_buffer . endswith ( '\x1b\\' ) : self . _osc_handler ( ) else : self . esc_buffer = '' continue changed = True if self . cursorX >= self . cols : self . newline ( ) self . cursorX = 0 try : self . renditions [ self . cursorY ] [ self . cursorX ] = self . cur_rendition if charnum in self . charset : char = self . charset [ charnum ] self . screen [ self . cursorY ] [ self . cursorX ] = char else : self . screen [ self . cursorY ] [ self . cursorX ] = char except IndexError : pass cursor_right ( ) if changed : self . modified = True try : for callback in self . callbacks [ CALLBACK_CHANGED ] . values ( ) : callback ( ) except TypeError : pass try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def flush ( self ) : pass def scroll_up ( self , n = 1 ) : for x in xrange ( int ( n ) ) : line = self . screen . pop ( self . top_margin ) self . scrollback_buf . append ( line ) if len ( self . scrollback_buf ) > 1000 : self . init_scrollback ( ) empty_line = [ u' ' for a in xrange ( self . cols ) ] self . screen . insert ( self . bottom_margin , empty_line ) style = self . renditions . pop ( self . top_margin ) self . scrollback_renditions . append ( style ) self . renditions . insert ( self . bottom_margin , [ [ 0 ] for a in xrange ( self . cols ) ] ) try : for callback in self . callbacks [ CALLBACK_CHANGED ] . values ( ) : callback ( ) except TypeError : pass try : for callback in self . callbacks [ CALLBACK_SCROLL_UP ] . values ( ) : callback ( ) except TypeError : pass def scroll_down ( self , n = 1 ) : for x in xrange ( int ( n ) ) : self . screen . pop ( self . bottom_margin ) empty_line = [ u' ' for a in xrange ( self . cols ) ] self . screen . insert ( self . top_margin , empty_line ) self . renditions . pop ( self . bottom_margin ) self . renditions . insert ( self . top_margin , [ [ 0 ] for a in xrange ( self . cols ) ] ) try : for callback in self . callbacks [ CALLBACK_CHANGED ] . values ( ) : callback ( ) except TypeError : pass try : for callback in self . callbacks [ CALLBACK_SCROLL_UP ] . values ( ) : callback ( ) except TypeError : pass def insert_line ( self , n = 1 ) : if not n : n = 1 n = int ( n ) for i in xrange ( n ) : self . screen . pop ( self . bottom_margin ) self . renditions . pop ( self . bottom_margin ) empty_line = [ u' ' for a in xrange ( self . cols ) ] self . screen . insert ( self . cursorY , empty_line ) self . renditions . insert ( self . cursorY , [ [ 0 ] for a in xrange ( self . cols ) ] ) def delete_line ( self , n = 1 ) : if not n : n = 1 n = int ( n ) for i in xrange ( n ) : self . screen . pop ( self . cursorY ) self . renditions . pop ( self . cursorY ) empty_line = [ u' ' for a in xrange ( self . cols ) ] self . screen . insert ( self . bottom_margin , empty_line ) self . renditions . insert ( self . bottom_margin , [ [ 0 ] for a in xrange ( self . cols ) ] ) def backspace ( self ) : try : self . renditions [ self . cursorY ] [ self . cursorX ] = [ ] except IndexError : pass self . cursor_left ( 1 ) def horizontal_tab ( self ) : next_tabstop = self . cols - 1 for tabstop in self . tabstops : if tabstop > self . cursorX : next_tabstop = tabstop break self . cursorX = next_tabstop def _set_tabstop ( self ) : if self . cursorX not in self . tabstops : for tabstop in self . tabstops : if self . cursorX > tabstop : self . tabstops . append ( self . cursorX ) self . tabstops . sort ( ) break def linefeed ( self ) : self . newline ( ) def next_line ( self ) : self . cursorX = self . cursor_home if self . cursorY < self . rows - 1 : self . cursorY += 1 def reverse_linefeed ( self ) : self . cursorX = 0 self . cursorY -= 1 if self . cursorY < self . top_margin : self . scroll_down ( ) self . cursorY = self . top_margin def newline ( self ) : self . cursorY += 1 if self . cursorY > self . bottom_margin : self . scroll_up ( ) self . cursorY = self . bottom_margin self . clear_line ( ) def _carriage_return ( self ) : self . cursorX = 0 def _xon ( self ) : logging . debug ( '_xon()' ) self . local_echo = True def _xoff ( self ) : logging . debug ( '_xoff()' ) self . local_echo = False def _cancel_esc_sequence ( self ) : self . esc_buffer = '' def _sub_esc_sequence ( self ) : self . esc_buffer = '' self . write ( '?' ) def _escape ( self ) : buf = self . esc_buffer if buf . startswith ( '\x1bP' ) or buf . startswith ( '\x1b]' ) : self . esc_buffer += '\x1b' else : self . esc_buffer = '\x1b' def _csi ( self ) : self . esc_buffer = '\x1b[' def _capture_image ( self ) : logging . debug ( "_capture_image() len(self.image): %s" % len ( self . image ) ) self . image = self . image . replace ( '\r\n' , '\n' ) if Image : i = StringIO . StringIO ( self . image ) try : im = Image . open ( i ) except IOError : return else : return if self . em_dimensions : width = im . size [ 0 ] height = im . size [ 1 ] if height <= self . em_dimensions [ 'height' ] : num_chars = int ( width / self . em_dimensions [ 'width' ] ) self . screen [ self . cursorY ] [ self . cursorX ] = self . image self . cursor_right ( num_chars ) else : newlines = int ( height / self . em_dimensions [ 'height' ] ) self . cursorX = 0 newlines = abs ( self . cursorY - newlines ) self . newline ( ) if newlines > self . cursorY : for line in xrange ( newlines ) : self . newline ( ) self . screen [ self . cursorY ] [ self . cursorX ] = self . image self . newline ( ) else : self . cursorY = self . rows - 1 self . screen [ self . cursorY ] [ self . cursorX ] = self . image self . newline ( ) self . newline ( ) def _string_terminator ( self ) : pass def _osc_handler ( self ) : match_obj = self . RE_TITLE_SEQ . match ( self . esc_buffer ) if match_obj : self . esc_buffer = '' title = match_obj . group ( 1 ) self . set_title ( title ) return match_obj = self . RE_OPT_SEQ . match ( self . esc_buffer ) if match_obj : self . esc_buffer = '' text = match_obj . group ( 1 ) self . _opt_handler ( text ) return self . esc_buffer = '' def bell ( self ) : if not self . esc_buffer : try : for callback in self . callbacks [ CALLBACK_BELL ] . values ( ) : callback ( ) except TypeError : pass else : self . esc_buffer += '\x07' self . _osc_handler ( ) def _device_status_report ( self ) : logging . debug ( "_device_status_report()" ) response = u"\x1b[0n" try : for callback in self . callbacks [ CALLBACK_DSR ] . values ( ) : callback ( response ) except TypeError : pass return response def _csi_device_status_report ( self , request ) : logging . debug ( "_csi_device_status_report()" ) response = u"\x1b[1;2c" try : for callback in self . callbacks [ CALLBACK_DSR ] . values ( ) : callback ( response ) except TypeError : pass return response def set_expanded_mode ( self , setting ) : setting = setting [ 1 : ] settings = setting . split ( ';' ) for setting in settings : try : self . expanded_modes [ setting ] ( True ) except ( KeyError , TypeError ) : pass try : for callback in self . callbacks [ CALLBACK_MODE ] . values ( ) : callback ( setting , True ) except TypeError : pass def reset_expanded_mode ( self , setting ) : setting = setting [ 1 : ] settings = setting . split ( ';' ) for setting in settings : try : self . expanded_modes [ setting ] ( False ) except ( KeyError , TypeError ) : pass try : for callback in self . callbacks [ CALLBACK_MODE ] . values ( ) : callback ( setting , False ) except TypeError : pass def set_application_mode ( self , boolean ) : self . application_keys = boolean def toggle_alternate_screen_buffer ( self , alt ) : if alt : self . alt_screen = copy . copy ( self . screen ) self . alt_renditions = copy . copy ( self . renditions ) self . clear_screen ( ) else : if self . alt_screen and self . alt_renditions : self . screen = self . alt_screen self . renditions = self . alt_renditions self . alt_screen = None self . alt_renditions = None self . cur_rendition = [ ] def toggle_alternate_screen_buffer_cursor ( self , alt ) : if alt : self . alt_cursorX = self . cursorX self . alt_cursorY = self . cursorY else : self . cursorX = self . alt_cursorX self . cursorY = self . alt_cursorY self . toggle_alternate_screen_buffer ( alt ) def show_hide_cursor ( self , boolean ) : self . show_cursor = boolean def send_receive_mode ( self , onoff ) : logging . debug ( "send_receive_mode(%s)" % repr ( onoff ) ) def insert_characters ( self , n = 1 ) : n = int ( n ) for i in xrange ( n ) : self . screen [ self . cursorY ] . pop ( ) self . screen [ self . cursorY ] . insert ( self . cursorX , u' ' ) def delete_characters ( self , n = 1 ) : if not n : n = 1 else : n = int ( n ) for i in xrange ( n ) : try : self . screen [ self . cursorY ] . pop ( self . cursorX ) self . screen [ self . cursorY ] . append ( u' ' ) self . renditions [ self . cursorY ] . pop ( self . cursorX ) self . renditions [ self . cursorY ] . append ( [ 0 ] ) except IndexError : pass def _erase_characters ( self , n = 1 ) : if not n : n = 1 else : n = int ( n ) distance = self . cols - self . cursorX n = min ( n , distance ) for i in xrange ( n ) : self . screen [ self . cursorY ] [ self . cursorX + i ] = u' ' self . renditions [ self . cursorY ] [ self . cursorX + i ] = [ 0 ] def cursor_left ( self , n = 1 ) : n = int ( n ) self . cursorX = max ( 0 , self . cursorX - n ) try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def cursor_right ( self , n = 1 ) : if not n : n = 1 n = int ( n ) self . cursorX += n try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def cursor_up ( self , n = 1 ) : if not n : n = 1 n = int ( n ) self . cursorY = max ( 0 , self . cursorY - n ) try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def cursor_down ( self , n = 1 ) : if not n : n = 1 n = int ( n ) self . cursorY = min ( self . rows , self . cursorY + n ) try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def cursor_next_line ( self , n ) : if not n : n = 1 n = int ( n ) self . cursorY = min ( self . rows , self . cursorY + n ) self . cursorX = 0 try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def cursor_previous_line ( self , n ) : if not n : n = 1 n = int ( n ) self . cursorY = max ( 0 , self . cursorY - n ) self . cursorX = 0 try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def cursor_horizontal_absolute ( self , n ) : if not n : n = 1 n = int ( n ) self . cursorX = n - 1 try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def cursor_position ( self , coordinates ) : if not coordinates : row , col = 0 , 0 elif ';' in coordinates : row , col = coordinates . split ( ';' ) else : row = coordinates col = 0 try : row = int ( row ) except ValueError : row = 0 try : col = int ( col ) except ValueError : col = 0 row = max ( 0 , row - 1 ) col = max ( 0 , col - 1 ) self . cursorY = row self . cursorX = col try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def cursor_position_vertical ( self , n ) : n = int ( n ) self . cursorY = n - 1 def clear_screen ( self ) : self . init_screen ( ) self . renditions = [ [ self . cur_rendition for a in xrange ( self . cols ) ] for b in xrange ( self . rows ) ] self . cursorX = 0 self . cursorY = 0 def clear_screen_from_cursor_down ( self ) : self . screen [ self . cursorY : ] = [ [ u' ' for a in xrange ( self . cols ) ] for a in self . screen [ self . cursorY : ] ] self . renditions [ self . cursorY : ] = [ [ self . cur_rendition for a in xrange ( self . cols ) ] for a in self . screen [ self . cursorY : ] ] self . cursorX = 0 def clear_screen_from_cursor_up ( self ) : self . screen [ : self . cursorY + 1 ] = [ [ u' ' for a in xrange ( self . cols ) ] for a in self . screen [ : self . cursorY ] ] self . renditions [ : self . cursorY + 1 ] = [ [ [ 0 ] for a in xrange ( self . cols ) ] for a in self . screen [ : self . cursorY ] ] self . cursorX = 0 self . cursorY = 0 def clear_screen_from_cursor ( self , n ) : try : n = int ( n ) except ValueError : n = 0 clear_types = { 0 : self . clear_screen_from_cursor_down , 1 : self . clear_screen_from_cursor_up , 2 : self . clear_screen } try : clear_types [ n ] ( ) except KeyError : logging . error ( _ ( "Error: Unsupported number for escape sequence J" ) ) try : for callback in self . callbacks [ CALLBACK_CHANGED ] . values ( ) : callback ( ) except TypeError : pass try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def clear_line_from_cursor_right ( self ) : self . screen [ self . cursorY ] [ self . cursorX : ] = [ for a in self . screen [ self . cursorY ] [ self . cursorX : ] ] self . renditions [ self . cursorY ] [ self . cursorX : ] = [ self . cur_rendition for a in self . screen [ self . cursorY ] [ self . cursorX : ] ] def clear_line_from_cursor_left ( self ) : saved = self . screen [ self . cursorY ] [ self . cursorX : ] saved_renditions = self . renditions [ self . cursorY ] [ self . cursorX : ] self . screen [ self . cursorY ] = [ for a in self . screen [ self . cursorY ] [ : self . cursorX ] ] + saved self . renditions [ self . cursorY ] = [ [ ] for a in self . screen [ self . cursorY ] [ : self . cursorX ] ] + saved_renditions def clear_line ( self ) : self . screen [ self . cursorY ] = [ u' ' for a in xrange ( self . cols ) ] self . renditions [ self . cursorY ] = [ [ 0 ] for a in xrange ( self . cols ) ] self . cursorX = 0 def clear_line_from_cursor ( self , n ) : try : n = int ( n ) except ValueError : n = 0 clear_types = { 0 : self . clear_line_from_cursor_right , 1 : self . clear_line_from_cursor_left , 2 : self . clear_line } try : clear_types [ n ] ( ) except KeyError : logging . error ( _ ( ) ) try : for callback in self . callbacks [ CALLBACK_CHANGED ] . values ( ) : callback ( ) except TypeError : pass try : for callback in self . callbacks [ CALLBACK_CURSOR_POS ] . values ( ) : callback ( ) except TypeError : pass def set_led_state ( self , n ) : states = n . split ( ';' ) for state in states : state = int ( state ) if state == 0 : self . leds [ 1 ] = False self . leds [ 2 ] = False self . leds [ 3 ] = False self . leds [ 4 ] = False else : self . leds [ state ] = True try : for callback in self . callbacks [ CALLBACK_LEDS ] . values ( ) : callback ( ) except TypeError : pass def _set_rendition ( self , n ) : cursorY = self . cursorY cursorX = self . cursorX if cursorX >= self . cols : if len ( self . renditions [ cursorY ] ) <= cursorX : self . renditions [ cursorY ] . append ( [ ] ) self . screen [ cursorY ] . append ( '\x00' ) if cursorY >= self . rows : logging . error ( _ ( ) ) return if not n : self . cur_rendition = [ 0 ] return new_renditions = [ int ( a ) for a in n . split ( ';' ) if a != '' ] if 38 in new_renditions : foreground_index = new_renditions . index ( 38 ) if len ( new_renditions [ foreground_index : ] ) >= 2 : if new_renditions [ foreground_index + 1 ] == 5 : new_renditions . pop ( foreground_index ) new_renditions . pop ( foreground_index ) new_renditions [ foreground_index ] += 1000 if 48 in new_renditions : background_index = new_renditions . index ( 48 ) if len ( new_renditions [ background_index : ] ) >= 2 : if new_renditions [ background_index + 1 ] == 5 : new_renditions . pop ( background_index ) new_renditions . pop ( background_index ) new_renditions [ background_index ] += 10000 out_renditions = [ ] for rend in new_renditions : if rend == 0 : out_renditions = [ 0 ] self . cur_rendition = [ 0 ] return else : out_renditions . append ( rend ) new_renditions = out_renditions reduced = _reduce_renditions ( self . cur_rendition + new_renditions ) self . cur_rendition = reduced def _opt_handler ( self , chars ) : try : for callback in self . callbacks [ CALLBACK_OPT ] . values ( ) : callback ( chars ) except TypeError as e : pass def _spanify_screen ( self ) : results = [ ] rendition_classes = RENDITION_CLASSES screen = self . screen renditions = self . renditions cursorX = self . cursorX cursorY = self . cursorY spancount = 0 current_classes = [ ] prev_rendition = None foregrounds = ( 'f0' , 'f1' , 'f2' , 'f3' , 'f4' , 'f5' , 'f6' , 'f7' ) backgrounds = ( 'b0' , 'b1' , 'b2' , 'b3' , 'b4' , 'b5' , 'b6' , 'b7' ) for linecount , line_rendition in enumerate ( izip ( screen , renditions ) ) : line = line_rendition [ 0 ] rendition = line_rendition [ 1 ] outline = "" charcount = 0 for char , rend in izip ( line , rendition ) : if len ( char ) > 1 : if not Image : outline += "<i>Image file</i>" continue image_data = char i = StringIO . StringIO ( image_data ) try : im = Image . open ( i ) except IOError : outline += "<i>Image file</i>" continue if len ( image_data ) > 50000 : if im : try : im . thumbnail ( ( 640 , 480 ) , Image . ANTIALIAS ) f = StringIO . StringIO ( ) im . save ( f , im . format ) f . seek ( 0 ) image_data = bytearray ( f . read ( ) ) except IOError : outline += "<i>Problem displaying this image</i>" continue else : outline += "<i>Problem displaying this image</i>" continue image_data = bytes ( image_data ) encoded = base64 . b64encode ( image_data ) . replace ( '\n' , '' ) data_uri = "data:image/%s;base64,%s" % ( im . format . lower ( ) , encoded ) outline += '<img src="%s" width="%s" height="%s">' % ( data_uri , im . size [ 0 ] , im . size [ 1 ] ) continue changed = True if char in "&<>" : char = char . replace ( '&' , '&amp;' ) char = char . replace ( '<' , '&lt;' ) char = char . replace ( '>' , '&gt;' ) if rend == prev_rendition : changed = False else : prev_rendition = rend if changed and rend : classes = imap ( rendition_classes . get , rend ) for _class in classes : if _class and _class not in current_classes : if spancount : outline += "</span>" spancount -= 1 if 'reset' in _class : if _class == 'reset' : current_classes = [ ] if spancount : for i in xrange ( spancount ) : outline += "</span>" spancount = 0 else : reset_class = _class . split ( 'reset' ) [ 0 ] if reset_class == 'foreground' : [ current_classes . pop ( i ) for i , a in enumerate ( current_classes ) if a in foregrounds ] elif reset_class == 'background' : [ current_classes . pop ( i ) for i , a in enumerate ( current_classes ) if a in backgrounds ] else : try : current_classes . remove ( reset_class ) except ValueError : pass else : if _class in foregrounds : [ current_classes . pop ( i ) for i , a in enumerate ( current_classes ) if a in foregrounds ] elif _class in backgrounds : [ current_classes . pop ( i ) for i , a in enumerate ( current_classes ) if a in backgrounds ] current_classes . append ( _class ) if current_classes : outline += '<span class="%s">' % " " . join ( current_classes ) spancount += 1 if linecount == cursorY and charcount == cursorX : if self . show_cursor : outline += '<span class="cursor">%s</span>' % char else : outline += char else : outline += char charcount += 1 if outline : results . append ( outline ) else : results . append ( None ) for whatever in xrange ( spancount ) : results [ - 1 ] += "</span>" return results def _spanify_scrollback ( self ) : results = [ ] screen = self . scrollback_buf renditions = self . scrollback_renditions rendition_classes = RENDITION_CLASSES spancount = 0 current_classes = [ ] prev_rendition = None foregrounds = ( 'f0' , 'f1' , 'f2' , 'f3' , 'f4' , 'f5' , 'f6' , 'f7' ) backgrounds = ( 'b0' , 'b1' , 'b2' , 'b3' , 'b4' , 'b5' , 'b6' , 'b7' ) for line , rendition in izip ( screen , renditions ) : outline = "" for char , rend in izip ( line , rendition ) : if len ( char ) > 1 : if not Image : outline += "<i>Image file</i>" continue image_data = char i = StringIO . StringIO ( image_data ) try : im = Image . open ( i ) except IOError : outline += "<i>Image file</i>" continue if len ( image_data ) > 50000 : if im : im . thumbnail ( ( 640 , 480 ) , Image . ANTIALIAS ) f = StringIO . StringIO ( ) im . save ( f , im . format ) f . seek ( 0 ) image_data = bytearray ( f . read ( ) ) else : outline += "<i>Problem displaying this image</i>" continue encoded = base64 . b64encode ( image_data ) . replace ( '\n' , '' ) data_uri = "data:image/%s;base64,%s" % ( im . format . lower ( ) , encoded ) outline += '\n<img src="%s" width="%s" height="%s">\n' % ( data_uri , im . size [ 0 ] , im . size [ 1 ] ) continue changed = True if char in "&<>" : char = char . replace ( '&' , '&amp;' ) char = char . replace ( '<' , '&lt;' ) char = char . replace ( '>' , '&gt;' ) if rend == prev_rendition : changed = False else : prev_rendition = rend if changed and rend != None : classes = imap ( rendition_classes . get , rend ) for _class in classes : if _class and _class not in current_classes : if spancount : outline += "</span>" spancount -= 1 if 'reset' in _class : if _class == 'reset' : current_classes = [ ] else : reset_class = _class . split ( 'reset' ) [ 0 ] if reset_class == 'foreground' : [ current_classes . pop ( i ) for i , a in enumerate ( current_classes ) if a in foregrounds ] elif reset_class == 'background' : [ current_classes . pop ( i ) for i , a in enumerate ( current_classes ) if a in backgrounds ] else : try : current_classes . remove ( reset_class ) except ValueError : pass else : if _class in foregrounds : [ current_classes . pop ( i ) for i , a in enumerate ( current_classes ) if a in foregrounds ] elif _class in backgrounds : [ current_classes . pop ( i ) for i , a in enumerate ( current_classes ) if a in backgrounds ] current_classes . append ( _class ) if current_classes : outline += '<span class="%s">' % " " . join ( current_classes ) spancount += 1 outline += char if outline : results . append ( outline ) else : results . append ( None ) for whatever in xrange ( spancount ) : results [ - 1 ] += "</span>" return results def dump_html ( self ) : results = self . _spanify_screen ( ) scrollback = [ ] if self . scrollback_buf : scrollback = self . _spanify_scrollback ( ) self . init_scrollback ( ) self . modified = False return ( scrollback , results ) def dump_plain ( self ) : screen = self . screen scrollback = self . scrollback_buf self . init_scrollback ( ) self . modified = False return ( scrollback , screen ) def dump_components ( self ) : screen = [ a . tounicode ( ) for a in self . screen ] scrollback = [ ] if self . scrollback_buf : scrollback = self . _spanify_scrollback ( self . scrollback_buf , self . scrollback_renditions ) self . init_scrollback ( ) self . modified = False return ( scrollback , screen , self . renditions , self . cursorY , self . cursorX ) def dump ( self ) : out = [ ] for line in self . screen : line_out = "" for char in line : if len ( char ) > 1 : line_out += u'⬚' else : line_out += char out . append ( line_out ) self . modified = False

__version__ = '1.0' __license__ = "AGPLv3 or Proprietary (see LICENSE.txt)" __version_info__ = ( 1.0 ) __author__ = 'Dan McDougall <daniel.mcdougall@liftoffsoftware.com>' __doc__ = """\ Authentication ============== This module contains Gate One's authentication classes. They map to Gate One's --auth configuration option like so: =============== =================== --auth=none NullAuthHandler --auth=kerberos KerberosAuthHandler --auth=google GoogleAuthHandler --auth=pam PAMAuthHandler =============== =================== None or Anonymous ----------------- By default Gate One will not authenticate users. This means that user sessions will be tied to their browser cookie and users will not be able to resume their sessions from another computer/browser. Most useful for situations where session persistence and logging aren't important. *All* users will show up as ANONYMOUS using this authentication type. .. note:: The % is there to avoid name conflicts. Kerberos -------- Kerberos authentication utilizes GSSAPI for Single Sign-on (SSO) but will fall back to HTTP Basic authentication if GSSAPI auth fails. This authentication type can be integrated into any Kerberos infrastructure including Windows Active Directory. It is great for both transparent authentication and being able to tie sessions and logs to specific users within your organization (compliance). .. note:: The sso.py module itself has extensive documentation on this authentication type. Google Authentication --------------------- If you want persistent user sessions but don't care to run your own authentication infrastructure this authentication type is for you. Assuming, of course, that your Gate One server and clients will have access to the Internet. .. note:: This authentication type is perfect if you're using Chromebooks (Chrome OS devices). Docstrings ========== """ import os import logging from utils import mkdir_p , generate_session_id from utils import get_translation import tornado . web import tornado . auth import tornado . escape _ = get_translation ( ) class BaseAuthHandler ( tornado . web . RequestHandler ) : def get_current_user ( self ) : user_json = self . get_secure_cookie ( "gateone_user" ) if not user_json : return None return tornado . escape . json_decode ( user_json ) def user_login ( self , user ) : logging . debug ( "user_login(%s)" % user ) user_dir = os . path . join ( self . settings [ 'user_dir' ] , user ) if not os . path . exists ( user_dir ) : logging . info ( _ ( "Creating user directory: %s" % user_dir ) ) mkdir_p ( user_dir ) os . chmod ( user_dir , 0700 ) session_file = os . path . join ( user_dir , 'session' ) if os . path . exists ( session_file ) : session_data = open ( session_file ) . read ( ) session_info = tornado . escape . json_decode ( session_data ) else : with open ( session_file , 'w' ) as f : session_info = { : user , : generate_session_id ( ) } session_info_json = tornado . escape . json_encode ( session_info ) f . write ( session_info_json ) self . set_secure_cookie ( , tornado . escape . json_encode ( session_info ) ) def user_logout ( self , user , redirect = None ) : logging . debug ( "user_logout(%s)" % user ) url_prefix = self . settings [ 'url_prefix' ] if redirect : self . write ( redirect ) self . finish ( ) else : self . write ( url_prefix ) self . finish ( ) class NullAuthHandler ( BaseAuthHandler ) : @ tornado . web . asynchronous def get ( self ) : user = r'ANONYMOUS' check = self . get_argument ( "check" , None ) if check : self . set_header ( 'Access-Control-Allow-Origin' , '*' ) self . write ( 'authenticated' ) self . finish ( ) return logout = self . get_argument ( "logout" , None ) if logout : self . clear_cookie ( 'gateone_user' ) self . user_logout ( user ) return self . user_login ( user ) next_url = self . get_argument ( "next" , None ) if next_url : self . redirect ( next_url ) else : self . redirect ( self . settings [ 'url_prefix' ] ) def user_login ( self , user ) : logging . debug ( "user_login(%s)" % user ) user_dir = os . path . join ( self . settings [ 'user_dir' ] , user ) if not os . path . exists ( user_dir ) : logging . info ( _ ( "Creating user directory: %s" % user_dir ) ) mkdir_p ( user_dir ) os . chmod ( user_dir , 0700 ) session_info = { : user , : generate_session_id ( ) } self . set_secure_cookie ( , tornado . escape . json_encode ( session_info ) ) class GoogleAuthHandler ( BaseAuthHandler , tornado . auth . GoogleMixin ) : @ tornado . web . asynchronous def get ( self ) : check = self . get_argument ( "check" , None ) if check : self . set_header ( 'Access-Control-Allow-Origin' , '*' ) user = self . get_current_user ( ) if user : self . write ( 'authenticated' ) else : self . write ( 'unauthenticated' ) self . finish ( ) return logout_url = "https://accounts.google.com/Logout" logout = self . get_argument ( "logout" , None ) if logout : user = self . get_current_user ( ) [ 'upn' ] self . clear_cookie ( 'gateone_user' ) self . user_logout ( user , logout_url ) return if self . get_argument ( "openid.mode" , None ) : self . get_authenticated_user ( self . _on_auth ) return self . authenticate_redirect ( ax_attrs = [ "name" , "email" , "language" , "username" ] ) def _on_auth ( self , user ) : if not user : raise tornado . web . HTTPError ( 500 , _ ( "Google auth failed" ) ) self . user_login ( user [ 'email' ] ) next_url = self . get_argument ( "next" , None ) if next_url : self . redirect ( next_url ) else : self . redirect ( self . settings [ 'url_prefix' ] ) KerberosAuthHandler = None try : from sso import KerberosAuthMixin class KerberosAuthHandler ( BaseAuthHandler , KerberosAuthMixin ) : @ tornado . web . asynchronous def get ( self ) : check = self . get_argument ( "check" , None ) self . set_header ( 'Access-Control-Allow-Origin' , '*' ) if check : user = self . get_current_user ( ) if user : self . write ( 'authenticated' ) else : self . write ( 'unauthenticated' ) self . finish ( ) return logout = self . get_argument ( "logout" , None ) if logout : user = self . get_current_user ( ) [ 'upn' ] self . clear_cookie ( 'gateone_user' ) self . user_logout ( user ) return auth_header = self . request . headers . get ( 'Authorization' ) if auth_header : self . get_authenticated_user ( self . _on_auth ) return self . authenticate_redirect ( ) def _on_auth ( self , user ) : if not user : raise tornado . web . HTTPError ( 500 , _ ( "Kerberos auth failed" ) ) self . user_login ( user ) logging . debug ( _ ( "KerberosAuthHandler user: %s" % user ) ) next_url = self . get_argument ( "next" , None ) if next_url : self . redirect ( next_url ) else : self . redirect ( self . settings [ 'url_prefix' ] ) except ImportError : pass PAMAuthHandler = None try : from authpam import PAMAuthMixin class PAMAuthHandler ( BaseAuthHandler , PAMAuthMixin ) : @ tornado . web . asynchronous def get ( self ) : check = self . get_argument ( "check" , None ) self . set_header ( 'Access-Control-Allow-Origin' , '*' ) if check : user = self . get_current_user ( ) if user : self . write ( 'authenticated' ) else : self . write ( 'unauthenticated' ) self . finish ( ) return logout = self . get_argument ( "logout" , None ) if logout : user = self . get_current_user ( ) [ 'upn' ] self . clear_cookie ( 'gateone_user' ) self . user_logout ( user ) return auth_header = self . request . headers . get ( 'Authorization' ) if auth_header : self . get_authenticated_user ( self . _on_auth ) return self . authenticate_redirect ( ) def _on_auth ( self , user ) : if not user : raise tornado . web . HTTPError ( 500 , _ ( "PAM auth failed" ) ) self . user_login ( user ) logging . debug ( _ ( "PAMAuthHandler user: %s" % user ) ) next_url = self . get_argument ( "next" , None ) if next_url : self . redirect ( next_url ) else : self . redirect ( self . settings [ 'url_prefix' ] ) except ImportError : pass

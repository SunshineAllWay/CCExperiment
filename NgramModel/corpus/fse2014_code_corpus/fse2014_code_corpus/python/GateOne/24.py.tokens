import codecs import re import types import sys from constants import EOF , spaceCharacters , asciiLetters , asciiUppercase from constants import encodings , ReparseException spaceCharactersBytes = frozenset ( [ str ( item ) for item in spaceCharacters ] ) asciiLettersBytes = frozenset ( [ str ( item ) for item in asciiLetters ] ) asciiUppercaseBytes = frozenset ( [ str ( item ) for item in asciiUppercase ] ) spacesAngleBrackets = spaceCharactersBytes | frozenset ( [ ">" , "<" ] ) invalid_unicode_re = re . compile ( u"[\u0001-\u0008\u000B\u000E-\u001F\u007F-\u009F\uD800-\uDFFF\uFDD0-\uFDEF\uFFFE\uFFFF\U0001FFFE\U0001FFFF\U0002FFFE\U0002FFFF\U0003FFFE\U0003FFFF\U0004FFFE\U0004FFFF\U0005FFFE\U0005FFFF\U0006FFFE\U0006FFFF\U0007FFFE\U0007FFFF\U0008FFFE\U0008FFFF\U0009FFFE\U0009FFFF\U000AFFFE\U000AFFFF\U000BFFFE\U000BFFFF\U000CFFFE\U000CFFFF\U000DFFFE\U000DFFFF\U000EFFFE\U000EFFFF\U000FFFFE\U000FFFFF\U0010FFFE\U0010FFFF]" ) non_bmp_invalid_codepoints = set ( [ 0x1FFFE , 0x1FFFF , 0x2FFFE , 0x2FFFF , 0x3FFFE , 0x3FFFF , 0x4FFFE , 0x4FFFF , 0x5FFFE , 0x5FFFF , 0x6FFFE , 0x6FFFF , 0x7FFFE , 0x7FFFF , 0x8FFFE , 0x8FFFF , 0x9FFFE , 0x9FFFF , 0xAFFFE , 0xAFFFF , 0xBFFFE , 0xBFFFF , 0xCFFFE , 0xCFFFF , 0xDFFFE , 0xDFFFF , 0xEFFFE , 0xEFFFF , 0xFFFFE , 0xFFFFF , 0x10FFFE , 0x10FFFF ] ) ascii_punctuation_re = re . compile ( ur"[\u0009-\u000D\u0020-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E]" ) charsUntilRegEx = { } class BufferedStream : def __init__ ( self , stream ) : self . stream = stream self . buffer = [ ] self . position = [ - 1 , 0 ] def tell ( self ) : pos = 0 for chunk in self . buffer [ : self . position [ 0 ] ] : pos += len ( chunk ) pos += self . position [ 1 ] return pos def seek ( self , pos ) : assert pos < self . _bufferedBytes ( ) offset = pos i = 0 while len ( self . buffer [ i ] ) < offset : offset -= pos i += 1 self . position = [ i , offset ] def read ( self , bytes ) : if not self . buffer : return self . _readStream ( bytes ) elif ( self . position [ 0 ] == len ( self . buffer ) and self . position [ 1 ] == len ( self . buffer [ - 1 ] ) ) : return self . _readStream ( bytes ) else : return self . _readFromBuffer ( bytes ) def _bufferedBytes ( self ) : return sum ( [ len ( item ) for item in self . buffer ] ) def _readStream ( self , bytes ) : data = self . stream . read ( bytes ) self . buffer . append ( data ) self . position [ 0 ] += 1 self . position [ 1 ] = len ( data ) return data def _readFromBuffer ( self , bytes ) : remainingBytes = bytes rv = [ ] bufferIndex = self . position [ 0 ] bufferOffset = self . position [ 1 ] while bufferIndex < len ( self . buffer ) and remainingBytes != 0 : assert remainingBytes > 0 bufferedData = self . buffer [ bufferIndex ] if remainingBytes <= len ( bufferedData ) - bufferOffset : bytesToRead = remainingBytes self . position = [ bufferIndex , bufferOffset + bytesToRead ] else : bytesToRead = len ( bufferedData ) - bufferOffset self . position = [ bufferIndex , len ( bufferedData ) ] bufferIndex += 1 data = rv . append ( bufferedData [ bufferOffset : bufferOffset + bytesToRead ] ) remainingBytes -= bytesToRead bufferOffset = 0 if remainingBytes : rv . append ( self . _readStream ( remainingBytes ) ) return "" . join ( rv ) class HTMLInputStream : _defaultChunkSize = 10240 def __init__ ( self , source , encoding = None , parseMeta = True , chardet = True ) : if len ( u"\U0010FFFF" ) == 1 : self . reportCharacterErrors = self . characterErrorsUCS4 else : self . reportCharacterErrors = self . characterErrorsUCS2 self . newLines = [ 0 ] self . charEncoding = ( codecName ( encoding ) , "certain" ) self . rawStream = self . openStream ( source ) self . numBytesMeta = 512 self . numBytesChardet = 100 self . defaultEncoding = "windows-1252" if ( self . charEncoding [ 0 ] is None ) : self . charEncoding = self . detectEncoding ( parseMeta , chardet ) self . reset ( ) def reset ( self ) : self . dataStream = codecs . getreader ( self . charEncoding [ 0 ] ) ( self . rawStream , ) self . chunk = u"" self . chunkSize = 0 self . chunkOffset = 0 self . errors = [ ] self . prevNumLines = 0 self . prevNumCols = 0 self . _lastChunkEndsWithCR = False def openStream ( self , source ) : if hasattr ( source , 'read' ) : stream = source else : if isinstance ( source , unicode ) : source = source . encode ( 'utf-8' ) self . charEncoding = ( "utf-8" , "certain" ) import cStringIO stream = cStringIO . StringIO ( str ( source ) ) if ( not ( hasattr ( stream , "tell" ) and hasattr ( stream , "seek" ) ) or stream is sys . stdin ) : stream = BufferedStream ( stream ) return stream def detectEncoding ( self , parseMeta = True , chardet = True ) : encoding = self . detectBOM ( ) confidence = "certain" if encoding is None and parseMeta : encoding = self . detectEncodingMeta ( ) confidence = "tentative" if encoding is None and chardet : confidence = "tentative" try : from chardet . universaldetector import UniversalDetector buffers = [ ] detector = UniversalDetector ( ) while not detector . done : buffer = self . rawStream . read ( self . numBytesChardet ) if not buffer : break buffers . append ( buffer ) detector . feed ( buffer ) detector . close ( ) encoding = detector . result [ 'encoding' ] self . rawStream . seek ( 0 ) except ImportError : pass if encoding is None : confidence = "tentative" encoding = self . defaultEncoding encodingSub = { "iso-8859-1" : "windows-1252" } if encoding . lower ( ) in encodingSub : encoding = encodingSub [ encoding . lower ( ) ] return encoding , confidence def changeEncoding ( self , newEncoding ) : newEncoding = codecName ( newEncoding ) if newEncoding in ( "utf-16" , "utf-16-be" , "utf-16-le" ) : newEncoding = "utf-8" if newEncoding is None : return elif newEncoding == self . charEncoding [ 0 ] : self . charEncoding = ( self . charEncoding [ 0 ] , "certain" ) else : self . rawStream . seek ( 0 ) self . reset ( ) self . charEncoding = ( newEncoding , "certain" ) raise ReparseException , "Encoding changed from %s to %s" % ( self . charEncoding [ 0 ] , newEncoding ) def detectBOM ( self ) : bomDict = { codecs . BOM_UTF8 : 'utf-8' , codecs . BOM_UTF16_LE : 'utf-16-le' , codecs . BOM_UTF16_BE : 'utf-16-be' , codecs . BOM_UTF32_LE : 'utf-32-le' , codecs . BOM_UTF32_BE : 'utf-32-be' } string = self . rawStream . read ( 4 ) encoding = bomDict . get ( string [ : 3 ] ) seek = 3 if not encoding : encoding = bomDict . get ( string ) seek = 4 if not encoding : encoding = bomDict . get ( string [ : 2 ] ) seek = 2 self . rawStream . seek ( encoding and seek or 0 ) return encoding def detectEncodingMeta ( self ) : buffer = self . rawStream . read ( self . numBytesMeta ) parser = EncodingParser ( buffer ) self . rawStream . seek ( 0 ) encoding = parser . getEncoding ( ) if encoding in ( "utf-16" , "utf-16-be" , "utf-16-le" ) : encoding = "utf-8" return encoding def _position ( self , offset ) : chunk = self . chunk nLines = chunk . count ( u'\n' , 0 , offset ) positionLine = self . prevNumLines + nLines lastLinePos = chunk . rfind ( u'\n' , 0 , offset ) if lastLinePos == - 1 : positionColumn = self . prevNumCols + offset else : positionColumn = offset - ( lastLinePos + 1 ) return ( positionLine , positionColumn ) def position ( self ) : line , col = self . _position ( self . chunkOffset ) return ( line + 1 , col ) def char ( self ) : if self . chunkOffset >= self . chunkSize : if not self . readChunk ( ) : return EOF chunkOffset = self . chunkOffset char = self . chunk [ chunkOffset ] self . chunkOffset = chunkOffset + 1 return char def readChunk ( self , chunkSize = None ) : if chunkSize is None : chunkSize = self . _defaultChunkSize self . prevNumLines , self . prevNumCols = self . _position ( self . chunkSize ) self . chunk = u"" self . chunkSize = 0 self . chunkOffset = 0 data = self . dataStream . read ( chunkSize ) if not data : return False self . reportCharacterErrors ( data ) data = data . replace ( u"\u0000" , u"\ufffd" ) if ( self . _lastChunkEndsWithCR and data [ 0 ] == u"\n" ) : data = data [ 1 : ] if not data : return False self . _lastChunkEndsWithCR = data [ - 1 ] == u"\r" data = data . replace ( u"\r\n" , u"\n" ) data = data . replace ( u"\r" , u"\n" ) self . chunk = data self . chunkSize = len ( data ) return True def characterErrorsUCS4 ( self , data ) : for i in xrange ( data . count ( u"\u0000" ) ) : self . errors . append ( "null-character" ) for i in xrange ( len ( invalid_unicode_re . findall ( data ) ) ) : self . errors . append ( "invalid-codepoint" ) def characterErrorsUCS2 ( self , data ) : for i in xrange ( data . count ( u"\u0000" ) ) : self . errors . append ( "null-character" ) skip = False import sys for match in invalid_unicode_re . finditer ( data ) : if skip : continue codepoint = ord ( match . group ( ) ) pos = match . start ( ) if ( codepoint >= 0xD800 and codepoint <= 0xDBFF and pos < len ( data ) - 1 and ord ( data [ pos + 1 ] ) >= 0xDC00 and ord ( data [ pos + 1 ] ) <= 0xDFFF ) : char_val = ( 0x10000 + ( codepoint - 0xD800 ) * 0x400 + ( ord ( data [ pos + 1 ] ) - 0xDC00 ) ) if char_val in non_bmp_invalid_codepoints : self . errors . append ( "invalid-codepoint" ) skip = True elif ( codepoint >= 0xD800 and codepoint <= 0xDFFF and pos == len ( data ) - 1 ) : self . errors . append ( "invalid-codepoint" ) else : skip = False self . errors . append ( "invalid-codepoint" ) def charsUntil ( self , characters , opposite = False ) : try : chars = charsUntilRegEx [ ( characters , opposite ) ] except KeyError : if __debug__ : for c in characters : assert ( ord ( c ) < 128 ) regex = u"" . join ( [ u"\\x%02x" % ord ( c ) for c in characters ] ) if not opposite : regex = u"^%s" % regex chars = charsUntilRegEx [ ( characters , opposite ) ] = re . compile ( u"[%s]+" % regex ) rv = [ ] while True : m = chars . match ( self . chunk , self . chunkOffset ) if m is None : if self . chunkOffset != self . chunkSize : break else : end = m . end ( ) if end != self . chunkSize : rv . append ( self . chunk [ self . chunkOffset : end ] ) self . chunkOffset = end break rv . append ( self . chunk [ self . chunkOffset : ] ) if not self . readChunk ( ) : break r = u"" . join ( rv ) return r def charsUntilEOF ( self ) : rv = [ ] while True : rv . append ( self . chunk [ self . chunkOffset : ] ) if not self . readChunk ( ) : break r = u"" . join ( rv ) return r def unget ( self , char ) : if char is not None : if self . chunkOffset == 0 : self . chunk = char + self . chunk self . chunkSize += 1 else : self . chunkOffset -= 1 assert self . chunk [ self . chunkOffset ] == char class EncodingBytes ( str ) : def __new__ ( self , value ) : return str . __new__ ( self , value . lower ( ) ) def __init__ ( self , value ) : self . _position = - 1 def __iter__ ( self ) : return self def next ( self ) : p = self . _position = self . _position + 1 if p >= len ( self ) : raise StopIteration elif p < 0 : raise TypeError return self [ p ] def previous ( self ) : p = self . _position if p >= len ( self ) : raise StopIteration elif p < 0 : raise TypeError self . _position = p = p - 1 return self [ p ] def setPosition ( self , position ) : if self . _position >= len ( self ) : raise StopIteration self . _position = position def getPosition ( self ) : if self . _position >= len ( self ) : raise StopIteration if self . _position >= 0 : return self . _position else : return None position = property ( getPosition , setPosition ) def getCurrentByte ( self ) : return self [ self . position ] currentByte = property ( getCurrentByte ) def skip ( self , chars = spaceCharactersBytes ) : p = self . position while p < len ( self ) : c = self [ p ] if c not in chars : self . _position = p return c p += 1 self . _position = p return None def skipUntil ( self , chars ) : p = self . position while p < len ( self ) : c = self [ p ] if c in chars : self . _position = p return c p += 1 self . _position = p return None def matchBytes ( self , bytes ) : p = self . position data = self [ p : p + len ( bytes ) ] rv = data . startswith ( bytes ) if rv : self . position += len ( bytes ) return rv def jumpTo ( self , bytes ) : newPosition = self [ self . position : ] . find ( bytes ) if newPosition > - 1 : if self . _position == - 1 : self . _position = 0 self . _position += ( newPosition + len ( bytes ) - 1 ) return True else : raise StopIteration class EncodingParser ( object ) : def __init__ ( self , data ) : self . data = EncodingBytes ( data ) self . encoding = None def getEncoding ( self ) : methodDispatch = ( ( "<!--" , self . handleComment ) , ( "<meta" , self . handleMeta ) , ( "</" , self . handlePossibleEndTag ) , ( "<!" , self . handleOther ) , ( "<?" , self . handleOther ) , ( "<" , self . handlePossibleStartTag ) ) for byte in self . data : keepParsing = True for key , method in methodDispatch : if self . data . matchBytes ( key ) : try : keepParsing = method ( ) break except StopIteration : keepParsing = False break if not keepParsing : break return self . encoding def handleComment ( self ) : return self . data . jumpTo ( "-->" ) def handleMeta ( self ) : if self . data . currentByte not in spaceCharactersBytes : return True while True : attr = self . getAttribute ( ) if attr is None : return True else : if attr [ 0 ] == "charset" : tentativeEncoding = attr [ 1 ] codec = codecName ( tentativeEncoding ) if codec is not None : self . encoding = codec return False elif attr [ 0 ] == "content" : contentParser = ContentAttrParser ( EncodingBytes ( attr [ 1 ] ) ) tentativeEncoding = contentParser . parse ( ) codec = codecName ( tentativeEncoding ) if codec is not None : self . encoding = codec return False def handlePossibleStartTag ( self ) : return self . handlePossibleTag ( False ) def handlePossibleEndTag ( self ) : self . data . next ( ) return self . handlePossibleTag ( True ) def handlePossibleTag ( self , endTag ) : data = self . data if data . currentByte not in asciiLettersBytes : if endTag : data . previous ( ) self . handleOther ( ) return True c = data . skipUntil ( spacesAngleBrackets ) if c == "<" : data . previous ( ) else : attr = self . getAttribute ( ) while attr is not None : attr = self . getAttribute ( ) return True def handleOther ( self ) : return self . data . jumpTo ( ">" ) def getAttribute ( self ) : data = self . data c = data . skip ( spaceCharactersBytes | frozenset ( "/" ) ) if c in ( ">" , None ) : return None attrName = [ ] attrValue = [ ] while True : if c == "=" and attrName : break elif c in spaceCharactersBytes : c = data . skip ( ) c = data . next ( ) break elif c in ( "/" , ">" ) : return "" . join ( attrName ) , "" elif c in asciiUppercaseBytes : attrName . append ( c . lower ( ) ) elif c == None : return None else : attrName . append ( c ) c = data . next ( ) if c != "=" : data . previous ( ) return "" . join ( attrName ) , "" data . next ( ) c = data . skip ( ) if c in ( "'" , '"' ) : quoteChar = c while True : c = data . next ( ) if c == quoteChar : data . next ( ) return "" . join ( attrName ) , "" . join ( attrValue ) elif c in asciiUppercaseBytes : attrValue . append ( c . lower ( ) ) else : attrValue . append ( c ) elif c == ">" : return "" . join ( attrName ) , "" elif c in asciiUppercaseBytes : attrValue . append ( c . lower ( ) ) elif c is None : return None else : attrValue . append ( c ) while True : c = data . next ( ) if c in spacesAngleBrackets : return "" . join ( attrName ) , "" . join ( attrValue ) elif c in asciiUppercaseBytes : attrValue . append ( c . lower ( ) ) elif c is None : return None else : attrValue . append ( c ) class ContentAttrParser ( object ) : def __init__ ( self , data ) : self . data = data def parse ( self ) : try : self . data . jumpTo ( "charset" ) self . data . position += 1 self . data . skip ( ) if not self . data . currentByte == "=" : return None self . data . position += 1 self . data . skip ( ) if self . data . currentByte in ( '"' , "'" ) : quoteMark = self . data . currentByte self . data . position += 1 oldPosition = self . data . position if self . data . jumpTo ( quoteMark ) : return self . data [ oldPosition : self . data . position ] else : return None else : oldPosition = self . data . position try : self . data . skipUntil ( spaceCharactersBytes ) return self . data [ oldPosition : self . data . position ] except StopIteration : return self . data [ oldPosition : ] except StopIteration : return None def codecName ( encoding ) : if ( encoding is not None and type ( encoding ) in types . StringTypes ) : canonicalName = ascii_punctuation_re . sub ( "" , encoding ) . lower ( ) return encodings . get ( canonicalName , None ) else : return None

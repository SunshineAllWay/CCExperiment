__doc__ = """\ ssh.py - A plugin for Gate One that adds additional SSH-specific features. """ __version__ = '1.0rc1' __license__ = "GNU AGPLv3 or Proprietary (see LICENSE.txt)" __version_info__ = ( 1 , 0 ) __author__ = 'Dan McDougall <daniel.mcdougall@liftoffsoftware.com>' import os , sys , logging , re , time , threading from datetime import datetime , timedelta from functools import partial from gateone import BaseHandler from utils import get_translation , mkdir_p , shell_command , which , json_encode from utils import noop _ = get_translation ( ) import tornado . web OPENSSH_VERSION = None DROPBEAR_VERSION = None OPEN_SUBCHANNELS = { } SUBCHANNEL_TIMEOUT = timedelta ( minutes = 5 ) READY_STRING = "GATEONE_SSH_EXEC_CMD_CHANNEL_READY" READY_MATCH = re . compile ( "^%s$" % READY_STRING , re . MULTILINE ) class SSHMultiplexingException ( Exception ) : pass class SSHExecutionException ( Exception ) : pass class SSHKeygenException ( Exception ) : pass class SSHKeypairException ( Exception ) : pass def get_ssh_dir ( tws ) : user = tws . get_current_user ( ) [ 'upn' ] users_dir = os . path . join ( tws . settings [ 'user_dir' ] , user ) users_ssh_dir = os . path . join ( users_dir , 'ssh' ) return users_ssh_dir def open_sub_channel ( term , tws ) : logging . debug ( "open_sub_channel() term: %s" % term ) global OPEN_SUBCHANNELS if term in OPEN_SUBCHANNELS and OPEN_SUBCHANNELS [ term ] . isalive ( ) : return OPEN_SUBCHANNELS [ term ] session = tws . session session_dir = tws . settings [ 'session_dir' ] session_path = os . path . join ( session_dir , session ) socket_path = None for f in os . listdir ( session_path ) : if f . startswith ( 'ssh:%s:' % term ) : for line in open ( os . path . join ( session_path , f ) ) : if line . startswith ( 'SSH_SOCKET' ) : socket_path = line . split ( '=' ) [ 1 ] . strip ( ) if not socket_path : raise SSHMultiplexingException ( _ ( ) ) users_ssh_dir = get_ssh_dir ( tws ) ssh_config_path = os . path . join ( users_ssh_dir , 'config' ) if not os . path . exists ( ssh_config_path ) : with open ( ssh_config_path , 'w' ) as f : f . write ( '\n' ) ssh = which ( 'ssh' ) ssh_command = '%s -x -S%s -F%s go_ssh_remote_cmd' % ( ssh , socket_path , ssh_config_path ) OPEN_SUBCHANNELS [ term ] = m = tws . new_multiplex ( ssh_command , "%s (sub)" % term ) fd = m . spawn ( rows = 100 , cols = 200 ) m . writeline ( u'\x1b]0;Term %s sub-channel\007' % term ) return m def wait_for_prompt ( term , cmd , errorback , callback , m_instance , matched ) : logging . debug ( 'wait_for_prompt()' ) m_instance . term . clear_screen ( ) getoutput = partial ( get_cmd_output , term , errorback , callback ) m_instance . expect ( READY_MATCH , getoutput , errorback = errorback , timeout = 10 ) m_instance . writeline ( u'%s; echo "%s"' % ( cmd , READY_STRING ) ) def get_cmd_output ( term , errorback , callback , m_instance , matched ) : logging . debug ( 'get_cmd_output()' ) cmd_out = [ a . rstrip ( ) for a in m_instance . dump ( ) if a . rstrip ( ) ] capture = False out = [ ] for line in cmd_out : if capture : if READY_STRING in line : break out . append ( line ) elif READY_STRING in line : capture = True m_instance . unexpect ( ) m_instance . expect ( , noop , errorback = timeout_sub_channel , timeout = SUBCHANNEL_TIMEOUT ) cmd_out = "\n" . join ( out ) if callback : callback ( cmd_out , None ) def terminate_sub_channel ( m_instance ) : global OPEN_SUBCHANNELS m_instance . terminate ( ) for key , value in OPEN_SUBCHANNELS . items ( ) : if hash ( value ) == hash ( m_instance ) : del OPEN_SUBCHANNELS [ key ] def timeout_sub_channel ( m_instance ) : logging . debug ( _ ( % repr ( m_instance . term_id ) ) ) terminate_sub_channel ( m_instance ) def got_error ( m_instance , match = None , cmd = None , tws = None ) : logging . error ( _ ( % ( m_instance . user , m_instance . cmd ) ) ) terminate_sub_channel ( m_instance ) if tws : message = { : { : cmd , : None , : 'Error: Timeout exceeded.' } } tws . write_message ( message ) def execute_command ( term , cmd , callback = None , tws = None ) : logging . debug ( % ( term , cmd ) ) m = open_sub_channel ( term , tws ) m . unexpect ( ) m . term . clear_screen ( ) errorback = partial ( got_error , cmd = cmd , tws = tws ) wait = partial ( wait_for_prompt , term , cmd , errorback , callback ) m . expect ( READY_MATCH , callback = wait , errorback = errorback , timeout = 10 ) m . writeline ( u'echo "%s"' % READY_STRING ) def send_result ( tws , cmd , output , m_instance ) : message = { : { : cmd , : output , : 'Success' } } tws . write_message ( message ) def ws_exec_command ( settings , tws ) : term = settings [ 'term' ] cmd = settings [ 'cmd' ] send = partial ( send_result , tws , cmd ) try : execute_command ( term , cmd , send , tws = tws ) except SSHExecutionException as e : message = { : { : cmd , : None , : 'Error: %s' % e } } tws . write_message ( message ) class KnownHostsHandler ( BaseHandler ) : @ tornado . web . authenticated def get ( self ) : get_kh = self . get_argument ( 'known_hosts' , None ) if get_kh : self . _return_known_hosts ( ) @ tornado . web . authenticated def post ( self ) : known_hosts = self . get_argument ( 'known_hosts' , None ) if known_hosts : kh = self . request . body self . _save_known_hosts ( kh ) def _return_known_hosts ( self ) : user = self . get_current_user ( ) [ 'upn' ] logging . debug ( "known_hosts requested by %s" % user ) users_dir = os . path . join ( self . settings [ 'user_dir' ] , user ) users_ssh_dir = os . path . join ( users_dir , 'ssh' ) kh_path = os . path . join ( users_ssh_dir , 'known_hosts' ) known_hosts = "" if os . path . exists ( kh_path ) : known_hosts = open ( kh_path ) . read ( ) self . set_header ( 'Content-Type' , 'text/plain' ) self . write ( known_hosts ) def _save_known_hosts ( self , known_hosts ) : user = self . get_current_user ( ) [ 'upn' ] users_dir = os . path . join ( self . settings [ 'user_dir' ] , user ) users_ssh_dir = os . path . join ( users_dir , 'ssh' ) kh_path = os . path . join ( users_ssh_dir , 'known_hosts' ) f = open ( kh_path , 'w' ) f . write ( known_hosts ) f . close ( ) self . write ( "success" ) def get_connect_string ( term , tws ) : logging . debug ( "get_connect_string() term: %s" % term ) session = tws . session session_dir = tws . settings [ 'session_dir' ] for f in os . listdir ( os . path . join ( session_dir , session ) ) : if f . startswith ( 'ssh:' ) : terminal , a_colon , connect_string = f [ 4 : ] . partition ( ':' ) terminal = int ( terminal ) if terminal == term : message = { : json_encode ( { term : connect_string } ) } tws . write_message ( message ) return def get_key ( name , public , tws ) : if not isinstance ( name , ( str , unicode ) ) : error_msg = _ ( % repr ( name ) ) message = { 'save_file' : { 'result' : error_msg } } tws . write_message ( message ) return out_dict if public and not name . endswith ( '.pub' ) : name += '.pub' out_dict = { : None , : name , : None , : 'text/plain' } users_ssh_dir = get_ssh_dir ( tws ) key_path = os . path . join ( users_ssh_dir , name ) if os . path . exists ( key_path ) : with open ( key_path ) as f : out_dict [ 'data' ] = f . read ( ) out_dict [ 'result' ] = 'Success' else : out_dict [ 'result' ] = _ ( % key_path ) message = { 'save_file' : out_dict } tws . write_message ( message ) return out_dict def get_public_key ( name , tws ) : get_key ( name , True , tws ) def get_private_key ( name , tws ) : get_key ( name , False , tws ) def get_host_fingerprint ( settings , tws ) : if 'port' not in settings : port = 22 else : port = settings [ 'port' ] if 'host' not in settings : out_dict [ 'result' ] = _ ( "Error: You must supply a 'host'." ) message = { 'sshjs_display_fingerprint' : out_dict } tws . write_message ( message ) else : host = settings [ 'host' ] logging . debug ( "get_host_fingerprint(%s:%s)" % ( host , port ) ) out_dict = { : 'Success' , : host , : None } ssh = which ( 'ssh' ) m = tws . new_multiplex ( % ( ssh , port , host ) , , logging = False ) def grab_fingerprint ( m_instance , match ) : out_dict [ 'fingerprint' ] = match . split ( ) [ - 1 ] [ : - 1 ] m_instance . terminate ( ) message = { 'sshjs_display_fingerprint' : out_dict } tws . write_message ( message ) del m_instance def errorback ( m_instance ) : leftovers = [ a . rstrip ( ) for a in m_instance . dump ( ) if a . strip ( ) ] out_dict [ 'result' ] = _ ( % ( host , port , "\n" . join ( leftovers ) ) ) m_instance . terminate ( ) message = { 'sshjs_display_fingerprint' : out_dict } tws . write_message ( message ) del m_instance m . expect ( '.+fingerprint .+$' , grab_fingerprint , errorback = errorback ) m . spawn ( ) def generate_new_keypair ( settings , tws ) : logging . debug ( 'generate_new_keypair()' ) out_dict = { } users_ssh_dir = get_ssh_dir ( tws ) name = 'id_ecdsa' keytype = None bits = None passphrase = '' comment = '' if 'name' in settings : name = settings [ 'name' ] if 'keytype' in settings : keytype = settings [ 'keytype' ] if 'bits' in settings : bits = settings [ 'bits' ] if 'passphrase' in settings : passphrase = settings [ 'passphrase' ] if 'comment' in settings : comment = settings [ 'comment' ] if which ( 'ssh-keygen' ) : openssh_generate_new_keypair ( name , users_ssh_dir , keytype = keytype , passphrase = passphrase , bits = bits , comment = comment , tws = tws ) elif which ( 'dropbearkey' ) : dropbear_generate_new_keypair ( * args , ** kwargs ) def errorback ( tws , m_instance ) : logging . debug ( "keygen errorback()" ) print ( m_instance . dump ( ) ) m_instance . terminate ( ) message = { : { : _ ( "There was a problem generating SSH keys: %s" % m_instance . dump ( ) ) , } } tws . write_message ( message ) def overwrite ( m_instance , match ) : logging . debug ( 'overwrite()' ) m_instance . writeline ( 'y' ) def enter_passphrase ( passphrase , m_instance , match ) : logging . debug ( "entering passphrase..." ) m_instance . writeline ( '%s' % passphrase ) def finished ( tws , m_instance , fingerprint ) : logging . debug ( "keygen finished. fingerprint: %s" % fingerprint ) message = { : { : 'Success' , : fingerprint } } m_instance . terminate ( ) tws . write_message ( message ) def openssh_generate_new_keypair ( name , path , keytype = None , passphrase = "" , bits = None , comment = "" , tws = None ) : logging . debug ( 'openssh_generate_new_keypair()' ) openssh_version = shell_command ( 'ssh -V' ) [ 1 ] ssh_major_version = int ( openssh_version . split ( ) [ 0 ] . split ( '_' ) [ 1 ] . split ( '.' ) [ 0 ] ) key_path = os . path . join ( path , name ) ssh_minor_version = int ( openssh_version . split ( ) [ 0 ] . split ( '_' ) [ 1 ] . split ( '.' ) [ 1 ] [ 0 ] ) ssh_version = "%s.%s" % ( ssh_major_version , ssh_minor_version ) ssh_version = float ( ssh_version ) if not keytype : if ssh_version >= 5.7 : keytype = "ecdsa" else : keytype = "rsa" else : keytype = keytype . lower ( ) if not bits and keytype == "ecdsa" : bits = 521 elif not bits and keytype == "rsa" : bits = 2048 if not passphrase : passphrase = '' hostname = os . uname ( ) [ 1 ] if not comment : now = datetime . now ( ) . isoformat ( ) comment = "Generated by Gate One on %s %s" % ( hostname , now ) ssh_keygen_path = which ( 'ssh-keygen' ) command = ( % ( ssh_keygen_path , bits , keytype , comment , key_path ) ) m = tws . new_multiplex ( command , "gen_ssh_keypair" ) call_errorback = partial ( errorback , tws ) m . expect ( '^Overwrite.*' , overwrite , optional = True , timeout = 10 ) passphrase_handler = partial ( enter_passphrase , passphrase ) m . expect ( '^Enter passphrase' , passphrase_handler , errorback = call_errorback , timeout = 10 ) m . expect ( '^Enter same passphrase again' , passphrase_handler , errorback = call_errorback , timeout = 10 ) finalize = partial ( finished , tws ) m . expect ( , finalize , errorback = call_errorback , timeout = 15 ) m . spawn ( ) def store_id_file ( settings , tws = None ) : logging . debug ( 'store_id_file()' ) out_dict = { 'result' : 'Success' } name , private , public , certificate = None , None , None , None try : if 'name' in settings : name = settings [ 'name' ] else : raise SSHKeypairException ( _ ( "You must specify a valid *name*." ) ) if 'private' in settings : private = settings [ 'private' ] if 'public' in settings : public = settings [ 'public' ] if 'certificate' in settings : certificate = settings [ 'certificate' ] if not private and not public and not certificate : raise SSHKeypairException ( _ ( "No files were given to save!" ) ) users_ssh_dir = get_ssh_dir ( tws ) private_key_path = os . path . join ( users_ssh_dir , name ) public_key_path = os . path . join ( users_ssh_dir , name + '.pub' ) certificate_path = os . path . join ( users_ssh_dir , name + '-cert.pub' ) if private : with open ( private_key_path , 'w' ) as f : f . write ( private ) os . chmod ( private_key_path , 0600 ) if public : with open ( public_key_path , 'w' ) as f : f . write ( public ) if certificate : with open ( certificate_path , 'w' ) as f : f . write ( certificate ) except Exception as e : out_dict [ 'result' ] = _ ( "Error saving keys: %s" % e ) message = { : out_dict } tws . write_message ( message ) def delete_identity ( name , tws ) : logging . debug ( 'delete_identity()' ) out_dict = { 'result' : 'Success' } users_ssh_dir = get_ssh_dir ( tws ) private_key_path = os . path . join ( users_ssh_dir , name ) public_key_path = os . path . join ( users_ssh_dir , name + '.pub' ) certificate_path = os . path . join ( users_ssh_dir , name + '-cert.pub' ) try : if os . path . exists ( private_key_path ) : os . remove ( private_key_path ) if os . path . exists ( public_key_path ) : os . remove ( public_key_path ) if os . path . exists ( certificate_path ) : os . remove ( certificate_path ) except Exception as e : out_dict [ 'result' ] = _ ( "Error deleting keypair: %s" % e ) message = { : out_dict } tws . write_message ( message ) def get_identities ( anything , tws ) : logging . debug ( 'get_identities()' ) out_dict = { 'result' : 'Success' } users_ssh_dir = get_ssh_dir ( tws ) out_dict [ 'identities' ] = [ ] ssh_keygen_path = which ( 'ssh-keygen' ) keytype_re = re . compile ( '.*\(([A-Z]+)\)$' , re . MULTILINE ) try : if os . path . exists ( users_ssh_dir ) : ssh_files = os . listdir ( users_ssh_dir ) for f in ssh_files : if f . endswith ( '.pub' ) : identity = f [ : - 4 ] if identity in ssh_files : id_path = os . path . join ( users_ssh_dir , identity ) pub_key_path = os . path . join ( users_ssh_dir , f ) public_key_contents = open ( pub_key_path ) . read ( ) comment = ' ' . join ( public_key_contents . split ( ' ' ) [ 2 : ] ) keygen_cmd = "%s -vlf %s" % ( ssh_keygen_path , id_path ) retcode , key_info = shell_command ( keygen_cmd ) try : keytype = keytype_re . search ( key_info ) . group ( 1 ) except AttributeError : out_dict = { : _ ( ) } randomart = '\n' . join ( key_info . splitlines ( ) [ 1 : ] ) bits = key_info . split ( ) [ 0 ] fingerprint = key_info . split ( ) [ 1 ] retcode , bubblebabble = shell_command ( % ( ssh_keygen_path , id_path ) ) bubblebabble = bubblebabble . split ( ) [ 1 ] certinfo = '' cert_path = "%s-cert.pub" % id_path if os . path . exists ( cert_path ) : retcode , certinfo = shell_command ( % ( ssh_keygen_path , cert_path ) ) certinfo = ' ' . join ( certinfo . split ( ' ' ) [ 1 : ] ) fixed_certinfo = '' for i , line in enumerate ( certinfo . splitlines ( ) ) : if i == 0 : line = line . lstrip ( ) fixed_certinfo += line . replace ( ' ' , ' ' ) fixed_certinfo += '\n' id_obj = { : identity , : public_key_contents , : keytype , : bubblebabble , : fingerprint , : randomart , : fixed_certinfo , : bits , : comment . rstrip ( ) , } out_dict [ 'identities' ] . append ( id_obj ) default_ids = [ ] default_ids_exists = False users_ssh_dir = get_ssh_dir ( tws ) default_ids_path = os . path . join ( users_ssh_dir , '.default_ids' ) if os . path . exists ( default_ids_path ) : default_ids_exists = True with open ( default_ids_path ) as f : default_ids = f . read ( ) . splitlines ( ) default_ids = [ os . path . split ( a ) [ 1 ] for a in default_ids ] if default_ids_exists : for i , id_obj in enumerate ( out_dict [ 'identities' ] ) : if id_obj [ 'name' ] in default_ids : out_dict [ 'identities' ] [ i ] [ 'default' ] = True else : out_dict [ 'identities' ] [ i ] [ 'default' ] = False except Exception as e : out_dict [ 'result' ] = _ ( "Error getting identities: %s" % e ) message = { : out_dict } tws . write_message ( message ) def set_default_identities ( identities , tws ) : if isinstance ( identities , list ) : users_ssh_dir = get_ssh_dir ( tws ) default_ids_path = os . path . join ( users_ssh_dir , '.default_ids' ) with open ( default_ids_path , 'w' ) as f : f . write ( '\n' . join ( identities ) + '\n' ) def opt_esc_handler ( text , tws ) : message = { 'sshjs_connect' : text } tws . write_message ( message ) def create_user_ssh_dir ( current_user , settings ) : user = current_user [ 'upn' ] users_dir = os . path . join ( settings [ 'user_dir' ] , user ) ssh_dir = os . path . join ( users_dir , 'ssh' ) try : mkdir_p ( ssh_dir ) except OSError as e : logging . error ( _ ( "Error creating user's ssh directory: %s\n" % e ) ) hooks = { : [ ( r"/ssh" , KnownHostsHandler ) ] , : { : get_connect_string , : ws_exec_command , : get_identities , : get_public_key , : get_private_key , : get_host_fingerprint , : generate_new_keypair , : store_id_file , : delete_identity , : set_default_identities } , : opt_esc_handler , : create_user_ssh_dir }

__doc__ = """\ bookmarks.py - A plugin for Gate One that adds fancy bookmarking capabilities. """ __version__ = '1.0rc1' __license__ = "GNU AGPLv3 or Proprietary (see LICENSE.txt)" __version_info__ = ( 1 , 0 ) __author__ = 'Dan McDougall <daniel.mcdougall@liftoffsoftware.com>' import os , sys , re , logging , time from functools import partial try : from urlparse import urlparse except ImportError : from urllib import parse as urlparse from gateone import BaseHandler from utils import get_translation , mkdir_p , noop , json_encode _ = get_translation ( ) import tornado . web from tornado . escape import json_decode plugin_path = os . path . split ( __file__ ) [ 0 ] sys . path . append ( os . path . join ( plugin_path , "dependencies" ) ) import html5lib from html5lib import treebuilders , treewalkers from htmlentitydefs import name2codepoint name2codepoint [ '#39' ] = 39 boolean_fix = { True : True , False : False , : True , : False , : True , : False } def unescape ( s ) : return re . sub ( '&(%s);' % '|' . join ( name2codepoint ) , lambda m : unichr ( name2codepoint [ m . group ( 1 ) ] ) , s ) def parse_bookmarks_html ( html ) : out_list = [ ] p = html5lib . HTMLParser ( tree = treebuilders . getTreeBuilder ( "dom" ) ) dom_tree = p . parse ( html ) walker = treewalkers . getTreeWalker ( "dom" ) stream = walker ( dom_tree ) level = 0 tags = [ ] h3on = False aon = False ddon = False add_date = None url = None icon = None name = "" notes = "" for token in stream : if 'name' in token : if token [ 'name' ] == 'dl' : if token [ 'type' ] == 'StartTag' : level += 1 elif token [ 'type' ] == 'EndTag' : if tags : tags . pop ( ) level -= 1 if token [ 'name' ] == 'dd' : if token [ 'type' ] == 'StartTag' : ddon = True elif token [ 'type' ] == 'EndTag' : ddon = False if token [ 'name' ] == 'h3' : if token [ 'type' ] == 'StartTag' : h3on = True elif token [ 'type' ] == 'EndTag' : h3on = False if token [ 'name' ] == 'a' : if token [ 'type' ] == 'StartTag' : aon = True elif token [ 'type' ] == 'EndTag' : aon = False if not add_date : add_date = int ( round ( time . time ( ) * 1000 ) ) add_date = int ( add_date ) if add_date > 9999999999999 : add_date = int ( add_date / 1000 ) if add_date < 10000000000 : add_date = int ( add_date * 1000 ) bm = { : url , : name . strip ( ) , : [ a for a in tags if a ] , : "" , : 0 , : add_date , : add_date , : 0 , : { 'favicon' : icon } } out_list . append ( bm ) add_date = None url = None icon = None name = "" if h3on : if token [ 'data' ] : if type ( token [ 'data' ] ) == str : tags . append ( token [ 'data' ] ) elif type ( token [ 'data' ] ) == unicode : tags . append ( token [ 'data' ] ) if ddon : if token [ 'data' ] : if token [ 'type' ] == 'Characters' : out_list [ - 1 ] [ 'notes' ] = unescape ( token [ 'data' ] . strip ( ) ) if aon : if token [ 'type' ] == 'StartTag' : for tup in token [ 'data' ] : if tup [ 0 ] == 'add_date' : add_date = tup [ 1 ] elif tup [ 0 ] == 'href' : url = tup [ 1 ] elif tup [ 0 ] == 'icon' : icon = tup [ 1 ] elif tup [ 0 ] == 'tags' : tags = tup [ 1 ] . split ( ',' ) elif token [ 'type' ] == 'Characters' : name += unescape ( token [ 'data' ] ) return out_list def get_json_tags ( json_dict , url ) : tags = [ ] if json_dict . has_key ( 'root' ) and json_dict . has_key ( 'children' ) : for item in json_dict [ 'children' ] : if item [ 'title' ] == 'Tags' : for child in item [ 'children' ] : if child [ 'type' ] == 'text/x-moz-place-container' : for subchild in child [ 'children' ] : if subchild [ 'type' ] == 'text/x-moz-place' : if subchild [ 'uri' ] == url : tags . append ( child [ 'title' ] ) return tags def get_ns_json_bookmarks ( json_dict , bookmarks ) : children = [ ] if json_dict . has_key ( 'children' ) : for child in json_dict [ 'children' ] : if child [ 'type' ] == 'text/x-moz-place' : if not bookmarks [ 0 ] . has_key ( child [ 'uri' ] ) : if child [ 'uri' ] [ 0 : 6 ] not in [ 'place:' , 'file:/' ] : tags = get_json_tags ( bookmarks [ 1 ] , child [ 'uri' ] ) if not tags : tags = [ 'Untagged' ] if child . has_key ( "annos" ) : notes = child [ "annos" ] else : notes = "" if child [ 'lastModified' ] > 9999999999999 : child [ 'lastModified' ] = int ( child [ 'lastModified' ] / 1000 ) elif child [ 'lastModified' ] < 10000000000 : child [ 'lastModified' ] = int ( child [ 'lastModified' ] * 1000 ) if child [ 'dateAdded' ] > 9999999999999 : child [ 'dateAdded' ] = int ( child [ 'dateAdded' ] / 1000 ) elif child [ 'dateAdded' ] < 10000000000 : child [ 'dateAdded' ] = int ( child [ 'dateAdded' ] * 1000 ) bm = { : child [ 'uri' ] , : child [ 'title' ] . strip ( ) , : tags , : notes , : 0 , : child [ 'lastModified' ] , : child [ 'dateAdded' ] , : 0 , : { } } bookmarks [ 0 ] . update ( { child [ 'uri' ] : bm } ) elif child [ 'type' ] == 'text/x-moz-place-container' : get_ns_json_bookmarks ( child , bookmarks ) def parse_bookmarks_json ( json_str ) : json_obj = json . loads ( json_str ) out_list = [ ] bookmarks = [ { } , json_obj ] get_ns_json_bookmarks ( json_obj , bookmarks ) for url , bm in bookmarks [ 0 ] . items ( ) : out_list . append ( bm ) return out_list class BookmarksDB ( object ) : def __init__ ( self , user_dir , user ) : self . bookmarks = [ ] self . user_dir = user_dir self . user = user users_dir = os . path . join ( user_dir , user ) self . bookmarks_path = os . path . join ( users_dir , "bookmarks.json" ) self . open_bookmarks ( ) def open_bookmarks ( self ) : if not os . path . exists ( self . bookmarks_path ) : with open ( self . bookmarks_path , 'w' ) as f : f . write ( '[]' ) return with open ( self . bookmarks_path ) as f : self . bookmarks = json_decode ( f . read ( ) ) def save_bookmarks ( self ) : with open ( self . bookmarks_path , 'w' ) as f : f . write ( json_encode ( self . bookmarks ) ) def sync_bookmarks ( self , bookmarks ) : highest_USN = self . get_highest_USN ( ) changed = False updated_bookmarks = [ ] for bm in bookmarks : if bm [ 'url' ] == "web+deleted:bookmarks/" : for j , deleted_bm in enumerate ( bm [ 'notes' ] ) : if deleted_bm [ 'url' ] == bookmark [ 'url' ] : bm [ 'notes' ] . pop ( j ) found_existing = False for i , db_bookmark in enumerate ( self . bookmarks ) : if bm [ 'url' ] == db_bookmark [ 'url' ] : found_existing = True if bm [ 'updateSequenceNum' ] > db_bookmark [ 'updateSequenceNum' ] : self . bookmarks [ i ] = bm highest_USN += 1 self . bookmarks [ i ] [ 'updateSequenceNum' ] = highest_USN changed = True elif bm [ 'updateSequenceNum' ] < db_bookmark [ 'updateSequenceNum' ] : updated_bookmarks . append ( db_bookmark ) if not found_existing : highest_USN += 1 bm [ 'updateSequenceNum' ] = highest_USN self . bookmarks . append ( bm ) changed = True if changed : self . save_bookmarks ( ) return updated_bookmarks def delete_bookmark ( self , bookmark ) : highest_USN = self . get_highest_USN ( ) for i , db_bookmark in enumerate ( self . bookmarks ) : if bookmark [ 'url' ] == db_bookmark [ 'url' ] : deleted = self . bookmarks . pop ( i ) special_deleted_bm = None for bm in self . bookmarks : if bm [ 'url' ] == "web+deleted:bookmarks/" : special_deleted_bm = bm if not special_deleted_bm : special_deleted_bm = { : "web+deleted:bookmarks/" , : "Deleted Bookmarks" , : [ ] , : [ bookmark ] , : highest_USN + 1 , : int ( round ( time . time ( ) * 1000 ) ) , : int ( round ( time . time ( ) * 1000 ) ) , : 0 , : { } } self . bookmarks . append ( special_deleted_bm ) else : updated = False for j , deleted_bm in enumerate ( special_deleted_bm [ 'notes' ] ) : if deleted_bm [ 'url' ] == bookmark [ 'url' ] : special_deleted_bm [ 'notes' ] [ j ] = bookmark updated = True if not updated : special_deleted_bm [ 'notes' ] . append ( bookmark ) highest_USN += 1 special_deleted_bm [ 'updateSequenceNum' ] = highest_USN break self . save_bookmarks ( ) def get_bookmarks ( self , updateSequenceNum = 0 ) : out_bookmarks = [ ] for bm in self . bookmarks : if bm [ 'updateSequenceNum' ] > updateSequenceNum : out_bookmarks . append ( bm ) return out_bookmarks def get_highest_USN ( self ) : highest_USN = 0 for bm in self . bookmarks : if bm [ 'updateSequenceNum' ] > highest_USN : highest_USN = bm [ 'updateSequenceNum' ] return highest_USN def rename_tag ( self , old_tag , new_tag ) : highest_USN = self . get_highest_USN ( ) for bm in self . bookmarks : if old_tag in bm [ 'tags' ] : highest_USN += 1 i = bm [ 'tags' ] . index ( old_tag ) bm [ 'tags' ] [ i ] = new_tag bm [ 'updateSequenceNum' ] = highest_USN bm [ 'updated' ] = int ( round ( time . time ( ) * 1000 ) ) self . save_bookmarks ( ) class FaviconHandler ( BaseHandler ) : favicon_mimetypes = [ , , , , , ] @ tornado . web . asynchronous def get ( self ) : self . process ( ) @ tornado . web . asynchronous def post ( self ) : self . process ( ) def process ( self ) : url = self . get_argument ( "url" ) http = tornado . httpclient . AsyncHTTPClient ( ) callback = partial ( self . on_response , url ) http . fetch ( url , callback , connect_timeout = 5.0 , request_timeout = 5.0 ) def get_favicon_url ( self , html ) : p = html5lib . HTMLParser ( tree = treebuilders . getTreeBuilder ( "dom" ) ) dom_tree = p . parse ( html ) walker = treewalkers . getTreeWalker ( "dom" ) stream = walker ( dom_tree ) fetch_url = None mimetype = None icon = False found_token = None for token in stream : if 'name' in token : if token [ 'name' ] == 'link' : for attr in token [ 'data' ] : if attr [ 0 ] == 'rel' : if 'shortcut icon' in attr [ 1 ] . lower ( ) : found_token = token icon = True elif attr [ 0 ] == 'href' : fetch_url = attr [ 1 ] elif attr [ 0 ] == 'type' : mimetype = attr [ 1 ] if fetch_url and icon : if not mimetype : mimetype = "image/x-icon" if mimetype in self . favicon_mimetypes : return ( fetch_url , mimetype ) return ( None , None ) def on_response ( self , url , response ) : if response . error : self . write ( 'Unable to fetch icon.' ) self . finish ( ) return fetch_url = None try : content = response . body . decode ( 'utf-8' ) except UnicodeDecodeError : content = response . body parsed_url = urlparse ( url ) ( fetch_url , mimetype ) = self . get_favicon_url ( content ) if fetch_url : if not fetch_url . startswith ( 'http' ) : fetch_url = '%s://%s%s' % ( parsed_url . scheme , parsed_url . netloc , fetch_url ) if not mimetype : mimetype = "image/x-icon" if not fetch_url : fetch_url = '%s://%s/favicon.ico' % ( parsed_url . scheme , parsed_url . netloc ) if fetch_url . startswith ( 'http://' ) or fetch_url . startswith ( 'https://' ) : noop ( ) else : raise tornado . web . HTTPError ( 404 ) http = tornado . httpclient . AsyncHTTPClient ( ) callback = partial ( self . icon_fetch , url , mimetype ) try : http . fetch ( fetch_url , callback , connect_timeout = 5.0 , request_timeout = 5.0 ) except gaierror : self . write ( 'Unable to fetch icon.' ) self . finish ( ) return def icon_multifetch ( self , urls , response ) : if response . error : if urls : url = urls . pop ( ) http = tornado . httpclient . AsyncHTTPClient ( ) callback = partial ( self . icon_multifetch , urls ) try : http . fetch ( url , callback ) except gaierror : raise tornado . web . HTTPError ( 404 ) else : raise tornado . web . HTTPError ( 404 ) else : if 'Content-Type' in response . headers : mimetype = response . headers [ 'Content-Type' ] self . set_header ( "Content-Type" , mimetype ) else : mimetype = "image/vnd.microsoft.icon" self . set_header ( "Content-Type" , mimetype ) data_uri = "data:%s;base64,%s" % ( mimetype , response . body . encode ( 'base64' ) . replace ( '\n' , '' ) ) self . write ( data_uri ) self . finish ( ) def icon_fetch ( self , url , mimetype , response ) : if response . error : self . write ( 'Unable to fetch icon.' ) self . finish ( ) return data_uri = "data:%s;base64,%s" % ( mimetype , response . body . encode ( 'base64' ) . replace ( '\n' , '' ) ) self . set_header ( "Content-Type" , mimetype ) self . write ( data_uri ) self . finish ( ) class ImportHandler ( tornado . web . RequestHandler ) : @ tornado . web . asynchronous def post ( self ) : html = self . request . body if html . startswith ( '{' ) : bookmarks = parse_bookmarks_json ( html ) else : bookmarks = parse_bookmarks_html ( html ) self . write ( tornado . escape . json_encode ( bookmarks ) ) self . finish ( ) class ExportHandler ( tornado . web . RequestHandler ) : @ tornado . web . asynchronous def post ( self ) : bookmarks = self . get_argument ( "bookmarks" ) bookmarks = tornado . escape . json_decode ( bookmarks ) self . set_header ( "Content-Type" , "text/html" ) self . set_header ( , 'attachment; filename="bookmarks.html"' ) templates_path = os . path . join ( plugin_path , "templates" ) bookmarks_html = os . path . join ( templates_path , "bookmarks.html" ) self . render ( bookmarks_html , bookmarks = bookmarks ) def save_bookmarks ( bookmarks , tws ) : out_dict = { : [ ] , : 0 , : [ ] } try : user = tws . get_current_user ( ) [ 'upn' ] bookmarks_db = BookmarksDB ( tws . settings [ 'user_dir' ] , user ) updates = bookmarks_db . sync_bookmarks ( bookmarks ) out_dict . update ( { : updates , : len ( bookmarks ) , } ) out_dict [ 'updateSequenceNum' ] = bookmarks_db . get_highest_USN ( ) except Exception as e : import traceback logging . error ( "Got exception synchronizing bookmarks: %s" % e ) traceback . print_exc ( file = sys . stdout ) out_dict [ 'errors' ] . append ( str ( e ) ) if out_dict [ 'errors' ] : out_dict [ 'result' ] = "Upload completed but errors were encountered." else : out_dict [ 'result' ] = "Upload successful" message = { 'bookmarks_save_result' : out_dict } tws . write_message ( json_encode ( message ) ) def get_bookmarks ( updateSequenceNum , tws ) : user = tws . get_current_user ( ) [ 'upn' ] bookmarks_db = BookmarksDB ( tws . settings [ 'user_dir' ] , user ) if updateSequenceNum : updateSequenceNum = int ( updateSequenceNum ) else : updateSequenceNum = 0 updated_bookmarks = bookmarks_db . get_bookmarks ( updateSequenceNum ) message = { 'bookmarks_updated' : updated_bookmarks } tws . write_message ( json_encode ( message ) ) def delete_bookmarks ( deleted_bookmarks , tws ) : user = tws . get_current_user ( ) [ 'upn' ] bookmarks_db = BookmarksDB ( tws . settings [ 'user_dir' ] , user ) out_dict = { : "" , : 0 , : [ ] , } try : for bookmark in deleted_bookmarks : out_dict [ 'count' ] += 1 bookmarks_db . delete_bookmark ( bookmark ) out_dict [ 'result' ] = "Success" except Exception as e : logging . error ( "delete_bookmarks error: %s" % e ) import traceback traceback . print_exc ( file = sys . stdout ) out_dict [ 'result' ] = "Errors" out_dict [ 'errors' ] . append ( str ( e ) ) message = { 'bookmarks_delete_result' : out_dict } tws . write_message ( json_encode ( message ) ) def rename_tags ( renamed_tags , tws ) : user = tws . get_current_user ( ) [ 'upn' ] bookmarks_db = BookmarksDB ( tws . settings [ 'user_dir' ] , user ) out_dict = { : "" , : 0 , : [ ] , : [ ] } for pair in renamed_tags : old_name , new_name = pair . split ( ',' ) bookmarks_db . rename_tag ( old_name , new_name ) out_dict [ 'count' ] += 1 message = { 'bookmarks_renamed_tags' : out_dict } tws . write_message ( json_encode ( message ) ) hooks = { : [ ( r"/bookmarks/fetchicon" , FaviconHandler ) , ( r"/bookmarks/export" , ExportHandler ) , ( r"/bookmarks/import" , ImportHandler ) , ] , : { : save_bookmarks , : get_bookmarks , : delete_bookmarks , : rename_tags , }

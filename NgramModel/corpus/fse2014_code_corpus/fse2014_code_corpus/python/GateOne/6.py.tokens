__doc__ = """\ Gate One utility functions and classes. """ __version__ = '1.0rc1' __license__ = "AGPLv3 or Proprietary (see LICENSE.txt)" __version_info__ = ( 1 , 0 ) __author__ = 'Dan McDougall <daniel.mcdougall@liftoffsoftware.com>' import os import signal import sys import random import re import errno import base64 import uuid import logging import mimetypes import struct import binascii import gzip from datetime import timedelta from tornado import locale try : from tornado . escape import json_encode as _json_encode from tornado . escape import json_decode except ImportError : from json import dumps as _json_encode from json import loads as json_encode MACOS = os . uname ( ) [ 0 ] == 'Darwin' RE_PSTREE = re . compile ( r'\(([0-9]*)\)' ) RE_OPT_SSH_SEQ = re . compile ( , re . MULTILINE | re . DOTALL ) RE_TITLE_SEQ = re . compile ( , re . DOTALL | re . MULTILINE ) REPLACEMENT_DICT = { 0 : u'^@' , 1 : u'^A' , 2 : u'^B' , 3 : u'^C' , 4 : u'^D' , 5 : u'^E' , 6 : u'^F' , 7 : u'^G' , 8 : u'^H' , 9 : u'^I' , 11 : u'^K' , 12 : u'^L' , 14 : u'^N' , 15 : u'^O' , 16 : u'^P' , 17 : u'^Q' , 18 : u'^R' , 19 : u'^S' , 20 : u'^T' , 21 : u'^U' , 22 : u'^V' , 23 : u'^W' , 24 : u'^X' , 25 : u'^Y' , 26 : u'^Z' , 27 : u'^[' , 28 : u'^\\' , 29 : u'^]' , 30 : u'^^' , 31 : u'^_' , 127 : u'^?' , } FACILITIES = { : 32 , : 72 , : 24 , : 0 , : 128 , : 136 , : 144 , : 152 , : 160 , : 168 , : 176 , : 184 , : 48 , : 16 , : 56 , : 40 , : 8 , : 64 } SEPARATOR = u"\U000f0f0f" class UnknownFacility ( Exception ) : pass class MimeTypeFail ( Exception ) : pass class SSLGenerationError ( Exception ) : pass def noop ( * args , ** kwargs ) : pass def shell_command ( cmd , timeout_duration = 5 ) : try : from commands import getstatusoutput except ImportError : from subprocess import getstatusoutput existing_handler = signal . getsignal ( signal . SIGCHLD ) default = ( 255 , _ ( "ERROR: Timeout running shell command" ) ) if existing_handler != 0 : try : signal . signal ( signal . SIGCHLD , signal . SIG_DFL ) except ValueError : pass result = timeout_func ( getstatusoutput , args = ( cmd , ) , default = default , timeout_duration = timeout_duration ) try : signal . signal ( signal . SIGCHLD , existing_handler ) except ValueError : pass return result def json_encode ( obj ) : return unicode ( _json_encode ( obj ) ) def get_translation ( ) : gateone_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) server_conf = os . path . join ( gateone_dir , 'server.conf' ) try : locale_str = os . environ . get ( 'LANG' , 'en_US' ) . split ( '.' ) [ 0 ] with open ( server_conf ) as f : for line in f : if line . startswith ( 'locale' ) : locale_str = line . split ( '=' ) [ 1 ] . strip ( ) locale_str = locale_str . strip ( '"' ) . strip ( "'" ) break except IOError : pass user_locale = locale . get ( locale_str ) return user_locale . translate def gen_self_signed_ssl ( ) : try : import OpenSSL gen_self_signed_func = gen_self_signed_pyopenssl except ImportError : gen_self_signed_func = gen_self_signed_openssl try : gen_self_signed_func ( ) except SSLGenerationError as e : logging . error ( _ ( % e ) ) def gen_self_signed_openssl ( ) : subject = ( % os . uname ( ) [ 1 ] ) gen_command = ( ) decrypt_key_command = ( ) csr_command = ( % subject ) cert_command = ( ) exitstatus , output = shell_command ( gen_command ) if exitstatus != 0 : error_msg = _ ( % output ) if os . path . exists ( 'keyfile.pem.tmp' ) : os . remove ( 'keyfile.pem.tmp' ) raise SSLGenerationError ( error_msg ) exitstatus , output = shell_command ( decrypt_key_command ) if exitstatus != 0 : error_msg = _ ( % output ) if os . path . exists ( 'keyfile.pem.tmp' ) : os . remove ( 'keyfile.pem.tmp' ) raise SSLGenerationError ( error_msg ) exitstatus , output = shell_command ( csr_command ) if exitstatus != 0 : error_msg = _ ( % output ) if os . path . exists ( 'keyfile.pem.tmp' ) : os . remove ( 'keyfile.pem.tmp' ) if os . path . exists ( 'temp.csr' ) : os . remove ( 'temp.csr' ) raise SSLGenerationError ( error_msg ) exitstatus , output = shell_command ( cert_command ) if exitstatus != 0 : error_msg = _ ( % output ) if os . path . exists ( 'keyfile.pem.tmp' ) : os . remove ( 'keyfile.pem.tmp' ) if os . path . exists ( 'temp.csr' ) : os . remove ( 'temp.csr' ) if os . path . exists ( 'certificate.pem' ) : os . remove ( 'certificate.pem' ) raise SSLGenerationError ( error_msg ) os . remove ( 'keyfile.pem.tmp' ) os . remove ( 'temp.csr' ) def gen_self_signed_pyopenssl ( notAfter = None ) : try : import OpenSSL except ImportError : error_msg = _ ( ) raise SSLGenerationError ( error_msg ) pkey = OpenSSL . crypto . PKey ( ) pkey . generate_key ( OpenSSL . crypto . TYPE_RSA , 4096 ) with open ( 'keyfile.pem' , 'w' ) as f : f . write ( OpenSSL . crypto . dump_privatekey ( OpenSSL . crypto . FILETYPE_PEM , pkey ) ) cert = OpenSSL . crypto . X509 ( ) cert . set_serial_number ( random . randint ( 0 , sys . maxint ) ) cert . gmtime_adj_notBefore ( 0 ) if notAfter : cert . gmtime_adj_notAfter ( notAfter ) else : cert . gmtime_adj_notAfter ( 60 * 60 * 24 * 3650 ) cert . get_subject ( ) . CN = '*' cert . get_subject ( ) . O = 'Gate One Certificate' cert . get_issuer ( ) . CN = 'Untrusted Authority' cert . get_issuer ( ) . O = 'Self-Signed' cert . set_pubkey ( pkey ) cert . sign ( pkey , 'md5' ) with open ( 'certificate.pem' , 'w' ) as f : f . write ( OpenSSL . crypto . dump_certificate ( OpenSSL . crypto . FILETYPE_PEM , cert ) ) def none_fix ( val ) : if isinstance ( val , basestring ) and val . lower ( ) in [ 'none' , '0' , 'no' ] : return None else : return val def str2bool ( val ) : if isinstance ( val , basestring ) and val . lower ( ) in [ '1' , 'true' , 'yes' ] : return True else : return False def generate_session_id ( ) : return base64 . b64encode ( uuid . uuid4 ( ) . hex + uuid . uuid4 ( ) . hex ) [ : 45 ] def mkdir_p ( path ) : try : os . makedirs ( path ) except OSError as exc : if exc . errno == errno . EEXIST : pass else : raise def cmd_var_swap ( cmd , session = None , session_hash = None , user_dir = None , user = None , time = None ) : if session : cmd = cmd . replace ( r'%SESSION%' , session ) if session_hash : cmd = cmd . replace ( r'%SESSION_HASH%' , session ) if user_dir : cmd = cmd . replace ( r'%USERDIR%' , user_dir ) if user : cmd = cmd . replace ( r'%USER%' , user ) if time : cmd = cmd . replace ( r'%TIME%' , str ( time ) ) return cmd def short_hash ( to_shorten ) : packed = struct . pack ( 'i' , binascii . crc32 ( to_shorten ) ) return base64 . urlsafe_b64encode ( packed ) . replace ( '=' , '' ) def get_process_tree ( parent_pid ) : parent_pid = str ( parent_pid ) ps = which ( 'ps' ) retcode , output = shell_command ( '%s -ef' % ps ) out = [ parent_pid ] pidmap = [ ] for line in output . splitlines ( ) : split_line = line . split ( ) pid = split_line [ 1 ] ppid = split_line [ 2 ] pidmap . append ( ( pid , ppid ) ) def walk_pids ( pidmap , checkpid ) : for pid , ppid in pidmap : if ppid == checkpid : out . append ( pid ) walk_pids ( pidmap , pid ) walk_pids ( pidmap , parent_pid ) return out def kill_dtached_proc ( session , term ) : logging . debug ( 'kill_dtached_proc(%s, %s)' % ( session , term ) ) dtach_socket_name = 'dtach_%s' % term to_kill = [ ] for f in os . listdir ( '/proc' ) : pid_dir = os . path . join ( '/proc' , f ) if os . path . isdir ( pid_dir ) : try : pid = int ( f ) except ValueError : continue try : with open ( os . path . join ( pid_dir , 'cmdline' ) ) as f : cmdline = f . read ( ) if cmdline and session in cmdline : if dtach_socket_name in cmdline : to_kill . append ( pid ) except Exception as e : pass for pid in to_kill : kill_pids = get_process_tree ( pid ) for _pid in kill_pids : _pid = int ( _pid ) try : os . kill ( _pid , signal . SIGTERM ) except OSError : pass def kill_dtached_proc_macos ( session , term ) : logging . debug ( 'kill_dtached_proc_macos(%s, %s)' % ( session , term ) ) ps = which ( 'ps' ) cmd = ( % ( ps , session , term ) ) exitstatus , output = shell_command ( cmd ) for line in output . splitlines ( ) : pid_to_kill = line . strip ( ) for pid in get_process_tree ( pid_to_kill ) : try : os . kill ( int ( pid ) , signal . SIGTERM ) except OSError : pass def killall ( session_dir ) : sessions = os . listdir ( session_dir ) for f in os . listdir ( '/proc' ) : pid_dir = os . path . join ( '/proc' , f ) if os . path . isdir ( pid_dir ) : try : pid = int ( f ) if pid == os . getpid ( ) : continue except ValueError : continue with open ( os . path . join ( pid_dir , 'cmdline' ) ) as f : cmdline = f . read ( ) for session in sessions : if session in cmdline : try : os . kill ( pid , signal . SIGTERM ) except OSError : pass elif 'python' in cmdline : if 'gateone.py' in cmdline : try : os . kill ( pid , signal . SIGTERM ) except OSError : pass def killall_macos ( session_dir ) : sessions = os . listdir ( session_dir ) for session in sessions : cmd = ( % session ) exitstatus , output = shell_command ( cmd ) def create_plugin_links ( static_dir , templates_dir , plugin_dir ) : for f in os . listdir ( static_dir ) : if os . path . islink ( f ) : if not os . path . exists ( os . readlink ( f ) ) : os . unlink ( f ) for f in os . listdir ( templates_dir ) : if os . path . islink ( f ) : if not os . path . exists ( os . readlink ( f ) ) : os . unlink ( f ) for directory in os . listdir ( plugin_dir ) : plugin_name = directory directory = os . path . join ( plugin_dir , directory ) for f in os . listdir ( directory ) : if f == 'static' : abs_src_path = os . path . join ( directory , f ) abs_dest_path = os . path . join ( static_dir , plugin_name ) try : os . symlink ( abs_src_path , abs_dest_path ) except OSError : pass if f == 'templates' : abs_src_path = os . path . join ( directory , f ) abs_dest_path = os . path . join ( templates_dir , plugin_name ) try : os . symlink ( abs_src_path , abs_dest_path ) except OSError : pass def get_plugins ( plugin_dir ) : out_dict = { 'js' : [ ] , 'css' : [ ] , 'py' : [ ] } for directory in os . listdir ( plugin_dir ) : plugin = directory http_static_path = '/static/%s' % plugin directory = os . path . join ( plugin_dir , directory ) plugin_files = os . listdir ( directory ) if "__init__.py" in plugin_files : out_dict [ 'py' ] . append ( plugin ) sys . path . append ( directory ) else : for plugin_file in plugin_files : if plugin_file . endswith ( '.py' ) : plugin_path = os . path . join ( directory , plugin_file ) sys . path . append ( directory ) ( basename , ext ) = os . path . splitext ( plugin_path ) basename = basename . split ( '/' ) [ - 1 ] out_dict [ 'py' ] . append ( basename ) for plugin_file in plugin_files : if plugin_file == 'static' : static_dir = os . path . join ( directory , plugin_file ) for static_file in os . listdir ( static_dir ) : if static_file . endswith ( '.js' ) : http_path = os . path . join ( http_static_path , static_file ) out_dict [ 'js' ] . append ( http_path ) elif static_file . endswith ( '.css' ) : http_path = os . path . join ( http_static_path , static_file ) out_dict [ 'css' ] . append ( http_path ) if plugin_file == 'templates' : templates_dir = os . path . join ( directory , plugin_file ) for template_file in os . listdir ( templates_dir ) : if template_file . endswith ( '.css' ) : http_path = "/cssrender?plugin=%s&template=%s" % ( plugin , template_file ) out_dict [ 'css' ] . append ( http_path ) out_dict [ 'py' ] . sort ( ) out_dict [ 'js' ] . sort ( ) out_dict [ 'css' ] . sort ( ) return out_dict def load_plugins ( plugins ) : out_list = [ ] for plugin in plugins : imported = __import__ ( plugin , None , None , [ '' ] ) out_list . append ( imported ) return out_list def merge_handlers ( handlers ) : out_list = [ ] regexes = [ ] handlers . reverse ( ) for handler in handlers : if handler [ 0 ] not in regexes : regexes . append ( handler [ 0 ] ) out_list . append ( handler ) out_list . reverse ( ) return out_list def convert_to_timedelta ( time_val ) : num = int ( time_val [ : - 1 ] ) if time_val . endswith ( 's' ) : return timedelta ( seconds = num ) elif time_val . endswith ( 'm' ) : return timedelta ( minutes = num ) elif time_val . endswith ( 'h' ) : return timedelta ( hours = num ) elif time_val . endswith ( 'd' ) : return timedelta ( days = num ) def process_opt_esc_sequence ( chars ) : plugin = None text = "" try : plugin , text = chars . split ( '|' ) except Exception as e : pass return ( plugin , text ) def raw ( text , replacement_dict = None ) : if not replacement_dict : replacement_dict = REPLACEMENT_DICT out = u'' for char in text : charnum = ord ( char ) if charnum in replacement_dict . keys ( ) : out += replacement_dict [ charnum ] else : out += char return out def string_to_syslog_facility ( facility ) : if facility . lower ( ) in FACILITIES : return FACILITIES [ facility . lower ( ) ] else : raise UnknownFacility ( _ ( % repr ( facility ) ) ) def create_data_uri ( filepath ) : mimetype = mimetypes . guess_type ( filepath ) [ 0 ] if not mimetype : raise MimeTypeFail ( "Could not guess mime type of: %s" % filepath ) f = open ( filepath ) . read ( ) encoded = base64 . b64encode ( f ) . replace ( '\n' , '' ) if len ( encoded ) > 65000 : logging . warn ( ) data_uri = "data:%s;base64,%s" % ( mimetype , encoded ) return data_uri def human_readable_bytes ( bytes ) : K , M , G , T = 1 << 10 , 1 << 20 , 1 << 30 , 1 << 40 if bytes >= T : return '%.1fT' % ( float ( bytes ) / T ) elif bytes >= G : return '%.1fG' % ( float ( bytes ) / G ) elif bytes >= M : return '%.1fM' % ( float ( bytes ) / M ) elif bytes >= K : return '%.1fK' % ( float ( bytes ) / K ) else : return '%d' % bytes def retrieve_first_frame ( golog_path ) : found_first_frame = None frame = "" f = gzip . open ( golog_path ) while not found_first_frame : frame += f . read ( 1 ) if frame . decode ( 'UTF-8' , "ignore" ) . endswith ( SEPARATOR ) : found_first_frame = True f . close ( ) return frame . decode ( 'UTF-8' , "ignore" ) . rstrip ( SEPARATOR ) def get_or_update_metadata ( golog_path , user , force_update = False ) : first_frame = retrieve_first_frame ( golog_path ) metadata = { } if first_frame [ 14 : ] . startswith ( '{' ) : metadata = json_decode ( first_frame [ 14 : ] ) if not force_update and 'end_date' in metadata : return metadata encoded_separator = SEPARATOR . encode ( 'UTF-8' ) golog = gzip . open ( golog_path ) chunk_size = 1024 * 128 log_data = '' while True : chunk = golog . read ( chunk_size ) log_data += chunk if len ( chunk ) < chunk_size : break golog_frames = log_data . split ( encoded_separator ) [ : - 1 ] start_date = golog_frames [ 0 ] [ : 13 ] end_date = golog_frames [ - 1 ] [ : 13 ] version = u"1.0" connect_string = None from gateone import PLUGINS if 'ssh' in PLUGINS [ 'py' ] : for frame in golog_frames [ : 50 ] : match_obj = RE_OPT_SSH_SEQ . match ( frame ) if match_obj : connect_string = match_obj . group ( 1 ) . split ( '|' ) [ 1 ] break if not connect_string : for frame in golog_frames [ : 50 ] : match_obj = RE_TITLE_SEQ . match ( frame ) if match_obj : connect_string = match_obj . group ( 1 ) break metadata . update ( { : user , : start_date , : end_date , : len ( golog_frames ) , : version , : connect_string , : os . path . split ( golog_path ) [ 1 ] } ) first_frame = u"%s:%s" % ( start_date , json_encode ( metadata ) ) golog_frames [ 0 ] = first_frame . encode ( 'UTF-8' ) log_data = '' for frame in golog_frames : log_data += frame + encoded_separator gzip . open ( golog_path , 'w' ) . write ( log_data ) return metadata def which ( binary , path = None ) : if path : paths = path . split ( ':' ) else : paths = os . environ [ 'PATH' ] . split ( ':' ) for path in paths : if not os . path . exists ( path ) : continue files = os . listdir ( path ) if binary in files : return os . path . join ( path , binary ) return None def timeout_func ( func , args = ( ) , kwargs = { } , timeout_duration = 10 , default = None ) : import threading class InterruptableThread ( threading . Thread ) : def __init__ ( self ) : threading . Thread . __init__ ( self ) self . result = None def run ( self ) : try : self . result = func ( * args , ** kwargs ) except : self . result = default it = InterruptableThread ( ) it . start ( ) it . join ( timeout_duration ) if it . isAlive ( ) : if hasattr ( default , '__call__' ) : return default ( ) else : return default else : return it . result _ = get_translation ( ) if MACOS : kill_dtached_proc = kill_dtached_proc_macos killall = killall_macos

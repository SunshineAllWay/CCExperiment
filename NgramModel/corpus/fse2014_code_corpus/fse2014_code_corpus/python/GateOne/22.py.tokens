try : frozenset except NameError : from sets import Set as set from sets import ImmutableSet as frozenset try : any except : def any ( iterable ) : for element in iterable : if element : return True return False import sys import inputstream import tokenizer import treebuilders from treebuilders . _base import Marker from treebuilders import simpletree import utils from constants import spaceCharacters , asciiUpper2Lower from constants import scopingElements , formattingElements , specialElements from constants import headingElements , tableInsertModeElements from constants import cdataElements , rcdataElements , voidElements from constants import tokenTypes , ReparseException , namespaces def parse ( doc , treebuilder = "simpletree" , encoding = None , namespaceHTMLElements = True ) : tb = treebuilders . getTreeBuilder ( treebuilder ) p = HTMLParser ( tb , namespaceHTMLElements = namespaceHTMLElements ) return p . parse ( doc , encoding = encoding ) def parseFragment ( doc , container = "div" , treebuilder = "simpletree" , encoding = None , namespaceHTMLElements = True ) : tb = treebuilders . getTreeBuilder ( treebuilder ) p = HTMLParser ( tb , namespaceHTMLElements = namespaceHTMLElements ) return p . parseFragment ( doc , container = container , encoding = encoding ) class HTMLParser ( object ) : def __init__ ( self , tree = simpletree . TreeBuilder , tokenizer = tokenizer . HTMLTokenizer , strict = False , namespaceHTMLElements = True ) : self . strict = strict self . tree = tree ( namespaceHTMLElements ) self . tokenizer_class = tokenizer self . errors = [ ] self . phases = { : InitialPhase ( self , self . tree ) , : BeforeHtmlPhase ( self , self . tree ) , : BeforeHeadPhase ( self , self . tree ) , : InHeadPhase ( self , self . tree ) , : AfterHeadPhase ( self , self . tree ) , : InBodyPhase ( self , self . tree ) , : TextPhase ( self , self . tree ) , : InTablePhase ( self , self . tree ) , : InTableTextPhase ( self , self . tree ) , : InCaptionPhase ( self , self . tree ) , : InColumnGroupPhase ( self , self . tree ) , : InTableBodyPhase ( self , self . tree ) , : InRowPhase ( self , self . tree ) , : InCellPhase ( self , self . tree ) , : InSelectPhase ( self , self . tree ) , : InSelectInTablePhase ( self , self . tree ) , : InForeignContentPhase ( self , self . tree ) , : AfterBodyPhase ( self , self . tree ) , : InFramesetPhase ( self , self . tree ) , : AfterFramesetPhase ( self , self . tree ) , : AfterAfterBodyPhase ( self , self . tree ) , : AfterAfterFramesetPhase ( self , self . tree ) , } def _parse ( self , stream , innerHTML = False , container = "div" , encoding = None , parseMeta = True , useChardet = True , ** kwargs ) : self . innerHTMLMode = innerHTML self . container = container self . tokenizer = self . tokenizer_class ( stream , encoding = encoding , parseMeta = parseMeta , useChardet = useChardet , ** kwargs ) self . reset ( ) while True : try : self . mainLoop ( ) break except ReparseException , e : self . reset ( ) def reset ( self ) : self . tree . reset ( ) self . firstStartTag = False self . errors = [ ] self . compatMode = "no quirks" if self . innerHTMLMode : self . innerHTML = self . container . lower ( ) if self . innerHTML in cdataElements : self . tokenizer . state = self . tokenizer . rcdataState elif self . innerHTML in rcdataElements : self . tokenizer . state = self . tokenizer . rawtextState elif self . innerHTML == 'plaintext' : self . tokenizer . state = self . tokenizer . plaintextState else : pass self . phase = self . phases [ "beforeHtml" ] self . phase . insertHtmlElement ( ) self . resetInsertionMode ( ) else : self . innerHTML = False self . phase = self . phases [ "initial" ] self . lastPhase = None self . secondaryPhase = None self . beforeRCDataPhase = None self . framesetOK = True def mainLoop ( self ) : ( CharactersToken , SpaceCharactersToken , StartTagToken , EndTagToken , CommentToken , DoctypeToken ) = ( tokenTypes [ "Characters" ] , tokenTypes [ "SpaceCharacters" ] , tokenTypes [ "StartTag" ] , tokenTypes [ "EndTag" ] , tokenTypes [ "Comment" ] , tokenTypes [ "Doctype" ] ) CharactersToken = tokenTypes [ "Characters" ] SpaceCharactersToken = tokenTypes [ "SpaceCharacters" ] StartTagToken = tokenTypes [ "StartTag" ] EndTagToken = tokenTypes [ "EndTag" ] CommentToken = tokenTypes [ "Comment" ] DoctypeToken = tokenTypes [ "Doctype" ] for token in self . normalizedTokens ( ) : type = token [ "type" ] if type == CharactersToken : self . phase . processCharacters ( token ) elif type == SpaceCharactersToken : self . phase . processSpaceCharacters ( token ) elif type == StartTagToken : self . selfClosingAcknowledged = False self . phase . processStartTag ( token ) if ( token [ "selfClosing" ] and not self . selfClosingAcknowledged ) : self . parseError ( "non-void-element-with-trailing-solidus" , { "name" : token [ "name" ] } ) elif type == EndTagToken : self . phase . processEndTag ( token ) elif type == CommentToken : self . phase . processComment ( token ) elif type == DoctypeToken : self . phase . processDoctype ( token ) else : self . parseError ( token [ "data" ] , token . get ( "datavars" , { } ) ) self . phase . processEOF ( ) def normalizedTokens ( self ) : for token in self . tokenizer : yield self . normalizeToken ( token ) def parse ( self , stream , encoding = None , parseMeta = True , useChardet = True ) : self . _parse ( stream , innerHTML = False , encoding = encoding , parseMeta = parseMeta , useChardet = useChardet ) return self . tree . getDocument ( ) def parseFragment ( self , stream , container = "div" , encoding = None , parseMeta = False , useChardet = True ) : self . _parse ( stream , True , container = container , encoding = encoding ) return self . tree . getFragment ( ) def parseError ( self , errorcode = "XXX-undefined-error" , datavars = { } ) : self . errors . append ( ( self . tokenizer . stream . position ( ) , errorcode , datavars ) ) if self . strict : raise ParseError def normalizeToken ( self , token ) : if token [ "type" ] == tokenTypes [ "StartTag" ] : token [ "data" ] = dict ( token [ "data" ] [ : : - 1 ] ) return token def adjustMathMLAttributes ( self , token ) : replacements = { "definitionurl" : "definitionURL" } for k , v in replacements . iteritems ( ) : if k in token [ "data" ] : token [ "data" ] [ v ] = token [ "data" ] [ k ] del token [ "data" ] [ k ] def adjustSVGAttributes ( self , token ) : replacements = { : "attributeName" , : "attributeType" , : "baseFrequency" , : "baseProfile" , : "calcMode" , : "clipPathUnits" , : "contentScriptType" , : "contentStyleType" , : "diffuseConstant" , : "edgeMode" , : "externalResourcesRequired" , : "filterRes" , : "filterUnits" , : "glyphRef" , : "gradientTransform" , : "gradientUnits" , : "kernelMatrix" , : "kernelUnitLength" , : "keyPoints" , : "keySplines" , : "keyTimes" , : "lengthAdjust" , : "limitingConeAngle" , : "markerHeight" , : "markerUnits" , : "markerWidth" , : "maskContentUnits" , : "maskUnits" , : "numOctaves" , : "pathLength" , : "patternContentUnits" , : "patternTransform" , : "patternUnits" , : "pointsAtX" , : "pointsAtY" , : "pointsAtZ" , : "preserveAlpha" , : "preserveAspectRatio" , : "primitiveUnits" , : "refX" , : "refY" , : "repeatCount" , : "repeatDur" , : "requiredExtensions" , : "requiredFeatures" , : "specularConstant" , : "specularExponent" , : "spreadMethod" , : "startOffset" , : "stdDeviation" , : "stitchTiles" , : "surfaceScale" , : "systemLanguage" , : "tableValues" , : "targetX" , : "targetY" , : "textLength" , : "viewBox" , : "viewTarget" , : "xChannelSelector" , : "yChannelSelector" , : "zoomAndPan" } for originalName in token [ "data" ] . keys ( ) : if originalName in replacements : svgName = replacements [ originalName ] token [ "data" ] [ svgName ] = token [ "data" ] [ originalName ] del token [ "data" ] [ originalName ] def adjustForeignAttributes ( self , token ) : replacements = { : ( "xlink" , "actuate" , namespaces [ "xlink" ] ) , : ( "xlink" , "arcrole" , namespaces [ "xlink" ] ) , : ( "xlink" , "href" , namespaces [ "xlink" ] ) , : ( "xlink" , "role" , namespaces [ "xlink" ] ) , : ( "xlink" , "show" , namespaces [ "xlink" ] ) , : ( "xlink" , "title" , namespaces [ "xlink" ] ) , : ( "xlink" , "type" , namespaces [ "xlink" ] ) , : ( "xml" , "base" , namespaces [ "xml" ] ) , : ( "xml" , "lang" , namespaces [ "xml" ] ) , : ( "xml" , "space" , namespaces [ "xml" ] ) , : ( None , "xmlns" , namespaces [ "xmlns" ] ) , : ( "xmlns" , "xlink" , namespaces [ "xmlns" ] ) } for originalName in token [ "data" ] . iterkeys ( ) : if originalName in replacements : foreignName = replacements [ originalName ] token [ "data" ] [ foreignName ] = token [ "data" ] [ originalName ] del token [ "data" ] [ originalName ] def resetInsertionMode ( self ) : last = False newModes = { : "inSelect" , : "inCell" , : "inCell" , : "inRow" , : "inTableBody" , : "inTableBody" , : "inTableBody" , : "inCaption" , : "inColumnGroup" , : "inTable" , : "inBody" , : "inBody" , : "inFrameset" } for node in self . tree . openElements [ : : - 1 ] : nodeName = node . name if node == self . tree . openElements [ 0 ] : last = True if nodeName not in [ 'td' , 'th' ] : assert self . innerHTML nodeName = self . innerHTML if nodeName in ( "select" , "colgroup" , "head" , "frameset" ) : assert self . innerHTML if nodeName in newModes : self . phase = self . phases [ newModes [ nodeName ] ] break elif node . namespace in ( namespaces [ "mathml" ] , namespaces [ "svg" ] ) : self . phase = self . phases [ "inForeignContent" ] self . secondaryPhase = self . phases [ "inBody" ] break elif nodeName == "html" : if self . tree . headPointer is None : self . phase = self . phases [ "beforeHead" ] else : self . phase = self . phases [ "afterHead" ] break elif last : self . phase = self . phases [ "inBody" ] break def parseRCDataRawtext ( self , token , contentType ) : assert contentType in ( "RAWTEXT" , "RCDATA" ) element = self . tree . insertElement ( token ) if contentType == "RAWTEXT" : self . tokenizer . state = self . tokenizer . rawtextState else : self . tokenizer . state = self . tokenizer . rcdataState self . originalPhase = self . phase self . phase = self . phases [ "text" ] class Phase ( object ) : def __init__ ( self , parser , tree ) : self . parser = parser self . tree = tree def processEOF ( self ) : raise NotImplementedError def processComment ( self , token ) : self . tree . insertComment ( token , self . tree . openElements [ - 1 ] ) def processDoctype ( self , token ) : self . parser . parseError ( "unexpected-doctype" ) def processCharacters ( self , token ) : self . tree . insertText ( token [ "data" ] ) def processSpaceCharacters ( self , token ) : self . tree . insertText ( token [ "data" ] ) def processStartTag ( self , token ) : self . startTagHandler [ token [ "name" ] ] ( token ) def startTagHtml ( self , token ) : if self . parser . firstStartTag == False and token [ "name" ] == "html" : self . parser . parseError ( "non-html-root" ) for attr , value in token [ "data" ] . iteritems ( ) : if attr not in self . tree . openElements [ 0 ] . attributes : self . tree . openElements [ 0 ] . attributes [ attr ] = value self . parser . firstStartTag = False def processEndTag ( self , token ) : self . endTagHandler [ token [ "name" ] ] ( token ) class InitialPhase ( Phase ) : def processSpaceCharacters ( self , token ) : pass def processComment ( self , token ) : self . tree . insertComment ( token , self . tree . document ) def processDoctype ( self , token ) : name = token [ "name" ] publicId = token [ "publicId" ] systemId = token [ "systemId" ] correct = token [ "correct" ] if ( name != "html" or publicId != None or systemId != None and systemId != "about:legacy-compat" ) : self . parser . parseError ( "unknown-doctype" ) if publicId is None : publicId = "" self . tree . insertDoctype ( token ) if publicId != "" : publicId = publicId . translate ( asciiUpper2Lower ) if ( not correct or token [ "name" ] != "html" or publicId . startswith ( ( "+//silmaril//dtd html pro v0r11 19970101//" , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ) ) or publicId in ( "-//w3o//dtd w3 html strict 3.0//en//" , , ) or publicId . startswith ( ( "-//w3c//dtd html 4.01 frameset//" , ) ) and systemId == None or systemId and systemId . lower ( ) == "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd" ) : self . parser . compatMode = "quirks" elif ( publicId . startswith ( ( "-//w3c//dtd xhtml 1.0 frameset//" , ) ) or publicId . startswith ( ( "-//w3c//dtd html 4.01 frameset//" , ) ) and systemId != None ) : self . parser . compatMode = "limited quirks" self . parser . phase = self . parser . phases [ "beforeHtml" ] def anythingElse ( self ) : self . parser . compatMode = "quirks" self . parser . phase = self . parser . phases [ "beforeHtml" ] def processCharacters ( self , token ) : self . parser . parseError ( "expected-doctype-but-got-chars" ) self . anythingElse ( ) self . parser . phase . processCharacters ( token ) def processStartTag ( self , token ) : self . parser . parseError ( "expected-doctype-but-got-start-tag" , { "name" : token [ "name" ] } ) self . anythingElse ( ) self . parser . phase . processStartTag ( token ) def processEndTag ( self , token ) : self . parser . parseError ( "expected-doctype-but-got-end-tag" , { "name" : token [ "name" ] } ) self . anythingElse ( ) self . parser . phase . processEndTag ( token ) def processEOF ( self ) : self . parser . parseError ( "expected-doctype-but-got-eof" ) self . anythingElse ( ) self . parser . phase . processEOF ( ) class BeforeHtmlPhase ( Phase ) : def insertHtmlElement ( self ) : self . tree . insertRoot ( impliedTagToken ( "html" , "StartTag" ) ) self . parser . phase = self . parser . phases [ "beforeHead" ] def processEOF ( self ) : self . insertHtmlElement ( ) self . parser . phase . processEOF ( ) def processComment ( self , token ) : self . tree . insertComment ( token , self . tree . document ) def processSpaceCharacters ( self , token ) : pass def processCharacters ( self , token ) : self . insertHtmlElement ( ) self . parser . phase . processCharacters ( token ) def processStartTag ( self , token ) : if token [ "name" ] == "html" : self . parser . firstStartTag = True self . insertHtmlElement ( ) self . parser . phase . processStartTag ( token ) def processEndTag ( self , token ) : if token [ "name" ] not in ( "head" , "body" , "html" , "br" ) : self . parser . parseError ( "unexpected-end-tag-before-html" , { "name" : token [ "name" ] } ) else : self . insertHtmlElement ( ) self . parser . phase . processEndTag ( token ) class BeforeHeadPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( "head" , self . startTagHead ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( ( "head" , "body" , "html" , "br" ) , self . endTagImplyHead ) ] ) self . endTagHandler . default = self . endTagOther def processEOF ( self ) : self . startTagHead ( impliedTagToken ( "head" , "StartTag" ) ) self . parser . phase . processEOF ( ) def processSpaceCharacters ( self , token ) : pass def processCharacters ( self , token ) : self . startTagHead ( impliedTagToken ( "head" , "StartTag" ) ) self . parser . phase . processCharacters ( token ) def startTagHtml ( self , token ) : self . parser . phases [ "inBody" ] . processStartTag ( token ) def startTagHead ( self , token ) : self . tree . insertElement ( token ) self . tree . headPointer = self . tree . openElements [ - 1 ] self . parser . phase = self . parser . phases [ "inHead" ] def startTagOther ( self , token ) : self . startTagHead ( impliedTagToken ( "head" , "StartTag" ) ) self . parser . phase . processStartTag ( token ) def endTagImplyHead ( self , token ) : self . startTagHead ( impliedTagToken ( "head" , "StartTag" ) ) self . parser . phase . processEndTag ( token ) def endTagOther ( self , token ) : self . parser . parseError ( "end-tag-after-implied-root" , { "name" : token [ "name" ] } ) class InHeadPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( "title" , self . startTagTitle ) , ( ( "noscript" , "noframes" , "style" ) , self . startTagNoScriptNoFramesStyle ) , ( "script" , self . startTagScript ) , ( ( "base" , "link" , "command" ) , self . startTagBaseLinkCommand ) , ( "meta" , self . startTagMeta ) , ( "head" , self . startTagHead ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "head" , self . endTagHead ) , ( ( "br" , "html" , "body" ) , self . endTagHtmlBodyBr ) ] ) self . endTagHandler . default = self . endTagOther def appendToHead ( self , element ) : if self . tree . headPointer is not None : self . tree . headPointer . appendChild ( element ) else : assert self . parser . innerHTML self . tree . openElementsw [ - 1 ] . appendChild ( element ) def processEOF ( self ) : self . anythingElse ( ) self . parser . phase . processEOF ( ) def processCharacters ( self , token ) : self . anythingElse ( ) self . parser . phase . processCharacters ( token ) def startTagHtml ( self , token ) : self . parser . phases [ "inBody" ] . processStartTag ( token ) def startTagHead ( self , token ) : self . parser . parseError ( "two-heads-are-not-better-than-one" ) def startTagBaseLinkCommand ( self , token ) : self . tree . insertElement ( token ) self . tree . openElements . pop ( ) token [ "selfClosingAcknowledged" ] = True def startTagMeta ( self , token ) : self . tree . insertElement ( token ) self . tree . openElements . pop ( ) token [ "selfClosingAcknowledged" ] = True attributes = token [ "data" ] if self . parser . tokenizer . stream . charEncoding [ 1 ] == "tentative" : if "charset" in attributes : self . parser . tokenizer . stream . changeEncoding ( attributes [ "charset" ] ) elif "content" in attributes : data = inputstream . EncodingBytes ( attributes [ "content" ] . encode ( "utf-8" ) ) parser = inputstream . ContentAttrParser ( data ) codec = parser . parse ( ) self . parser . tokenizer . stream . changeEncoding ( codec ) def startTagTitle ( self , token ) : self . parser . parseRCDataRawtext ( token , "RCDATA" ) def startTagNoScriptNoFramesStyle ( self , token ) : self . parser . parseRCDataRawtext ( token , "RAWTEXT" ) def startTagScript ( self , token ) : self . tree . insertElement ( token ) self . parser . tokenizer . state = self . parser . tokenizer . scriptDataState self . parser . originalPhase = self . parser . phase self . parser . phase = self . parser . phases [ "text" ] def startTagOther ( self , token ) : self . anythingElse ( ) self . parser . phase . processStartTag ( token ) def endTagHead ( self , token ) : node = self . parser . tree . openElements . pop ( ) assert node . name == "head" , "Expected head got %s" % node . name self . parser . phase = self . parser . phases [ "afterHead" ] def endTagHtmlBodyBr ( self , token ) : self . anythingElse ( ) self . parser . phase . processEndTag ( token ) def endTagOther ( self , token ) : self . parser . parseError ( "unexpected-end-tag" , { "name" : token [ "name" ] } ) def anythingElse ( self ) : self . endTagHead ( impliedTagToken ( "head" ) ) class AfterHeadPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( "body" , self . startTagBody ) , ( "frameset" , self . startTagFrameset ) , ( ( "base" , "link" , "meta" , "noframes" , "script" , "style" , "title" ) , self . startTagFromHead ) , ( "head" , self . startTagHead ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( ( "body" , "html" , "br" ) , self . endTagHtmlBodyBr ) ] ) self . endTagHandler . default = self . endTagOther def processEOF ( self ) : self . anythingElse ( ) self . parser . phase . processEOF ( ) def processCharacters ( self , token ) : self . anythingElse ( ) self . parser . phase . processCharacters ( token ) def startTagBody ( self , token ) : self . parser . framesetOK = False self . tree . insertElement ( token ) self . parser . phase = self . parser . phases [ "inBody" ] def startTagFrameset ( self , token ) : self . tree . insertElement ( token ) self . parser . phase = self . parser . phases [ "inFrameset" ] def startTagFromHead ( self , token ) : self . parser . parseError ( "unexpected-start-tag-out-of-my-head" , { "name" : token [ "name" ] } ) self . tree . openElements . append ( self . tree . headPointer ) self . parser . phases [ "inHead" ] . processStartTag ( token ) for node in self . tree . openElements [ : : - 1 ] : if node . name == "head" : self . tree . openElements . remove ( node ) break def startTagHead ( self , token ) : self . parser . parseError ( "unexpected-start-tag" , { "name" : token [ "name" ] } ) def startTagOther ( self , token ) : self . anythingElse ( ) self . parser . phase . processStartTag ( token ) def endTagHtmlBodyBr ( self , token ) : self . anythingElse ( ) self . parser . phase . processEndTag ( token ) def endTagOther ( self , token ) : self . parser . parseError ( "unexpected-end-tag" , { "name" : token [ "name" ] } ) def anythingElse ( self ) : self . tree . insertElement ( impliedTagToken ( "body" , "StartTag" ) ) self . parser . phase = self . parser . phases [ "inBody" ] self . parser . framesetOK = True class InBodyPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . processSpaceCharactersNonPre = self . processSpaceCharacters self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( ( "base" , "command" , "link" , "meta" , "noframes" , "script" , "style" , ) , self . startTagProcessInHead ) , ( "body" , self . startTagBody ) , ( "frameset" , self . startTagFrameset ) , ( ( "address" , "article" , "aside" , "blockquote" , "center" , "datagrid" , , "dir" , "div" , "dl" , "fieldset" , "figure" , , "header" , "hgroup" , "menu" , "nav" , "ol" , "p" , , "ul" ) , self . startTagCloseP ) , ( ( "pre" , "listing" ) , self . startTagPreListing ) , ( "form" , self . startTagForm ) , ( ( "li" , "dd" , "dt" ) , self . startTagListItem ) , ( "plaintext" , self . startTagPlaintext ) , ( headingElements , self . startTagHeading ) , ( "a" , self . startTagA ) , ( ( "b" , "big" , "code" , "em" , "font" , "i" , "s" , "small" , "strike" , , "tt" , "u" ) , self . startTagFormatting ) , ( "nobr" , self . startTagNobr ) , ( "button" , self . startTagButton ) , ( ( "applet" , "marquee" , "object" ) , self . startTagAppletMarqueeObject ) , ( "xmp" , self . startTagXmp ) , ( "table" , self . startTagTable ) , ( ( "area" , "basefont" , "bgsound" , "br" , "embed" , "img" , "input" , , "spacer" , "wbr" ) , self . startTagVoidFormatting ) , ( ( "param" , "source" ) , self . startTagParamSource ) , ( "hr" , self . startTagHr ) , ( "image" , self . startTagImage ) , ( "isindex" , self . startTagIsIndex ) , ( "textarea" , self . startTagTextarea ) , ( "iframe" , self . startTagIFrame ) , ( ( "noembed" , "noframes" , "noscript" ) , self . startTagRawtext ) , ( "select" , self . startTagSelect ) , ( ( "rp" , "rt" ) , self . startTagRpRt ) , ( ( "option" , "optgroup" ) , self . startTagOpt ) , ( ( "math" ) , self . startTagMath ) , ( ( "svg" ) , self . startTagSvg ) , ( ( "caption" , "col" , "colgroup" , "frame" , "head" , , "td" , "tfoot" , "th" , "thead" , ) , self . startTagMisplaced ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "body" , self . endTagBody ) , ( "html" , self . endTagHtml ) , ( ( "address" , "article" , "aside" , "blockquote" , "center" , "datagrid" , , "dir" , "div" , "dl" , "fieldset" , "figure" , , "header" , "hgroup" , "listing" , "menu" , "nav" , "ol" , "pre" , , "ul" ) , self . endTagBlock ) , ( "form" , self . endTagForm ) , ( "p" , self . endTagP ) , ( ( "dd" , "dt" , "li" ) , self . endTagListItem ) , ( headingElements , self . endTagHeading ) , ( ( "a" , "b" , "big" , "code" , "em" , "font" , "i" , "nobr" , "s" , "small" , , "strong" , "tt" , "u" ) , self . endTagFormatting ) , ( ( "applet" , "button" , "marquee" , "object" ) , self . endTagAppletButtonMarqueeObject ) , ( "br" , self . endTagBr ) , ] ) self . endTagHandler . default = self . endTagOther def addFormattingElement ( self , token ) : self . tree . insertElement ( token ) self . tree . activeFormattingElements . append ( self . tree . openElements [ - 1 ] ) def processEOF ( self ) : allowed_elements = frozenset ( ( "dd" , "dt" , "li" , "p" , "tbody" , "td" , , "th" , "thead" , "tr" , "body" , ) ) for node in self . tree . openElements [ : : - 1 ] : if node . name not in allowed_elements : self . parser . parseError ( "expected-closing-tag-but-got-eof" ) break def processSpaceCharactersDropNewline ( self , token ) : data = token [ "data" ] self . processSpaceCharacters = self . processSpaceCharactersNonPre if ( data . startswith ( "\n" ) and self . tree . openElements [ - 1 ] . name in ( "pre" , "listing" , "textarea" ) and not self . tree . openElements [ - 1 ] . hasContent ( ) ) : data = data [ 1 : ] if data : self . tree . reconstructActiveFormattingElements ( ) self . tree . insertText ( data ) def processCharacters ( self , token ) : self . tree . reconstructActiveFormattingElements ( ) self . tree . insertText ( token [ "data" ] ) self . parser . framesetOK = False def processSpaceCharacters ( self , token ) : self . tree . reconstructActiveFormattingElements ( ) self . tree . insertText ( token [ "data" ] ) def startTagProcessInHead ( self , token ) : self . parser . phases [ "inHead" ] . processStartTag ( token ) def startTagBody ( self , token ) : self . parser . parseError ( "unexpected-start-tag" , { "name" : "body" } ) if ( len ( self . tree . openElements ) == 1 or self . tree . openElements [ 1 ] . name != "body" ) : assert self . parser . innerHTML else : for attr , value in token [ "data" ] . iteritems ( ) : if attr not in self . tree . openElements [ 1 ] . attributes : self . tree . openElements [ 1 ] . attributes [ attr ] = value def startTagFrameset ( self , token ) : self . parser . parseError ( "unexpected-start-tag" , { "name" : "frameset" } ) if ( len ( self . tree . openElements ) == 1 or self . tree . openElements [ 1 ] . name != "body" ) : assert self . parser . innerHTML elif not self . parser . framesetOK : pass else : if self . tree . openElements [ 1 ] . parent : self . tree . openElements [ 1 ] . parent . removeChild ( self . tree . openElements [ 1 ] ) while self . tree . openElements [ - 1 ] . name != "html" : self . tree . openElements . pop ( ) self . tree . insertElement ( token ) self . parser . phase = self . parser . phases [ "inFrameset" ] def startTagCloseP ( self , token ) : if self . tree . elementInScope ( "p" ) : self . endTagP ( impliedTagToken ( "p" ) ) self . tree . insertElement ( token ) def startTagPreListing ( self , token ) : if self . tree . elementInScope ( "p" ) : self . endTagP ( impliedTagToken ( "p" ) ) self . tree . insertElement ( token ) self . parser . framesetOK = False self . processSpaceCharacters = self . processSpaceCharactersDropNewline def startTagForm ( self , token ) : if self . tree . formPointer : self . parser . parseError ( u"unexpected-start-tag" , { "name" : "form" } ) else : if self . tree . elementInScope ( "p" ) : self . endTagP ( "p" ) self . tree . insertElement ( token ) self . tree . formPointer = self . tree . openElements [ - 1 ] def startTagListItem ( self , token ) : self . parser . framesetOK = False stopNamesMap = { "li" : [ "li" ] , : [ "dt" , "dd" ] , : [ "dt" , "dd" ] } stopNames = stopNamesMap [ token [ "name" ] ] for node in reversed ( self . tree . openElements ) : if node . name in stopNames : self . parser . phase . processEndTag ( impliedTagToken ( node . name , "EndTag" ) ) break if ( node . nameTuple in ( scopingElements | specialElements ) and node . name not in ( "address" , "div" , "p" ) ) : break if self . tree . elementInScope ( "p" ) : self . parser . phase . processEndTag ( impliedTagToken ( "p" , "EndTag" ) ) self . tree . insertElement ( token ) def startTagPlaintext ( self , token ) : if self . tree . elementInScope ( "p" ) : self . endTagP ( impliedTagToken ( "p" ) ) self . tree . insertElement ( token ) self . parser . tokenizer . state = self . parser . tokenizer . plaintextState def startTagHeading ( self , token ) : if self . tree . elementInScope ( "p" ) : self . endTagP ( impliedTagToken ( "p" ) ) if self . tree . openElements [ - 1 ] . name in headingElements : self . parser . parseError ( "unexpected-start-tag" , { "name" : token [ "name" ] } ) self . tree . openElements . pop ( ) self . tree . insertElement ( token ) def startTagA ( self , token ) : afeAElement = self . tree . elementInActiveFormattingElements ( "a" ) if afeAElement : self . parser . parseError ( "unexpected-start-tag-implies-end-tag" , { "startName" : "a" , "endName" : "a" } ) self . endTagFormatting ( impliedTagToken ( "a" ) ) if afeAElement in self . tree . openElements : self . tree . openElements . remove ( afeAElement ) if afeAElement in self . tree . activeFormattingElements : self . tree . activeFormattingElements . remove ( afeAElement ) self . tree . reconstructActiveFormattingElements ( ) self . addFormattingElement ( token ) def startTagFormatting ( self , token ) : self . tree . reconstructActiveFormattingElements ( ) self . addFormattingElement ( token ) def startTagNobr ( self , token ) : self . tree . reconstructActiveFormattingElements ( ) if self . tree . elementInScope ( "nobr" ) : self . parser . parseError ( "unexpected-start-tag-implies-end-tag" , { "startName" : "nobr" , "endName" : "nobr" } ) self . processEndTag ( impliedTagToken ( "nobr" ) ) self . tree . reconstructActiveFormattingElements ( ) self . addFormattingElement ( token ) def startTagButton ( self , token ) : if self . tree . elementInScope ( "button" ) : self . parser . parseError ( "unexpected-start-tag-implies-end-tag" , { "startName" : "button" , "endName" : "button" } ) self . processEndTag ( impliedTagToken ( "button" ) ) self . parser . phase . processStartTag ( token ) else : self . tree . reconstructActiveFormattingElements ( ) self . tree . insertElement ( token ) self . tree . activeFormattingElements . append ( Marker ) self . parser . framesetOK = False def startTagAppletMarqueeObject ( self , token ) : self . tree . reconstructActiveFormattingElements ( ) self . tree . insertElement ( token ) self . tree . activeFormattingElements . append ( Marker ) self . parser . framesetOK = False def startTagXmp ( self , token ) : if self . tree . elementInScope ( "p" ) : self . endTagP ( impliedTagToken ( "p" ) ) self . tree . reconstructActiveFormattingElements ( ) self . parser . framesetOK = False self . parser . parseRCDataRawtext ( token , "RAWTEXT" ) def startTagTable ( self , token ) : if self . parser . compatMode != "quirks" : if self . tree . elementInScope ( "p" ) : self . processEndTag ( impliedTagToken ( "p" ) ) self . tree . insertElement ( token ) self . parser . framesetOK = False self . parser . phase = self . parser . phases [ "inTable" ] def startTagVoidFormatting ( self , token ) : self . tree . reconstructActiveFormattingElements ( ) self . tree . insertElement ( token ) self . tree . openElements . pop ( ) token [ "selfClosingAcknowledged" ] = True self . parser . framesetOK = False def startTagParamSource ( self , token ) : self . tree . insertElement ( token ) self . tree . openElements . pop ( ) token [ "selfClosingAcknowledged" ] = True def startTagHr ( self , token ) : if self . tree . elementInScope ( "p" ) : self . endTagP ( impliedTagToken ( "p" ) ) self . tree . insertElement ( token ) self . tree . openElements . pop ( ) token [ "selfClosingAcknowledged" ] = True self . parser . framesetOK = False def startTagImage ( self , token ) : self . parser . parseError ( "unexpected-start-tag-treated-as" , { "originalName" : "image" , "newName" : "img" } ) self . processStartTag ( impliedTagToken ( "img" , "StartTag" , attributes = token [ "data" ] , selfClosing = token [ "selfClosing" ] ) ) def startTagIsIndex ( self , token ) : self . parser . parseError ( "deprecated-tag" , { "name" : "isindex" } ) if self . tree . formPointer : return form_attrs = { } if "action" in token [ "data" ] : form_attrs [ "action" ] = token [ "data" ] [ "action" ] self . processStartTag ( impliedTagToken ( "form" , "StartTag" , attributes = form_attrs ) ) self . processStartTag ( impliedTagToken ( "hr" , "StartTag" ) ) self . processStartTag ( impliedTagToken ( "label" , "StartTag" ) ) if "prompt" in token [ "data" ] : prompt = token [ "data" ] [ "prompt" ] else : prompt = "This is a searchable index. Insert your search keywords here: " self . processCharacters ( { "type" : tokenTypes [ "Characters" ] , "data" : prompt } ) attributes = token [ "data" ] . copy ( ) if "action" in attributes : del attributes [ "action" ] if "prompt" in attributes : del attributes [ "prompt" ] attributes [ "name" ] = "isindex" self . processStartTag ( impliedTagToken ( "input" , "StartTag" , attributes = attributes , selfClosing = token [ "selfClosing" ] ) ) self . processEndTag ( impliedTagToken ( "label" ) ) self . processStartTag ( impliedTagToken ( "hr" , "StartTag" ) ) self . processEndTag ( impliedTagToken ( "form" ) ) def startTagTextarea ( self , token ) : self . tree . insertElement ( token ) self . parser . tokenizer . state = self . parser . tokenizer . rcdataState self . processSpaceCharacters = self . processSpaceCharactersDropNewline self . parser . framesetOK = False def startTagIFrame ( self , token ) : self . parser . framesetOK = False self . startTagRawtext ( token ) def startTagRawtext ( self , token ) : self . parser . parseRCDataRawtext ( token , "RAWTEXT" ) def startTagOpt ( self , token ) : if self . tree . elementInScope ( "option" ) : self . parser . phase . processEndTag ( impliedTagToken ( "option" ) ) self . tree . reconstructActiveFormattingElements ( ) self . parser . tree . insertElement ( token ) def startTagSelect ( self , token ) : self . tree . reconstructActiveFormattingElements ( ) self . tree . insertElement ( token ) self . parser . framesetOK = False if self . parser . phase in ( self . parser . phases [ "inTable" ] , self . parser . phases [ "inCaption" ] , self . parser . phases [ "inColumnGroup" ] , self . parser . phases [ "inTableBody" ] , self . parser . phases [ "inRow" ] , self . parser . phases [ "inCell" ] ) : self . parser . phase = self . parser . phases [ "inSelectInTable" ] else : self . parser . phase = self . parser . phases [ "inSelect" ] def startTagRpRt ( self , token ) : if self . tree . elementInScope ( "ruby" ) : self . tree . generateImpliedEndTags ( ) if self . tree . openElements [ - 1 ] . name != "ruby" : self . parser . parseError ( ) while self . tree . openElements [ - 1 ] . name != "ruby" : self . tree . openElements . pop ( ) self . tree . insertElement ( token ) def startTagMath ( self , token ) : self . tree . reconstructActiveFormattingElements ( ) self . parser . adjustMathMLAttributes ( token ) self . parser . adjustForeignAttributes ( token ) token [ "namespace" ] = namespaces [ "mathml" ] self . tree . insertElement ( token ) if self . parser . phase != self . parser . phases [ "inForeignContent" ] : self . parser . secondaryPhase = self . parser . phase self . parser . phase = self . parser . phases [ "inForeignContent" ] if token [ "selfClosing" ] : self . tree . openElements . pop ( ) token [ "selfClosingAcknowledged" ] = True def startTagSvg ( self , token ) : self . tree . reconstructActiveFormattingElements ( ) self . parser . adjustSVGAttributes ( token ) self . parser . adjustForeignAttributes ( token ) token [ "namespace" ] = namespaces [ "svg" ] self . tree . insertElement ( token ) if self . parser . phase != self . parser . phases [ "inForeignContent" ] : self . parser . secondaryPhase = self . parser . phase self . parser . phase = self . parser . phases [ "inForeignContent" ] if token [ "selfClosing" ] : self . tree . openElements . pop ( ) token [ "selfClosingAcknowledged" ] = True def startTagMisplaced ( self , token ) : self . parser . parseError ( "unexpected-start-tag-ignored" , { "name" : token [ "name" ] } ) def startTagOther ( self , token ) : self . tree . reconstructActiveFormattingElements ( ) self . tree . insertElement ( token ) def endTagP ( self , token ) : if not self . tree . elementInScope ( "p" ) : self . startTagCloseP ( impliedTagToken ( "p" , "StartTag" ) ) self . parser . parseError ( "unexpected-end-tag" , { "name" : "p" } ) self . endTagP ( impliedTagToken ( "p" , "EndTag" ) ) else : self . tree . generateImpliedEndTags ( "p" ) if self . tree . openElements [ - 1 ] . name != "p" : self . parser . parseError ( "unexpected-end-tag" , { "name" : "p" } ) node = self . tree . openElements . pop ( ) while node . name != "p" : node = self . tree . openElements . pop ( ) def endTagBody ( self , token ) : if not self . tree . elementInScope ( "body" ) : self . parser . parseError ( ) return elif self . tree . openElements [ - 1 ] . name != "body" : for node in self . tree . openElements [ 2 : ] : if node . name not in frozenset ( ( "dd" , "dt" , "li" , "optgroup" , , "p" , "rp" , "rt" , , "td" , "tfoot" , , "thead" , "tr" , "body" , ) ) : self . parser . parseError ( , { "expectedName" : "body" , "gotName" : node . name } ) break self . parser . phase = self . parser . phases [ "afterBody" ] def endTagHtml ( self , token ) : if self . tree . elementInScope ( "body" ) : self . endTagBody ( impliedTagToken ( "body" ) ) self . parser . phase . processEndTag ( token ) def endTagBlock ( self , token ) : if token [ "name" ] == "pre" : self . processSpaceCharacters = self . processSpaceCharactersNonPre inScope = self . tree . elementInScope ( token [ "name" ] ) if inScope : self . tree . generateImpliedEndTags ( ) if self . tree . openElements [ - 1 ] . name != token [ "name" ] : self . parser . parseError ( "end-tag-too-early" , { "name" : token [ "name" ] } ) if inScope : node = self . tree . openElements . pop ( ) while node . name != token [ "name" ] : node = self . tree . openElements . pop ( ) def endTagForm ( self , token ) : node = self . tree . formPointer self . tree . formPointer = None if node is None or not self . tree . elementInScope ( node ) : self . parser . parseError ( "unexpected-end-tag" , { "name" : "form" } ) else : self . tree . generateImpliedEndTags ( ) if self . tree . openElements [ - 1 ] . name != node : self . parser . parseError ( "end-tag-too-early-ignored" , { "name" : "form" } ) self . tree . openElements . remove ( node ) def endTagListItem ( self , token ) : if token [ "name" ] == "li" : variant = "list" else : variant = None if not self . tree . elementInScope ( token [ "name" ] , variant = variant ) : self . parser . parseError ( "unexpected-end-tag" , { "name" : token [ "name" ] } ) else : self . tree . generateImpliedEndTags ( exclude = token [ "name" ] ) if self . tree . openElements [ - 1 ] . name != token [ "name" ] : self . parser . parseError ( , { "name" : token [ "name" ] } ) node = self . tree . openElements . pop ( ) while node . name != token [ "name" ] : node = self . tree . openElements . pop ( ) def endTagHeading ( self , token ) : for item in headingElements : if self . tree . elementInScope ( item ) : self . tree . generateImpliedEndTags ( ) break if self . tree . openElements [ - 1 ] . name != token [ "name" ] : self . parser . parseError ( "end-tag-too-early" , { "name" : token [ "name" ] } ) for item in headingElements : if self . tree . elementInScope ( item ) : item = self . tree . openElements . pop ( ) while item . name not in headingElements : item = self . tree . openElements . pop ( ) break def endTagFormatting ( self , token ) : name = token [ "name" ] while True : formattingElement = self . tree . elementInActiveFormattingElements ( token [ "name" ] ) if not formattingElement or ( formattingElement in self . tree . openElements and not self . tree . elementInScope ( formattingElement . name ) ) : self . parser . parseError ( "adoption-agency-1.1" , { "name" : token [ "name" ] } ) return elif formattingElement not in self . tree . openElements : self . parser . parseError ( "adoption-agency-1.2" , { "name" : token [ "name" ] } ) self . tree . activeFormattingElements . remove ( formattingElement ) return if formattingElement != self . tree . openElements [ - 1 ] : self . parser . parseError ( "adoption-agency-1.3" , { "name" : token [ "name" ] } ) afeIndex = self . tree . openElements . index ( formattingElement ) furthestBlock = None for element in self . tree . openElements [ afeIndex : ] : if ( element . nameTuple in specialElements | scopingElements ) : furthestBlock = element break if furthestBlock is None : element = self . tree . openElements . pop ( ) while element != formattingElement : element = self . tree . openElements . pop ( ) self . tree . activeFormattingElements . remove ( element ) return commonAncestor = self . tree . openElements [ afeIndex - 1 ] bookmark = self . tree . activeFormattingElements . index ( formattingElement ) lastNode = node = furthestBlock while True : node = self . tree . openElements [ self . tree . openElements . index ( node ) - 1 ] while node not in self . tree . activeFormattingElements : tmpNode = node node = self . tree . openElements [ self . tree . openElements . index ( node ) - 1 ] self . tree . openElements . remove ( tmpNode ) if node == formattingElement : break if lastNode == furthestBlock : bookmark = ( self . tree . activeFormattingElements . index ( node ) + 1 ) clone = node . cloneNode ( ) self . tree . activeFormattingElements [ self . tree . activeFormattingElements . index ( node ) ] = clone self . tree . openElements [ self . tree . openElements . index ( node ) ] = clone node = clone if lastNode . parent : lastNode . parent . removeChild ( lastNode ) node . appendChild ( lastNode ) lastNode = node if lastNode . parent : lastNode . parent . removeChild ( lastNode ) commonAncestor . appendChild ( lastNode ) clone = formattingElement . cloneNode ( ) furthestBlock . reparentChildren ( clone ) furthestBlock . appendChild ( clone ) self . tree . activeFormattingElements . remove ( formattingElement ) self . tree . activeFormattingElements . insert ( bookmark , clone ) self . tree . openElements . remove ( formattingElement ) self . tree . openElements . insert ( self . tree . openElements . index ( furthestBlock ) + 1 , clone ) def endTagAppletButtonMarqueeObject ( self , token ) : if self . tree . elementInScope ( token [ "name" ] ) : self . tree . generateImpliedEndTags ( ) if self . tree . openElements [ - 1 ] . name != token [ "name" ] : self . parser . parseError ( "end-tag-too-early" , { "name" : token [ "name" ] } ) if self . tree . elementInScope ( token [ "name" ] ) : element = self . tree . openElements . pop ( ) while element . name != token [ "name" ] : element = self . tree . openElements . pop ( ) self . tree . clearActiveFormattingElements ( ) def endTagBr ( self , token ) : self . parser . parseError ( "unexpected-end-tag-treated-as" , { "originalName" : "br" , "newName" : "br element" } ) self . tree . reconstructActiveFormattingElements ( ) self . tree . insertElement ( impliedTagToken ( "br" , "StartTag" ) ) self . tree . openElements . pop ( ) def endTagOther ( self , token ) : for node in self . tree . openElements [ : : - 1 ] : if node . name == token [ "name" ] : self . tree . generateImpliedEndTags ( ) if self . tree . openElements [ - 1 ] . name != token [ "name" ] : self . parser . parseError ( "unexpected-end-tag" , { "name" : token [ "name" ] } ) while self . tree . openElements . pop ( ) != node : pass break else : if ( node . nameTuple in specialElements | scopingElements ) : self . parser . parseError ( "unexpected-end-tag" , { "name" : token [ "name" ] } ) break class TextPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "script" , self . endTagScript ) ] ) self . endTagHandler . default = self . endTagOther def processCharacters ( self , token ) : self . tree . insertText ( token [ "data" ] ) def processEOF ( self ) : self . parser . parseError ( "expected-named-closing-tag-but-got-eof" , self . tree . openElements [ - 1 ] . name ) self . tree . openElements . pop ( ) self . parser . phase = self . parser . originalPhase self . parser . phase . processEOF ( ) def startTagOther ( self , token ) : assert False , "Tried to process start tag %s in RCDATA/RAWTEXT mode" % name def endTagScript ( self , token ) : node = self . tree . openElements . pop ( ) assert node . name == "script" self . parser . phase = self . parser . originalPhase def endTagOther ( self , token ) : node = self . tree . openElements . pop ( ) self . parser . phase = self . parser . originalPhase class InTablePhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( "caption" , self . startTagCaption ) , ( "colgroup" , self . startTagColgroup ) , ( "col" , self . startTagCol ) , ( ( "tbody" , "tfoot" , "thead" ) , self . startTagRowGroup ) , ( ( "td" , "th" , "tr" ) , self . startTagImplyTbody ) , ( "table" , self . startTagTable ) , ( ( "style" , "script" ) , self . startTagStyleScript ) , ( "input" , self . startTagInput ) , ( "form" , self . startTagForm ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "table" , self . endTagTable ) , ( ( "body" , "caption" , "col" , "colgroup" , "html" , "tbody" , "td" , , "th" , "thead" , "tr" ) , self . endTagIgnore ) ] ) self . endTagHandler . default = self . endTagOther def clearStackToTableContext ( self ) : while self . tree . openElements [ - 1 ] . name not in ( "table" , "html" ) : self . tree . openElements . pop ( ) def getCurrentTable ( self ) : i = - 1 while - i <= len ( self . tree . openElements ) and self . tree . openElements [ i ] . name != "table" : i -= 1 if - i > len ( self . tree . openElements ) : return self . tree . openElements [ 0 ] else : return self . tree . openElements [ i ] def processEOF ( self ) : if self . tree . openElements [ - 1 ] . name != "html" : self . parser . parseError ( "eof-in-table" ) else : assert self . parser . innerHTML def processSpaceCharacters ( self , token ) : originalPhase = self . parser . phase self . parser . phase = self . parser . phases [ "inTableText" ] self . parser . phase . originalPhase = originalPhase self . parser . phase . characterTokens . append ( token ) def processCharacters ( self , token ) : self . tree . insertFromTable = True self . parser . phases [ "inBody" ] . processCharacters ( token ) self . tree . insertFromTable = False def startTagCaption ( self , token ) : self . clearStackToTableContext ( ) self . tree . activeFormattingElements . append ( Marker ) self . tree . insertElement ( token ) self . parser . phase = self . parser . phases [ "inCaption" ] def startTagColgroup ( self , token ) : self . clearStackToTableContext ( ) self . tree . insertElement ( token ) self . parser . phase = self . parser . phases [ "inColumnGroup" ] def startTagCol ( self , token ) : self . startTagColgroup ( impliedTagToken ( "colgroup" , "StartTag" ) ) self . parser . phase . processStartTag ( token ) def startTagRowGroup ( self , token ) : self . clearStackToTableContext ( ) self . tree . insertElement ( token ) self . parser . phase = self . parser . phases [ "inTableBody" ] def startTagImplyTbody ( self , token ) : self . startTagRowGroup ( impliedTagToken ( "tbody" , "StartTag" ) ) self . parser . phase . processStartTag ( token ) def startTagTable ( self , token ) : self . parser . parseError ( "unexpected-start-tag-implies-end-tag" , { "startName" : "table" , "endName" : "table" } ) self . parser . phase . processEndTag ( impliedTagToken ( "table" ) ) if not self . parser . innerHTML : self . parser . phase . processStartTag ( token ) def startTagStyleScript ( self , token ) : self . parser . phases [ "inHead" ] . processStartTag ( token ) def startTagInput ( self , token ) : if ( "type" in token [ "data" ] and token [ "data" ] [ "type" ] . translate ( asciiUpper2Lower ) == "hidden" ) : self . parser . parseError ( "unexpected-hidden-input-in-table" ) self . tree . insertElement ( token ) self . tree . openElements . pop ( ) else : self . startTagOther ( token ) def startTagForm ( self , token ) : self . parser . parseError ( "unexpected-form-in-table" ) self . tree . insertElement ( token ) self . tree . openElements . pop ( ) def startTagOther ( self , token ) : self . parser . parseError ( "unexpected-start-tag-implies-table-voodoo" , { "name" : token [ "name" ] } ) if "tainted" not in self . getCurrentTable ( ) . _flags : self . getCurrentTable ( ) . _flags . append ( "tainted" ) self . tree . insertFromTable = True self . parser . phases [ "inBody" ] . processStartTag ( token ) self . tree . insertFromTable = False def endTagTable ( self , token ) : if self . tree . elementInScope ( "table" , variant = "table" ) : self . tree . generateImpliedEndTags ( ) if self . tree . openElements [ - 1 ] . name != "table" : self . parser . parseError ( "end-tag-too-early-named" , { "gotName" : "table" , : self . tree . openElements [ - 1 ] . name } ) while self . tree . openElements [ - 1 ] . name != "table" : self . tree . openElements . pop ( ) self . tree . openElements . pop ( ) self . parser . resetInsertionMode ( ) else : assert self . parser . innerHTML self . parser . parseError ( ) def endTagIgnore ( self , token ) : self . parser . parseError ( "unexpected-end-tag" , { "name" : token [ "name" ] } ) def endTagOther ( self , token ) : self . parser . parseError ( "unexpected-end-tag-implies-table-voodoo" , { "name" : token [ "name" ] } ) if "tainted" not in self . getCurrentTable ( ) . _flags : self . getCurrentTable ( ) . _flags . append ( "tainted" ) self . tree . insertFromTable = True self . parser . phases [ "inBody" ] . processEndTag ( token ) self . tree . insertFromTable = False class InTableTextPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . originalPhase = None self . characterTokens = [ ] def flushCharacters ( self ) : data = "" . join ( [ item [ "data" ] for item in self . characterTokens ] ) if any ( [ item not in spaceCharacters for item in data ] ) : token = { "type" : tokenTypes [ "Characters" ] , "data" : data } self . originalPhase . processCharacters ( token ) elif data : self . tree . insertText ( data ) self . characterTokens = [ ] def processComment ( self , token ) : self . flushCharacters ( ) self . phase = self . originalPhase self . phase . processComment ( token ) def processEOF ( self ) : self . flushCharacters ( ) self . phase = self . originalPhase self . phase . processEOF ( ) def processCharacters ( self , token ) : self . characterTokens . append ( token ) def processSpaceCharacters ( self , token ) : self . characterTokens . append ( token ) def processStartTag ( self , token ) : self . flushCharacters ( ) self . phase = self . originalPhase self . phase . processStartTag ( token ) def processEndTag ( self , token ) : self . flushCharacters ( ) self . phase = self . originalPhase self . phase . processEndTag ( token ) class InCaptionPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( ( "caption" , "col" , "colgroup" , "tbody" , "td" , "tfoot" , "th" , , "tr" ) , self . startTagTableElement ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "caption" , self . endTagCaption ) , ( "table" , self . endTagTable ) , ( ( "body" , "col" , "colgroup" , "html" , "tbody" , "td" , "tfoot" , "th" , , "tr" ) , self . endTagIgnore ) ] ) self . endTagHandler . default = self . endTagOther def ignoreEndTagCaption ( self ) : return not self . tree . elementInScope ( "caption" , variant = "table" ) def processEOF ( self ) : self . parser . phases [ "inBody" ] . processEOF ( ) def processCharacters ( self , token ) : self . parser . phases [ "inBody" ] . processCharacters ( token ) def startTagTableElement ( self , token ) : self . parser . parseError ( ) ignoreEndTag = self . ignoreEndTagCaption ( ) self . parser . phase . processEndTag ( impliedTagToken ( "caption" ) ) if not ignoreEndTag : self . parser . phase . processStartTag ( token ) def startTagOther ( self , token ) : self . parser . phases [ "inBody" ] . processStartTag ( token ) def endTagCaption ( self , token ) : if not self . ignoreEndTagCaption ( ) : self . tree . generateImpliedEndTags ( ) if self . tree . openElements [ - 1 ] . name != "caption" : self . parser . parseError ( "expected-one-end-tag-but-got-another" , { "gotName" : "caption" , : self . tree . openElements [ - 1 ] . name } ) while self . tree . openElements [ - 1 ] . name != "caption" : self . tree . openElements . pop ( ) self . tree . openElements . pop ( ) self . tree . clearActiveFormattingElements ( ) self . parser . phase = self . parser . phases [ "inTable" ] else : assert self . parser . innerHTML self . parser . parseError ( ) def endTagTable ( self , token ) : self . parser . parseError ( ) ignoreEndTag = self . ignoreEndTagCaption ( ) self . parser . phase . processEndTag ( impliedTagToken ( "caption" ) ) if not ignoreEndTag : self . parser . phase . processEndTag ( token ) def endTagIgnore ( self , token ) : self . parser . parseError ( "unexpected-end-tag" , { "name" : token [ "name" ] } ) def endTagOther ( self , token ) : self . parser . phases [ "inBody" ] . processEndTag ( token ) class InColumnGroupPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( "col" , self . startTagCol ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "colgroup" , self . endTagColgroup ) , ( "col" , self . endTagCol ) ] ) self . endTagHandler . default = self . endTagOther def ignoreEndTagColgroup ( self ) : return self . tree . openElements [ - 1 ] . name == "html" def processEOF ( self ) : if self . tree . openElements [ - 1 ] . name == "html" : assert self . parser . innerHTML return else : ignoreEndTag = self . ignoreEndTagColgroup ( ) self . endTagColgroup ( "colgroup" ) if not ignoreEndTag : self . parser . phase . processEOF ( ) def processCharacters ( self , token ) : ignoreEndTag = self . ignoreEndTagColgroup ( ) self . endTagColgroup ( impliedTagToken ( "colgroup" ) ) if not ignoreEndTag : self . parser . phase . processCharacters ( token ) def startTagCol ( self , token ) : self . tree . insertElement ( token ) self . tree . openElements . pop ( ) def startTagOther ( self , token ) : ignoreEndTag = self . ignoreEndTagColgroup ( ) self . endTagColgroup ( "colgroup" ) if not ignoreEndTag : self . parser . phase . processStartTag ( token ) def endTagColgroup ( self , token ) : if self . ignoreEndTagColgroup ( ) : assert self . parser . innerHTML self . parser . parseError ( ) else : self . tree . openElements . pop ( ) self . parser . phase = self . parser . phases [ "inTable" ] def endTagCol ( self , token ) : self . parser . parseError ( "no-end-tag" , { "name" : "col" } ) def endTagOther ( self , token ) : ignoreEndTag = self . ignoreEndTagColgroup ( ) self . endTagColgroup ( "colgroup" ) if not ignoreEndTag : self . parser . phase . processEndTag ( token ) class InTableBodyPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( "tr" , self . startTagTr ) , ( ( "td" , "th" ) , self . startTagTableCell ) , ( ( "caption" , "col" , "colgroup" , "tbody" , "tfoot" , "thead" ) , self . startTagTableOther ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( ( "tbody" , "tfoot" , "thead" ) , self . endTagTableRowGroup ) , ( "table" , self . endTagTable ) , ( ( "body" , "caption" , "col" , "colgroup" , "html" , "td" , "th" , ) , self . endTagIgnore ) ] ) self . endTagHandler . default = self . endTagOther def clearStackToTableBodyContext ( self ) : while self . tree . openElements [ - 1 ] . name not in ( "tbody" , "tfoot" , , "html" ) : self . tree . openElements . pop ( ) if self . tree . openElements [ - 1 ] . name == "html" : assert self . parser . innerHTML def processEOF ( self ) : self . parser . phases [ "inTable" ] . processEOF ( ) def processSpaceCharacters ( self , token ) : self . parser . phases [ "inTable" ] . processSpaceCharacters ( token ) def processCharacters ( self , token ) : self . parser . phases [ "inTable" ] . processCharacters ( token ) def startTagTr ( self , token ) : self . clearStackToTableBodyContext ( ) self . tree . insertElement ( token ) self . parser . phase = self . parser . phases [ "inRow" ] def startTagTableCell ( self , token ) : self . parser . parseError ( "unexpected-cell-in-table-body" , { "name" : token [ "name" ] } ) self . startTagTr ( impliedTagToken ( "tr" , "StartTag" ) ) self . parser . phase . processStartTag ( token ) def startTagTableOther ( self , token ) : if ( self . tree . elementInScope ( "tbody" , variant = "table" ) or self . tree . elementInScope ( "thead" , variant = "table" ) or self . tree . elementInScope ( "tfoot" , variant = "table" ) ) : self . clearStackToTableBodyContext ( ) self . endTagTableRowGroup ( impliedTagToken ( self . tree . openElements [ - 1 ] . name ) ) self . parser . phase . processStartTag ( token ) else : self . parser . parseError ( ) def startTagOther ( self , token ) : self . parser . phases [ "inTable" ] . processStartTag ( token ) def endTagTableRowGroup ( self , token ) : if self . tree . elementInScope ( token [ "name" ] , variant = "table" ) : self . clearStackToTableBodyContext ( ) self . tree . openElements . pop ( ) self . parser . phase = self . parser . phases [ "inTable" ] else : self . parser . parseError ( "unexpected-end-tag-in-table-body" , { "name" : token [ "name" ] } ) def endTagTable ( self , token ) : if ( self . tree . elementInScope ( "tbody" , variant = "table" ) or self . tree . elementInScope ( "thead" , variant = "table" ) or self . tree . elementInScope ( "tfoot" , variant = "table" ) ) : self . clearStackToTableBodyContext ( ) self . endTagTableRowGroup ( impliedTagToken ( self . tree . openElements [ - 1 ] . name ) ) self . parser . phase . processEndTag ( token ) else : self . parser . parseError ( ) def endTagIgnore ( self , token ) : self . parser . parseError ( "unexpected-end-tag-in-table-body" , { "name" : token [ "name" ] } ) def endTagOther ( self , token ) : self . parser . phases [ "inTable" ] . processEndTag ( token ) class InRowPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( ( "td" , "th" ) , self . startTagTableCell ) , ( ( "caption" , "col" , "colgroup" , "tbody" , "tfoot" , "thead" , ) , self . startTagTableOther ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "tr" , self . endTagTr ) , ( "table" , self . endTagTable ) , ( ( "tbody" , "tfoot" , "thead" ) , self . endTagTableRowGroup ) , ( ( "body" , "caption" , "col" , "colgroup" , "html" , "td" , "th" ) , self . endTagIgnore ) ] ) self . endTagHandler . default = self . endTagOther def clearStackToTableRowContext ( self ) : while self . tree . openElements [ - 1 ] . name not in ( "tr" , "html" ) : self . parser . parseError ( "unexpected-implied-end-tag-in-table-row" , { "name" : self . tree . openElements [ - 1 ] . name } ) self . tree . openElements . pop ( ) def ignoreEndTagTr ( self ) : return not self . tree . elementInScope ( "tr" , variant = "table" ) def processEOF ( self ) : self . parser . phases [ "inTable" ] . processEOF ( ) def processSpaceCharacters ( self , token ) : self . parser . phases [ "inTable" ] . processSpaceCharacters ( token ) def processCharacters ( self , token ) : self . parser . phases [ "inTable" ] . processCharacters ( token ) def startTagTableCell ( self , token ) : self . clearStackToTableRowContext ( ) self . tree . insertElement ( token ) self . parser . phase = self . parser . phases [ "inCell" ] self . tree . activeFormattingElements . append ( Marker ) def startTagTableOther ( self , token ) : ignoreEndTag = self . ignoreEndTagTr ( ) self . endTagTr ( "tr" ) if not ignoreEndTag : self . parser . phase . processStartTag ( token ) def startTagOther ( self , token ) : self . parser . phases [ "inTable" ] . processStartTag ( token ) def endTagTr ( self , token ) : if not self . ignoreEndTagTr ( ) : self . clearStackToTableRowContext ( ) self . tree . openElements . pop ( ) self . parser . phase = self . parser . phases [ "inTableBody" ] else : assert self . parser . innerHTML self . parser . parseError ( ) def endTagTable ( self , token ) : ignoreEndTag = self . ignoreEndTagTr ( ) self . endTagTr ( "tr" ) if not ignoreEndTag : self . parser . phase . processEndTag ( token ) def endTagTableRowGroup ( self , token ) : if self . tree . elementInScope ( token [ "name" ] , variant = "table" ) : self . endTagTr ( "tr" ) self . parser . phase . processEndTag ( token ) else : self . parser . parseError ( ) def endTagIgnore ( self , token ) : self . parser . parseError ( "unexpected-end-tag-in-table-row" , { "name" : token [ "name" ] } ) def endTagOther ( self , token ) : self . parser . phases [ "inTable" ] . processEndTag ( token ) class InCellPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( ( "caption" , "col" , "colgroup" , "tbody" , "td" , "tfoot" , "th" , , "tr" ) , self . startTagTableOther ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( ( "td" , "th" ) , self . endTagTableCell ) , ( ( "body" , "caption" , "col" , "colgroup" , "html" ) , self . endTagIgnore ) , ( ( "table" , "tbody" , "tfoot" , "thead" , "tr" ) , self . endTagImply ) ] ) self . endTagHandler . default = self . endTagOther def closeCell ( self ) : if self . tree . elementInScope ( "td" , variant = "table" ) : self . endTagTableCell ( impliedTagToken ( "td" ) ) elif self . tree . elementInScope ( "th" , variant = "table" ) : self . endTagTableCell ( impliedTagToken ( "th" ) ) def processEOF ( self ) : self . parser . phases [ "inBody" ] . processEOF ( ) def processCharacters ( self , token ) : self . parser . phases [ "inBody" ] . processCharacters ( token ) def startTagTableOther ( self , token ) : if ( self . tree . elementInScope ( "td" , variant = "table" ) or self . tree . elementInScope ( "th" , variant = "table" ) ) : self . closeCell ( ) self . parser . phase . processStartTag ( token ) else : self . parser . parseError ( ) def startTagOther ( self , token ) : self . parser . phases [ "inBody" ] . processStartTag ( token ) self . startTagHandler . default = self . parser . phases [ "inBody" ] . processStartTag def endTagTableCell ( self , token ) : if self . tree . elementInScope ( token [ "name" ] , variant = "table" ) : self . tree . generateImpliedEndTags ( token [ "name" ] ) if self . tree . openElements [ - 1 ] . name != token [ "name" ] : self . parser . parseError ( "unexpected-cell-end-tag" , { "name" : token [ "name" ] } ) while True : node = self . tree . openElements . pop ( ) if node . name == token [ "name" ] : break else : self . tree . openElements . pop ( ) self . tree . clearActiveFormattingElements ( ) self . parser . phase = self . parser . phases [ "inRow" ] else : self . parser . parseError ( "unexpected-end-tag" , { "name" : token [ "name" ] } ) def endTagIgnore ( self , token ) : self . parser . parseError ( "unexpected-end-tag" , { "name" : token [ "name" ] } ) def endTagImply ( self , token ) : if self . tree . elementInScope ( token [ "name" ] , variant = "table" ) : self . closeCell ( ) self . parser . phase . processEndTag ( token ) else : self . parser . parseError ( ) def endTagOther ( self , token ) : self . parser . phases [ "inBody" ] . processEndTag ( token ) self . endTagHandler . default = self . parser . phases [ "inBody" ] . processEndTag class InSelectPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( "option" , self . startTagOption ) , ( "optgroup" , self . startTagOptgroup ) , ( "select" , self . startTagSelect ) , ( ( "input" , "keygen" , "textarea" ) , self . startTagInput ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "option" , self . endTagOption ) , ( "optgroup" , self . endTagOptgroup ) , ( "select" , self . endTagSelect ) , ( ( "caption" , "table" , "tbody" , "tfoot" , "thead" , "tr" , "td" , ) , self . endTagTableElements ) ] ) self . endTagHandler . default = self . endTagOther def processEOF ( self ) : if self . tree . openElements [ - 1 ] . name != "html" : self . parser . parseError ( "eof-in-select" ) else : assert self . parser . innerHTML def processCharacters ( self , token ) : self . tree . insertText ( token [ "data" ] ) def startTagOption ( self , token ) : if self . tree . openElements [ - 1 ] . name == "option" : self . tree . openElements . pop ( ) self . tree . insertElement ( token ) def startTagOptgroup ( self , token ) : if self . tree . openElements [ - 1 ] . name == "option" : self . tree . openElements . pop ( ) if self . tree . openElements [ - 1 ] . name == "optgroup" : self . tree . openElements . pop ( ) self . tree . insertElement ( token ) def startTagSelect ( self , token ) : self . parser . parseError ( "unexpected-select-in-select" ) self . endTagSelect ( "select" ) def startTagInput ( self , token ) : self . parser . parseError ( "unexpected-input-in-select" ) if self . tree . elementInScope ( "select" , variant = "table" ) : self . endTagSelect ( "select" ) self . parser . phase . processStartTag ( token ) def startTagOther ( self , token ) : self . parser . parseError ( "unexpected-start-tag-in-select" , { "name" : token [ "name" ] } ) def endTagOption ( self , token ) : if self . tree . openElements [ - 1 ] . name == "option" : self . tree . openElements . pop ( ) else : self . parser . parseError ( "unexpected-end-tag-in-select" , { "name" : "option" } ) def endTagOptgroup ( self , token ) : if ( self . tree . openElements [ - 1 ] . name == "option" and self . tree . openElements [ - 2 ] . name == "optgroup" ) : self . tree . openElements . pop ( ) if self . tree . openElements [ - 1 ] . name == "optgroup" : self . tree . openElements . pop ( ) else : self . parser . parseError ( "unexpected-end-tag-in-select" , { "name" : "optgroup" } ) def endTagSelect ( self , token ) : if self . tree . elementInScope ( "select" , variant = "table" ) : node = self . tree . openElements . pop ( ) while node . name != "select" : node = self . tree . openElements . pop ( ) self . parser . resetInsertionMode ( ) else : self . parser . parseError ( ) def endTagTableElements ( self , token ) : self . parser . parseError ( "unexpected-end-tag-in-select" , { "name" : token [ "name" ] } ) if self . tree . elementInScope ( token [ "name" ] , variant = "table" ) : self . endTagSelect ( "select" ) self . parser . phase . processEndTag ( token ) def endTagOther ( self , token ) : self . parser . parseError ( "unexpected-end-tag-in-select" , { "name" : token [ "name" ] } ) class InSelectInTablePhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( ( "caption" , "table" , "tbody" , "tfoot" , "thead" , "tr" , "td" , "th" ) , self . startTagTable ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( ( "caption" , "table" , "tbody" , "tfoot" , "thead" , "tr" , "td" , "th" ) , self . endTagTable ) ] ) self . endTagHandler . default = self . endTagOther def processEOF ( self ) : self . parser . phases [ "inSelect" ] . processEOF ( ) def processCharacters ( self , token ) : self . parser . phases [ "inSelect" ] . processCharacters ( token ) def startTagTable ( self , token ) : self . parser . parseError ( "unexpected-table-element-start-tag-in-select-in-table" , { "name" : token [ "name" ] } ) self . endTagOther ( impliedTagToken ( "select" ) ) self . parser . phase . processStartTag ( token ) def startTagOther ( self , token ) : self . parser . phases [ "inSelect" ] . processStartTag ( token ) def endTagTable ( self , token ) : self . parser . parseError ( "unexpected-table-element-end-tag-in-select-in-table" , { "name" : token [ "name" ] } ) if self . tree . elementInScope ( token [ "name" ] , variant = "table" ) : self . endTagOther ( impliedTagToken ( "select" ) ) self . parser . phase . processEndTag ( token ) def endTagOther ( self , token ) : self . parser . phases [ "inSelect" ] . processEndTag ( token ) class InForeignContentPhase ( Phase ) : breakoutElements = frozenset ( [ "b" , "big" , "blockquote" , "body" , "br" , , "code" , "dd" , "div" , "dl" , "dt" , , "embed" , "font" , "h1" , "h2" , "h3" , , "h5" , "h6" , "head" , "hr" , "i" , "img" , , "listing" , "menu" , "meta" , "nobr" , , "p" , "pre" , "ruby" , "s" , "small" , , "strong" , "strike" , "sub" , "sup" , , "tt" , "u" , "ul" , "var" ] ) def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) def nonHTMLElementInScope ( self ) : for element in self . tree . openElements [ : : - 1 ] : if element . namespace == self . tree . defaultNamespace : return self . tree . elementInScope ( element ) assert False for item in self . tree . openElements [ : : - 1 ] : if item . namespace == self . tree . defaultNamespace : return True elif item . nameTuple in scopingElements : return False return False def adjustSVGTagNames ( self , token ) : replacements = { "altglyph" : "altGlyph" , : "altGlyphDef" , : "altGlyphItem" , : "animateColor" , : "animateMotion" , : "animateTransform" , : "clipPath" , : "feBlend" , : "feColorMatrix" , : "feComponentTransfer" , : "feComposite" , : "feConvolveMatrix" , : "feDiffuseLighting" , : "feDisplacementMap" , : "feDistantLight" , : "feFlood" , : "feFuncA" , : "feFuncB" , : "feFuncG" , : "feFuncR" , : "feGaussianBlur" , : "feImage" , : "feMerge" , : "feMergeNode" , : "feMorphology" , : "feOffset" , : "fePointLight" , : "feSpecularLighting" , : "feSpotLight" , : "feTile" , : "feTurbulence" , : "foreignObject" , : "glyphRef" , : "linearGradient" , : "radialGradient" , : "textPath" } if token [ "name" ] in replacements : token [ "name" ] = replacements [ token [ "name" ] ] def processCharacters ( self , token ) : self . parser . framesetOK = False Phase . processCharacters ( self , token ) def processEOF ( self ) : pass def processStartTag ( self , token ) : currentNode = self . tree . openElements [ - 1 ] if ( currentNode . namespace == self . tree . defaultNamespace or ( currentNode . namespace == namespaces [ "mathml" ] and token [ "name" ] not in frozenset ( [ "mglyph" , "malignmark" ] ) and currentNode . name in frozenset ( [ "mi" , "mo" , "mn" , , "mtext" ] ) ) or ( currentNode . namespace == namespaces [ "mathml" ] and currentNode . name == "annotation-xml" and token [ "name" ] == "svg" ) or ( currentNode . namespace == namespaces [ "svg" ] and currentNode . name in frozenset ( [ "foreignObject" , , "title" ] ) ) ) : assert self . parser . secondaryPhase != self self . parser . secondaryPhase . processStartTag ( token ) if self . parser . phase == self and self . nonHTMLElementInScope ( ) : self . parser . phase = self . parser . secondaryPhase elif token [ "name" ] in self . breakoutElements : self . parser . parseError ( "unexpected-html-element-in-foreign-content" , token [ "name" ] ) while ( self . tree . openElements [ - 1 ] . namespace != self . tree . defaultNamespace ) : self . tree . openElements . pop ( ) self . parser . phase = self . parser . secondaryPhase self . parser . phase . processStartTag ( token ) else : if currentNode . namespace == namespaces [ "mathml" ] : self . parser . adjustMathMLAttributes ( token ) elif currentNode . namespace == namespaces [ "svg" ] : self . adjustSVGTagNames ( token ) self . parser . adjustSVGAttributes ( token ) self . parser . adjustForeignAttributes ( token ) token [ "namespace" ] = currentNode . namespace self . tree . insertElement ( token ) if token [ "selfClosing" ] : self . tree . openElements . pop ( ) token [ "selfClosingAcknowledged" ] = True def processEndTag ( self , token ) : self . adjustSVGTagNames ( token ) self . parser . secondaryPhase . processEndTag ( token ) if self . parser . phase == self and self . nonHTMLElementInScope ( ) : self . parser . phase = self . parser . secondaryPhase class AfterBodyPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "html" , self . endTagHtml ) ] ) self . endTagHandler . default = self . endTagOther def processEOF ( self ) : pass def processComment ( self , token ) : self . tree . insertComment ( token , self . tree . openElements [ 0 ] ) def processCharacters ( self , token ) : self . parser . parseError ( "unexpected-char-after-body" ) self . parser . phase = self . parser . phases [ "inBody" ] self . parser . phase . processCharacters ( token ) def startTagHtml ( self , token ) : self . parser . phases [ "inBody" ] . processStartTag ( token ) def startTagOther ( self , token ) : self . parser . parseError ( "unexpected-start-tag-after-body" , { "name" : token [ "name" ] } ) self . parser . phase = self . parser . phases [ "inBody" ] self . parser . phase . processStartTag ( token ) def endTagHtml ( self , name ) : if self . parser . innerHTML : self . parser . parseError ( "unexpected-end-tag-after-body-innerhtml" ) else : self . parser . phase = self . parser . phases [ "afterAfterBody" ] def endTagOther ( self , token ) : self . parser . parseError ( "unexpected-end-tag-after-body" , { "name" : token [ "name" ] } ) self . parser . phase = self . parser . phases [ "inBody" ] self . parser . phase . processEndTag ( token ) class InFramesetPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( "frameset" , self . startTagFrameset ) , ( "frame" , self . startTagFrame ) , ( "noframes" , self . startTagNoframes ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "frameset" , self . endTagFrameset ) , ( "noframes" , self . endTagNoframes ) ] ) self . endTagHandler . default = self . endTagOther def processEOF ( self ) : if self . tree . openElements [ - 1 ] . name != "html" : self . parser . parseError ( "eof-in-frameset" ) else : assert self . parser . innerHTML def processCharacters ( self , token ) : self . parser . parseError ( "unexpected-char-in-frameset" ) def startTagFrameset ( self , token ) : self . tree . insertElement ( token ) def startTagFrame ( self , token ) : self . tree . insertElement ( token ) self . tree . openElements . pop ( ) def startTagNoframes ( self , token ) : self . parser . phases [ "inBody" ] . processStartTag ( token ) def startTagOther ( self , token ) : self . parser . parseError ( "unexpected-start-tag-in-frameset" , { "name" : token [ "name" ] } ) def endTagFrameset ( self , token ) : if self . tree . openElements [ - 1 ] . name == "html" : self . parser . parseError ( "unexpected-frameset-in-frameset-innerhtml" ) else : self . tree . openElements . pop ( ) if ( not self . parser . innerHTML and self . tree . openElements [ - 1 ] . name != "frameset" ) : self . parser . phase = self . parser . phases [ "afterFrameset" ] def endTagNoframes ( self , token ) : self . parser . phases [ "inBody" ] . processEndTag ( token ) def endTagOther ( self , token ) : self . parser . parseError ( "unexpected-end-tag-in-frameset" , { "name" : token [ "name" ] } ) class AfterFramesetPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( "noframes" , self . startTagNoframes ) ] ) self . startTagHandler . default = self . startTagOther self . endTagHandler = utils . MethodDispatcher ( [ ( "html" , self . endTagHtml ) ] ) self . endTagHandler . default = self . endTagOther def processEOF ( self ) : pass def processCharacters ( self , token ) : self . parser . parseError ( "unexpected-char-after-frameset" ) def startTagNoframes ( self , token ) : self . parser . phases [ "inHead" ] . processStartTag ( token ) def startTagOther ( self , token ) : self . parser . parseError ( "unexpected-start-tag-after-frameset" , { "name" : token [ "name" ] } ) def endTagHtml ( self , token ) : self . parser . phase = self . parser . phases [ "afterAfterFrameset" ] def endTagOther ( self , token ) : self . parser . parseError ( "unexpected-end-tag-after-frameset" , { "name" : token [ "name" ] } ) class AfterAfterBodyPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) ] ) self . startTagHandler . default = self . startTagOther def processEOF ( self ) : pass def processComment ( self , token ) : self . tree . insertComment ( token , self . tree . document ) def processSpaceCharacters ( self , token ) : self . parser . phases [ "inBody" ] . processSpaceCharacters ( token ) def processCharacters ( self , token ) : self . parser . parseError ( "expected-eof-but-got-char" ) self . parser . phase = self . parser . phases [ "inBody" ] self . parser . phase . processCharacters ( token ) def startTagHtml ( self , token ) : self . parser . phases [ "inBody" ] . processStartTag ( token ) def startTagOther ( self , token ) : self . parser . parseError ( "expected-eof-but-got-start-tag" , { "name" : token [ "name" ] } ) self . parser . phase = self . parser . phases [ "inBody" ] self . parser . phase . processStartTag ( token ) def processEndTag ( self , token ) : self . parser . parseError ( "expected-eof-but-got-end-tag" , { "name" : token [ "name" ] } ) self . parser . phase = self . parser . phases [ "inBody" ] self . parser . phase . processEndTag ( token ) class AfterAfterFramesetPhase ( Phase ) : def __init__ ( self , parser , tree ) : Phase . __init__ ( self , parser , tree ) self . startTagHandler = utils . MethodDispatcher ( [ ( "html" , self . startTagHtml ) , ( "noframes" , self . startTagNoFrames ) ] ) self . startTagHandler . default = self . startTagOther def processEOF ( self ) : pass def processComment ( self , token ) : self . tree . insertComment ( token , self . tree . document ) def processSpaceCharacters ( self , token ) : self . parser . phases [ "inBody" ] . processSpaceCharacters ( token ) def processCharacters ( self , token ) : self . parser . parseError ( "expected-eof-but-got-char" ) self . parser . phase = self . parser . phases [ "inBody" ] self . parser . phase . processCharacters ( token ) def startTagHtml ( self , token ) : self . parser . phases [ "inBody" ] . processStartTag ( token ) def startTagNoFrames ( self , token ) : self . parser . phases [ "inHead" ] . processStartTag ( token ) def startTagOther ( self , token ) : self . parser . parseError ( "expected-eof-but-got-start-tag" , { "name" : token [ "name" ] } ) self . parser . phase = self . parser . phases [ "inBody" ] self . parser . phase . processStartTag ( token ) def processEndTag ( self , token ) : self . parser . parseError ( "expected-eof-but-got-end-tag" , { "name" : token [ "name" ] } ) self . parser . phase = self . parser . phases [ "inBody" ] self . parser . phase . processEndTag ( token ) def impliedTagToken ( name , type = "EndTag" , attributes = None , selfClosing = False ) : if attributes is None : attributes = { } return { "type" : tokenTypes [ type ] , "name" : name , "data" : attributes , : selfClosing } class ParseError ( Exception ) : pass

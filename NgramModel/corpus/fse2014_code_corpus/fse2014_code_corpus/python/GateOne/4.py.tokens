__version__ = '1.0rc1' __license__ = "AGPLv3 or Proprietary (see LICENSE.txt)" __version_info__ = ( 1 , 0 ) __author__ = 'Dan McDougall <daniel.mcdougall@liftoffsoftware.com>' __doc__ = """\ About termio ============ This module provides a Multiplex class that can perform the following: * Fork a child process that opens a given terminal program. * Read and write data to and from the child process (asynchronously). * Examine the output of the child process in real-time and perform actions (also asynchronously!) based on what is "expected" (aka non-blocking, pexpect-like functionality). * Log the output of the child process to a file and/or syslog. The Multiplex class is meant to be used in conjunction with a running :class:`tornado.ioloop.IOLoop` instance. It can be instantiated from within your Tornado application like so:: multiplexer = termio.Multiplex( 'nethack', log_path='/var/log/myapp', user='bsmith@CORP', term_id=1, syslog=True ) .. note:: Support for event loops other than Tornado is in the works! Then *multiplexer* can create and launch a new controlling terminal (tty) running the given command (e.g. 'nethack'):: env = { 'PATH': os.environ['PATH'], 'MYVAR': 'foo' } fd = multiplexer.spawn(80, 24, env=env) # The fd is returned from spawn() in case you want more low-level control. Input and output from the controlled program is asynchronous and gets handled via IOLoop. It will automatically write all output from the terminal program to an instance of self.terminal_emulator (which defaults to Gate One's `terminal.Terminal`). So if you want to perform an action whenever the running terminal application has output (like, say, sending a message to a client) you'll need to attach a callback:: def screen_update(): 'Called when new output is ready to send to the client' output = multiplexer.dump_html() socket_or_something.write(output) multiplexer.callbacks[multiplexer.CALLBACK_UPDATE] = screen_update In this example, `screen_update()` will `write()` the output of `multiplexer.dump_html()` to *socket_or_something* whenever the terminal program has some sort of output. You can also make calls directly to the terminal emulator (if you're using a custom one):: def screen_update(): output = multiplexer.term.my_custom_func() whatever.write(output) Writing characters to the controlled terminal application is pretty straightforward:: multiplexer.write(u'some text') Typically you'd pass in keystrokes or commands from your application to the underlying program this way and the screen/terminal emulator would get updated automatically. If using Gate One's `terminal.Terminal()` you can also attach callbacks to perform further actions when more specific situations are encountered (e.g. when the window title is set via its respective escape sequence):: def set_title(): 'Hypothetical title-setting function' print("Window title was just set to: %s" % multiplexer.term.title) multiplexer.term.callbacks[multiplexer.CALLBACK_TITLE] = set_title Module Functions and Classes ============================ """ import signal , threading , os , sys , time , struct , io , gzip , re , weakref , logging from datetime import timedelta , datetime from functools import partial from itertools import izip from multiprocessing import Process from utils import get_translation , human_readable_bytes , noop , which from utils import get_or_update_metadata , json_encode , shell_command from utils import timeout_func _ = get_translation ( ) SEPARATOR = u"\U000f0f0f" CALLBACK_THREAD = None POSIX = 'posix' in sys . builtin_module_names MACOS = os . uname ( ) [ 0 ] == 'Darwin' def debug_expect ( m_instance , match ) : print ( "%s was matched..." % repr ( match ) ) out = "" for line in m_instance . dump ( ) : regex = re . escape ( match ) match_obj = re . match ( regex , line ) if match_obj : out += "--->%s\n" % repr ( line ) break else : out += " %s\n" % repr ( line ) print ( out ) class Timeout ( Exception ) : pass class Pattern ( object ) : def __init__ ( self , pattern , callback , optional = False , sticky = False , errorback = None , preprocess = False , timeout = 30 ) : self . pattern = pattern self . callback = callback self . errorback = errorback self . optional = optional self . sticky = sticky self . preprocess = preprocess self . timeout = timeout self . created = datetime . now ( ) class BaseMultiplex ( object ) : CALLBACK_UPDATE = 1 CALLBACK_EXIT = 2 def __init__ ( self , cmd , terminal_emulator = None , log_path = None , user = None , term_id = None , syslog = False , syslog_host = None , syslog_facility = None , debug = False ) : self . debug = debug self . lock = threading . Lock ( ) self . cmd = cmd if not terminal_emulator : from terminal import Terminal self . terminal_emulator = Terminal else : self . terminal_emulator = terminal_emulator self . log_path = log_path self . syslog = syslog self . _alive = False self . ratelimiter_engaged = False self . rows = 24 self . cols = 80 self . pid = - 1 self . started = "Never" self . _patterns = [ ] self . timeout_thread = None self . callbacks = { self . CALLBACK_UPDATE : { } , self . CALLBACK_EXIT : { } , } self . user = user self . term_id = term_id self . syslog_buffer = '' if self . syslog and not self . syslog_host : try : import syslog except ImportError : logging . error ( _ ( ) ) sys . exit ( 1 ) if not syslog_facility : syslog_facility = syslog . LOG_DAEMON syslog_facility = syslog_facility syslog . openlog ( 'gateone' , 0 , syslog_facility ) def __repr__ ( self ) : return "<%s>" % self . __str__ ( ) def __str__ ( self ) : started = self . started if started != "Never" : started = self . started . isoformat ( ) out = ( % ( self . __module__ , self . __class__ . __name__ , self . term_id , self . _alive , repr ( self . cmd ) , started ) ) return out def add_callback ( self , event , callback , identifier = None ) : if not identifier : identifier = callback . __hash__ ( ) self . callbacks [ event ] [ identifier ] = callback return identifier def remove_callback ( self , event , identifier ) : try : del self . callbacks [ event ] [ identifier ] except KeyError : pass def remove_all_callbacks ( self , identifier ) : for event , identifiers in self . callbacks . items ( ) : try : del self . callbacks [ event ] [ identifier ] except KeyError : pass def _call_callback ( self , callback ) : callback ( ) def spawn ( self , rows = 24 , cols = 80 , env = None , em_dimensions = None ) : raise NotImplementedError ( _ ( ) ) def isalive ( self ) : raise NotImplementedError ( _ ( ) ) def term_write ( self , stream ) : if self . log_path : now = int ( round ( time . time ( ) * 1000 ) ) if not os . path . exists ( self . log_path ) : metadata = { : '1.0' , : self . rows , : self . cols , : now } metadata_frame = str ( json_encode ( metadata ) ) metadata_frame = "%s:%s\xf3\xb0\xbc\x8f" % ( now , metadata_frame ) log = gzip . open ( self . log_path , mode = 'a' ) log . write ( metadata_frame ) log . close ( ) output = "%s:%s\xf3\xb0\xbc\x8f" % ( now , stream ) log = gzip . open ( self . log_path , mode = 'a' ) log . write ( output ) log . close ( ) if self . syslog : if '\n' in stream : for line in stream . splitlines ( ) : if self . syslog_buffer : line = self . syslog_buffer + line self . syslog_buffer = '' line = line . encode ( 'ascii' , 'xmlcharrefreplace' ) syslog . syslog ( "%s %s: %s" % ( self . user , self . term_id , line ) ) else : self . syslog_buffer += stream if self . _patterns : self . preprocess ( stream ) self . term . write ( stream ) if self . _patterns : self . postprocess ( ) if self . CALLBACK_UPDATE in self . callbacks : for callback in self . callbacks [ self . CALLBACK_UPDATE ] . values ( ) : self . _call_callback ( callback ) def preprocess ( self , stream ) : preprocess_patterns = ( a for a in self . _patterns if a . preprocess ) finished_non_sticky = False for pattern_obj in preprocess_patterns : if finished_non_sticky and not pattern_obj . sticky : continue match = pattern_obj . pattern . search ( stream ) if match : callback = partial ( pattern_obj . callback , self , match . group ( ) ) self . _call_callback ( callback ) if not pattern_obj . sticky : self . unexpect ( hash ( pattern_obj ) ) if not pattern_obj . optional : finished_non_sticky = True def postprocess ( self ) : post_patterns = ( a for a in self . _patterns if not a . preprocess ) finished_non_sticky = False for pattern_obj in post_patterns : if finished_non_sticky and not pattern_obj . sticky : continue term_lines = "\n" . join ( [ a . rstrip ( ) for a in self . term . dump ( ) ] ) . rstrip ( ) if isinstance ( pattern_obj . pattern , ( list , tuple ) ) : for pat in pattern_obj . pattern : match = pat . search ( term_lines ) if match : self . _handle_match ( pattern_obj , match ) else : match = pattern_obj . pattern . search ( term_lines ) if match : self . _handle_match ( pattern_obj , match ) def _handle_match ( self , pattern_obj , match ) : callback = partial ( pattern_obj . callback , self , match . group ( ) ) self . _call_callback ( callback ) if self . debug : debug_callback = partial ( debug_expect , self , match . group ( ) ) self . _call_callback ( debug_callback ) if not pattern_obj . sticky : self . unexpect ( hash ( pattern_obj ) ) if not pattern_obj . optional and not pattern_obj . sticky : finished_non_sticky = True def writeline ( self , line = '' ) : self . write ( line + u'\n' ) def writelines ( self , lines ) : if getattr ( lines , '__iter__' , False ) : for line in lines : self . write ( line + u'\n' ) else : raise TypeError ( _ ( % type ( lines ) ) ) def dump_html ( self , full = False , client_id = '0' ) : if client_id not in self . prev_output : self . prev_output [ client_id ] = [ None for a in xrange ( self . rows - 1 ) ] try : scrollback , html = ( [ ] , [ ] ) if self . term : try : result = self . term . dump_html ( ) if result : scrollback , html = result preserved_html = html [ : ] except IOError as e : logging . debug ( _ ( "IOError attempting self.term.dump_html()" ) ) logging . debug ( "%s" % e ) if html : if not full : count = 0 for line1 , line2 in izip ( self . prev_output [ client_id ] , html ) : if line1 != line2 : html [ count ] = line2 else : html [ count ] = '' count += 1 self . prev_output . update ( { client_id : preserved_html } ) return ( scrollback , html ) except ValueError as e : logging . error ( _ ( "ValueError in dumplines(): %s" % e ) ) return ( [ ] , [ ] ) except ( IOError , TypeError ) as e : logging . error ( _ ( "Unhandled exception in dumplines(): %s" % e ) ) if self . ratelimiter_engaged : return ( [ ] , [ _ ( "<b>Program output too noisy. Sending Ctrl-c...</b>" ) ] ) else : import traceback traceback . print_exc ( file = sys . stdout ) return ( [ ] , [ ] ) def dump ( self ) : return self . term . dump ( ) def timeout_check ( self , timeout_now = False ) : remaining_patterns = False for pattern_obj in self . _patterns : if timeout_now : if pattern_obj . errorback : errorback = partial ( pattern_obj . errorback , self ) self . _call_callback ( errorback ) self . unexpect ( ) return False elapsed = datetime . now ( ) - pattern_obj . created if elapsed > pattern_obj . timeout : if not pattern_obj . sticky : self . unexpect ( hash ( pattern_obj ) ) if pattern_obj . errorback : errorback = partial ( pattern_obj . errorback , self ) self . _call_callback ( errorback ) elif not pattern_obj . sticky : remaining_patterns = True return remaining_patterns def expect ( self , patterns , callback , optional = False , sticky = False , errorback = None , timeout = 15 , position = None , preprocess = False ) : if isinstance ( patterns , ( str , unicode ) ) : patterns = re . compile ( patterns , re . MULTILINE ) if isinstance ( patterns , ( tuple , list ) ) : pattern_list = [ ] for pattern in patterns : if isinstance ( pattern , str ) : pattern = re . compile ( pattern ) pattern_list . append ( pattern ) else : pattern_list . append ( pattern ) patterns = tuple ( pattern_list ) if isinstance ( timeout , ( str , int , float ) ) : timeout = timedelta ( seconds = float ( timeout ) ) elif not isinstance ( timeout , timedelta ) : raise TypeError ( _ ( ) ) pattern_obj = Pattern ( patterns , callback , optional = optional , sticky = sticky , errorback = errorback , preprocess = preprocess , timeout = timeout ) if not position : self . _patterns . append ( pattern_obj ) else : self . _patterns . insert ( position , pattern_obj ) return hash ( pattern_obj ) def unexpect ( self , ref = None ) : if not ref : self . _patterns = [ ] return for i , item in enumerate ( self . _patterns ) : if hash ( item ) == ref : self . _patterns . pop ( i ) def await ( self , timeout = 15 , rows = 24 , cols = 80 , env = None , em_dimensions = None ) : if not self . isalive ( ) : self . spawn ( rows = rows , cols = cols , env = env , em_dimensions = em_dimensions ) start = datetime . now ( ) if isinstance ( timeout , ( str , int , float ) ) : timeout = timedelta ( seconds = float ( timeout ) ) elif not isinstance ( timeout , timedelta ) : raise TypeError ( _ ( ) ) remaining_patterns = True while remaining_patterns : remaining_patterns = False for pattern in self . _patterns : if not pattern . optional and not pattern . sticky : remaining_patterns = True break if ( datetime . now ( ) - start ) > timeout : raise Timeout ( "Lingered longer than %s" % timeout . seconds ) self . read ( ) time . sleep ( 0.1 ) return True def terminate ( self ) : raise NotImplementedError ( _ ( ) ) def _read ( self , bytes = - 1 ) : raise NotImplementedError ( _ ( ) ) def read ( self , bytes = - 1 ) : result = self . _read ( bytes ) self . timeout_check ( ) return result def write ( self ) : raise NotImplementedError ( _ ( ) ) class MultiplexPOSIXIOLoop ( BaseMultiplex ) : def __init__ ( self , * args , ** kwargs ) : super ( MultiplexPOSIXIOLoop , self ) . __init__ ( * args , ** kwargs ) from tornado import ioloop self . terminating = False self . sent_sigint = False self . env = { } self . io_loop = ioloop . IOLoop . instance ( ) signal . signal ( signal . SIGALRM , self . _blocked_io_handler ) self . reenable_timeout = None interval = 100 self . scheduler = ioloop . PeriodicCallback ( weakref . proxy ( self . _timeout_checker ) , interval ) def __del__ ( self ) : logging . debug ( "MultiplexPOSIXIOLoop.__del__()" ) def _call_callback ( self , callback ) : try : if self . io_loop . running ( ) : self . io_loop . add_callback ( callback ) else : callback ( ) finally : del callback def _reenable_output ( self ) : self . ratelimiter_engaged = False with self . lock : with io . open ( self . fd , 'rb' , closefd = False ) as reader : reader . read ( ) with io . open ( self . fd , 'wb' , closefd = False ) as writer : writer . write ( _ ( "# Process was auto-killed via ctrl-c." ) ) self . term . reset ( ) for i in self . prev_output . keys ( ) : self . prev_output . update ( { i : [ None for a in xrange ( self . rows - 1 ) ] } ) self . io_loop . add_handler ( self . fd , self . _ioloop_read_handler , self . io_loop . READ ) def __reset_sent_sigint ( self ) : self . sent_sigint = False def _blocked_io_handler ( self , signum = None , frame = None ) : if not self . isalive ( ) : return logging . warning ( _ ( % self . pid ) ) self . io_loop . remove_handler ( self . fd ) if not self . sent_sigint : try : with io . open ( self . fd , 'wb' , closefd = False ) as writer : writer . write ( "\x03\n" ) self . sent_sigint = True self . io_loop . add_timeout ( timedelta ( seconds = 10 ) , self . __reset_sent_sigint ) except OSError : pass else : logging . warning ( _ ( "Ctrl-c to %s failed. Terminating..." ) ) try : os . close ( self . fd ) except ( KeyError , IOError , OSError ) : pass try : os . kill ( self . pid , signal . SIGTERM ) os . waitpid ( - 1 , os . WNOHANG ) except OSError : pass self . ratelimiter_engaged = False self . spawn ( rows = self . rows , cols = self . cols , env = self . env , em_dimensions = self . em_dimensions ) return self . ratelimiter_engaged = True for callback in self . callbacks [ self . CALLBACK_UPDATE ] . values ( ) : self . _call_callback ( callback ) self . reenable_timeout = self . io_loop . add_timeout ( timedelta ( seconds = 3 ) , self . _reenable_output ) def spawn ( self , rows = 24 , cols = 80 , env = None , em_dimensions = None ) : self . started = datetime . now ( ) signal . signal ( signal . SIGCHLD , signal . SIG_IGN ) logging . debug ( % ( rows , cols , repr ( env ) , repr ( em_dimensions ) ) ) import pty pid , fd = pty . fork ( ) if pid == 0 : try : os . closerange ( 3 , 256 ) except OSError : pass if not env : env = { } env [ "COLUMNS" ] = str ( cols ) env [ "LINES" ] = str ( rows ) env [ "TERM" ] = "xterm-256color" env [ "PATH" ] = os . environ [ 'PATH' ] env [ "LANG" ] = os . environ . get ( 'LANG' , 'en_US.UTF-8' ) env [ "PYTHONIOENCODING" ] = "utf_8" cmd = [ '/bin/sh' , '-c' , self . cmd + '; sleep .1' ] os . dup2 ( 2 , 1 ) os . execvpe ( cmd [ 0 ] , cmd , env ) os . _exit ( 0 ) else : logging . debug ( "spawn() pid: %s" % pid ) self . _alive = True self . fd = fd self . env = env self . em_dimensions = em_dimensions self . pid = pid self . time = time . time ( ) self . term = self . terminal_emulator ( rows = rows , cols = cols , em_dimensions = em_dimensions ) self . io_loop . add_handler ( fd , self . _ioloop_read_handler , self . io_loop . READ ) self . prev_output = { } import fcntl fl = fcntl . fcntl ( sys . stdin , fcntl . F_GETFL ) fcntl . fcntl ( self . fd , fcntl . F_SETFL , fl | os . O_NONBLOCK ) self . resize ( rows , cols , ctrl_l = False ) return fd def isalive ( self ) : if self . _alive : for f in os . listdir ( '/proc' ) : pid_dir = os . path . join ( '/proc' , f ) if os . path . isdir ( pid_dir ) : try : pid = int ( f ) except ValueError : continue if pid == self . pid : self . _alive = True return True self . _alive = False return False def resize ( self , rows , cols , em_dimensions = None , ctrl_l = True ) : logging . debug ( "Resizing term %s to rows: %s, cols: %s" % ( self . term_id , rows , cols ) ) if rows < 2 : rows = 24 if cols < 2 : cols = 80 self . rows = rows self . cols = cols self . term . resize ( rows , cols , em_dimensions ) import fcntl , termios s = struct . pack ( "HHHH" , rows , cols , 0 , 0 ) fcntl . ioctl ( self . fd , termios . TIOCSWINSZ , s ) if ctrl_l : self . write ( u'\x0c' ) def terminate ( self ) : if not self . terminating : self . terminating = True else : return logging . debug ( "terminate() self.pid: %s" % self . pid ) if self . reenable_timeout : self . io_loop . remove_timeout ( self . reenable_timeout ) try : self . io_loop . set_blocking_signal_threshold ( None , None ) except ValueError : pass for callback in self . callbacks [ self . CALLBACK_EXIT ] . values ( ) : self . _call_callback ( callback ) if self . _patterns : self . timeout_check ( timeout_now = True ) self . unexpect ( ) self . scheduler . stop ( ) del self . scheduler try : self . io_loop . remove_handler ( self . fd ) os . close ( self . fd ) except ( KeyError , IOError , OSError ) : pass try : os . kill ( self . pid , signal . SIGTERM ) os . waitpid ( - 1 , os . WNOHANG ) except OSError : pass self . callbacks = { self . CALLBACK_UPDATE : { } , self . CALLBACK_EXIT : { } , } if not self . log_path : return PROC = Process ( target = get_or_update_metadata , args = ( self . log_path , self . user ) , kwargs = { 'force_update' : True } ) PROC . start ( ) def _ioloop_read_handler ( self , fd , event ) : if event == self . io_loop . READ : self . _call_callback ( self . read ) else : logging . debug ( _ ( % ( self . fd , event ) ) ) self . terminate ( ) def _read ( self , bytes = - 1 ) : result = "" try : with self . lock : with io . open ( self . fd , 'rb' , closefd = False ) as reader : if bytes == - 1 : while True : updated = reader . read ( bytes ) if not updated : break if self . ratelimiter_engaged : break result += updated timeout_func ( self . term_write , args = ( updated , ) , default = self . _blocked_io_handler , timeout_duration = 3 ) elif bytes : result = reader . read ( bytes ) self . term_write ( result ) except IOError as e : pass except OSError as e : logging . error ( "Got exception in read: %s" % ` e ` ) except Exception as e : import traceback logging . error ( % ` e ` ) traceback . print_exc ( file = sys . stdout ) if self . isalive ( ) : self . terminate ( ) finally : return result def _timeout_checker ( self ) : remaining_patterns = self . timeout_check ( ) if not remaining_patterns : logging . debug ( "Stopping self.scheduler" ) try : self . scheduler . stop ( ) except AttributeError : pass def read ( self , bytes = - 1 ) : result = self . _read ( bytes ) remaining_patterns = self . timeout_check ( ) if remaining_patterns and not self . scheduler . _running : logging . debug ( "Starting self.scheduler to check for timeouts" ) self . scheduler . start ( ) return result def _write ( self , chars ) : try : with self . lock : with io . open ( self . fd , , newline = "" , encoding = 'UTF-8' , closefd = False ) as writer : writer . write ( chars ) except ( IOError , OSError ) as e : if self . isalive ( ) : self . terminate ( ) except Exception as e : logging . error ( "write() exception: %s" % e ) def write ( self , chars ) : write = partial ( self . _write , chars ) self . _call_callback ( write ) class MultiplexMacOSIOLoop ( MultiplexPOSIXIOLoop ) : def isalive ( self ) : exitstatus , output = shell_command ( % self . pid ) if exitstatus != 0 : self . _alive = True else : self . _alive = False return self . _alive def spawn ( cmd , rows = 24 , cols = 80 , env = None , em_dimensions = None , * args , ** kwargs ) : m = Multiplex ( cmd , * args , ** kwargs ) m . spawn ( rows , cols , env , em_dimensions = em_dimensions ) return m if POSIX : if MACOS : Multiplex = MultiplexMacOSIOLoop else : Multiplex = MultiplexPOSIXIOLoop else : raise NotImplementedError ( _ (

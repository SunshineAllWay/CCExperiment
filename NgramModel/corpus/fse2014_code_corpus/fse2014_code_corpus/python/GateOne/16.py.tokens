__doc__ = """\ ssh_connect.py - Opens an interactive SSH session with the given arguments and sets the window title to user@host. """ __version__ = '1.1' __license__ = "AGPLv3 or Proprietary (see LICENSE.txt)" __version_info__ = ( 1 , 1 ) __author__ = 'Dan McDougall <daniel.mcdougall@liftoffsoftware.com>' import os , sys , errno , readline , tempfile , base64 , binascii , struct , signal from subprocess import Popen from optparse import OptionParser import gettext gettext . bindtextdomain ( 'ssh_connect' , 'i18n' ) gettext . textdomain ( 'ssh_connect' ) _ = gettext . gettext readline . parse_and_bind ( 'esc: none' ) POSIX = 'posix' in sys . builtin_module_names wrapper_script = """\ #!/bin/sh # This variable is for easy retrieval later SSH_SOCKET='{socket}' {cmd} echo '[Press Enter to close this terminal]' read waitforuser rm -f {temp} # Cleanup exit 0 """ def mkdir_p ( path ) : try : os . makedirs ( path ) except OSError as exc : if exc . errno == errno . EEXIST : pass else : raise def which ( binary , path = None ) : if path : paths = path . split ( ':' ) else : paths = os . environ [ 'PATH' ] . split ( ':' ) for path in paths : if not os . path . exists ( path ) : continue files = os . listdir ( path ) if binary in files : return os . path . join ( path , binary ) return None def short_hash ( to_shorten ) : packed = struct . pack ( 'i' , binascii . crc32 ( to_shorten ) ) return base64 . urlsafe_b64encode ( packed ) . replace ( '=' , '' ) def get_identities ( users_ssh_dir , only_defaults = False ) : identities = [ ] if os . path . exists ( users_ssh_dir ) : ssh_files = os . listdir ( users_ssh_dir ) defaults_present = False defaults = [ ] if only_defaults and '.default_ids' in ssh_files : defaults_present = True with open ( os . path . join ( users_ssh_dir , '.default_ids' ) ) as f : defaults = f . read ( ) . splitlines ( ) defaults = [ a for a in defaults if a ] defaults = [ os . path . split ( a ) [ 1 ] for a in defaults ] for f in ssh_files : if f . endswith ( '.pub' ) : identity = f [ : - 4 ] if identity in ssh_files : identities . append ( os . path . join ( users_ssh_dir , identity ) ) if defaults_present : identities = [ a for a in identities if os . path . split ( a ) [ 1 ] in defaults ] return identities def openssh_connect ( user , host , port = 22 , config = None , command = None , password = None , env = None , socket = None , sshfp = False , randomart = False , identities = None , additional_args = None ) : try : int ( port ) except ValueError : print ( _ ( "The port must be an integer < 65535" ) ) sys . exit ( 1 ) signal . signal ( signal . SIGCHLD , signal . SIG_IGN ) if not env : env = { : 'xterm' , : 'en_US.UTF-8' , } try : env [ 'LINES' ] = os . environ [ 'LINES' ] env [ 'COLUMNS' ] = os . environ [ 'COLUMNS' ] except KeyError : pass if 'GO_USER' in os . environ : go_user = os . environ [ 'GO_USER' ] else : go_user = os . environ [ 'USER' ] if 'GO_USER_DIR' in os . environ : users_dir = os . path . join ( os . environ [ 'GO_USER_DIR' ] , go_user ) users_ssh_dir = os . path . join ( users_dir , 'ssh' ) else : if POSIX : users_ssh_dir = os . path . join ( os . environ [ 'HOME' ] , '.ssh' ) else : users_ssh_dir = os . path . join ( os . environ [ 'USERPROFILE' ] , '.ssh' ) ssh_config_path = os . path . join ( users_ssh_dir , 'config' ) if not os . path . exists ( ssh_config_path ) : with open ( ssh_config_path , 'w' ) as f : f . write ( '\n' ) ssh_default_identity_path = os . path . join ( users_ssh_dir , 'id_ecdsa' ) args = [ , % ssh_config_path , , % ssh_default_identity_path , , port , , user , ] if identities : if isinstance ( identities , ( unicode , str ) ) : if os . path . sep not in identities : identities = os . path . join ( users_ssh_dir , identities ) identities = [ identities ] else : identities = get_identities ( users_ssh_dir , only_defaults = True ) if identities : print ( _ ( ) ) for identity in identities : if os . path . sep not in identity : identity = os . path . join ( users_ssh_dir , identity ) args . insert ( 3 , "-i%s" % identity ) print ( _ ( "\t\x1b[1m%s\x1b[0m" % os . path . split ( identity ) [ 1 ] ) ) args . insert ( 3 , ) else : args . insert ( 3 , ) if sshfp : args . insert ( 3 , "-oVerifyHostKeyDNS=yes" ) if randomart : args . insert ( 3 , "-oVisualHostKey=yes" ) if not command : if 'PATH' in env : command = which ( "ssh" , path = env [ 'PATH' ] ) else : env [ 'PATH' ] = os . environ [ 'PATH' ] command = which ( "ssh" ) if socket : socket_path = socket . replace ( r'%r' , user ) socket_path = socket_path . replace ( r'%h' , host ) socket_path = socket_path . replace ( r'%p' , port ) user_at_host_port = "%s@%s:%s" % ( user , host , port ) hashed = short_hash ( user_at_host_port ) socket_path = socket_path . replace ( r'%SHORT_SOCKET%' , hashed ) if not os . path . exists ( socket_path ) : args . insert ( 0 , "-M" ) else : print ( "\x1b]0;%s@%s (child)\007" % ( user , host ) ) print ( _ ( % ( user , host , port ) ) ) socket = socket . replace ( r'%SHORT_SOCKET%' , hashed ) socket_arg = "-S%s" % socket basedir = os . path . split ( socket ) [ 0 ] mkdir_p ( basedir ) os . chmod ( basedir , 0700 ) args . insert ( 1 , socket_arg ) if additional_args : if isinstance ( additional_args , list ) : args . extend ( additional_args ) elif isinstance ( additional_args , basestring ) : args . extend ( additional_args . split ( ) ) args . insert ( 0 , command ) args . append ( host ) if password : temp = tempfile . NamedTemporaryFile ( delete = False ) os . chmod ( temp . name , 0700 ) temp . write ( '#!/bin/bash\necho "%s"\n' % password ) temp . close ( ) env [ 'SSH_ASKPASS' ] = temp . name env [ 'DISPLAY' ] = ':9999' Popen ( "sleep 15 && /bin/rm -f %s" % temp . name , shell = True ) script_path = None if 'GO_TERM' in os . environ . keys ( ) : if 'GO_SESSION_DIR' in os . environ . keys ( ) : term = os . environ [ 'GO_TERM' ] ssh_session = 'ssh:%s:%s@%s:%s' % ( term , user , host , port ) script_path = os . path . join ( os . environ [ 'GO_SESSION_DIR' ] , ssh_session ) if not script_path : temp = tempfile . NamedTemporaryFile ( prefix = "ssh_connect" , delete = False ) script_path = "%s" % temp . name temp . close ( ) script = wrapper_script . format ( socket = socket , cmd = " " . join ( args ) , temp = script_path ) with open ( script_path , 'w' ) as f : f . write ( script ) os . chmod ( script_path , 0700 ) if password : pid = os . fork ( ) if pid == 0 : os . setsid ( ) os . execvpe ( script_path , [ ] , env ) os . _exit ( 0 ) else : os . _exit ( 0 ) else : os . execvpe ( script_path , [ ] , env ) os . _exit ( 0 ) def telnet_connect ( user , host , port = 23 , env = None ) : try : int ( port ) except ValueError : print ( _ ( "The port must be an integer < 65535" ) ) sys . exit ( 1 ) signal . signal ( signal . SIGCHLD , signal . SIG_IGN ) if not env : env = { : 'xterm' , : 'en_US.UTF-8' , } try : env [ 'LINES' ] = os . environ [ 'LINES' ] env [ 'COLUMNS' ] = os . environ [ 'COLUMNS' ] except KeyError : pass if 'PATH' in env : command = which ( "telnet" , path = env [ 'PATH' ] ) else : env [ 'PATH' ] = os . environ [ 'PATH' ] command = which ( "telnet" ) args = [ host , port ] if user : args . insert ( 0 , user ) args . insert ( 0 , "-l" ) args . insert ( 0 , command ) script_path = None if 'GO_TERM' in os . environ . keys ( ) : if 'GO_SESSION_DIR' in os . environ . keys ( ) : term = os . environ [ 'GO_TERM' ] telnet_session = 'telnet:%s:%s@%s:%s' % ( term , user , host , port ) script_path = os . path . join ( os . environ [ 'GO_SESSION_DIR' ] , telnet_session ) if not script_path : temp = tempfile . NamedTemporaryFile ( prefix = "ssh_connect" , delete = False ) script_path = "%s" % temp . name temp . close ( ) script = wrapper_script . format ( socket = "NO SOCKET" , cmd = " " . join ( args ) , temp = script_path ) with open ( script_path , 'w' ) as f : f . write ( script ) os . chmod ( script_path , 0700 ) os . execvpe ( script_path , [ ] , env ) os . _exit ( 0 ) def parse_telent_url ( url ) : user = None if '@' in url : host = url . split ( '@' ) [ 1 ] . split ( ':' ) [ 0 ] user = url . split ( '@' ) [ 0 ] [ 9 : ] if ':' in user : password = user . split ( ':' ) [ 1 ] user = user . split ( ':' ) [ 0 ] if len ( url . split ( '@' ) [ 1 ] . split ( ':' ) ) == 1 : port = '23' else : port = url . split ( '@' ) [ 1 ] . split ( ':' ) [ 1 ] port = port . split ( '/' ) [ 0 ] else : url = url [ 9 : ] host = url . split ( ':' ) [ 0 ] if len ( url . split ( ':' ) ) == 2 : port = url . split ( ':' ) [ 1 ] port = port . split ( '/' ) [ 0 ] else : port = '23' return ( user , host , port ) def parse_ssh_url ( url ) : identities = [ ] password = None if url . startswith ( 'web+' ) : url = url [ 4 : ] if '@' in url : host = url . split ( '@' ) [ 1 ] . split ( ':' ) [ 0 ] user = url . split ( '@' ) [ 0 ] [ 6 : ] if ':' in user : password = user . split ( ':' ) [ 1 ] user = user . split ( ':' ) [ 0 ] if len ( url . split ( '@' ) [ 1 ] . split ( ':' ) ) == 1 : port = '22' else : port = url . split ( '@' ) [ 1 ] . split ( ':' ) [ 1 ] port = port . split ( '/' ) [ 0 ] else : try : user = os . environ [ 'GO_USER' ] except KeyError : user = os . environ [ 'USER' ] url = url [ 6 : ] host = url . split ( ':' ) [ 0 ] if len ( url . split ( ':' ) ) == 2 : port = url . split ( ':' ) [ 1 ] port = port . split ( '/' ) [ 0 ] else : port = '22' if "?" in url : query_string = url . split ( '?' ) [ 1 ] options = query_string . split ( '&' ) options_dict = { } for option in options : key , value = option . split ( '=' ) options_dict [ key ] = value if 'identities' in options_dict : identities = options_dict [ 'identities' ] . split ( ',' ) return ( user , host , port , password , identities ) if __name__ == "__main__" : usage = ( ) parser = OptionParser ( usage = usage , version = __version__ ) parser . disable_interspersed_args ( ) parser . add_option ( "-c" , "--command" , dest = "command" , default = 'ssh' , help = _ ( "Path to the ssh command. Default: 'ssh' (which usually means " ) , metavar = "'<filepath>'" ) parser . add_option ( "-a" , "--args" , dest = "additional_args" , default = None , help = _ ( "Any additional arguments that should be passed to the ssh " ) , metavar = "'<args>'" ) parser . add_option ( "-S" , dest = "socket" , default = None , help = _ ( "Path to the control socket for connection sharing (see master " ) , metavar = "'<filepath>'" ) parser . add_option ( "--sshfp" , dest = "sshfp" , default = False , action = "store_true" , help = _ ( "Enable the use of SSHFP in verifying host keys. See: " ) ) parser . add_option ( "--randomart" , dest = "randomart" , default = False , action = "store_true" , help = _ ( "Enable the VisualHostKey (randomart hash host key) option when " ) ) parser . add_option ( "--logo" , dest = "logo" , default = False , action = "store_true" , help = _ ( "Display the Liftoff Software logo inline in the terminal." ) ) ( options , args ) = parser . parse_args ( ) try : if len ( args ) == 1 : ( user , host , port , password , identities ) = parse_ssh_url ( args [ 0 ] ) openssh_connect ( user , host , port , command = options . command , password = password , sshfp = options . sshfp , randomart = options . randomart , identities = identities , additional_args = options . additional_args , socket = options . socket ) elif len ( args ) == 2 : openssh_connect ( args [ 0 ] , args [ 1 ] , '22' , command = options . command , sshfp = options . sshfp , randomart = options . randomart , additional_args = options . additional_args , socket = options . socket ) elif len ( args ) == 3 : openssh_connect ( args [ 0 ] , args [ 1 ] , args [ 2 ] , command = options . command , sshfp = options . sshfp , randomart = options . randomart , additional_args = options . additional_args , socket = options . socket ) except Exception : pass password = None try : identities = [ ] protocol = None script_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) logo_path = os . path . join ( script_dir , 'logo.png' ) logo = None if options . logo : if 'GO_TERM' in os . environ . keys ( ) : if os . path . exists ( logo_path ) : with open ( logo_path ) as f : logo = f . read ( ) sys . stdout . write ( logo ) url = raw_input ( _ ( ) ) if url . startswith ( 'ssh://' ) or url . startswith ( 'web+ssh' ) : ( user , host , port , password , identities ) = parse_ssh_url ( url ) protocol = 'ssh' elif url . startswith ( 'telnet://' ) : ( user , host , port ) = parse_telent_url ( url ) protocol = 'telnet' else : if not protocol : protocol = 'ssh' port = raw_input ( "Port [22]: " ) if not port : port = '22' user = raw_input ( "User: " ) host = url if not url : host = 'localhost' if protocol == 'ssh' : print ( _ ( 'Connecting to ssh://%s@%s:%s' % ( user , host , port ) ) ) print ( "\x1b]0;ssh://%s@%s\007" % ( user , host ) ) print ( "\x1b]_;ssh|%s@%s:%s\007" % ( user , host , port ) ) openssh_connect ( user , host , port , command = options . command , password = password , sshfp = options . sshfp , randomart = options . randomart , identities = identities , additional_args = options . additional_args , socket = options . socket ) elif protocol == 'telnet' : if user : print ( _ ( 'Connecting to telnet://%s@%s:%s' % ( user , host , port ) ) ) print ( "\x1b]0;telnet://%s@%s\007" % ( user , host ) ) else : print ( _ ( 'Connecting to telnet://%s:%s' % ( host , port ) ) ) print ( "\x1b]0;telnet://%s\007" % host ) telnet_connect ( user , host , port ) except KeyboardInterrupt : print ( _ ( "\nKeyboardInterrupt detected. Quitting..." ) ) except Exception as e : print e noop = raw_input ( _ ( "[Press any key to close this terminal]" ) )

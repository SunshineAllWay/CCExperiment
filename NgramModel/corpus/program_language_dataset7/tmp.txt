 package edu ucdavis cacheca import org eclipse core runtime Status import org eclipse ui plugin AbstractUIPlugin import org osgi framework BundleContext * The activator class controls the plug-in life public class Activator extends AbstractUIPlugin  // The plug-in public static final String PLUGIN_ID = "CACHECA"  // The shared private static Activator plugin * The public Activator     *  non-Javadoc * @see org eclipse ui plugin AbstractUIPlugin#start org osgi framework BundleContext public void start BundleContext context  throws Exception  super start context  plugin = this  *  non-Javadoc * @see org eclipse ui plugin AbstractUIPlugin#stop org osgi framework BundleContext public void stop BundleContext context  throws Exception  plugin = null super stop context   * Returns the shared * @return the shared public static Activator getDefault    return plugin  public void log  String msg  getLog   log new Status Status INFO  PLUGIN_ID  Status OK  msg  null     package edu ucdavis cacheca import java io BufferedReader import java io FileNotFoundException import java io FileReader import java io IOException import java util ArrayList import java util Collections import java util Comparator import java util HashMap import java util Map // @author Originally written in C++ by Zhaopeng  converted to Java by * Cache model: Core component of Cacheca * Record the recent cache public class Cache  private Map<String  Record> mRecords private int mMinOrder private int mOrder public Cache int order  int minOrder  mRecords = new HashMap<String  Record>   init order  minOrder   private void init int order  int minOrder  mMinOrder = minOrder mOrder = order  private void clear   mRecords clear    * build the mRecords based on the * @param inputFile: private void build String inputFile  ArrayList<String> tokens = new ArrayList<String>   tokens add "<s>"  String line  cachePrefix BufferedReader br try  br = new BufferedReader new FileReader inputFile   line = br readLine   while line != null  String   splitString = line split "  ?<=\\  | ?=\\   | |  ?<=\\  | ?=\\   |  ?<=\\  | ?=\\   |  ?<=\\  | ?=\\   |  ?<=\\  | ?=\\   "  for String token : splitString  if  token != null && ! token equals ""    token trim   token = token replaceAll "\t"  ""  token = token replaceAll " "  ""  tokens add token    line = br readLine    br close     catch  FileNotFoundException e    e printStackTrace     catch  IOException e    e printStackTrace     for int i = mMinOrder-1  i < tokens size    i++  int start = i- mOrder-1  > 0 ? i- mOrder-1  : 0 int end = i-1 StringBuilder mergedString = new StringBuilder   if  start < end  for int j = start  j < end  j++  mergedString append tokens get j  + " "   mergedString append tokens get end    cachePrefix = mergedString toString   update cachePrefix  tokens get i     * update mRecords when * @param prefix: prefix of the * @param token: last token of the string of which the prefix is param private void update String prefix  String token  int n = Utilities countWords prefix  for int i = n  i >= mMinOrder-1  --i  String newPrefix = Utilities getLastNWords prefix  i  Record val = mRecords get newPrefix  if  val != null  val update token   else mRecords put newPrefix  new Record token      * update candidates after interpolation * P t | h  cache  = 1 /  1 + H  * P_n-gram t | h  + H/ 1 + H  * P_cache t | h * @param prefix: current tokens of * @param candidates: list of words recommended by n-gram * @return updated candidates fixed by public ArrayList<Word> updateCandidates String prefix  ArrayList<Word> candidates  int cacheCount = getCount prefix  if cacheCount != 0  float cache_discount =  float cacheCount/ cacheCount+1  float ngram_discount = 1-cache_discount // found cache records of the Map<String  Integer> tokenCounts = getTokenCounts prefix  // update the information of candidates from ngram for  int i=0  i< int candidates size    ++i  // discount the probability candidates get i  mProb *= ngram_discount Integer val = tokenCounts get candidates get i  mToken  if  val != null  candidates get i  mProb += cache_discount * val/cacheCount tokenCounts remove candidates get i  mToken    // add the left records in the cache to the // See http://stackoverflow for  Map Entry<String  Integer> entry : tokenCounts entrySet    candidates add new Word entry getKey    cache_discount *   float entry getValue  /cacheCount     // See: http://stackoverflow Collections sort candidates  new Comparator<Word>    // first less than the second = neg  first greater than second = public int compare Word one  Word two   if one mProb > two mProb return 1 else if one mProb < two mProb return -1 return 0      return candidates  * get the possible suggestions from the * @param prefix       the previous  n-1  * public Map<String  Integer> getTokenCounts String prefix  int n = Utilities countWords prefix  for  int i=n  i>=mMinOrder-1  --i  // use the prefix from longest to m_min_order until we match the String newPrefix = Utilities getLastNWords prefix  i  Record val = mRecords get newPrefix  if  val != null  return val getTokenCounts     return null  * get the number of records for a given prefix  to calculate the discount * @param prefix       the previous  n-1  private int getCount String prefix  int n = Utilities countWords prefix  for  int i=n  i>=mMinOrder-1  --i  String newPrefix = Utilities getLastNWords prefix  i  Record val = mRecords get newPrefix  if  val != null  return val getCount     return 0  //inner class private class Record private int mCount private Map<String  Integer> mTokens private Record    mCount = 0 mTokens = new HashMap<String  Integer>    private Record  String token  mCount = 1 mTokens = new HashMap<String  Integer>   mTokens put token  1   void update String token  mCount++ Integer val = mTokens get token  if val != null  mTokens put token  ++val   else mTokens put token  1    Map<String  Integer> getTokenCounts   return mTokens  int getCount   return mCount    package edu ucdavis cacheca import java net URL import java util ArrayList import org eclipse core runtime Platform * CachecaComputer: Controller of Cacheca public class CachecaComputer  private static final CachecaComputer INSTANCE = new CachecaComputer   private static boolean initialized public static String file private CachecaComputer   initialized = false file = ""  public void init URL u  int order  String sourceFile  init u  order  build sourceFile  file = sourceFile initialized = true  public static CachecaComputer getInstance String p  if !p equals file   INSTANCE init Platform getBundle Activator PLUGIN_ID  getEntry "train 3grams"   3  p   return INSTANCE  public static boolean isInitialized   return initialized  * Initialize the n-gram component in cacheca * @param u: corpus * @param ngramOrder: order of n-gram * @return: true if init private boolean init URL u  int ngramOrder  // Initialize the whole return Data Init u  ngramOrder   * build cache * @param inputFile: private void build String inputFile  // Before editing  build the cache on the current Data CACHE build inputFile   * @param p: * @return list of public ArrayList<Word> getCandidates String p  String   pref = p split "  ?<=\\  | ?=\\   | |  ?<=\\  | ?=\\   |  ?<=\\  | ?=\\   |  ?<=\\  | ?=\\   |  ?<=\\  | ?=\\   |  ?<=\\  | ?=\\   "  String prefix = "" boolean start = true for  String pre : pref  pre trim   if pre == null || pre equals ""  || pre equals " "  continue if start == false prefix+= " " prefix+=pre start = false  ArrayList<Word> candidates String ngramPrefix  cachePrefix // order = # prefix + 1  current token // Take 3-gram for example  the prefix contains 2 ngramPrefix = Utilities getLastNWords prefix  Data NGRAM_ORDER-1  cachePrefix = Utilities getLastNWords prefix  Data CACHE_ORDER-1  // n-gram word candidates =  Data NGRAM  getCandidates ngramPrefix  Data USE_BACKOFF  if Data USE_CACHE  // update the candidates according to the candidates =  Data CACHE  updateCandidates cachePrefix  candidates   return candidates   package edu ucdavis cacheca import java net URL //Author: This class was originally written in C++ by Zhaopeng  converted to Java by * Parameter public class Data  //data wrapper static public boolean USE_BACKOFF = true static public int NGRAM_ORDER = 3 static public boolean USE_CACHE = true static public int CACHE_ORDER = 10 static public int CACHE_MIN_ORDER = 3 static public boolean USE_FILE_CACHE = true static public int BEAM_SIZE = 10 static public Ngram NGRAM static public Cache CACHE static public boolean Init URL u  int ngram_order  NGRAM_ORDER = ngram_order NGRAM = new Ngram u  NGRAM_ORDER  BEAM_SIZE  CACHE = new Cache CACHE_ORDER  CACHE_MIN_ORDER  return true   package edu ucdavis cacheca import java util ArrayList import java util Arrays import java util Collections import java util Comparator import java util List import org eclipse core runtime IPath import org eclipse core runtime IProgressMonitor import org eclipse core runtime NullProgressMonitor import org eclipse jdt core JavaModelException import org eclipse jdt ui text java CompletionProposalCollector import org eclipse jdt ui text java ContentAssistInvocationContext import org eclipse jdt ui text java IJavaCompletionProposal import org eclipse jdt ui text java IJavaCompletionProposalComputer import org eclipse jdt ui text java JavaContentAssistInvocationContext import org eclipse jface text BadLocationException import org eclipse jface text contentassist CompletionProposal import org eclipse jface text contentassist ICompletionProposal import org eclipse jface text contentassist IContextInformation import org eclipse ui IEditorInput import org eclipse ui IPartListener2 import org eclipse ui IWorkbenchPartReference import org eclipse ui PlatformUI import org eclipse ui part FileEditorInput // @author Christine * Handle proposals of Java code public class JavaCompletionProposals implements IJavaCompletionProposalComputer public JavaCompletionProposals   IPartListener2 openListener = new IPartListener2    public void partActivated IWorkbenchPartReference partRef    public void partBroughtToTop IWorkbenchPartReference partRef    public void partClosed IWorkbenchPartReference partRef    public void partDeactivated IWorkbenchPartReference partRef    public void partOpened IWorkbenchPartReference partRef    public void partHidden IWorkbenchPartReference partRef    public void partVisible IWorkbenchPartReference partRef   IEditorInput ip = partRef getPage   getActiveEditor   getEditorInput   IPath path =   FileEditorInput ip  getPath   String p = path toOSString   CachecaComputer getInstance p   public void partInputChanged IWorkbenchPartReference partRef      PlatformUI getWorkbench   getActiveWorkbenchWindow   getPartService   addPartListener openListener   public void sessionStarted     * merge EclipseProposals and cachecaProposals using strategy of heuristic mixing * Refer to the tool paper: CACHECA: A Cache Language Model Based Code Suggestion public List<ICompletionProposal> computeCompletionProposals ContentAssistInvocationContext context  IProgressMonitor monitor   JavaContentAssistInvocationContext ctx =  JavaContentAssistInvocationContext context int masterOffset = ctx getInvocationOffset  -1 CompletionProposalCollector collector = new CompletionProposalCollector ctx getCompilationUnit    collector setInvocationContext ctx  try  ctx getCompilationUnit   codeComplete ctx getInvocationOffset    collector  new NullProgressMonitor      catch  JavaModelException e2   e2 printStackTrace    IJavaCompletionProposal   jProps = collector getJavaCompletionProposals   Arrays sort jProps  new Comparator<IJavaCompletionProposal>   public int compare IJavaCompletionProposal one  IJavaCompletionProposal two  if one getRelevance   < two getRelevance   return 1 else if one getRelevance   > two getRelevance   return -1 else  return one getDisplayString   compareTo two getDisplayString         List<ICompletionProposal> eclipseProposals = new ArrayList<ICompletionProposal>   int proposalFractionFromEclipse = 50 if jProps length < proposalFractionFromEclipse  proposalFractionFromEclipse = jProps length  for  int j = 0  j < proposalFractionFromEclipse  j++   eclipseProposals add jProps j    //custom //get int replacementLength = 0 try  int offset = masterOffset if offset < 0  return eclipseProposals char c = ctx getDocument   getChar offset  while  c != ' '  offset-- replacementLength++ c = ctx getDocument   getChar offset     catch  BadLocationException e   e printStackTrace    //get StringBuilder b = new StringBuilder   try  int numberOfSeparators = 0 int offset = masterOffset offset -= replacementLength char c = ctx getDocument   getChar offset  boolean prevCharWasWhitespace = false while  numberOfSeparators < 10 && offset >= 0  if  ! Character isWhitespace ctx getDocument   getChar offset     prevCharWasWhitespace = false b append c   else  if prevCharWasWhitespace == false b append " "  prevCharWasWhitespace = true  if c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == '\n'   numberOfSeparators++  offset-- if  offset < 0   break  c = ctx getDocument   getChar offset     catch  BadLocationException e   e printStackTrace    String pref = b reverse   toString   //get StringBuilder input = new StringBuilder   try  int offset = masterOffset char c = ctx getDocument   getChar offset  while  c != ' '  input append c  offset-- c = ctx getDocument   getChar offset     catch  BadLocationException e   e printStackTrace    String inp = input reverse   toString   trim   IPath path = ctx getCompilationUnit   getResource   getRawLocation   String realPath = path toOSString   List<ICompletionProposal> cachecaProposals = new ArrayList<ICompletionProposal>   CachecaComputer comp = CachecaComputer getInstance realPath  if CachecaComputer isInitialized   == true  ArrayList<Word> p = comp getCandidates pref  int found = 0 for  int i = p size  -1  i >= 0 && found < 100  i--  String token = p get i  mToken if token length   < inp length   continue if inp length   >= 1 ? p get i  mToken substring 0  inp length    equals inp  : true  cachecaProposals add new CompletionProposal token  masterOffset-replacementLength+1  replacementLength  token length    null token  null  "Suggested by CACHECA with probability " + p get i  mProb   found++    // form blended proposal List<ICompletionProposal> finalProposals = new ArrayList<ICompletionProposal>   // merge common proposals and add to top of final int counter = 0 for  int j = 0  j < eclipseProposals size    j++   ICompletionProposal cp = eclipseProposals get counter  String eclipseProposalString = cp getDisplayString   int parenIndex = eclipseProposalString indexOf ' '  int spaceIndex = eclipseProposalString indexOf ' '  if  parenIndex > 1 || spaceIndex > 1   int index if  spaceIndex < 1   index = parenIndex   else if  parenIndex < 1   index = spaceIndex   else  index = Math min parenIndex  spaceIndex   eclipseProposalString = eclipseProposalString substring 0  index   counter++ for  int i = 0  i < cachecaProposals size    i++   if  eclipseProposalString equals cachecaProposals get i  getDisplayString     finalProposals add cp  counter-- eclipseProposals remove counter  cachecaProposals remove i     // take top suggestions  if the number of decalca ones is while  cachecaProposals size   > 0 && cachecaProposals size   < 3   String cachecaProposalString = cachecaProposals get 0  getDisplayString   boolean foundFlag = false int checkSentinel = 0 for ICompletionProposal eclipseProposal : eclipseProposals   if  checkSentinel > 100   break  String eclipseProposalString = eclipseProposal getDisplayString   int parenIndex = eclipseProposalString indexOf ' '  int spaceIndex = eclipseProposalString indexOf ' '  if  parenIndex > 1 || spaceIndex > 1   int index if  spaceIndex < 1   index = parenIndex   else if  parenIndex < 1   index = spaceIndex   else  index = Math min parenIndex  spaceIndex   eclipseProposalString = eclipseProposalString substring 0  index   if  eclipseProposalString equals cachecaProposalString    finalProposals add eclipseProposal  cachecaProposals remove 0  eclipseProposals remove eclipseProposal  foundFlag = true break  checkSentinel++  if  foundFlag == false   finalProposals add cachecaProposals get 0   cachecaProposals remove 0    // interleave the while eclipseProposals size   != 0 || cachecaProposals size   != 0   if  eclipseProposals size   != 0   finalProposals add eclipseProposals get 0   eclipseProposals remove 0   if  cachecaProposals size   != 0   finalProposals add cachecaProposals get 0   cachecaProposals remove 0    // since we added them in a stack-like way  we need to reverse it to get correct Collections reverse finalProposals  return finalProposals  public List<IContextInformation> computeContextInformation ContentAssistInvocationContext context  IProgressMonitor monitor   return null  public String getErrorMessage    return null  public void sessionEnded      package edu ucdavis cacheca import java io BufferedReader import java io IOException import java io InputStreamReader import java net URL import java util ArrayList import java util Collections import java util Comparator import java util HashMap import java util Map // @author Originally written in C++ by Zhaopeng  converted to Java by * Core component of Cacheca * Capture the repeativity of public class Ngram  // the array list that stores the candidates word given all n-grams  i e   1-grams  2-grams        n-1 -grams private ArrayList<Map<String  ArrayList<Word>>> mNgramsList public Ngram URL u  int order  int beam_size  String line BufferedReader br = null try  br = new BufferedReader new InputStreamReader u openStream       catch  IOException e   e printStackTrace    ArrayList<String> items = new ArrayList<String>   ArrayList<Word> words = new ArrayList<Word>   mNgramsList = new ArrayList<Map<String  ArrayList<Word>>>   String prefix  lastPrefix = null int n = -1 try  while   line = br readLine    != null  if  line endsWith "-grams:"   // push the words into the list  before changing the if  !words isEmpty    // sort the words according to their // See: http://stackoverflow Collections sort words  new Comparator<Word>    // first less than the second = neg  first greater than second = public int compare Word one  Word two   if one mProb > two mProb return -1 else if one mProb < two mProb return 1 return 0     if mNgramsList size   < n  while  mNgramsList size   < n  Map<String  ArrayList<Word>> added = new HashMap<String  ArrayList<Word>>   mNgramsList add added    mNgramsList get n-1  put lastPrefix  new ArrayList<Word> words    // here we don't need to update the last prefix because when "n" changes  the prefix must be words clear   // read the n of the current n = Integer parseInt line substring 1  line length  -7    //See: http://stackoverflow   items = Utilities split line  "\t"  if  items size   > 1  Word word = new Word   word mProb = Float parseFloat items get 0   if  items size   > 2  // back-off word mProb += Float parseFloat items get 2    word mProb =  float  Math pow 10 0  word mProb  prefix = Utilities getFirstNWords items get 1   n-1  word mToken = Utilities getLastNWords items get 1   1  if  prefix equals lastPrefix   words add word    if  !words isEmpty    // sort the words according to their // See: http://stackoverflow Collections sort words  new Comparator<Word>    // first less than the second = neg  first greater than second = public int compare Word one  Word two   if one mProb > two mProb return -1 else if one mProb < two mProb return 1 return 0     if mNgramsList size   <= n  while  mNgramsList size   <= n  Map<String  ArrayList<Word>> added = new HashMap<String  ArrayList<Word>>   mNgramsList add added    mNgramsList get n-1  put lastPrefix  new ArrayList<Word> words    lastPrefix = prefix words clear   words add word        catch  NumberFormatException e   e printStackTrace     catch  IOException e   e printStackTrace    finally try  if br != null br close     catch  IOException e   e printStackTrace     if  !words isEmpty    if mNgramsList size   < n  while  mNgramsList size   < n  Map<String  ArrayList<Word>> added = new HashMap<String  ArrayList<Word>>   mNgramsList add added    mNgramsList get n-1  put lastPrefix  words    * get the candidate tokens when given the * @param prefix the previous  n-1  * @param use_backoff Using back-off  when there is no candidates given  n-1  grams we will search the candidates given the previous  n-2  grams    until candidates are * @param candidates the result public ArrayList<Word> getCandidates String prefix  boolean useBackoff  ArrayList<Word> candidates = new ArrayList<Word>   int n = Utilities countWords prefix  // here n is the number of grams in the prefix  the real "n" should be // therefore  here we use "n" rather than Map<String  ArrayList<Word>> ngramMap = mNgramsList get n  ArrayList<Word> val = ngramMap get prefix  if  val != null  candidates = val return candidates   if  useBackoff  // when n is less or equal to 1  we cannot do the back-off if  n < 1 return null String useBackoffPrefix useBackoffPrefix = Utilities getLastNWords prefix  n-1  return getCandidates useBackoffPrefix  useBackoff    return null     package edu ucdavis cacheca import org eclipse jdt ui text java AbstractProposalSorter import org eclipse jface text contentassist ICompletionProposal * No public class NoSorter extends AbstractProposalSorter public int compare ICompletionProposal p1  ICompletionProposal p2   return -1   package edu ucdavis cacheca import java util ArrayList //@author Originally written in C++ by Zhaopeng  converted to Java by * utility public final class Utilities  * split string by * @param line: input * @param separator: * @return the list of segments in the string separated by static public ArrayList<String> split String line  String separator  ArrayList<String> items = new ArrayList<String>   int start  end int sep_size = separator length   start = 0 //See: http://en wikipedia org/wiki/Comparison_of_programming_languages_ string_functions end = line indexOf separator  while  end != -1  //See: http://en wikipedia org/wiki/Comparison_of_programming_languages_ string_functions  >> returns this if not  items add line substring start  end   start = end + sep_size end = line indexOf separator  start   items add line substring start  line length     return items  //count words in the static public int countWords String str  if str equals ""  || str == null  return 0  int numberSpaces = 0 for char c : str toCharArray    if c == ' '  numberSpaces++   return ++numberSpaces  //get the first n words in the static public String getFirstNWords String str  int n  if  n == 0 return "" int pos = str indexOf " "  int count = 0 //indexOf returns -1 when not while  ++count < n && pos != -1 pos = str indexOf " "  pos+1  if  count < n return str return str substring 0  pos   //get the last n words in the static  public String getLastNWords String str  int n  if  n == 0 return "" int pos = str lastIndexOf " "  int count = 0 //indexOf returns -1 when not while  ++count < n && pos != -1 pos = str lastIndexOf " "  pos-1  if  count < n return str return str substring pos+1  str length      package edu ucdavis cacheca //@author Originally written in C++ by Zhaopeng  converted to Java by //Note: originally an inner class of Ngram * Token and tis public class Word  public String mToken public float mProb public Word   mProb = 0 0f  public Word String token  float prob  mProb = prob mToken = token  